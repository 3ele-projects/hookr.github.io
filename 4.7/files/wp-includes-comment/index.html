<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="wordpress" data-version="4.7" data-type="file" data-id="4718"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp-includes-comment | file | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, wordpress, 4.7" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=fdebc404c36dcc81c145f7d9627ad066' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/wp-includes-comment/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-comment%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-comment%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7-file-wp-includes-comment","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp-includes-comment" class="blog single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7." href="http://hookr.io/4.7/" class="H_VERSION"><span property="name">4.7</span></a><meta property="position" content="2"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp-includes-comment</span><meta property="position" content="3"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="6307"><a href="http://hookr.io/4.7/all/" title="All">All <span class="count badge">6307</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/4.7/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="2531"><a href="http://hookr.io/4.7/hooks/" title="Hooks">Hooks <span class="count badge">2531</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1667"><a href="http://hookr.io/4.7/filters/" title="Filters">Filters <span class="count badge">1667</span></a></li><li class="" data-id="class" data-count="351"><a href="http://hookr.io/4.7/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2851"><a href="http://hookr.io/4.7/functions/" title="Functions">Functions <span class="count badge">2851</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/wp-includes/comment.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Core Comment API</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage Comment</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check whether a comment passes internal checks to be allowed to add.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If manual comment moderation is set in the administration, then all checks, </span>&nbsp;</div></li><li><div><span class="comment"> * regardless of their type and whitelist, will fail and the function will</span>&nbsp;</div></li><li><div><span class="comment"> * return false.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the number of links exceeds the amount in the administration, then the</span>&nbsp;</div></li><li><div><span class="comment"> * check fails. If any of the parameter contents match the blacklist of words, </span>&nbsp;</div></li><li><div><span class="comment"> * then the check fails.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the comment author was approved before, then the comment is automatically</span>&nbsp;</div></li><li><div><span class="comment"> * whitelisted.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If all checks pass, the function will return true.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $author       Comment author name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $email        Comment author email.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $url          Comment author URL.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $comment      Content of the comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $user_ip      Comment author IP address.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $user_agent   Comment author User-Agent.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $comment_type Comment type, either user-submitted comment, </span>&nbsp;</div></li><li><div><span class="comment"> *                               trackback, or pingback.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool If all checks pass, true, otherwise false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function check_comment($author, $email, $url, $comment, $user_ip, $user_agent, $comment_type) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If manual moderation is enabled, skip all checks and return false.</span>&nbsp;</div></li><li><div>  if ( 1 == get_option('comment_moderation') )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/** This filter is documented in wp-includes/comment-template.php */</span>&nbsp;</div></li><li><div>  $comment = apply_filters( 'comment_text', $comment );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Check for the number of external links if a max allowed number is set.</span>&nbsp;</div></li><li><div>  if ( $max_links = get_option( 'comment_max_links' ) ) {&nbsp;</div></li><li><div>      $num_links = preg_match_all( '/&lt;a [^&gt;]*href/i', $comment, $out );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the number of links found in a comment.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.7.0 Added the `$comment` parameter.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $num_links The number of links found.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $url       Comment author's URL. Included in allowed links total.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $comment   Content of the comment.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $num_links = apply_filters( 'comment_max_links_url', $num_links, $url, $comment );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * If the number of links in the comment exceeds the allowed amount, </span>&nbsp;</div></li><li><div><span class="comment">       * fail the check by returning false.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( $num_links &gt;= $max_links )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $mod_keys = trim(get_option('moderation_keys'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If moderation 'keys' (keywords) are set, process them.</span>&nbsp;</div></li><li><div>  if ( !empty($mod_keys) ) {&nbsp;</div></li><li><div>      $words = explode(&quot;\n&quot;, $mod_keys );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $words as $word) {&nbsp;</div></li><li><div>          $word = trim($word);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// Skip empty lines</span>.</span>&nbsp;</div></li><li><div>          if ( empty($word) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Do some escaping magic so that '#' (number of) characters in the spam</span>&nbsp;</div></li><li><div><span class="comment">           * words don't break things:</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $word = preg_quote($word, '#');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Check the comment fields for moderation keywords. If any are found, </span>&nbsp;</div></li><li><div><span class="comment">           * fail the check for the given field by returning false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $pattern = &quot;#$word#i&quot;;&nbsp;</div></li><li><div>          if ( preg_match($pattern, $author) ) return false;&nbsp;</div></li><li><div>          if ( preg_match($pattern, $email) ) return false;&nbsp;</div></li><li><div>          if ( preg_match($pattern, $url) ) return false;&nbsp;</div></li><li><div>          if ( preg_match($pattern, $comment) ) return false;&nbsp;</div></li><li><div>          if ( preg_match($pattern, $user_ip) ) return false;&nbsp;</div></li><li><div>          if ( preg_match($pattern, $user_agent) ) return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Check if the option to approve comments by previously-approved authors is enabled.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If it is enabled, check whether the comment author has a previously-approved comment, </span>&nbsp;</div></li><li><div><span class="comment">   * as well as whether there are any moderation keywords (if set) present in the author</span>&nbsp;</div></li><li><div><span class="comment">   * email address. If both checks pass, return true. Otherwise, return false.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( 1 == get_option('comment_whitelist')) {&nbsp;</div></li><li><div>      if ( 'trackback' != $comment_type && 'pingback' != $comment_type && $author != '' && $email != '' ) {&nbsp;</div></li><li><div>          $comment_user = get_user_by( 'email', wp_unslash( $email ) );&nbsp;</div></li><li><div>          if ( ! empty( $comment_user-&gt;ID ) ) {&nbsp;</div></li><li><div>              $ok_to_comment = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT comment_approved FROM $wpdb-&gt;comments WHERE user_id = %d AND comment_approved = '1' LIMIT 1&quot;, $comment_user-&gt;ID ) );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              <span class="comment">// expected_slashed ($author, $email)</span>&nbsp;</div></li><li><div>              $ok_to_comment = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT comment_approved FROM $wpdb-&gt;comments WHERE comment_author = %s AND comment_author_email = %s and comment_approved = '1' LIMIT 1&quot;, $author, $email ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ( ( 1 == $ok_to_comment ) &&&nbsp;</div></li><li><div>              ( empty($mod_keys) || false === strpos( $email, $mod_keys) ) )&nbsp;</div></li><li><div>                  return true;&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              return false;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the approved comments for post $post_id.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.1.0 Refactored to leverage WP_Comment_Query over a direct query.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param  int   $post_id The ID of the post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param  array $args    Optional. See WP_Comment_Query::query() for information on accepted arguments.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|array $comments The approved comments, or number of comments if `$count`</span>&nbsp;</div></li><li><div><span class="comment"> *                             argument is true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_approved_comments( $post_id, $args = array() ) {&nbsp;</div></li><li><div>  if ( ! $post_id ) {&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'status' =&gt; 1, &nbsp;</div></li><li><div>      'post_id' =&gt; $post_id, &nbsp;</div></li><li><div>      'order' =&gt; 'ASC', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $query = new WP_Comment_Query;&nbsp;</div></li><li><div>  return $query-&gt;query( $r );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves comment data given a comment ID or comment object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If an object is passed then the comment data will be cached and then returned</span>&nbsp;</div></li><li><div><span class="comment"> * after being passed through a filter. If the comment is empty, then the global</span>&nbsp;</div></li><li><div><span class="comment"> * comment variable will be used, if it is set.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Comment $comment</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Comment|string|int $comment Comment to retrieve.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string                $output  Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                                       a WP_Comment object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Comment|array|null Depends on $output value.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_comment( &$comment = null, $output = OBJECT ) {&nbsp;</div></li><li><div>  if ( empty( $comment ) && isset( $GLOBALS['comment'] ) ) {&nbsp;</div></li><li><div>      $comment = $GLOBALS['comment'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $comment instanceof WP_Comment ) {&nbsp;</div></li><li><div>      $_comment = $comment;&nbsp;</div></li><li><div>  } elseif ( is_object( $comment ) ) {&nbsp;</div></li><li><div>      $_comment = new WP_Comment( $comment );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $_comment = WP_Comment::get_instance( $comment );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $_comment ) {&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a comment is retrieved.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param mixed $_comment Comment data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $_comment = apply_filters( 'get_comment', $_comment );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $output == OBJECT ) {&nbsp;</div></li><li><div>      return $_comment;&nbsp;</div></li><li><div>  } elseif ( $output == ARRAY_A ) {&nbsp;</div></li><li><div>      return $_comment-&gt;to_array();&nbsp;</div></li><li><div>  } elseif ( $output == ARRAY_N ) {&nbsp;</div></li><li><div>      return array_values( $_comment-&gt;to_array() );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $_comment;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve a list of comments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The comment list can be for the blog as a whole or for an individual post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $args Optional. Array or string of arguments. See WP_Comment_Query::parse_query()</span>&nbsp;</div></li><li><div><span class="comment"> *                           for information on accepted arguments. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|array List of comments or number of found comments if `$count` argument is true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_comments( $args = '' ) {&nbsp;</div></li><li><div>  $query = new WP_Comment_Query;&nbsp;</div></li><li><div>  return $query-&gt;query( $args );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve all of the WordPress supported comment statuses.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Comments have a limited set of valid status values, this provides the comment</span>&nbsp;</div></li><li><div><span class="comment"> * status values and descriptions.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of comment statuses.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_comment_statuses() {&nbsp;</div></li><li><div>  $status = array(&nbsp;</div></li><li><div>      'hold' =&gt; __( 'Unapproved' ), &nbsp;</div></li><li><div>      'approve' =&gt; _x( 'Approved', 'comment status' ), &nbsp;</div></li><li><div>      'spam' =&gt; _x( 'Spam', 'comment status' ), &nbsp;</div></li><li><div>      'trash' =&gt; _x( 'Trash', 'comment status' ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $status;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Gets the default comment status for a post type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type    Optional. Post type. Default 'post'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $comment_type Optional. Comment type. Default 'comment'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string Expected return value is 'open' or 'closed'.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_default_comment_status( $post_type = 'post', $comment_type = 'comment' ) {&nbsp;</div></li><li><div>  switch ( $comment_type ) {&nbsp;</div></li><li><div>      case 'pingback' :&nbsp;</div></li><li><div>      case 'trackback' :&nbsp;</div></li><li><div>          $supports = 'trackbacks';&nbsp;</div></li><li><div>          $option = 'ping';&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      default :&nbsp;</div></li><li><div>          $supports = 'comments';&nbsp;</div></li><li><div>          $option = 'comment';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Set the status.</span>&nbsp;</div></li><li><div>  if ( 'page' === $post_type ) {&nbsp;</div></li><li><div>      $status = 'closed';&nbsp;</div></li><li><div>  } elseif ( post_type_supports( $post_type, $supports ) ) {&nbsp;</div></li><li><div>      $status = get_option( &quot;default_{$option}_status&quot; );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $status = 'closed';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the default comment status for the given post type.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $status       Default status for the given post type, </span>&nbsp;</div></li><li><div><span class="comment">   *                             either 'open' or 'closed'.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $post_type    Post type. Default is `post`.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_type Type of comment. Default is `comment`.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_default_comment_status' , $status, $post_type, $comment_type );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * The date the last comment was modified.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Replaced caching the modified date in a local static variable</span>&nbsp;</div></li><li><div><span class="comment"> *              with the Object Cache API.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $timezone Which timezone to use in reference to 'gmt', 'blog', or 'server' locations.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false Last comment modified date on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_lastcommentmodified( $timezone = 'server' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $timezone = strtolower( $timezone );&nbsp;</div></li><li><div>  $key = &quot;lastcommentmodified:$timezone&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_modified_date = wp_cache_get( $key, 'timeinfo' );&nbsp;</div></li><li><div>  if ( false !== $comment_modified_date ) {&nbsp;</div></li><li><div>      return $comment_modified_date;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  switch ( $timezone ) {&nbsp;</div></li><li><div>      case 'gmt':&nbsp;</div></li><li><div>          $comment_modified_date = $wpdb-&gt;get_var( &quot;SELECT comment_date_gmt FROM $wpdb-&gt;comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1&quot; );&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      case 'blog':&nbsp;</div></li><li><div>          $comment_modified_date = $wpdb-&gt;get_var( &quot;SELECT comment_date FROM $wpdb-&gt;comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1&quot; );&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      case 'server':&nbsp;</div></li><li><div>          $add_seconds_server = date( 'Z' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $comment_modified_date = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT DATE_ADD(comment_date_gmt, INTERVAL %s SECOND) FROM $wpdb-&gt;comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1&quot;, $add_seconds_server ) );&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $comment_modified_date ) {&nbsp;</div></li><li><div>      wp_cache_set( $key, $comment_modified_date, 'timeinfo' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $comment_modified_date;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * The amount of comments in a post or total comments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A lot like wp_count_comments(), in that they both return comment stats (albeit with different types).</span>&nbsp;</div></li><li><div><span class="comment"> * The wp_count_comments() actually caches, but this function does not.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Comment amount in post if &gt; 0, else total comments blog wide.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array The amount of spam, approved, awaiting moderation, and total comments.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_comment_count( $post_id = 0 ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $where = '';&nbsp;</div></li><li><div>  if ( $post_id &gt; 0 ) {&nbsp;</div></li><li><div>      $where = $wpdb-&gt;prepare(&quot;WHERE comment_post_ID = %d&quot;, $post_id);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $totals = (array) $wpdb-&gt;get_results(&quot;&nbsp;</div></li><li><div>      SELECT comment_approved, COUNT( * ) AS total&nbsp;</div></li><li><div>      FROM {$wpdb-&gt;comments}&nbsp;</div></li><li><div>      {$where}&nbsp;</div></li><li><div>      GROUP BY comment_approved&nbsp;</div></li><li><div>  &quot;, ARRAY_A);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_count = array(&nbsp;</div></li><li><div>      'approved' =&gt; 0, &nbsp;</div></li><li><div>      'awaiting_moderation' =&gt; 0, &nbsp;</div></li><li><div>      'spam' =&gt; 0, &nbsp;</div></li><li><div>      'trash' =&gt; 0, &nbsp;</div></li><li><div>      'post-trashed' =&gt; 0, &nbsp;</div></li><li><div>      'total_comments' =&gt; 0, &nbsp;</div></li><li><div>      'all' =&gt; 0, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $totals as $row ) {&nbsp;</div></li><li><div>      switch ( $row['comment_approved'] ) {&nbsp;</div></li><li><div>          case 'trash':&nbsp;</div></li><li><div>              $comment_count['trash'] = $row['total'];&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case 'post-trashed':&nbsp;</div></li><li><div>              $comment_count['post-trashed'] = $row['total'];&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case 'spam':&nbsp;</div></li><li><div>              $comment_count['spam'] = $row['total'];&nbsp;</div></li><li><div>              $comment_count['total_comments'] += $row['total'];&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case '1':&nbsp;</div></li><li><div>              $comment_count['approved'] = $row['total'];&nbsp;</div></li><li><div>              $comment_count['total_comments'] += $row['total'];&nbsp;</div></li><li><div>              $comment_count['all'] += $row['total'];&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case '0':&nbsp;</div></li><li><div>              $comment_count['awaiting_moderation'] = $row['total'];&nbsp;</div></li><li><div>              $comment_count['total_comments'] += $row['total'];&nbsp;</div></li><li><div>              $comment_count['all'] += $row['total'];&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          default:&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $comment_count;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">// Comment meta functions</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add meta data field to a comment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> * @link https://codex.wordpress.org/Function_Reference/add_comment_meta</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $comment_id Comment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key Metadata name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed $meta_value Metadata value.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $unique Optional, default is false. Whether the same key should not be added.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|bool Meta ID on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_comment_meta($comment_id, $meta_key, $meta_value, $unique = false) {&nbsp;</div></li><li><div>  return add_metadata('comment', $comment_id, $meta_key, $meta_value, $unique);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove metadata matching criteria from a comment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * You can match based on the key, or key and value. Removing based on key and</span>&nbsp;</div></li><li><div><span class="comment"> * value, will keep from removing duplicate metadata with the same key. It also</span>&nbsp;</div></li><li><div><span class="comment"> * allows removing all metadata matching key, if needed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> * @link https://codex.wordpress.org/Function_Reference/delete_comment_meta</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $comment_id comment ID</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key Metadata name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed $meta_value Optional. Metadata value.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function delete_comment_meta($comment_id, $meta_key, $meta_value = '') {&nbsp;</div></li><li><div>  return delete_metadata('comment', $comment_id, $meta_key, $meta_value);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve comment meta field for a comment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> * @link https://codex.wordpress.org/Function_Reference/get_comment_meta</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $comment_id Comment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $key Optional. The meta key to retrieve. By default, returns data for all keys.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $single Whether to return a single value.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed Will be an array if $single is false. Will be value of meta data field if $single</span>&nbsp;</div></li><li><div><span class="comment"> *  is true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_comment_meta($comment_id, $key = '', $single = false) {&nbsp;</div></li><li><div>  return get_metadata('comment', $comment_id, $key, $single);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update comment meta field based on comment ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Use the $prev_value parameter to differentiate between meta fields with the</span>&nbsp;</div></li><li><div><span class="comment"> * same key and comment ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the meta field for the comment does not exist, it will be added.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> * @link https://codex.wordpress.org/Function_Reference/update_comment_meta</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $comment_id Comment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key Metadata key.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed $meta_value Metadata value.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed $prev_value Optional. Previous value to check before removing.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|bool Meta ID if the key didn't exist, true on successful update, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_comment_meta($comment_id, $meta_key, $meta_value, $prev_value = '') {&nbsp;</div></li><li><div>  return update_metadata('comment', $comment_id, $meta_key, $meta_value, $prev_value);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Queues comments for metadata lazy-loading.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $comments Array of comment objects.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_queue_comments_for_comment_meta_lazyload( $comments ) {&nbsp;</div></li><li><div>  <span class="comment">// Don't use `wp_list_pluck()` to avoid by-reference manipulation.</span>&nbsp;</div></li><li><div>  $comment_ids = array();&nbsp;</div></li><li><div>  if ( is_array( $comments ) ) {&nbsp;</div></li><li><div>      foreach ( $comments as $comment ) {&nbsp;</div></li><li><div>          if ( $comment instanceof WP_Comment ) {&nbsp;</div></li><li><div>              $comment_ids[] = $comment-&gt;comment_ID;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $comment_ids ) {&nbsp;</div></li><li><div>      $lazyloader = wp_metadata_lazyloader();&nbsp;</div></li><li><div>      $lazyloader-&gt;queue_objects( 'comment', $comment_ids );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sets the cookies used to store an unauthenticated commentator's identity. Typically used</span>&nbsp;</div></li><li><div><span class="comment"> * to recall previous comments by this commentator that are still held in moderation.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Comment $comment Comment object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param object     $user    Comment author's object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.4.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_set_comment_cookies($comment, $user) {&nbsp;</div></li><li><div>  if ( $user-&gt;exists() )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the lifetime of the comment cookie in seconds.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $seconds Comment cookie lifetime. Default 30000000.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $comment_cookie_lifetime = apply_filters( 'comment_cookie_lifetime', 30000000 );&nbsp;</div></li><li><div>  $secure = ( 'https' === parse_url( home_url(), PHP_URL_SCHEME ) );&nbsp;</div></li><li><div>  setcookie( 'comment_author_' . COOKIEHASH, $comment-&gt;comment_author, time() + $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );&nbsp;</div></li><li><div>  setcookie( 'comment_author_email_' . COOKIEHASH, $comment-&gt;comment_author_email, time() + $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );&nbsp;</div></li><li><div>  setcookie( 'comment_author_url_' . COOKIEHASH, esc_url($comment-&gt;comment_author_url), time() + $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sanitizes the cookies sent to the user already.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Will only do anything if the cookies have already been created for the user.</span>&nbsp;</div></li><li><div><span class="comment"> * Mostly used after cookies had been sent to use elsewhere.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.4</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function sanitize_comment_cookies() {&nbsp;</div></li><li><div>  if ( isset( $_COOKIE['comment_author_' . COOKIEHASH] ) ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the comment author's name cookie before it is set.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * When this filter hook is evaluated in wp_filter_comment(), </span>&nbsp;</div></li><li><div><span class="comment">       * the comment author's name string is passed.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $author_cookie The comment author name cookie.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $comment_author = apply_filters( 'pre_comment_author_name', $_COOKIE['comment_author_' . COOKIEHASH] );&nbsp;</div></li><li><div>      $comment_author = wp_unslash($comment_author);&nbsp;</div></li><li><div>      $comment_author = esc_attr($comment_author);&nbsp;</div></li><li><div>      $_COOKIE['comment_author_' . COOKIEHASH] = $comment_author;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $_COOKIE['comment_author_email_' . COOKIEHASH] ) ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the comment author's email cookie before it is set.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * When this filter hook is evaluated in wp_filter_comment(), </span>&nbsp;</div></li><li><div><span class="comment">       * the comment author's email string is passed.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $author_email_cookie The comment author email cookie.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $comment_author_email = apply_filters( 'pre_comment_author_email', $_COOKIE['comment_author_email_' . COOKIEHASH] );&nbsp;</div></li><li><div>      $comment_author_email = wp_unslash($comment_author_email);&nbsp;</div></li><li><div>      $comment_author_email = esc_attr($comment_author_email);&nbsp;</div></li><li><div>      $_COOKIE['comment_author_email_'.COOKIEHASH] = $comment_author_email;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $_COOKIE['comment_author_url_' . COOKIEHASH] ) ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the comment author's URL cookie before it is set.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * When this filter hook is evaluated in wp_filter_comment(), </span>&nbsp;</div></li><li><div><span class="comment">       * the comment author's URL string is passed.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $author_url_cookie The comment author URL cookie.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $comment_author_url = apply_filters( 'pre_comment_author_url', $_COOKIE['comment_author_url_' . COOKIEHASH] );&nbsp;</div></li><li><div>      $comment_author_url = wp_unslash($comment_author_url);&nbsp;</div></li><li><div>      $_COOKIE['comment_author_url_'.COOKIEHASH] = $comment_author_url;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Validates whether this comment is allowed to be made.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 The `$avoid_die` parameter was added, allowing the function to</span>&nbsp;</div></li><li><div><span class="comment"> *              return a WP_Error object instead of dying.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $commentdata Contains information on the comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $avoid_die   When true, a disallowed comment will result in the function</span>&nbsp;</div></li><li><div><span class="comment"> *                           returning a WP_Error object, rather than executing wp_die().</span>&nbsp;</div></li><li><div><span class="comment"> *                           Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|string|WP_Error Allowed comments return the approval status (0|1|'spam').</span>&nbsp;</div></li><li><div><span class="comment"> *                             If `$avoid_die` is true, disallowed comments return a WP_Error.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_allow_comment( $commentdata, $avoid_die = false ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Simple duplicate check</span>&nbsp;</div></li><li><div>  <span class="comment">// expected_slashed ($comment_post_ID, $comment_author, $comment_author_email, $comment_content)</span>&nbsp;</div></li><li><div>  $dupe = $wpdb-&gt;prepare(&nbsp;</div></li><li><div>      &quot;SELECT comment_ID FROM $wpdb-&gt;comments WHERE comment_post_ID = %d AND comment_parent = %s AND comment_approved != 'trash' AND ( comment_author = %s &quot;, &nbsp;</div></li><li><div>      wp_unslash( $commentdata['comment_post_ID'] ), &nbsp;</div></li><li><div>      wp_unslash( $commentdata['comment_parent'] ), &nbsp;</div></li><li><div>      wp_unslash( $commentdata['comment_author'] )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  if ( $commentdata['comment_author_email'] ) {&nbsp;</div></li><li><div>      $dupe .= $wpdb-&gt;prepare(&nbsp;</div></li><li><div>          &quot;AND comment_author_email = %s &quot;, &nbsp;</div></li><li><div>          wp_unslash( $commentdata['comment_author_email'] )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $dupe .= $wpdb-&gt;prepare(&nbsp;</div></li><li><div>      &quot;) AND comment_content = %s LIMIT 1&quot;, &nbsp;</div></li><li><div>      wp_unslash( $commentdata['comment_content'] )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $dupe_id = $wpdb-&gt;get_var( $dupe );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the ID, if any, of the duplicate comment found when creating a new comment.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Return an empty value from this filter to allow what WP considers a duplicate comment.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $dupe_id     ID of the comment identified as a duplicate.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $commentdata Data for the comment being created.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $dupe_id = apply_filters( 'duplicate_comment_id', $dupe_id, $commentdata );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $dupe_id ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a duplicate comment is detected.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $commentdata Comment data.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'comment_duplicate_trigger', $commentdata );&nbsp;</div></li><li><div>      if ( true === $avoid_die ) {&nbsp;</div></li><li><div>          return new WP_Error( 'comment_duplicate', __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ), 409 );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          if ( wp_doing_ajax() ) {&nbsp;</div></li><li><div>              die( __('Duplicate comment detected; it looks as though you&#8217;ve already said that!') );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          wp_die( __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ), 409 );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a comment is marked approved.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Allows checking for comment flooding.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.7.0 The `$avoid_die` parameter was added.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_author_IP    Comment author's IP address.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_author_email Comment author's email.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_date_gmt     GMT date the comment was posted.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $avoid_die            Whether to prevent executing wp_die()</span>&nbsp;</div></li><li><div><span class="comment">   *                                     or die() if a comment flood is occurring.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action(&nbsp;</div></li><li><div>      'check_comment_flood', &nbsp;</div></li><li><div>      $commentdata['comment_author_IP'], &nbsp;</div></li><li><div>      $commentdata['comment_author_email'], &nbsp;</div></li><li><div>      $commentdata['comment_date_gmt'], &nbsp;</div></li><li><div>      $avoid_die&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters whether a comment is part of a comment flood.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The default check is wp_check_comment_flood(). See check_comment_flood_db().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $is_flood             Is a comment flooding occurring? Default false.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_author_IP    Comment author's IP address.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_author_email Comment author's email.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_date_gmt     GMT date the comment was posted.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $avoid_die            Whether to prevent executing wp_die()</span>&nbsp;</div></li><li><div><span class="comment">   *                                     or die() if a comment flood is occurring.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $is_flood = apply_filters(&nbsp;</div></li><li><div>      'wp_is_comment_flood', &nbsp;</div></li><li><div>      false, &nbsp;</div></li><li><div>      $commentdata['comment_author_IP'], &nbsp;</div></li><li><div>      $commentdata['comment_author_email'], &nbsp;</div></li><li><div>      $commentdata['comment_date_gmt'], &nbsp;</div></li><li><div>      $avoid_die&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $is_flood ) {&nbsp;</div></li><li><div>      return new WP_Error( 'comment_flood', __( 'You are posting comments too quickly. Slow down.' ), 429 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $commentdata['user_id'] ) ) {&nbsp;</div></li><li><div>      $user = get_userdata( $commentdata['user_id'] );&nbsp;</div></li><li><div>      $post_author = $wpdb-&gt;get_var( $wpdb-&gt;prepare(&nbsp;</div></li><li><div>          &quot;SELECT post_author FROM $wpdb-&gt;posts WHERE ID = %d LIMIT 1&quot;, &nbsp;</div></li><li><div>          $commentdata['comment_post_ID']&nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $user ) && ( $commentdata['user_id'] == $post_author || $user-&gt;has_cap( 'moderate_comments' ) ) ) {&nbsp;</div></li><li><div>      <span class="comment">// The author and the admins get respect.</span>&nbsp;</div></li><li><div>      $approved = 1;&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment">// Everyone else's comments will be checked.</span>&nbsp;</div></li><li><div>      if ( check_comment(&nbsp;</div></li><li><div>          $commentdata['comment_author'], &nbsp;</div></li><li><div>          $commentdata['comment_author_email'], &nbsp;</div></li><li><div>          $commentdata['comment_author_url'], &nbsp;</div></li><li><div>          $commentdata['comment_content'], &nbsp;</div></li><li><div>          $commentdata['comment_author_IP'], &nbsp;</div></li><li><div>          $commentdata['comment_agent'], &nbsp;</div></li><li><div>          $commentdata['comment_type']&nbsp;</div></li><li><div> ) ) {&nbsp;</div></li><li><div>          $approved = 1;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $approved = 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( wp_blacklist_check(&nbsp;</div></li><li><div>          $commentdata['comment_author'], &nbsp;</div></li><li><div>          $commentdata['comment_author_email'], &nbsp;</div></li><li><div>          $commentdata['comment_author_url'], &nbsp;</div></li><li><div>          $commentdata['comment_content'], &nbsp;</div></li><li><div>          $commentdata['comment_author_IP'], &nbsp;</div></li><li><div>          $commentdata['comment_agent']&nbsp;</div></li><li><div> ) ) {&nbsp;</div></li><li><div>          $approved = EMPTY_TRASH_DAYS ? 'trash' : 'spam';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters a comment's approval status before it is set.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool|string $approved    The approval status. Accepts 1, 0, or 'spam'.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array       $commentdata Comment data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $approved = apply_filters( 'pre_comment_approved', $approved, $commentdata );&nbsp;</div></li><li><div>  return $approved;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Hooks WP's native database-based comment-flood check.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This wrapper maintains backward compatibility with plugins that expect to</span>&nbsp;</div></li><li><div><span class="comment"> * be able to unhook the legacy check_comment_flood_db() function from</span>&nbsp;</div></li><li><div><span class="comment"> * 'check_comment_flood' using remove_action().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Converted to be an add_filter() wrapper.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function check_comment_flood_db() {&nbsp;</div></li><li><div>  add_filter( 'wp_is_comment_flood', 'wp_check_comment_flood', 10, 5 );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Checks whether comment flooding is occurring.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Won't run, if current user can manage options, so to not block</span>&nbsp;</div></li><li><div><span class="comment"> * administrators.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $is_flood  Is a comment flooding occurring?</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $ip        Comment IP.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $email     Comment author email address.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $date      MySQL time string.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $avoid_die When true, a disallowed comment will result in the function</span>&nbsp;</div></li><li><div><span class="comment"> *                          returning a WP_Error object, rather than executing wp_die().</span>&nbsp;</div></li><li><div><span class="comment"> *                          Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether comment flooding is occurring.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_check_comment_flood( $is_flood, $ip, $email, $date, $avoid_die = false ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Another callback has declared a flood. Trust it.</span>&nbsp;</div></li><li><div>  if ( true === $is_flood ) {&nbsp;</div></li><li><div>      return $is_flood;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// don't throttle admins or moderators</span>&nbsp;</div></li><li><div>  if ( current_user_can( 'manage_options' ) || current_user_can( 'moderate_comments' ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $hour_ago = gmdate( 'Y-m-d H:i:s', time() - HOUR_IN_SECONDS );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_user_logged_in() ) {&nbsp;</div></li><li><div>      $user = get_current_user_id();&nbsp;</div></li><li><div>      $check_column = '`user_id`';&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $user = $ip;&nbsp;</div></li><li><div>      $check_column = '`comment_author_IP`';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $sql = $wpdb-&gt;prepare(&nbsp;</div></li><li><div>      &quot;SELECT `comment_date_gmt` FROM `$wpdb-&gt;comments` WHERE `comment_date_gmt` &gt;= %s AND ( $check_column = %s OR `comment_author_email` = %s ) ORDER BY `comment_date_gmt` DESC LIMIT 1&quot;, &nbsp;</div></li><li><div>      $hour_ago, &nbsp;</div></li><li><div>      $user, &nbsp;</div></li><li><div>      $email&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  $lasttime = $wpdb-&gt;get_var( $sql );&nbsp;</div></li><li><div>  if ( $lasttime ) {&nbsp;</div></li><li><div>      $time_lastcomment = mysql2date('U', $lasttime, false);&nbsp;</div></li><li><div>      $time_newcomment = mysql2date('U', $date, false);&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the comment flood status.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool $bool             Whether a comment flood is occurring. Default false.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int  $time_lastcomment Timestamp of when the last comment was posted.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int  $time_newcomment  Timestamp of when the new comment was posted.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $flood_die = apply_filters( 'comment_flood_filter', false, $time_lastcomment, $time_newcomment );&nbsp;</div></li><li><div>      if ( $flood_die ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires before the comment flood message is triggered.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param int $time_lastcomment Timestamp of when the last comment was posted.</span>&nbsp;</div></li><li><div><span class="comment">           * @param int $time_newcomment  Timestamp of when the new comment was posted.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'comment_flood_trigger', $time_lastcomment, $time_newcomment );&nbsp;</div></li><li><div>          if ( true === $avoid_die ) {&nbsp;</div></li><li><div>              return true;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              if ( wp_doing_ajax() ) {&nbsp;</div></li><li><div>                  die( __('You are posting comments too quickly. Slow down.') );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              wp_die( __( 'You are posting comments too quickly. Slow down.' ), 429 );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Separates an array of comments into an array keyed by comment_type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $comments Array of comments</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Array of comments keyed by comment_type.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function separate_comments(&$comments) {&nbsp;</div></li><li><div>  $comments_by_type = array('comment' =&gt; array(), 'trackback' =&gt; array(), 'pingback' =&gt; array(), 'pings' =&gt; array());&nbsp;</div></li><li><div>  $count = count($comments);&nbsp;</div></li><li><div>  for ( $i = 0; $i &lt; $count; $i++ ) {&nbsp;</div></li><li><div>      $type = $comments[$i]-&gt;comment_type;&nbsp;</div></li><li><div>      if ( empty($type) )&nbsp;</div></li><li><div>          $type = 'comment';&nbsp;</div></li><li><div>      $comments_by_type[$type][] = &$comments[$i];&nbsp;</div></li><li><div>      if ( 'trackback' == $type || 'pingback' == $type )&nbsp;</div></li><li><div>          $comments_by_type['pings'][] = &$comments[$i];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $comments_by_type;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Calculate the total number of comment pages.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @uses Walker_Comment</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Query $wp_query</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $comments Optional array of WP_Comment objects. Defaults to $wp_query-&gt;comments</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $per_page Optional comments per page.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $threaded Optional control over flat or threaded comments.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int Number of comment pages.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_comment_pages_count( $comments = null, $per_page = null, $threaded = null ) {&nbsp;</div></li><li><div>  global $wp_query;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $comments && null === $per_page && null === $threaded && !empty($wp_query-&gt;max_num_comment_pages) )&nbsp;</div></li><li><div>      return $wp_query-&gt;max_num_comment_pages;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ( ! $comments || ! is_array( $comments ) ) && ! empty( $wp_query-&gt;comments ) )&nbsp;</div></li><li><div>      $comments = $wp_query-&gt;comments;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($comments) )&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! get_option( 'page_comments' ) ) {&nbsp;</div></li><li><div>      return 1;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset($per_page) )&nbsp;</div></li><li><div>      $per_page = (int) get_query_var('comments_per_page');&nbsp;</div></li><li><div>  if ( 0 === $per_page )&nbsp;</div></li><li><div>      $per_page = (int) get_option('comments_per_page');&nbsp;</div></li><li><div>  if ( 0 === $per_page )&nbsp;</div></li><li><div>      return 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset($threaded) )&nbsp;</div></li><li><div>      $threaded = get_option('thread_comments');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $threaded ) {&nbsp;</div></li><li><div>      $walker = new Walker_Comment;&nbsp;</div></li><li><div>      $count = ceil( $walker-&gt;get_number_of_root_elements( $comments ) / $per_page );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $count = ceil( count( $comments ) / $per_page );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $count;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Calculate what page number a comment will appear on for comment paging.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $comment_ID Comment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $args {</span>&nbsp;</div></li><li><div><span class="comment"> *      Array of optional arguments.</span>&nbsp;</div></li><li><div><span class="comment"> *      @type string     $type      Limit paginated comments to those matching a given type. Accepts 'comment', </span>&nbsp;</div></li><li><div><span class="comment"> *                                  'trackback', 'pingback', 'pings' (trackbacks and pingbacks), or 'all'.</span>&nbsp;</div></li><li><div><span class="comment"> *                                  Default is 'all'.</span>&nbsp;</div></li><li><div><span class="comment"> *      @type int        $per_page  Per-page count to use when calculating pagination. Defaults to the value of the</span>&nbsp;</div></li><li><div><span class="comment"> *                                  'comments_per_page' option.</span>&nbsp;</div></li><li><div><span class="comment"> *      @type int|string $max_depth If greater than 1, comment page will be determined for the top-level parent of</span>&nbsp;</div></li><li><div><span class="comment"> *                                  `$comment_ID`. Defaults to the value of the 'thread_comments_depth' option.</span>&nbsp;</div></li><li><div><span class="comment"> * } *</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|null Comment page number or null on error.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page_of_comment( $comment_ID, $args = array() ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $page = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$comment = get_comment( $comment_ID ) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array( 'type' =&gt; 'all', 'page' =&gt; '', 'per_page' =&gt; '', 'max_depth' =&gt; '' );&nbsp;</div></li><li><div>  $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>  $original_args = $args;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Order of precedence: 1. `$args['per_page']`, 2. 'comments_per_page' query_var, 3. 'comments_per_page' option.</span>&nbsp;</div></li><li><div>  if ( get_option( 'page_comments' ) ) {&nbsp;</div></li><li><div>      if ( '' === $args['per_page'] ) {&nbsp;</div></li><li><div>          $args['per_page'] = get_query_var( 'comments_per_page' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( '' === $args['per_page'] ) {&nbsp;</div></li><li><div>          $args['per_page'] = get_option( 'comments_per_page' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($args['per_page']) ) {&nbsp;</div></li><li><div>      $args['per_page'] = 0;&nbsp;</div></li><li><div>      $args['page'] = 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $args['per_page'] &lt; 1 ) {&nbsp;</div></li><li><div>      $page = 1;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $page ) {&nbsp;</div></li><li><div>      if ( '' === $args['max_depth'] ) {&nbsp;</div></li><li><div>          if ( get_option('thread_comments') )&nbsp;</div></li><li><div>              $args['max_depth'] = get_option('thread_comments_depth');&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $args['max_depth'] = -1;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Find this comment's top level parent if threading is enabled</span>&nbsp;</div></li><li><div>      if ( $args['max_depth'] &gt; 1 && 0 != $comment-&gt;comment_parent )&nbsp;</div></li><li><div>          return get_page_of_comment( $comment-&gt;comment_parent, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'desc' === get_option( 'comment_order' ) ) {&nbsp;</div></li><li><div>          $compare = 'after';&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $compare = 'before';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $comment_args = array(&nbsp;</div></li><li><div>          'type' =&gt; $args['type'], &nbsp;</div></li><li><div>          'post_id' =&gt; $comment-&gt;comment_post_ID, &nbsp;</div></li><li><div>          'fields' =&gt; 'ids', &nbsp;</div></li><li><div>          'count' =&gt; true, &nbsp;</div></li><li><div>          'status' =&gt; 'approve', &nbsp;</div></li><li><div>          'parent' =&gt; 0, &nbsp;</div></li><li><div>          'date_query' =&gt; array(&nbsp;</div></li><li><div>              array(&nbsp;</div></li><li><div>                  'column' =&gt; &quot;$wpdb-&gt;comments.comment_date_gmt&quot;, &nbsp;</div></li><li><div>                  $compare =&gt; $comment-&gt;comment_date_gmt, &nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $comment_query = new WP_Comment_Query();&nbsp;</div></li><li><div>      $older_comment_count = $comment_query-&gt;query( $comment_args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// No older comments? Then it's page #1.</span>&nbsp;</div></li><li><div>      if ( 0 == $older_comment_count ) {&nbsp;</div></li><li><div>          $page = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Divide comments older than this one by comments per page to get this comment's page number</span>&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $page = ceil( ( $older_comment_count + 1 ) / $args['per_page'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the calculated page on which a comment appears.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.7.0 Introduced the `$comment_ID` parameter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $page          Comment page.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $args {</span>&nbsp;</div></li><li><div><span class="comment">   *     Arguments used to calculate pagination. These include arguments auto-detected by the function, </span>&nbsp;</div></li><li><div><span class="comment">   *     based on query vars, system settings, etc. For pristine arguments passed to the function, </span>&nbsp;</div></li><li><div><span class="comment">   *     see `$original_args`.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $type      Type of comments to count.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int    $page      Calculated current page.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int    $per_page  Calculated number of comments per page.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int    $max_depth Maximum comment threading depth allowed.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $original_args {</span>&nbsp;</div></li><li><div><span class="comment">   *     Array of arguments passed to the function. Some or all of these may not be set.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $type      Type of comments to count.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int    $page      Current comment page.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int    $per_page  Number of comments per page.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int    $max_depth Maximum comment threading depth allowed.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $comment_ID ID of the comment.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_page_of_comment', (int) $page, $args, $original_args, $comment_ID );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves the maximum character lengths for the comment form fields.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Maximum character length for the comment form fields.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_comment_fields_max_lengths() {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $lengths = array(&nbsp;</div></li><li><div>      'comment_author' =&gt; 245, &nbsp;</div></li><li><div>      'comment_author_email' =&gt; 100, &nbsp;</div></li><li><div>      'comment_author_url' =&gt; 200, &nbsp;</div></li><li><div>      'comment_content' =&gt; 65525, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $wpdb-&gt;is_mysql ) {&nbsp;</div></li><li><div>      foreach ( $lengths as $column =&gt; $length ) {&nbsp;</div></li><li><div>          $col_length = $wpdb-&gt;get_col_length( $wpdb-&gt;comments, $column );&nbsp;</div></li><li><div>          $max_length = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// No point if we can't get the DB column lengths</span>&nbsp;</div></li><li><div>          if ( is_wp_error( $col_length ) ) {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( ! is_array( $col_length ) && (int) $col_length &gt; 0 ) {&nbsp;</div></li><li><div>              $max_length = (int) $col_length;&nbsp;</div></li><li><div>          } elseif ( is_array( $col_length ) && isset( $col_length['length'] ) && intval( $col_length['length'] ) &gt; 0 ) {&nbsp;</div></li><li><div>              $max_length = (int) $col_length['length'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( ! empty( $col_length['type'] ) && 'byte' === $col_length['type'] ) {&nbsp;</div></li><li><div>                  $max_length = $max_length - 10;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $max_length &gt; 0 ) {&nbsp;</div></li><li><div>              $lengths[ $column ] = $max_length;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the lengths for the comment form fields.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $lengths Associative array `'field_name' =&gt; 'maximum length'`.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_get_comment_fields_max_lengths', $lengths );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Compares the lengths of comment data against the maximum character limits.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $comment_data Array of arguments for inserting a comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Error|true WP_Error when a comment field exceeds the limit, </span>&nbsp;</div></li><li><div><span class="comment"> *                       otherwise true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_check_comment_data_max_lengths( $comment_data ) {&nbsp;</div></li><li><div>  $max_lengths = wp_get_comment_fields_max_lengths();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $comment_data['comment_author'] ) && mb_strlen( $comment_data['comment_author'], '8bit' ) &gt; $max_lengths['comment_author'] ) {&nbsp;</div></li><li><div>      return new WP_Error( 'comment_author_column_length', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: your name is too long.' ), 200 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $comment_data['comment_author_email'] ) && strlen( $comment_data['comment_author_email'] ) &gt; $max_lengths['comment_author_email'] ) {&nbsp;</div></li><li><div>      return new WP_Error( 'comment_author_email_column_length', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: your email address is too long.' ), 200 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $comment_data['comment_author_url'] ) && strlen( $comment_data['comment_author_url'] ) &gt; $max_lengths['comment_author_url'] ) {&nbsp;</div></li><li><div>      return new WP_Error( 'comment_author_url_column_length', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: your url is too long.' ), 200 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $comment_data['comment_content'] ) && mb_strlen( $comment_data['comment_content'], '8bit' ) &gt; $max_lengths['comment_content'] ) {&nbsp;</div></li><li><div>      return new WP_Error( 'comment_content_column_length', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: your comment is too long.' ), 200 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Does comment contain blacklisted characters or words.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $author The author of the comment</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $email The email of the comment</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $url The url used in the comment</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $comment The comment content</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $user_ip The comment author IP address</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $user_agent The author's browser user agent</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True if comment contains blacklisted content, false if comment does not</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_blacklist_check($author, $email, $url, $comment, $user_ip, $user_agent) {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires before the comment is tested for blacklisted characters or words.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $author     Comment author.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $email      Comment author's email.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url        Comment author's URL.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment    Comment content.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $user_ip    Comment author's IP address.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $user_agent Comment author's browser user agent.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'wp_blacklist_check', $author, $email, $url, $comment, $user_ip, $user_agent );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $mod_keys = trim( get_option('blacklist_keys') );&nbsp;</div></li><li><div>  if ( '' == $mod_keys )&nbsp;</div></li><li><div>      return false; <span class="comment">// If moderation keys are empty</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Ensure HTML tags are not being used to bypass the blacklist.</span>&nbsp;</div></li><li><div>  $comment_without_html = wp_strip_all_tags( $comment );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $words = explode(&quot;\n&quot;, $mod_keys );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $words as $word ) {&nbsp;</div></li><li><div>      $word = trim($word);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Skip empty lines</span>&nbsp;</div></li><li><div>      if ( empty($word) ) { continue; }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Do some escaping magic so that '#' chars in the</span>&nbsp;</div></li><li><div>      <span class="comment">// spam words don't break things:</span>&nbsp;</div></li><li><div>      $word = preg_quote($word, '#');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $pattern = &quot;#$word#i&quot;;&nbsp;</div></li><li><div>      if (&nbsp;</div></li><li><div>             preg_match($pattern, $author)&nbsp;</div></li><li><div>          || preg_match($pattern, $email)&nbsp;</div></li><li><div>          || preg_match($pattern, $url)&nbsp;</div></li><li><div>          || preg_match($pattern, $comment)&nbsp;</div></li><li><div>          || preg_match($pattern, $comment_without_html)&nbsp;</div></li><li><div>          || preg_match($pattern, $user_ip)&nbsp;</div></li><li><div>          || preg_match($pattern, $user_agent)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve total comments for blog or single post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The properties of the returned object contain the 'moderated', 'approved', </span>&nbsp;</div></li><li><div><span class="comment"> * and spam comments for either the entire blog or single post. Those properties</span>&nbsp;</div></li><li><div><span class="comment"> * contain the amount of comments that match the status. The 'total_comments'</span>&nbsp;</div></li><li><div><span class="comment"> * property contains the integer of total comments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The comment stats are cached and then retrieved, if they already exist in the</span>&nbsp;</div></li><li><div><span class="comment"> * cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object|array Comment stats.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_count_comments( $post_id = 0 ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the comments count for a given post.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $count   An empty array.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $post_id The post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $filtered = apply_filters( 'wp_count_comments', array(), $post_id );&nbsp;</div></li><li><div>  if ( ! empty( $filtered ) ) {&nbsp;</div></li><li><div>      return $filtered;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $count = wp_cache_get( &quot;comments-{$post_id}&quot;, 'counts' );&nbsp;</div></li><li><div>  if ( false !== $count ) {&nbsp;</div></li><li><div>      return $count;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $stats = get_comment_count( $post_id );&nbsp;</div></li><li><div>  $stats['moderated'] = $stats['awaiting_moderation'];&nbsp;</div></li><li><div>  unset( $stats['awaiting_moderation'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $stats_object = (object) $stats;&nbsp;</div></li><li><div>  wp_cache_set( &quot;comments-{$post_id}&quot;, $stats_object, 'counts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $stats_object;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Trashes or deletes a comment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The comment is moved to trash instead of permanently deleted unless trash is</span>&nbsp;</div></li><li><div><span class="comment"> * disabled, item is already in the trash, or $force_delete is true.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The post comment count will be updated if the comment was approved and has a</span>&nbsp;</div></li><li><div><span class="comment"> * post ID available.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Comment $comment_id   Comment ID or WP_Comment object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool           $force_delete Whether to bypass trash and force deletion. Default is false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_delete_comment($comment_id, $force_delete = false) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>  if (!$comment = get_comment($comment_id))&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$force_delete && EMPTY_TRASH_DAYS && !in_array( wp_get_comment_status( $comment ), array( 'trash', 'spam' ) ) )&nbsp;</div></li><li><div>      return wp_trash_comment($comment_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a comment is deleted from the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'delete_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Move children up a level.</span>&nbsp;</div></li><li><div>  $children = $wpdb-&gt;get_col( $wpdb-&gt;prepare(&quot;SELECT comment_ID FROM $wpdb-&gt;comments WHERE comment_parent = %d&quot;, $comment-&gt;comment_ID) );&nbsp;</div></li><li><div>  if ( !empty($children) ) {&nbsp;</div></li><li><div>      $wpdb-&gt;update($wpdb-&gt;comments, array('comment_parent' =&gt; $comment-&gt;comment_parent), array('comment_parent' =&gt; $comment-&gt;comment_ID));&nbsp;</div></li><li><div>      clean_comment_cache($children);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Delete metadata</span>&nbsp;</div></li><li><div>  $meta_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT meta_id FROM $wpdb-&gt;commentmeta WHERE comment_id = %d&quot;, $comment-&gt;comment_ID ) );&nbsp;</div></li><li><div>  foreach ( $meta_ids as $mid )&nbsp;</div></li><li><div>      delete_metadata_by_mid( 'comment', $mid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $wpdb-&gt;delete( $wpdb-&gt;comments, array( 'comment_ID' =&gt; $comment-&gt;comment_ID ) ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a comment is deleted from the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'deleted_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_id = $comment-&gt;comment_post_ID;&nbsp;</div></li><li><div>  if ( $post_id && $comment-&gt;comment_approved == 1 )&nbsp;</div></li><li><div>      wp_update_comment_count($post_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_comment_cache( $comment-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/** This action is documented in wp-includes/comment.php */</span>&nbsp;</div></li><li><div>  do_action( 'wp_set_comment_status', $comment-&gt;comment_ID, 'delete' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_transition_comment_status('delete', $comment-&gt;comment_approved, $comment);&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Moves a comment to the Trash</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If trash is disabled, comment is permanently deleted.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_trash_comment($comment_id) {&nbsp;</div></li><li><div>  if ( !EMPTY_TRASH_DAYS )&nbsp;</div></li><li><div>      return wp_delete_comment($comment_id, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$comment = get_comment($comment_id) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a comment is sent to the Trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'trash_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_set_comment_status( $comment, 'trash' ) ) {&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status' );&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_time' );&nbsp;</div></li><li><div>      add_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status', $comment-&gt;comment_approved );&nbsp;</div></li><li><div>      add_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_time', time() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a comment is sent to Trash.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'trashed_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Removes a comment from the Trash</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_untrash_comment($comment_id) {&nbsp;</div></li><li><div>  $comment = get_comment( $comment_id );&nbsp;</div></li><li><div>  if ( ! $comment ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a comment is restored from the Trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'untrash_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $status = (string) get_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status', true );&nbsp;</div></li><li><div>  if ( empty($status) )&nbsp;</div></li><li><div>      $status = '0';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_set_comment_status( $comment, $status ) ) {&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_time' );&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status' );&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a comment is restored from the Trash.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'untrashed_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Marks a comment as Spam</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_spam_comment( $comment_id ) {&nbsp;</div></li><li><div>  $comment = get_comment( $comment_id );&nbsp;</div></li><li><div>  if ( ! $comment ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a comment is marked as Spam.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'spam_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_set_comment_status( $comment, 'spam' ) ) {&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status' );&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_time' );&nbsp;</div></li><li><div>      add_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status', $comment-&gt;comment_approved );&nbsp;</div></li><li><div>      add_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_time', time() );&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a comment is marked as Spam.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'spammed_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Removes a comment from the Spam</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_unspam_comment( $comment_id ) {&nbsp;</div></li><li><div>  $comment = get_comment( $comment_id );&nbsp;</div></li><li><div>  if ( ! $comment ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a comment is unmarked as Spam.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'unspam_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $status = (string) get_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status', true );&nbsp;</div></li><li><div>  if ( empty($status) )&nbsp;</div></li><li><div>      $status = '0';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_set_comment_status( $comment, $status ) ) {&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_status' );&nbsp;</div></li><li><div>      delete_comment_meta( $comment-&gt;comment_ID, '_wp_trash_meta_time' );&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a comment is unmarked as Spam.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_id The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'unspammed_comment', $comment-&gt;comment_ID );&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * The status of a comment by ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Comment $comment_id Comment ID or WP_Comment object</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string Status might be 'trash', 'approved', 'unapproved', 'spam'. False on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_comment_status($comment_id) {&nbsp;</div></li><li><div>  $comment = get_comment($comment_id);&nbsp;</div></li><li><div>  if ( !$comment )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $approved = $comment-&gt;comment_approved;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $approved == null )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  elseif ( $approved == '1' )&nbsp;</div></li><li><div>      return 'approved';&nbsp;</div></li><li><div>  elseif ( $approved == '0' )&nbsp;</div></li><li><div>      return 'unapproved';&nbsp;</div></li><li><div>  elseif ( $approved == 'spam' )&nbsp;</div></li><li><div>      return 'spam';&nbsp;</div></li><li><div>  elseif ( $approved == 'trash' )&nbsp;</div></li><li><div>      return 'trash';&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Call hooks for when a comment status transition occurs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Calls hooks for comment status transitions. If the new comment status is not the same</span>&nbsp;</div></li><li><div><span class="comment"> * as the previous comment status, then two hooks will be ran, the first is</span>&nbsp;</div></li><li><div><span class="comment"> * {@see 'transition_comment_status'} with new status, old status, and comment data. The</span>&nbsp;</div></li><li><div><span class="comment"> * next action called is {@see comment_$old_status_to_$new_status'}. It has the</span>&nbsp;</div></li><li><div><span class="comment"> * comment data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The final action will run whether or not the comment statuses are the same. The</span>&nbsp;</div></li><li><div><span class="comment"> * action is named {@see 'comment_$new_status_$comment-&gt;comment_type'}.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $new_status New comment status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $old_status Previous comment status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param object $comment Comment data.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_transition_comment_status($new_status, $old_status, $comment) {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Translate raw statuses to human readable formats for the hooks.</span>&nbsp;</div></li><li><div><span class="comment">   * This is not a complete list of comment status, it's only the ones</span>&nbsp;</div></li><li><div><span class="comment">   * that need to be renamed</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $comment_statuses = array(&nbsp;</div></li><li><div>      0 =&gt; 'unapproved', &nbsp;</div></li><li><div>      'hold' =&gt; 'unapproved', <span class="comment">// wp_set_comment_status() uses &quot;hold&quot;</span>&nbsp;</div></li><li><div>      1 =&gt; 'approved', &nbsp;</div></li><li><div>      'approve' =&gt; 'approved', <span class="comment">// wp_set_comment_status() uses &quot;approve&quot;</span>&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  if ( isset($comment_statuses[$new_status]) ) $new_status = $comment_statuses[$new_status];&nbsp;</div></li><li><div>  if ( isset($comment_statuses[$old_status]) ) $old_status = $comment_statuses[$old_status];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Call the hooks</span>&nbsp;</div></li><li><div>  if ( $new_status != $old_status ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when the comment status is in transition.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int|string $new_status The new comment status.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int|string $old_status The old comment status.</span>&nbsp;</div></li><li><div><span class="comment">       * @param object     $comment    The comment data.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'transition_comment_status', $new_status, $old_status, $comment );&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when the comment status is in transition from one specific status to another.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portions of the hook name, `$old_status`, and `$new_status`, </span>&nbsp;</div></li><li><div><span class="comment">       * refer to the old and new comment statuses, respectively.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Comment $comment Comment object.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( &quot;comment_{$old_status}_to_{$new_status}&quot;, $comment );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires when the status of a specific comment type is in transition.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portions of the hook name, `$new_status`, and `$comment-&gt;comment_type`, </span>&nbsp;</div></li><li><div><span class="comment">   * refer to the new comment status, and the type of comment, respectively.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Typical comment types include an empty string (standard comment), 'pingback', </span>&nbsp;</div></li><li><div><span class="comment">   * or 'trackback'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int        $comment_ID The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Comment $comment    Comment object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;comment_{$new_status}_{$comment-&gt;comment_type}&quot;, $comment-&gt;comment_ID, $comment );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Clear the lastcommentmodified cached value when a comment status is changed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Deletes the lastcommentmodified cache key when a comment enters or leaves</span>&nbsp;</div></li><li><div><span class="comment"> * 'approved' status.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $new_status The new comment status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $old_status The old comment status.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _clear_modified_cache_on_transition_comment_status( $new_status, $old_status ) {&nbsp;</div></li><li><div>  if ( 'approved' === $new_status || 'approved' === $old_status ) {&nbsp;</div></li><li><div>      foreach ( array( 'server', 'gmt', 'blog' ) as $timezone ) {&nbsp;</div></li><li><div>          wp_cache_delete( &quot;lastcommentmodified:$timezone&quot;, 'timeinfo' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get current commenter's name, email, and URL.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Expects cookies content to already be sanitized. User of this function might</span>&nbsp;</div></li><li><div><span class="comment"> * wish to recheck the returned array for validity.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see sanitize_comment_cookies() Use to sanitize cookies</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.4</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Comment author, email, url respectively.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_current_commenter() {&nbsp;</div></li><li><div>  <span class="comment">// Cookies should already be sanitized.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_author = '';&nbsp;</div></li><li><div>  if ( isset($_COOKIE['comment_author_'.COOKIEHASH]) )&nbsp;</div></li><li><div>      $comment_author = $_COOKIE['comment_author_'.COOKIEHASH];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_author_email = '';&nbsp;</div></li><li><div>  if ( isset($_COOKIE['comment_author_email_'.COOKIEHASH]) )&nbsp;</div></li><li><div>      $comment_author_email = $_COOKIE['comment_author_email_'.COOKIEHASH];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_author_url = '';&nbsp;</div></li><li><div>  if ( isset($_COOKIE['comment_author_url_'.COOKIEHASH]) )&nbsp;</div></li><li><div>      $comment_author_url = $_COOKIE['comment_author_url_'.COOKIEHASH];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the current commenter's name, email, and URL.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $comment_author_data {</span>&nbsp;</div></li><li><div><span class="comment">   *     An array of current commenter variables.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $comment_author       The name of the author of the comment. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $comment_author_email The email address of the `$comment_author`. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $comment_author_url   The URL address of the `$comment_author`. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_get_current_commenter', compact('comment_author', 'comment_author_email', 'comment_author_url') );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Inserts a comment into the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Introduced `$comment_meta` argument.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $commentdata {</span>&nbsp;</div></li><li><div><span class="comment"> *     Array of arguments for inserting a new comment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_agent        The HTTP user agent of the `$comment_author` when</span>&nbsp;</div></li><li><div><span class="comment"> *                                            the comment was submitted. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int|string $comment_approved     Whether the comment has been approved. Default 1.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_author       The name of the author of the comment. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_author_email The email address of the `$comment_author`. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_author_IP    The IP address of the `$comment_author`. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_author_url   The URL address of the `$comment_author`. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_content      The content of the comment. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_date         The date the comment was submitted. To set the date</span>&nbsp;</div></li><li><div><span class="comment"> *                                            manually, `$comment_date_gmt` must also be specified.</span>&nbsp;</div></li><li><div><span class="comment"> *                                            Default is the current time.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_date_gmt     The date the comment was submitted in the GMT timezone.</span>&nbsp;</div></li><li><div><span class="comment"> *                                            Default is `$comment_date` in the site's GMT timezone.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int        $comment_karma        The karma of the comment. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int        $comment_parent       ID of this comment's parent, if any. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int        $comment_post_ID      ID of the post that relates to the comment, if any.</span>&nbsp;</div></li><li><div><span class="comment"> *                                            Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment_type         Comment type. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array      $comment_meta         Optional. Array of key/value pairs to be stored in commentmeta for the</span>&nbsp;</div></li><li><div><span class="comment"> *                                            new comment.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int        $user_id              ID of the user who submitted the comment. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false The new comment's ID on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_insert_comment( $commentdata ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>  $data = wp_unslash( $commentdata );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_author = ! isset( $data['comment_author'] )       ? '' : $data['comment_author'];&nbsp;</div></li><li><div>  $comment_author_email = ! isset( $data['comment_author_email'] ) ? '' : $data['comment_author_email'];&nbsp;</div></li><li><div>  $comment_author_url = ! isset( $data['comment_author_url'] )   ? '' : $data['comment_author_url'];&nbsp;</div></li><li><div>  $comment_author_IP = ! isset( $data['comment_author_IP'] )    ? '' : $data['comment_author_IP'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_date = ! isset( $data['comment_date'] )     ? current_time( 'mysql' )            : $data['comment_date'];&nbsp;</div></li><li><div>  $comment_date_gmt = ! isset( $data['comment_date_gmt'] ) ? get_gmt_from_date( $comment_date ) : $data['comment_date_gmt'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_post_ID = ! isset( $data['comment_post_ID'] )  ? 0  : $data['comment_post_ID'];&nbsp;</div></li><li><div>  $comment_content = ! isset( $data['comment_content'] )  ? '' : $data['comment_content'];&nbsp;</div></li><li><div>  $comment_karma = ! isset( $data['comment_karma'] )    ? 0  : $data['comment_karma'];&nbsp;</div></li><li><div>  $comment_approved = ! isset( $data['comment_approved'] ) ? 1  : $data['comment_approved'];&nbsp;</div></li><li><div>  $comment_agent = ! isset( $data['comment_agent'] )    ? '' : $data['comment_agent'];&nbsp;</div></li><li><div>  $comment_type = ! isset( $data['comment_type'] )     ? '' : $data['comment_type'];&nbsp;</div></li><li><div>  $comment_parent = ! isset( $data['comment_parent'] )   ? 0  : $data['comment_parent'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $user_id = ! isset( $data['user_id'] ) ? 0 : $data['user_id'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $compacted = compact( 'comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_author_IP', 'comment_date', 'comment_date_gmt', 'comment_content', 'comment_karma', 'comment_approved', 'comment_agent', 'comment_type', 'comment_parent', 'user_id' );&nbsp;</div></li><li><div>  if ( ! $wpdb-&gt;insert( $wpdb-&gt;comments, $compacted ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $id = (int) $wpdb-&gt;insert_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $comment_approved == 1 ) {&nbsp;</div></li><li><div>      wp_update_comment_count( $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( array( 'server', 'gmt', 'blog' ) as $timezone ) {&nbsp;</div></li><li><div>          wp_cache_delete( &quot;lastcommentmodified:$timezone&quot;, 'timeinfo' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_comment_cache( $id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment = get_comment( $id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If metadata is provided, store it.</span>&nbsp;</div></li><li><div>  if ( isset( $commentdata['comment_meta'] ) && is_array( $commentdata['comment_meta'] ) ) {&nbsp;</div></li><li><div>      foreach ( $commentdata['comment_meta'] as $meta_key =&gt; $meta_value ) {&nbsp;</div></li><li><div>          add_comment_meta( $comment-&gt;comment_ID, $meta_key, $meta_value, true );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a comment is inserted into the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int        $id      The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Comment $comment Comment object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'wp_insert_comment', $id, $comment );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $id;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Filters and sanitizes comment data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Sets the comment data 'filtered' field to true when finished. This can be</span>&nbsp;</div></li><li><div><span class="comment"> * checked as to whether the comment should be filtered and to keep from</span>&nbsp;</div></li><li><div><span class="comment"> * filtering the same comment more than once.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $commentdata Contains information on the comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Parsed comment information.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_filter_comment($commentdata) {&nbsp;</div></li><li><div>  if ( isset( $commentdata['user_ID'] ) ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the comment author's user id before it is set.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The first time this filter is evaluated, 'user_ID' is checked</span>&nbsp;</div></li><li><div><span class="comment">       * (for back-compat), followed by the standard 'user_id' value.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $user_ID The comment author's user ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $commentdata['user_id'] = apply_filters( 'pre_user_id', $commentdata['user_ID'] );&nbsp;</div></li><li><div>  } elseif ( isset( $commentdata['user_id'] ) ) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/comment.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>      $commentdata['user_id'] = apply_filters( 'pre_user_id', $commentdata['user_id'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the comment author's browser user agent before it is set.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_agent The comment author's browser user agent.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $commentdata['comment_agent'] = apply_filters( 'pre_comment_user_agent', ( isset( $commentdata['comment_agent'] ) ? $commentdata['comment_agent'] : '' ) );&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/comment.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  $commentdata['comment_author'] = apply_filters( 'pre_comment_author_name', $commentdata['comment_author'] );&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the comment content before it is set.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_content The comment content.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $commentdata['comment_content'] = apply_filters( 'pre_comment_content', $commentdata['comment_content'] );&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the comment author's IP before it is set.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_author_ip The comment author's IP.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $commentdata['comment_author_IP'] = apply_filters( 'pre_comment_user_ip', $commentdata['comment_author_IP'] );&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/comment.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  $commentdata['comment_author_url'] = apply_filters( 'pre_comment_author_url', $commentdata['comment_author_url'] );&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/comment.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  $commentdata['comment_author_email'] = apply_filters( 'pre_comment_author_email', $commentdata['comment_author_email'] );&nbsp;</div></li><li><div>  $commentdata['filtered'] = true;&nbsp;</div></li><li><div>  return $commentdata;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Whether a comment should be blocked because of comment flood.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $block Whether plugin has already blocked comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $time_lastcomment Timestamp for last comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $time_newcomment Timestamp for new comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether comment should be blocked.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_throttle_comment_flood($block, $time_lastcomment, $time_newcomment) {&nbsp;</div></li><li><div>  if ( $block ) <span class="comment">// a plugin has already blocked... we'll let that decision stand</span>&nbsp;</div></li><li><div>      return $block;&nbsp;</div></li><li><div>  if ( ($time_newcomment - $time_lastcomment) &lt; 15 )&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds a new comment to the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Filters new comment to ensure that the fields are sanitized and valid before</span>&nbsp;</div></li><li><div><span class="comment"> * inserting comment into database. Calls {@see 'comment_post'} action with comment ID</span>&nbsp;</div></li><li><div><span class="comment"> * and whether comment is approved by WordPress. Also has {@see 'preprocess_comment'}</span>&nbsp;</div></li><li><div><span class="comment"> * filter for processing the comment data before the function handles it.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * We use `REMOTE_ADDR` here directly. If you are behind a proxy, you should ensure</span>&nbsp;</div></li><li><div><span class="comment"> * that it is properly set, such as in wp-config.php, for your environment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * See {@link https://core.trac.wordpress.org/ticket/9235}</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0 'comment_agent' and 'comment_author_IP' can be set via `$commentdata`.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 The `$avoid_die` parameter was added, allowing the function to</span>&nbsp;</div></li><li><div><span class="comment"> *              return a WP_Error object instead of dying.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_insert_comment()</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $commentdata {</span>&nbsp;</div></li><li><div><span class="comment"> *     Comment data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_author       The name of the comment author.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_author_email The comment author email address.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_author_url   The comment author URL.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_content      The content of the comment.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_date         The date the comment was submitted. Default is the current time.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_date_gmt     The date the comment was submitted in the GMT timezone.</span>&nbsp;</div></li><li><div><span class="comment"> *                                        Default is `$comment_date` in the GMT timezone.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $comment_parent       The ID of this comment's parent, if any. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $comment_post_ID      The ID of the post that relates to the comment.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $user_id              The ID of the user who submitted the comment. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $user_ID              Kept for backward-compatibility. Use `$user_id` instead.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_agent        Comment author user agent. Default is the value of 'HTTP_USER_AGENT'</span>&nbsp;</div></li><li><div><span class="comment"> *                                        in the `$_SERVER` superglobal sent in the original request.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_author_IP    Comment author IP address in IPv4 format. Default is the value of</span>&nbsp;</div></li><li><div><span class="comment"> *                                        'REMOTE_ADDR' in the `$_SERVER` superglobal sent in the original request.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $avoid_die Should errors be returned as WP_Error objects instead of</span>&nbsp;</div></li><li><div><span class="comment"> *                        executing wp_die()? Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false|WP_Error The ID of the comment on success, false or WP_Error on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_new_comment( $commentdata, $avoid_die = false ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $commentdata['user_ID'] ) ) {&nbsp;</div></li><li><div>      $commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $prefiltered_user_id = ( isset( $commentdata['user_id'] ) ) ? (int) $commentdata['user_id'] : 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters a comment's data before it is sanitized and inserted into the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $commentdata Comment data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $commentdata = apply_filters( 'preprocess_comment', $commentdata );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $commentdata['comment_post_ID'] = (int) $commentdata['comment_post_ID'];&nbsp;</div></li><li><div>  if ( isset( $commentdata['user_ID'] ) && $prefiltered_user_id !== (int) $commentdata['user_ID'] ) {&nbsp;</div></li><li><div>      $commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];&nbsp;</div></li><li><div>  } elseif ( isset( $commentdata['user_id'] ) ) {&nbsp;</div></li><li><div>      $commentdata['user_id'] = (int) $commentdata['user_id'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $commentdata['comment_parent'] = isset($commentdata['comment_parent']) ? absint($commentdata['comment_parent']) : 0;&nbsp;</div></li><li><div>  $parent_status = ( 0 &lt; $commentdata['comment_parent'] ) ? wp_get_comment_status($commentdata['comment_parent']) : '';&nbsp;</div></li><li><div>  $commentdata['comment_parent'] = ( 'approved' == $parent_status || 'unapproved' == $parent_status ) ? $commentdata['comment_parent'] : 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! isset( $commentdata['comment_author_IP'] ) ) {&nbsp;</div></li><li><div>      $commentdata['comment_author_IP'] = $_SERVER['REMOTE_ADDR'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $commentdata['comment_author_IP'] = preg_replace( '/[^0-9a-fA-F:., ]/', '', $commentdata['comment_author_IP'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! isset( $commentdata['comment_agent'] ) ) {&nbsp;</div></li><li><div>      $commentdata['comment_agent'] = isset( $_SERVER['HTTP_USER_AGENT'] ) ? $_SERVER['HTTP_USER_AGENT']: '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $commentdata['comment_agent'] = substr( $commentdata['comment_agent'], 0, 254 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $commentdata['comment_date'] ) ) {&nbsp;</div></li><li><div>      $commentdata['comment_date'] = current_time('mysql');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $commentdata['comment_date_gmt'] ) ) {&nbsp;</div></li><li><div>      $commentdata['comment_date_gmt'] = current_time( 'mysql', 1 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $commentdata = wp_filter_comment($commentdata);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $commentdata['comment_approved'] = wp_allow_comment( $commentdata, $avoid_die );&nbsp;</div></li><li><div>  if ( is_wp_error( $commentdata['comment_approved'] ) ) {&nbsp;</div></li><li><div>      return $commentdata['comment_approved'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_ID = wp_insert_comment($commentdata);&nbsp;</div></li><li><div>  if ( ! $comment_ID ) {&nbsp;</div></li><li><div>      $fields = array( 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_content' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $fields as $field ) {&nbsp;</div></li><li><div>          if ( isset( $commentdata[ $field ] ) ) {&nbsp;</div></li><li><div>              $commentdata[ $field ] = $wpdb-&gt;strip_invalid_text_for_column( $wpdb-&gt;comments, $field, $commentdata[ $field ] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $commentdata = wp_filter_comment( $commentdata );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $commentdata['comment_approved'] = wp_allow_comment( $commentdata, $avoid_die );&nbsp;</div></li><li><div>      if ( is_wp_error( $commentdata['comment_approved'] ) ) {&nbsp;</div></li><li><div>          return $commentdata['comment_approved'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $comment_ID = wp_insert_comment( $commentdata );&nbsp;</div></li><li><div>      if ( ! $comment_ID ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a comment is inserted into the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0 The `$commentdata` parameter was added.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int        $comment_ID       The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|string $comment_approved 1 if the comment is approved, 0 if not, 'spam' if spam.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array      $commentdata      Comment data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'comment_post', $comment_ID, $commentdata['comment_approved'], $commentdata );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $comment_ID;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Send a comment moderation notification to the comment moderator.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $comment_ID ID of the comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_new_comment_notify_moderator( $comment_ID ) {&nbsp;</div></li><li><div>  $comment = get_comment( $comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Only send notifications for pending comments.</span>&nbsp;</div></li><li><div>  $maybe_notify = ( '0' == $comment-&gt;comment_approved );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/comment.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  $maybe_notify = apply_filters( 'notify_moderator', $maybe_notify, $comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $maybe_notify ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_notify_moderator( $comment_ID );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Send a notification of a new comment to the post author.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Uses the {@see 'notify_post_author'} filter to determine whether the post author</span>&nbsp;</div></li><li><div><span class="comment"> * should be notified when a new comment is added, overriding site setting.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $comment_ID Comment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_new_comment_notify_postauthor( $comment_ID ) {&nbsp;</div></li><li><div>  $comment = get_comment( $comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $maybe_notify = get_option( 'comments_notify' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters whether to send the post author new comment notification emails, </span>&nbsp;</div></li><li><div><span class="comment">   * overriding the site setting.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool $maybe_notify Whether to notify the post author about the new comment.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int  $comment_ID   The ID of the comment for the notification.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $maybe_notify = apply_filters( 'notify_post_author', $maybe_notify, $comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * wp_notify_postauthor() checks if notifying the author of their own comment.</span>&nbsp;</div></li><li><div><span class="comment">   * By default, it won't, but filters can override this.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( ! $maybe_notify ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Only send notifications for approved comments.</span>&nbsp;</div></li><li><div>  if ( ! isset( $comment-&gt;comment_approved ) || '1' != $comment-&gt;comment_approved ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_notify_postauthor( $comment_ID );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sets the status of a comment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The {@see 'wp_set_comment_status'} action is called after the comment is handled.</span>&nbsp;</div></li><li><div><span class="comment"> * If the comment status is not in the list, then false is returned.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Comment $comment_id     Comment ID or WP_Comment object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string         $comment_status New comment status, either 'hold', 'approve', 'spam', or 'trash'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool           $wp_error       Whether to return a WP_Error object if there is a failure. Default is false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|WP_Error True on success, false or WP_Error on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_set_comment_status($comment_id, $comment_status, $wp_error = false) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  switch ( $comment_status ) {&nbsp;</div></li><li><div>      case 'hold':&nbsp;</div></li><li><div>      case '0':&nbsp;</div></li><li><div>          $status = '0';&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      case 'approve':&nbsp;</div></li><li><div>      case '1':&nbsp;</div></li><li><div>          $status = '1';&nbsp;</div></li><li><div>          add_action( 'wp_set_comment_status', 'wp_new_comment_notify_postauthor' );&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      case 'spam':&nbsp;</div></li><li><div>          $status = 'spam';&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      case 'trash':&nbsp;</div></li><li><div>          $status = 'trash';&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      default:&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_old = clone get_comment($comment_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$wpdb-&gt;update( $wpdb-&gt;comments, array('comment_approved' =&gt; $status), array( 'comment_ID' =&gt; $comment_old-&gt;comment_ID ) ) ) {&nbsp;</div></li><li><div>      if ( $wp_error )&nbsp;</div></li><li><div>          return new WP_Error('db_update_error', __('Could not update comment status'), $wpdb-&gt;last_error);&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_comment_cache( $comment_old-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment = get_comment( $comment_old-&gt;comment_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before transitioning a comment's status from one to another</span>&nbsp;</div></li><li><div><span class="comment">   * in the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int         $comment_id     Comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|bool $comment_status Current comment status. Possible values include</span>&nbsp;</div></li><li><div><span class="comment">   *                                    'hold', 'approve', 'spam', 'trash', or false.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'wp_set_comment_status', $comment-&gt;comment_ID, $comment_status );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_transition_comment_status($comment_status, $comment_old-&gt;comment_approved, $comment);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_update_comment_count($comment-&gt;comment_post_ID);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates an existing comment in the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Filters the comment and makes sure certain fields are valid before updating.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $commentarr Contains information on the comment.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int Comment was updated if value is 1, or was not updated if value is 0.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_comment($commentarr) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// First, get all of the original fields</span>&nbsp;</div></li><li><div>  $comment = get_comment($commentarr['comment_ID'], ARRAY_A);&nbsp;</div></li><li><div>  if ( empty( $comment ) ) {&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Make sure that the comment post ID is valid (if specified).</span>&nbsp;</div></li><li><div>  if ( ! empty( $commentarr['comment_post_ID'] ) && ! get_post( $commentarr['comment_post_ID'] ) ) {&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Escape data pulled from DB.</span>&nbsp;</div></li><li><div>  $comment = wp_slash($comment);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $old_status = $comment['comment_approved'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Merge old and new fields with new fields overwriting old ones.</span>&nbsp;</div></li><li><div>  $commentarr = array_merge($comment, $commentarr);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $commentarr = wp_filter_comment( $commentarr );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Now extract the merged array.</span>&nbsp;</div></li><li><div>  $data = wp_unslash( $commentarr );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the comment content before it is updated in the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $comment_content The comment data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $data['comment_content'] = apply_filters( 'comment_save_pre', $data['comment_content'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $data['comment_date_gmt'] = get_gmt_from_date( $data['comment_date'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! isset( $data['comment_approved'] ) ) {&nbsp;</div></li><li><div>      $data['comment_approved'] = 1;&nbsp;</div></li><li><div>  } elseif ( 'hold' == $data['comment_approved'] ) {&nbsp;</div></li><li><div>      $data['comment_approved'] = 0;&nbsp;</div></li><li><div>  } elseif ( 'approve' == $data['comment_approved'] ) {&nbsp;</div></li><li><div>      $data['comment_approved'] = 1;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_ID = $data['comment_ID'];&nbsp;</div></li><li><div>  $comment_post_ID = $data['comment_post_ID'];&nbsp;</div></li><li><div>  $keys = array( 'comment_post_ID', 'comment_content', 'comment_author', 'comment_author_email', 'comment_approved', 'comment_karma', 'comment_author_url', 'comment_date', 'comment_date_gmt', 'comment_type', 'comment_parent', 'user_id', 'comment_agent', 'comment_author_IP' );&nbsp;</div></li><li><div>  $data = wp_array_slice_assoc( $data, $keys );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the comment data immediately before it is updated in the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Note: data being passed to the filter is already unslashed.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $data       The new, processed comment data.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $comment    The old, unslashed comment data.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $commentarr The new, raw comment data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $data = apply_filters( 'wp_update_comment_data', $data, $comment, $commentarr );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $rval = $wpdb-&gt;update( $wpdb-&gt;comments, $data, compact( 'comment_ID' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_comment_cache( $comment_ID );&nbsp;</div></li><li><div>  wp_update_comment_count( $comment_post_ID );&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a comment is updated in the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The hook also fires immediately before comment status transition hooks are fired.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.6.0 Added the `$data` parameter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $comment_ID The comment ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $data       Comment data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'edit_comment', $comment_ID, $data );&nbsp;</div></li><li><div>  $comment = get_comment($comment_ID);&nbsp;</div></li><li><div>  wp_transition_comment_status($comment-&gt;comment_approved, $old_status, $comment);&nbsp;</div></li><li><div>  return $rval;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Whether to defer comment counting.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * When setting $defer to true, all post comment counts will not be updated</span>&nbsp;</div></li><li><div><span class="comment"> * until $defer is set to false. When $defer is set to false, then all</span>&nbsp;</div></li><li><div><span class="comment"> * previously deferred updated post comment counts will then be automatically</span>&nbsp;</div></li><li><div><span class="comment"> * updated without having to call wp_update_comment_count() after.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @staticvar bool $_defer</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $defer</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_defer_comment_counting($defer=null) {&nbsp;</div></li><li><div>  static $_defer = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_bool($defer) ) {&nbsp;</div></li><li><div>      $_defer = $defer;&nbsp;</div></li><li><div>      <span class="comment">// flush any deferred counts</span>&nbsp;</div></li><li><div>      if ( !$defer )&nbsp;</div></li><li><div>          wp_update_comment_count( null, true );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $_defer;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates the comment count for post(s).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * When $do_deferred is false (is by default) and the comments have been set to</span>&nbsp;</div></li><li><div><span class="comment"> * be deferred, the post_id will be added to a queue, which will be updated at a</span>&nbsp;</div></li><li><div><span class="comment"> * later date and only updated once per post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the comments have not be set up to be deferred, then the post will be</span>&nbsp;</div></li><li><div><span class="comment"> * updated. When $do_deferred is set to true, then all previous deferred post</span>&nbsp;</div></li><li><div><span class="comment"> * IDs will be updated along with the current $post_id.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_update_comment_count_now() For what could cause a false return value</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @staticvar array $_deferred</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|null $post_id     Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool     $do_deferred Optional. Whether to process previously deferred</span>&nbsp;</div></li><li><div><span class="comment"> *                              post comment counts. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|void True on success, false on failure or if post with ID does</span>&nbsp;</div></li><li><div><span class="comment"> *                   not exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_comment_count($post_id, $do_deferred=false) {&nbsp;</div></li><li><div>  static $_deferred = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $post_id ) && ! $do_deferred ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $do_deferred ) {&nbsp;</div></li><li><div>      $_deferred = array_unique($_deferred);&nbsp;</div></li><li><div>      foreach ( $_deferred as $i =&gt; $_post_id ) {&nbsp;</div></li><li><div>          wp_update_comment_count_now($_post_id);&nbsp;</div></li><li><div>          unset( $_deferred[$i] ); <span class="comment">/** @todo Move this outside of the foreach and reset $_deferred to an array instead */</span>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_defer_comment_counting() ) {&nbsp;</div></li><li><div>      $_deferred[] = $post_id;&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  elseif ( $post_id ) {&nbsp;</div></li><li><div>      return wp_update_comment_count_now($post_id);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates the comment count for the post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Post ID</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on '0' $post_id or if post with ID does not exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_comment_count_now($post_id) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>  if ( !$post_id )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_delete( 'comments-0', 'counts' );&nbsp;</div></li><li><div>  wp_cache_delete( &quot;comments-{$post_id}&quot;, 'counts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$post = get_post($post_id) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $old = (int) $post-&gt;comment_count;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters a post's comment count before it is updated in the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $new     The new comment count. Default null.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $old     The old comment count.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $new = apply_filters( 'pre_wp_update_comment_count_now', null, $old, $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_null( $new ) ) {&nbsp;</div></li><li><div>      $new = (int) $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(*) FROM $wpdb-&gt;comments WHERE comment_post_ID = %d AND comment_approved = '1'&quot;, $post_id ) );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $new = (int) $new;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wpdb-&gt;update( $wpdb-&gt;posts, array('comment_count' =&gt; $new), array('ID' =&gt; $post_id) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_post_cache( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a post's comment count is updated in the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $new     The new comment count.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $old     The old comment count.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'wp_update_comment_count', $post_id, $new, $old );&nbsp;</div></li><li><div>  <span class="comment">/** This action is documented in wp-includes/post.php */</span>&nbsp;</div></li><li><div>  do_action( 'edit_post', $post_id, $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Ping and trackback functions.&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Finds a pingback server URI based on the given URL.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Checks the HTML for the rel=&quot;pingback&quot; link and x-pingback headers. It does</span>&nbsp;</div></li><li><div><span class="comment"> * a check for the x-pingback headers first and returns that, if available. The</span>&nbsp;</div></li><li><div><span class="comment"> * check for the rel=&quot;pingback&quot; has more overhead than just the header.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $url URL to ping.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $deprecated Not Used.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string False on failure, string containing URI on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function discover_pingback_server_uri( $url, $deprecated = '' ) {&nbsp;</div></li><li><div>  if ( !empty( $deprecated ) )&nbsp;</div></li><li><div>      _deprecated_argument( __FUNCTION__, '2.7.0' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $pingback_str_dquote = 'rel=&quot;pingback&quot;';&nbsp;</div></li><li><div>  $pingback_str_squote = 'rel=\'pingback\'';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/** @todo Should use Filter Extension or custom preg_match instead. */</span>&nbsp;</div></li><li><div>  $parsed_url = parse_url($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! isset( $parsed_url['host'] ) ) <span class="comment">// Not a URL. This should never happen.</span>&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">//Do not search for a pingback server on our own uploads</span>&nbsp;</div></li><li><div>  $uploads_dir = wp_get_upload_dir();&nbsp;</div></li><li><div>  if ( 0 === strpos($url, $uploads_dir['baseurl']) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $response = wp_safe_remote_head( $url, array( 'timeout' =&gt; 2, 'httpversion' =&gt; '1.0' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error( $response ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_remote_retrieve_header( $response, 'x-pingback' ) )&nbsp;</div></li><li><div>      return wp_remote_retrieve_header( $response, 'x-pingback' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Not an (x)html, sgml, or xml page, no use going further.</span>&nbsp;</div></li><li><div>  if ( preg_match('#(image|audio|video|model)/#is', wp_remote_retrieve_header( $response, 'content-type' )) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Now do a GET since we're going to look in the html headers (and we're sure it's not a binary file)</span>&nbsp;</div></li><li><div>  $response = wp_safe_remote_get( $url, array( 'timeout' =&gt; 2, 'httpversion' =&gt; '1.0' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error( $response ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $contents = wp_remote_retrieve_body( $response );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $pingback_link_offset_dquote = strpos($contents, $pingback_str_dquote);&nbsp;</div></li><li><div>  $pingback_link_offset_squote = strpos($contents, $pingback_str_squote);&nbsp;</div></li><li><div>  if ( $pingback_link_offset_dquote || $pingback_link_offset_squote ) {&nbsp;</div></li><li><div>      $quote = ($pingback_link_offset_dquote) ? '&quot;' : '\'';&nbsp;</div></li><li><div>      $pingback_link_offset = ($quote=='&quot;') ? $pingback_link_offset_dquote : $pingback_link_offset_squote;&nbsp;</div></li><li><div>      $pingback_href_pos = @strpos($contents, 'href=', $pingback_link_offset);&nbsp;</div></li><li><div>      $pingback_href_start = $pingback_href_pos+6;&nbsp;</div></li><li><div>      $pingback_href_end = @strpos($contents, $quote, $pingback_href_start);&nbsp;</div></li><li><div>      $pingback_server_url_len = $pingback_href_end - $pingback_href_start;&nbsp;</div></li><li><div>      $pingback_server_url = substr($contents, $pingback_href_start, $pingback_server_url_len);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// We may find rel=&quot;pingback&quot; but an incomplete pingback URL</span>&nbsp;</div></li><li><div>      if ( $pingback_server_url_len &gt; 0 ) { <span class="comment">// We got it!</span>&nbsp;</div></li><li><div>          return $pingback_server_url;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Perform all pingbacks, enclosures, trackbacks, and send to pingback services.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function do_all_pings() {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Do pingbacks</span>&nbsp;</div></li><li><div>  while ($ping = $wpdb-&gt;get_row(&quot;SELECT ID, post_content, meta_id FROM {$wpdb-&gt;posts}, {$wpdb-&gt;postmeta} WHERE {$wpdb-&gt;posts}.ID = {$wpdb-&gt;postmeta}.post_id AND {$wpdb-&gt;postmeta}.meta_key = '_pingme' LIMIT 1&quot;)) {&nbsp;</div></li><li><div>      delete_metadata_by_mid( 'post', $ping-&gt;meta_id );&nbsp;</div></li><li><div>      pingback( $ping-&gt;post_content, $ping-&gt;ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Do Enclosures</span>&nbsp;</div></li><li><div>  while ($enclosure = $wpdb-&gt;get_row(&quot;SELECT ID, post_content, meta_id FROM {$wpdb-&gt;posts}, {$wpdb-&gt;postmeta} WHERE {$wpdb-&gt;posts}.ID = {$wpdb-&gt;postmeta}.post_id AND {$wpdb-&gt;postmeta}.meta_key = '_encloseme' LIMIT 1&quot;)) {&nbsp;</div></li><li><div>      delete_metadata_by_mid( 'post', $enclosure-&gt;meta_id );&nbsp;</div></li><li><div>      do_enclose( $enclosure-&gt;post_content, $enclosure-&gt;ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Do Trackbacks</span>&nbsp;</div></li><li><div>  $trackbacks = $wpdb-&gt;get_col(&quot;SELECT ID FROM $wpdb-&gt;posts WHERE to_ping &lt;&gt; '' AND post_status = 'publish'&quot;);&nbsp;</div></li><li><div>  if ( is_array($trackbacks) )&nbsp;</div></li><li><div>      foreach ( $trackbacks as $trackback )&nbsp;</div></li><li><div>          do_trackbacks($trackback);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">//Do Update Services/Generic Pings</span>&nbsp;</div></li><li><div>  generic_ping();&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Perform trackbacks.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 $post_id can be a WP_Post object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post_id Post object or ID to do trackbacks on.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function do_trackbacks( $post_id ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>  $post = get_post( $post_id );&nbsp;</div></li><li><div>  if ( ! $post ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $to_ping = get_to_ping( $post );&nbsp;</div></li><li><div>  $pinged = get_pung( $post );&nbsp;</div></li><li><div>  if ( empty( $to_ping ) ) {&nbsp;</div></li><li><div>      $wpdb-&gt;update($wpdb-&gt;posts, array( 'to_ping' =&gt; '' ), array( 'ID' =&gt; $post-&gt;ID ) );&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($post-&gt;post_excerpt) ) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/post-template.php */</span></span></span>&nbsp;</div></li><li><div>      $excerpt = apply_filters( 'the_content', $post-&gt;post_content, $post-&gt;ID );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/post-template.php */</span></span></span>&nbsp;</div></li><li><div>      $excerpt = apply_filters( 'the_excerpt', $post-&gt;post_excerpt );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $excerpt = str_replace(']]&gt;', ']]&gt;', $excerpt);&nbsp;</div></li><li><div>  $excerpt = wp_html_excerpt($excerpt, 252, '&#8230;');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/post-template.php */</span></span></span>&nbsp;</div></li><li><div>  $post_title = apply_filters( 'the_title', $post-&gt;post_title, $post-&gt;ID );&nbsp;</div></li><li><div>  $post_title = strip_tags($post_title);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $to_ping ) {&nbsp;</div></li><li><div>      foreach ( (array) $to_ping as $tb_ping ) {&nbsp;</div></li><li><div>          $tb_ping = trim($tb_ping);&nbsp;</div></li><li><div>          if ( !in_array($tb_ping, $pinged) ) {&nbsp;</div></li><li><div>              trackback( $tb_ping, $post_title, $excerpt, $post-&gt;ID );&nbsp;</div></li><li><div>              $pinged[] = $tb_ping;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $wpdb-&gt;query( $wpdb-&gt;prepare( &quot;UPDATE $wpdb-&gt;posts SET to_ping = TRIM(REPLACE(to_ping, %s, &nbsp;</div></li><li><div>                  '')) WHERE ID = %d&quot;, $tb_ping, $post-&gt;ID ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sends pings to all of the ping site services.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int Same as Post ID from parameter</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function generic_ping( $post_id = 0 ) {&nbsp;</div></li><li><div>  $services = get_option('ping_sites');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $services = explode(&quot;\n&quot;, $services);&nbsp;</div></li><li><div>  foreach ( (array) $services as $service ) {&nbsp;</div></li><li><div>      $service = trim($service);&nbsp;</div></li><li><div>      if ( '' != $service )&nbsp;</div></li><li><div>          weblog_ping($service);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post_id;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Pings back the links found in a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 0.71</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 $post_id can be a WP_Post object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $content Post content to check for links. If empty will retrieve from post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post_id Post Object or ID.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function pingback( $content, $post_id ) {&nbsp;</div></li><li><div>  include_once( ABSPATH . WPINC . '/class-IXR.php' );&nbsp;</div></li><li><div>  include_once( ABSPATH . WPINC . '/class-wp-http-ixr-client.php' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// original code by Mort (http://mort.mine.nu:8080)</span>&nbsp;</div></li><li><div>  $post_links = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post( $post_id );&nbsp;</div></li><li><div>  if ( ! $post ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $pung = get_pung( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $content ) ) {&nbsp;</div></li><li><div>      $content = $post-&gt;post_content;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Step 1</span>&nbsp;</div></li><li><div>  <span class="comment">// Parsing the post, external links (if any) are stored in the $post_links array</span>&nbsp;</div></li><li><div>  $post_links_temp = wp_extract_urls( $content );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Step 2.</span>&nbsp;</div></li><li><div>  <span class="comment">// Walking thru the links array</span>&nbsp;</div></li><li><div>  <span class="comment">// first we get rid of links pointing to sites, not to specific files</span>&nbsp;</div></li><li><div>  <span class="comment">// Example:</span>&nbsp;</div></li><li><div>  <span class="comment">// http://dummy-weblog.org</span>&nbsp;</div></li><li><div>  <span class="comment">// http://dummy-weblog.org</span>/&nbsp;</div></li><li><div>  <span class="comment">// http://dummy-weblog.org</span>/post.php&nbsp;</div></li><li><div>  <span class="comment">// We don't wanna ping first and second types, even if they have a valid &lt;link/&gt;</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $post_links_temp as $link_test ) :&nbsp;</div></li><li><div>      if ( ! in_array( $link_test, $pung ) && ( url_to_postid( $link_test ) != $post-&gt;ID ) <span class="comment">// If we haven't pung it already and it isn't a link to itself</span>&nbsp;</div></li><li><div>              && !is_local_attachment($link_test) ) : <span class="comment">// Also, let's never ping local attachments.</span>&nbsp;</div></li><li><div>          if ( $test = @parse_url($link_test) ) {&nbsp;</div></li><li><div>              if ( isset($test['query']) )&nbsp;</div></li><li><div>                  $post_links[] = $link_test;&nbsp;</div></li><li><div>              elseif ( isset( $test['path'] ) && ( $test['path'] != '/' ) && ( $test['path'] != '' ) )&nbsp;</div></li><li><div>                  $post_links[] = $link_test;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      endif;&nbsp;</div></li><li><div>  endforeach;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_links = array_unique( $post_links );&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires just before pinging back links found in a post.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array &$post_links An array of post links to be checked, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array &$pung       Whether a link has already been pinged, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $post_ID     The post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action_ref_array( 'pre_ping', array( &$post_links, &$pung, $post-&gt;ID ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $post_links as $pagelinkedto ) {&nbsp;</div></li><li><div>      $pingback_server_url = discover_pingback_server_uri( $pagelinkedto );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $pingback_server_url ) {&nbsp;</div></li><li><div>          @ set_time_limit( 60 );&nbsp;</div></li><li><div>          <span class="comment">// Now, the RPC call</span>&nbsp;</div></li><li><div>          $pagelinkedfrom = get_permalink( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// using a timeout of 3 seconds should be enough to cover slow servers</span></span>&nbsp;</div></li><li><div>          $client = new WP_HTTP_IXR_Client($pingback_server_url);&nbsp;</div></li><li><div>          $client-&gt;timeout = 3;&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the user agent sent when pinging-back a URL.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $concat_useragent    The user agent concatenated with ' -- WordPress/'</span>&nbsp;</div></li><li><div><span class="comment">           *                                    and the WordPress version.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $useragent           The useragent.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $pingback_server_url The server URL being linked to.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $pagelinkedto        URL of page linked to.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $pagelinkedfrom      URL of page linked from.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $client-&gt;useragent = apply_filters( 'pingback_useragent', $client-&gt;useragent . ' -- WordPress/' . get_bloginfo( 'version' ), $client-&gt;useragent, $pingback_server_url, $pagelinkedto, $pagelinkedfrom );&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// when set to true, this outputs debug messages by itself</span></span>&nbsp;</div></li><li><div>          $client-&gt;debug = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $client-&gt;query('pingback.ping', $pagelinkedfrom, $pagelinkedto) || ( isset($client-&gt;error-&gt;code) && 48 == $client-&gt;error-&gt;code ) ) <span class="comment">// Already registered</span>&nbsp;</div></li><li><div>              add_ping( $post, $pagelinkedto );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check whether blog is public before returning sites.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed $sites Will return if blog is public, will not return if not public.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed Empty string if blog is not public, returns $sites, if site is public.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function privacy_ping_filter($sites) {&nbsp;</div></li><li><div>  if ( '0' != get_option('blog_public') )&nbsp;</div></li><li><div>      return $sites;&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      return '';&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Send a Trackback.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Updates database when sending trackback to prevent duplicates.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 0.71</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $trackback_url URL to send trackbacks.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $title Title of post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $excerpt Excerpt of post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false|void Database query from update.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function trackback($trackback_url, $title, $excerpt, $ID) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($trackback_url) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $options = array();&nbsp;</div></li><li><div>  $options['timeout'] = 10;&nbsp;</div></li><li><div>  $options['body'] = array(&nbsp;</div></li><li><div>      'title' =&gt; $title, &nbsp;</div></li><li><div>      'url' =&gt; get_permalink($ID), &nbsp;</div></li><li><div>      'blog_name' =&gt; get_option('blogname'), &nbsp;</div></li><li><div>      'excerpt' =&gt; $excerpt&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $response = wp_safe_remote_post( $trackback_url, $options );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error( $response ) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wpdb-&gt;query( $wpdb-&gt;prepare(&quot;UPDATE $wpdb-&gt;posts SET pinged = CONCAT(pinged, '\n', %s) WHERE ID = %d&quot;, $trackback_url, $ID) );&nbsp;</div></li><li><div>  return $wpdb-&gt;query( $wpdb-&gt;prepare(&quot;UPDATE $wpdb-&gt;posts SET to_ping = TRIM(REPLACE(to_ping, %s, '')) WHERE ID = %d&quot;, $trackback_url, $ID) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Send a pingback.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $server Host of blog to connect to.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $path Path to send the ping.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function weblog_ping($server = '', $path = '') {&nbsp;</div></li><li><div>  include_once( ABSPATH . WPINC . '/class-IXR.php' );&nbsp;</div></li><li><div>  include_once( ABSPATH . WPINC . '/class-wp-http-ixr-client.php' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// using a timeout of 3 seconds should be enough to cover slow servers</span></span>&nbsp;</div></li><li><div>  $client = new WP_HTTP_IXR_Client($server, ((!strlen(trim($path)) || ('/' == $path)) ? false : $path));&nbsp;</div></li><li><div>  $client-&gt;timeout = 3;&nbsp;</div></li><li><div>  $client-&gt;useragent .= ' -- WordPress/' . get_bloginfo( 'version' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// when set to true, this outputs debug messages by itself</span></span>&nbsp;</div></li><li><div>  $client-&gt;debug = false;&nbsp;</div></li><li><div>  $home = trailingslashit( home_url() );&nbsp;</div></li><li><div>  if ( !$client-&gt;query('weblogUpdates.extendedPing', get_option('blogname'), $home, get_bloginfo('rss2_url') ) ) <span class="comment">// then try a normal ping</span>&nbsp;</div></li><li><div>      $client-&gt;query('weblogUpdates.ping', get_option('blogname'), $home);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Default filter attached to pingback_ping_source_uri to validate the pingback's Source URI</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.5.1</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_http_validate_url()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $source_uri</span>&nbsp;</div></li><li><div><span class="comment"> * @return string</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function pingback_ping_source_uri( $source_uri ) {&nbsp;</div></li><li><div>  return (string) wp_http_validate_url( $source_uri );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Default filter attached to xmlrpc_pingback_error.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Returns a generic pingback error code unless the error code is 48, </span>&nbsp;</div></li><li><div><span class="comment"> * which reports that the pingback is already registered.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.5.1</span>&nbsp;</div></li><li><div><span class="comment"> * @link https://www.hixie.ch/specs/pingback/pingback#TOC3</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param IXR_Error $ixr_error</span>&nbsp;</div></li><li><div><span class="comment"> * @return IXR_Error</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function xmlrpc_pingback_error( $ixr_error ) {&nbsp;</div></li><li><div>  if ( $ixr_error-&gt;code === 48 )&nbsp;</div></li><li><div>      return $ixr_error;&nbsp;</div></li><li><div>  return new IXR_Error( 0, '' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Cache&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Removes a comment from the object cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|array $ids Comment ID or an array of comment IDs to remove from cache.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function clean_comment_cache($ids) {&nbsp;</div></li><li><div>  foreach ( (array) $ids as $id ) {&nbsp;</div></li><li><div>      wp_cache_delete( $id, 'comment' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a comment has been removed from the object cache.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $id Comment ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'clean_comment_cache', $id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_set( 'last_changed', microtime(), 'comment' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates the comment cache of given comments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Will add the comments in $comments to the cache. If comment ID already exists</span>&nbsp;</div></li><li><div><span class="comment"> * in the comment cache then it will not be updated. The comment is added to the</span>&nbsp;</div></li><li><div><span class="comment"> * cache using the comment group with the key using the ID of the comments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Introduced the `$update_meta_cache` parameter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $comments          Array of comment row objects</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $update_meta_cache Whether to update commentmeta cache. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_comment_cache( $comments, $update_meta_cache = true ) {&nbsp;</div></li><li><div>  foreach ( (array) $comments as $comment )&nbsp;</div></li><li><div>      wp_cache_add($comment-&gt;comment_ID, $comment, 'comment');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $update_meta_cache ) {&nbsp;</div></li><li><div>      <span class="comment">// Avoid `wp_list_pluck()` in case `$comments` is passed by reference.</span>&nbsp;</div></li><li><div>      $comment_ids = array();&nbsp;</div></li><li><div>      foreach ( $comments as $comment ) {&nbsp;</div></li><li><div>          $comment_ids[] = $comment-&gt;comment_ID;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      update_meta_cache( 'comment', $comment_ids );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds any comments from the given IDs to the cache that do not already exist in cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see update_comment_cache()</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $comment_ids       Array of comment IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $update_meta_cache Optional. Whether to update the meta cache. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _prime_comment_caches( $comment_ids, $update_meta_cache = true ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $non_cached_ids = _get_non_cached_ids( $comment_ids, 'comment' );&nbsp;</div></li><li><div>  if ( !empty( $non_cached_ids ) ) {&nbsp;</div></li><li><div>      $fresh_comments = $wpdb-&gt;get_results( sprintf( &quot;SELECT $wpdb-&gt;comments.* FROM $wpdb-&gt;comments WHERE comment_ID IN (%s)&quot;, join( &quot;, &quot;, array_map( 'intval', $non_cached_ids ) ) ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      update_comment_cache( $fresh_comments, $update_meta_cache );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Internal&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Close comments on old posts on the fly, without any extra DB queries. Hooked to the_posts.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post  $posts Post data object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Query $query Query object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _close_comments_for_old_posts( $posts, $query ) {&nbsp;</div></li><li><div>  if ( empty( $posts ) || ! $query-&gt;is_singular() || ! get_option( 'close_comments_for_old_posts' ) )&nbsp;</div></li><li><div>      return $posts;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the list of post types to automatically close comments for.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $post_types An array of registered post types. Default array with 'post'.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $post_types = apply_filters( 'close_comments_for_post_types', array( 'post' ) );&nbsp;</div></li><li><div>  if ( ! in_array( $posts[0]-&gt;post_type, $post_types ) )&nbsp;</div></li><li><div>      return $posts;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $days_old = (int) get_option( 'close_comments_days_old' );&nbsp;</div></li><li><div>  if ( ! $days_old )&nbsp;</div></li><li><div>      return $posts;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( time() - strtotime( $posts[0]-&gt;post_date_gmt ) &gt; ( $days_old * DAY_IN_SECONDS ) ) {&nbsp;</div></li><li><div>      $posts[0]-&gt;comment_status = 'closed';&nbsp;</div></li><li><div>      $posts[0]-&gt;ping_status = 'closed';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $posts;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Close comments on an old post. Hooked to comments_open and pings_open.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $open Comments open or closed</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Post ID</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool $open</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _close_comments_for_old_post( $open, $post_id ) {&nbsp;</div></li><li><div>  if ( ! $open )&nbsp;</div></li><li><div>      return $open;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !get_option('close_comments_for_old_posts') )&nbsp;</div></li><li><div>      return $open;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $days_old = (int) get_option('close_comments_days_old');&nbsp;</div></li><li><div>  if ( !$days_old )&nbsp;</div></li><li><div>      return $open;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post($post_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/comment.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  $post_types = apply_filters( 'close_comments_for_post_types', array( 'post' ) );&nbsp;</div></li><li><div>  if ( ! in_array( $post-&gt;post_type, $post_types ) )&nbsp;</div></li><li><div>      return $open;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Undated drafts should not show up as comments closed.</span>&nbsp;</div></li><li><div>  if ( '0000-00-00 00:00:00' === $post-&gt;post_date_gmt ) {&nbsp;</div></li><li><div>      return $open;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( time() - strtotime( $post-&gt;post_date_gmt ) &gt; ( $days_old * DAY_IN_SECONDS ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $open;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Handles the submission of a comment, usually posted to wp-comments-post.php via a comment form.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function expects unslashed data, as opposed to functions such as `wp_new_comment()` which</span>&nbsp;</div></li><li><div><span class="comment"> * expect slashed data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $comment_data {</span>&nbsp;</div></li><li><div><span class="comment"> *     Comment data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|int $comment_post_ID             The ID of the post that relates to the comment.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $author                      The name of the comment author.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $email                       The comment author email address.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $url                         The comment author URL.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $comment                     The content of the comment.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|int $comment_parent              The ID of this comment's parent, if any. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string     $_wp_unfiltered_html_comment The nonce value for allowing unfiltered HTML.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Comment|WP_Error A WP_Comment object on success, a WP_Error object on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_handle_comment_submission( $comment_data ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_post_ID = $comment_parent = 0;&nbsp;</div></li><li><div>  $comment_author = $comment_author_email = $comment_author_url = $comment_content = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $comment_data['comment_post_ID'] ) ) {&nbsp;</div></li><li><div>      $comment_post_ID = (int) $comment_data['comment_post_ID'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( isset( $comment_data['author'] ) && is_string( $comment_data['author'] ) ) {&nbsp;</div></li><li><div>      $comment_author = trim( strip_tags( $comment_data['author'] ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( isset( $comment_data['email'] ) && is_string( $comment_data['email'] ) ) {&nbsp;</div></li><li><div>      $comment_author_email = trim( $comment_data['email'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( isset( $comment_data['url'] ) && is_string( $comment_data['url'] ) ) {&nbsp;</div></li><li><div>      $comment_author_url = trim( $comment_data['url'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( isset( $comment_data['comment'] ) && is_string( $comment_data['comment'] ) ) {&nbsp;</div></li><li><div>      $comment_content = trim( $comment_data['comment'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( isset( $comment_data['comment_parent'] ) ) {&nbsp;</div></li><li><div>      $comment_parent = absint( $comment_data['comment_parent'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post( $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $post-&gt;comment_status ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when a comment is attempted on a post that does not exist.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'comment_id_not_found', $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return new WP_Error( 'comment_id_not_found' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// get_post_status() will get the parent status for attachments.</span>&nbsp;</div></li><li><div>  $status = get_post_status( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ( 'private' == $status ) && ! current_user_can( 'read_post', $comment_post_ID ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'comment_id_not_found' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $status_obj = get_post_status_object( $status );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! comments_open( $comment_post_ID ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when a comment is attempted on a post that has comments closed.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'comment_closed', $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return new WP_Error( 'comment_closed', __( 'Sorry, comments are closed for this item.' ), 403 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  } elseif ( 'trash' == $status ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when a comment is attempted on a trashed post.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'comment_on_trash', $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return new WP_Error( 'comment_on_trash' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  } elseif ( ! $status_obj-&gt;public && ! $status_obj-&gt;private ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when a comment is attempted on a post in draft mode.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.1</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'comment_on_draft', $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return new WP_Error( 'comment_on_draft' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  } elseif ( post_password_required( $comment_post_ID ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when a comment is attempted on a password-protected post.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'comment_on_password_protected', $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return new WP_Error( 'comment_on_password_protected' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires before a comment is posted.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $comment_post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'pre_comment_on_post', $comment_post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If the user is logged in</span>&nbsp;</div></li><li><div>  $user = wp_get_current_user();&nbsp;</div></li><li><div>  if ( $user-&gt;exists() ) {&nbsp;</div></li><li><div>      if ( empty( $user-&gt;display_name ) ) {&nbsp;</div></li><li><div>          $user-&gt;display_name=$user-&gt;user_login;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $comment_author = $user-&gt;display_name;&nbsp;</div></li><li><div>      $comment_author_email = $user-&gt;user_email;&nbsp;</div></li><li><div>      $comment_author_url = $user-&gt;user_url;&nbsp;</div></li><li><div>      $user_ID = $user-&gt;ID;&nbsp;</div></li><li><div>      if ( current_user_can( 'unfiltered_html' ) ) {&nbsp;</div></li><li><div>          if ( ! isset( $comment_data['_wp_unfiltered_html_comment'] )&nbsp;</div></li><li><div>              || ! wp_verify_nonce( $comment_data['_wp_unfiltered_html_comment'], 'unfiltered-html-comment_' . $comment_post_ID )&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>              kses_remove_filters(); <span class="comment">// start with a clean slate</span>&nbsp;</div></li><li><div>              kses_init_filters(); <span class="comment">// set up the filters</span>&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      if ( get_option( 'comment_registration' ) ) {&nbsp;</div></li><li><div>          return new WP_Error( 'not_logged_in', __( 'Sorry, you must be logged in to comment.' ), 403 );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_type = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( get_option( 'require_name_email' ) && ! $user-&gt;exists() ) {&nbsp;</div></li><li><div>      if ( 6 &gt; strlen( $comment_author_email ) || '' == $comment_author ) {&nbsp;</div></li><li><div>          return new WP_Error( 'require_name_email', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: please fill the required fields (name, email).' ), 200 );&nbsp;</div></li><li><div>      } elseif ( ! is_email( $comment_author_email ) ) {&nbsp;</div></li><li><div>          return new WP_Error( 'require_valid_email', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: please enter a valid email address.' ), 200 );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( '' == $comment_content ) {&nbsp;</div></li><li><div>      return new WP_Error( 'require_valid_comment', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: please type a comment.' ), 200 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $commentdata = compact(&nbsp;</div></li><li><div>      'comment_post_ID', &nbsp;</div></li><li><div>      'comment_author', &nbsp;</div></li><li><div>      'comment_author_email', &nbsp;</div></li><li><div>      'comment_author_url', &nbsp;</div></li><li><div>      'comment_content', &nbsp;</div></li><li><div>      'comment_type', &nbsp;</div></li><li><div>      'comment_parent', &nbsp;</div></li><li><div>      'user_ID'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $check_max_lengths = wp_check_comment_data_max_lengths( $commentdata );&nbsp;</div></li><li><div>  if ( is_wp_error( $check_max_lengths ) ) {&nbsp;</div></li><li><div>      return $check_max_lengths;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_id = wp_new_comment( wp_slash( $commentdata ), true );&nbsp;</div></li><li><div>  if ( is_wp_error( $comment_id ) ) {&nbsp;</div></li><li><div>      return $comment_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $comment_id ) {&nbsp;</div></li><li><div>      return new WP_Error( 'comment_save_error', __( '&lt;strong&gt;ERROR&lt;/strong&gt;: The comment could not be saved. Please try again later.' ), 500 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return get_comment( $comment_id );&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>file</li><li><span></span></li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>