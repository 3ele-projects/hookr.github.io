<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="wordpress" data-version="4.7" data-type="class" data-id="3790"><head xmlns="http://www.w3.org/1999/xhtml"><title> smtp | class | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="SMTP, class, wordpress, 4.7" /><meta name="description" content="PHPMailer RFC821 SMTP email transport class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.10"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=b4703e6af03f64834419eca8fe58b105' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.10' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/smtp/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fsmtp%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fsmtp%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7-class-smtp","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="smtp" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7." href="http://hookr.io/4.7/" class="H_VERSION"><span property="name">4.7</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/4.7/classes/" class=""><span property="name">classes</span></a><meta property="position" content="3"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">smtp</span><meta property="position" content="4"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="6307"><a href="http://hookr.io/4.7/all/" title="All">All <span class="count badge">6307</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/4.7/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="2531"><a href="http://hookr.io/4.7/hooks/" title="Hooks">Hooks <span class="count badge">2531</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1667"><a href="http://hookr.io/4.7/filters/" title="Filters">Filters <span class="count badge">1667</span></a></li><li class="active" data-id="class" data-count="351"><a href="http://hookr.io/4.7/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2851"><a href="http://hookr.io/4.7/functions/" title="Functions">Functions <span class="count badge">2851</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>SMTP</strong></h1><p>PHPMailer RFC821 SMTP email transport class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/4.7/files/wp-includes-class-smtp/" class="file">/wp-includes/class-smtp.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="27" class="block" start="27"><li><div>class SMTP&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The PHPMailer SMTP version number.&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const VERSION = '5.2.14';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * SMTP line break constant.&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const CRLF = &quot;\r\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The SMTP port to use if one is not specified.&nbsp;</div></li><li><div>     * @var integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const DEFAULT_SMTP_PORT = 25;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The maximum line length allowed by RFC 2822 section 2.1.1&nbsp;</div></li><li><div>     * @var integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const MAX_LINE_LENGTH = 998;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Debug level for no output&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const DEBUG_OFF = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Debug level to show client -&gt; server messages&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const DEBUG_CLIENT = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Debug level to show client -&gt; server and server -&gt; client messages&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const DEBUG_SERVER = 2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Debug level to show connection status, client -&gt; server and server -&gt; client messages&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const DEBUG_CONNECTION = 3;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Debug level to show all messages&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const DEBUG_LOWLEVEL = 4;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The PHPMailer SMTP Version number.&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     * @deprecated Use the `VERSION` constant instead&nbsp;</div></li><li><div>     * @see SMTP::VERSION&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $Version = '5.2.14';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * SMTP server port number.&nbsp;</div></li><li><div>     * @var integer&nbsp;</div></li><li><div>     * @deprecated This is only ever used as a default value, so use the `DEFAULT_SMTP_PORT` constant instead&nbsp;</div></li><li><div>     * @see SMTP::DEFAULT_SMTP_PORT&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $SMTP_PORT = 25;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * SMTP reply line ending.&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     * @deprecated Use the `CRLF` constant instead&nbsp;</div></li><li><div>     * @see SMTP::CRLF&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $CRLF = &quot;\r\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Debug output level.&nbsp;</div></li><li><div>     * Options:&nbsp;</div></li><li><div>     * * self::DEBUG_OFF (`0`) No debug output, default&nbsp;</div></li><li><div>     * * self::DEBUG_CLIENT (`1`) Client commands&nbsp;</div></li><li><div>     * * self::DEBUG_SERVER (`2`) Client commands and server responses&nbsp;</div></li><li><div>     * * self::DEBUG_CONNECTION (`3`) As DEBUG_SERVER plus connection status&nbsp;</div></li><li><div>     * * self::DEBUG_LOWLEVEL (`4`) Low-level data output, all messages&nbsp;</div></li><li><div>     * @var integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $do_debug = self::DEBUG_OFF;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * How to handle debug output.&nbsp;</div></li><li><div>     * Options:&nbsp;</div></li><li><div>     * * `echo` Output plain-text as-is, appropriate for CLI&nbsp;</div></li><li><div>     * * `html` Output escaped, line breaks converted to `&lt;br&gt;`, appropriate for browser output&nbsp;</div></li><li><div>     * * `error_log` Output to error log as configured in php.ini&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Alternatively, you can provide a callable expecting two params: a message string and the debug level:&nbsp;</div></li><li><div>     * &lt;code&gt;&nbsp;</div></li><li><div>     * $smtp-&gt;Debugoutput = function($str, $level) {echo &quot;debug level $level; message: $str&quot;;};&nbsp;</div></li><li><div>     * &lt;/code&gt;&nbsp;</div></li><li><div>     * @var string|callable&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $Debugoutput = 'echo';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Whether to use VERP.&nbsp;</div></li><li><div>     * @link http://en.wikipedia.org/wiki/Variable_envelope_return_path&nbsp;</div></li><li><div>     * @link http://www.postfix.org/VERP_README.html Info on VERP&nbsp;</div></li><li><div>     * @var boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $do_verp = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The timeout value for connection, in seconds.&nbsp;</div></li><li><div>     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2&nbsp;</div></li><li><div>     * This needs to be quite high to function correctly with hosts using greetdelay as an anti-spam measure.&nbsp;</div></li><li><div>     * @link http://tools.ietf.org/html/rfc2821#section-4.5.3.2&nbsp;</div></li><li><div>     * @var integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $Timeout = 300;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * How long to wait for commands to complete, in seconds.&nbsp;</div></li><li><div>     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2&nbsp;</div></li><li><div>     * @var integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $Timelimit = 300;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The socket for the server connection.&nbsp;</div></li><li><div>     * @var resource&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $smtp_conn;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Error information, if any, for the last SMTP command.&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $error = array(&nbsp;</div></li><li><div>        'error' =&gt; '', &nbsp;</div></li><li><div>        'detail' =&gt; '', &nbsp;</div></li><li><div>        'smtp_code' =&gt; '', &nbsp;</div></li><li><div>        'smtp_code_ex' =&gt; ''&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The reply the server sent to us for HELO.&nbsp;</div></li><li><div>     * If null, no HELO string has yet been received.&nbsp;</div></li><li><div>     * @var string|null&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $helo_rply = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The set of SMTP extensions sent in reply to EHLO command.&nbsp;</div></li><li><div>     * Indexes of the array are extension names.&nbsp;</div></li><li><div>     * Value at index 'HELO' or 'EHLO' (according to command that was sent)&nbsp;</div></li><li><div>     * represents the server name. In case of HELO it is the only element of the array.&nbsp;</div></li><li><div>     * Other values can be boolean TRUE or an array containing extension options.&nbsp;</div></li><li><div>     * If null, no HELO/EHLO string has yet been received.&nbsp;</div></li><li><div>     * @var array|null&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $server_caps = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The most recent reply received from the server.&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $last_reply = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Output debugging info via a user-selected method.&nbsp;</div></li><li><div>     * @see SMTP::$Debugoutput&nbsp;</div></li><li><div>     * @see SMTP::$do_debug&nbsp;</div></li><li><div>     * @param string $str Debug string to output&nbsp;</div></li><li><div>     * @param integer $level The debug level of this message; see DEBUG_* constants&nbsp;</div></li><li><div>     * @return void&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function edebug($str, $level = 0)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if ($level &gt; $this-&gt;do_debug) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        //Avoid clash with built-in function names&nbsp;</div></li><li><div>        if (!in_array($this-&gt;Debugoutput, array('error_log', 'html', 'echo')) and is_callable($this-&gt;Debugoutput)) {&nbsp;</div></li><li><div>            call_user_func($this-&gt;Debugoutput, $str, $this-&gt;do_debug);&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        switch ($this-&gt;Debugoutput) {&nbsp;</div></li><li><div>            case 'error_log':&nbsp;</div></li><li><div>                //Don't output, just log&nbsp;</div></li><li><div>                error_log($str);&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            case 'html':&nbsp;</div></li><li><div>                //Cleans up output a bit for a better looking, HTML-safe output&nbsp;</div></li><li><div>                echo htmlentities(&nbsp;</div></li><li><div>                    preg_replace('/[\r\n]+/', '', $str), &nbsp;</div></li><li><div>                    ENT_QUOTES, &nbsp;</div></li><li><div>                    'UTF-8'&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                . &quot;&lt;br&gt;\n&quot;;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            case 'echo':&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                //Normalize line breaks&nbsp;</div></li><li><div>                $str = preg_replace('/(\r\n|\r|\n)/ms', &quot;\n&quot;, $str);&nbsp;</div></li><li><div>                echo gmdate('Y-m-d H:i:s') . &quot;\t&quot; . str_replace(&nbsp;</div></li><li><div>                    &quot;\n&quot;, &nbsp;</div></li><li><div>                    &quot;\n                   \t                  &quot;, &nbsp;</div></li><li><div>                    trim($str)&nbsp;</div></li><li><div> ).&quot;\n&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Connect to an SMTP server.&nbsp;</div></li><li><div>     * @param string $host SMTP server IP or host name&nbsp;</div></li><li><div>     * @param integer $port The port number to connect to&nbsp;</div></li><li><div>     * @param integer $timeout How long to wait for the connection to open&nbsp;</div></li><li><div>     * @param array $options An array of options for stream_context_create()&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function connect($host, $port = null, $timeout = 30, $options = array())&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        static $streamok;&nbsp;</div></li><li><div>        //This is enabled by default since 5.0.0 but some providers disable it&nbsp;</div></li><li><div>        //Check this once and cache the result&nbsp;</div></li><li><div>        if (is_null($streamok)) {&nbsp;</div></li><li><div>            $streamok = function_exists('stream_socket_client');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Clear errors to avoid confusion&nbsp;</div></li><li><div>        $this-&gt;setError('');&nbsp;</div></li><li><div>        // Make sure we are __not__ connected&nbsp;</div></li><li><div>        if ($this-&gt;connected()) {&nbsp;</div></li><li><div>            // Already connected, generate error&nbsp;</div></li><li><div>            $this-&gt;setError('Already connected to a server');&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (empty($port)) {&nbsp;</div></li><li><div>            $port = self::DEFAULT_SMTP_PORT;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Connect to the SMTP server&nbsp;</div></li><li><div>        $this-&gt;edebug(&nbsp;</div></li><li><div>            &quot;Connection: opening to $host:$port, timeout=$timeout, options=&quot;.var_export($options, true), &nbsp;</div></li><li><div>            self::DEBUG_CONNECTION&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        $errno = 0;&nbsp;</div></li><li><div>        $errstr = '';&nbsp;</div></li><li><div>        if ($streamok) {&nbsp;</div></li><li><div>            $socket_context = stream_context_create($options);&nbsp;</div></li><li><div>            //Suppress errors; connection failures are handled at a higher level&nbsp;</div></li><li><div>            $this-&gt;smtp_conn = @stream_socket_client(&nbsp;</div></li><li><div>                $host . &quot;:&quot; . $port, &nbsp;</div></li><li><div>                $errno, &nbsp;</div></li><li><div>                $errstr, &nbsp;</div></li><li><div>                $timeout, &nbsp;</div></li><li><div>                STREAM_CLIENT_CONNECT, &nbsp;</div></li><li><div>                $socket_context&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            //Fall back to fsockopen which should work in more places, but is missing some features&nbsp;</div></li><li><div>            $this-&gt;edebug(&nbsp;</div></li><li><div>                &quot;Connection: stream_socket_client not available, falling back to fsockopen&quot;, &nbsp;</div></li><li><div>                self::DEBUG_CONNECTION&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>            $this-&gt;smtp_conn = fsockopen(&nbsp;</div></li><li><div>                $host, &nbsp;</div></li><li><div>                $port, &nbsp;</div></li><li><div>                $errno, &nbsp;</div></li><li><div>                $errstr, &nbsp;</div></li><li><div>                $timeout&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Verify we connected properly&nbsp;</div></li><li><div>        if (!is_resource($this-&gt;smtp_conn)) {&nbsp;</div></li><li><div>            $this-&gt;setError(&nbsp;</div></li><li><div>                'Failed to connect to server', &nbsp;</div></li><li><div>                $errno, &nbsp;</div></li><li><div>                $errstr&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>            $this-&gt;edebug(&nbsp;</div></li><li><div>                'SMTP ERROR: ' . $this-&gt;error['error']&nbsp;</div></li><li><div>                . &quot;: $errstr ($errno)&quot;, &nbsp;</div></li><li><div>                self::DEBUG_CLIENT&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $this-&gt;edebug('Connection: opened', self::DEBUG_CONNECTION);&nbsp;</div></li><li><div>        // SMTP server can take longer to respond, give longer timeout for first read&nbsp;</div></li><li><div>        // Windows does not have support for this timeout function&nbsp;</div></li><li><div>        if (substr(PHP_OS, 0, 3) != 'WIN') {&nbsp;</div></li><li><div>            $max = ini_get('max_execution_time');&nbsp;</div></li><li><div>            // Don't bother if unlimited&nbsp;</div></li><li><div>            if ($max != 0 && $timeout &gt; $max) {&nbsp;</div></li><li><div>                @set_time_limit($timeout);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            stream_set_timeout($this-&gt;smtp_conn, $timeout, 0);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Get any announcement&nbsp;</div></li><li><div>        $announce = $this-&gt;get_lines();&nbsp;</div></li><li><div>        $this-&gt;edebug('SERVER -&gt; CLIENT: ' . $announce, self::DEBUG_SERVER);&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Initiate a TLS (encrypted) session.&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function startTLS()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (!$this-&gt;sendCommand('STARTTLS', 'STARTTLS', 220)) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Begin encrypted connection&nbsp;</div></li><li><div>        if (!stream_socket_enable_crypto(&nbsp;</div></li><li><div>            $this-&gt;smtp_conn, &nbsp;</div></li><li><div>            true, &nbsp;</div></li><li><div>            STREAM_CRYPTO_METHOD_TLS_CLIENT&nbsp;</div></li><li><div> )) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Perform SMTP authentication.&nbsp;</div></li><li><div>     * Must be run after hello().&nbsp;</div></li><li><div>     * @see hello()&nbsp;</div></li><li><div>     * @param string $username The user name&nbsp;</div></li><li><div>     * @param string $password The password&nbsp;</div></li><li><div>     * @param string $authtype The auth type (PLAIN, LOGIN, NTLM, CRAM-MD5, XOAUTH2)&nbsp;</div></li><li><div>     * @param string $realm The auth realm for NTLM&nbsp;</div></li><li><div>     * @param string $workstation The auth workstation for NTLM&nbsp;</div></li><li><div>     * @param null|OAuth $OAuth An optional OAuth instance (@see PHPMailerOAuth)&nbsp;</div></li><li><div>     * @return bool True if successfully authenticated.* @access public&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function authenticate(&nbsp;</div></li><li><div>        $username, &nbsp;</div></li><li><div>        $password, &nbsp;</div></li><li><div>        $authtype = null, &nbsp;</div></li><li><div>        $realm = '', &nbsp;</div></li><li><div>        $workstation = '', &nbsp;</div></li><li><div>        $OAuth = null&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>        if (!$this-&gt;server_caps) {&nbsp;</div></li><li><div>            $this-&gt;setError('Authentication is not allowed before HELO/EHLO');&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (array_key_exists('EHLO', $this-&gt;server_caps)) {&nbsp;</div></li><li><div>        // SMTP extensions are available. Let's try to find a proper authentication method&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (!array_key_exists('AUTH', $this-&gt;server_caps)) {&nbsp;</div></li><li><div>                $this-&gt;setError('Authentication is not allowed at this stage');&nbsp;</div></li><li><div>                // 'at this stage' means that auth may be allowed after the stage changes&nbsp;</div></li><li><div>                // e.g. after STARTTLS&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            self::edebug('Auth method requested: ' . ($authtype ? $authtype : 'UNKNOWN'), self::DEBUG_LOWLEVEL);&nbsp;</div></li><li><div>            self::edebug(&nbsp;</div></li><li><div>                'Auth methods available on the server: ' . implode(', ', $this-&gt;server_caps['AUTH']), &nbsp;</div></li><li><div>                self::DEBUG_LOWLEVEL&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (empty($authtype)) {&nbsp;</div></li><li><div>                foreach (array('LOGIN', 'CRAM-MD5', 'PLAIN') as $method) {&nbsp;</div></li><li><div>                    if (in_array($method, $this-&gt;server_caps['AUTH'])) {&nbsp;</div></li><li><div>                        $authtype = $method;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (empty($authtype)) {&nbsp;</div></li><li><div>                    $this-&gt;setError('No supported authentication methods found');&nbsp;</div></li><li><div>                    return false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                self::edebug('Auth method selected: '.$authtype, self::DEBUG_LOWLEVEL);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (!in_array($authtype, $this-&gt;server_caps['AUTH'])) {&nbsp;</div></li><li><div>                $this-&gt;setError(&quot;The requested authentication method \&quot;$authtype\&quot; is not supported by the server&quot;);&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } elseif (empty($authtype)) {&nbsp;</div></li><li><div>            $authtype = 'LOGIN';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        switch ($authtype) {&nbsp;</div></li><li><div>            case 'PLAIN':&nbsp;</div></li><li><div>                // Start authentication&nbsp;</div></li><li><div>                if (!$this-&gt;sendCommand('AUTH', 'AUTH PLAIN', 334)) {&nbsp;</div></li><li><div>                    return false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // Send encoded username and password&nbsp;</div></li><li><div>                if (!$this-&gt;sendCommand(&nbsp;</div></li><li><div>                    'User & Password', &nbsp;</div></li><li><div>                    base64_encode(&quot;\0&quot; . $username . &quot;\0&quot; . $password), &nbsp;</div></li><li><div>                    235&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                    return false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            case 'LOGIN':&nbsp;</div></li><li><div>                // Start authentication&nbsp;</div></li><li><div>                if (!$this-&gt;sendCommand('AUTH', 'AUTH LOGIN', 334)) {&nbsp;</div></li><li><div>                    return false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (!$this-&gt;sendCommand(&quot;Username&quot;, base64_encode($username), 334)) {&nbsp;</div></li><li><div>                    return false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (!$this-&gt;sendCommand(&quot;Password&quot;, base64_encode($password), 235)) {&nbsp;</div></li><li><div>                    return false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            case 'CRAM-MD5':&nbsp;</div></li><li><div>                // Start authentication&nbsp;</div></li><li><div>                if (!$this-&gt;sendCommand('AUTH CRAM-MD5', 'AUTH CRAM-MD5', 334)) {&nbsp;</div></li><li><div>                    return false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // Get the challenge&nbsp;</div></li><li><div>                $challenge = base64_decode(substr($this-&gt;last_reply, 4));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Build the response&nbsp;</div></li><li><div>                $response = $username . ' ' . $this-&gt;hmac($challenge, $password);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // send encoded credentials&nbsp;</div></li><li><div>                return $this-&gt;sendCommand('Username', base64_encode($response), 235);&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                $this-&gt;setError(&quot;Authentication method \&quot;$authtype\&quot; is not supported&quot;);&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Calculate an MD5 HMAC hash.&nbsp;</div></li><li><div>     * Works like hash_hmac('md5', $data, $key)&nbsp;</div></li><li><div>     * in case that function is not available&nbsp;</div></li><li><div>     * @param string $data The data to hash&nbsp;</div></li><li><div>     * @param string $key  The key to hash with&nbsp;</div></li><li><div>     * @access protected&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function hmac($data, $key)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (function_exists('hash_hmac')) {&nbsp;</div></li><li><div>            return hash_hmac('md5', $data, $key);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // The following borrowed from&nbsp;</div></li><li><div>        // http://php.net/manual/en/function.mhash.php#27225&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // RFC 2104 HMAC implementation for php.&nbsp;</div></li><li><div>        // Creates an md5 HMAC.&nbsp;</div></li><li><div>        // Eliminates the need to install mhash to compute a HMAC&nbsp;</div></li><li><div>        // by Lance Rushing&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $bytelen = 64; // byte length for md5&nbsp;</div></li><li><div>        if (strlen($key) &gt; $bytelen) {&nbsp;</div></li><li><div>            $key = pack('H*', md5($key));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $key = str_pad($key, $bytelen, chr(0x00));&nbsp;</div></li><li><div>        $ipad = str_pad('', $bytelen, chr(0x36));&nbsp;</div></li><li><div>        $opad = str_pad('', $bytelen, chr(0x5c));&nbsp;</div></li><li><div>        $k_ipad = $key ^ $ipad;&nbsp;</div></li><li><div>        $k_opad = $key ^ $opad;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return md5($k_opad . pack('H*', md5($k_ipad . $data)));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Check connection state.&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean True if connected.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function connected()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (is_resource($this-&gt;smtp_conn)) {&nbsp;</div></li><li><div>            $sock_status = stream_get_meta_data($this-&gt;smtp_conn);&nbsp;</div></li><li><div>            if ($sock_status['eof']) {&nbsp;</div></li><li><div>                // The socket is valid but we are not connected&nbsp;</div></li><li><div>                $this-&gt;edebug(&nbsp;</div></li><li><div>                    'SMTP NOTICE: EOF caught while checking if connected', &nbsp;</div></li><li><div>                    self::DEBUG_CLIENT&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                $this-&gt;close();&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return true; // everything looks good&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Close the socket and clean up the state of the class.&nbsp;</div></li><li><div>     * Don't use this function without first trying to use QUIT.&nbsp;</div></li><li><div>     * @see quit()&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return void&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function close()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;setError('');&nbsp;</div></li><li><div>        $this-&gt;server_caps = null;&nbsp;</div></li><li><div>        $this-&gt;helo_rply = null;&nbsp;</div></li><li><div>        if (is_resource($this-&gt;smtp_conn)) {&nbsp;</div></li><li><div>            // close the connection and cleanup&nbsp;</div></li><li><div>            fclose($this-&gt;smtp_conn);&nbsp;</div></li><li><div>            $this-&gt;smtp_conn = null; //Makes for cleaner serialization&nbsp;</div></li><li><div>            $this-&gt;edebug('Connection: closed', self::DEBUG_CONNECTION);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP DATA command.&nbsp;</div></li><li><div>     * Issues a data command and sends the msg_data to the server, &nbsp;</div></li><li><div>     * finializing the mail transaction. $msg_data is the message&nbsp;</div></li><li><div>     * that is to be send with the headers. Each header needs to be&nbsp;</div></li><li><div>     * on a single line followed by a &lt;CRLF&gt; with the message headers&nbsp;</div></li><li><div>     * and the message body being separated by and additional &lt;CRLF&gt;.&nbsp;</div></li><li><div>     * Implements rfc 821: DATA &lt;CRLF&gt;&nbsp;</div></li><li><div>     * @param string $msg_data Message data to send&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function data($msg_data)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        //This will use the standard timelimit&nbsp;</div></li><li><div>        if (!$this-&gt;sendCommand('DATA', 'DATA', 354)) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** The server is ready to accept data!&nbsp;</div></li><li><div>         * According to rfc821 we should not send more than 1000 characters on a single line (including the CRLF)&nbsp;</div></li><li><div>         * so we will break the data up into lines by \r and/or \n then if needed we will break each of those into&nbsp;</div></li><li><div>         * smaller lines to fit within the limit.&nbsp;</div></li><li><div>         * We will also look for lines that start with a '.' and prepend an additional '.'.&nbsp;</div></li><li><div>         * NOTE: this does not count towards line-length limit.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Normalize line breaks before exploding&nbsp;</div></li><li><div>        $lines = explode(&quot;\n&quot;, str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;), &quot;\n&quot;, $msg_data));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** To distinguish between a complete RFC822 message and a plain message body, we check if the first field&nbsp;</div></li><li><div>         * of the first line (':' separated) does not contain a space then it _should_ be a header and we will&nbsp;</div></li><li><div>         * process all lines before a blank line as headers.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $field = substr($lines[0], 0, strpos($lines[0], ':'));&nbsp;</div></li><li><div>        $in_headers = false;&nbsp;</div></li><li><div>        if (!empty($field) && strpos($field, ' ') === false) {&nbsp;</div></li><li><div>            $in_headers = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($lines as $line) {&nbsp;</div></li><li><div>            $lines_out = array();&nbsp;</div></li><li><div>            if ($in_headers and $line == '') {&nbsp;</div></li><li><div>                $in_headers = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //Break this line up into several smaller lines if it's too long&nbsp;</div></li><li><div>            //Micro-optimisation: isset($str[$len]) is faster than (strlen($str) &gt; $len), &nbsp;</div></li><li><div>            while (isset($line[self::MAX_LINE_LENGTH])) {&nbsp;</div></li><li><div>                //Working backwards, try to find a space within the last MAX_LINE_LENGTH chars of the line to break on&nbsp;</div></li><li><div>                //so as to avoid breaking in the middle of a word&nbsp;</div></li><li><div>                $pos = strrpos(substr($line, 0, self::MAX_LINE_LENGTH), ' ');&nbsp;</div></li><li><div>                //Deliberately matches both false and 0&nbsp;</div></li><li><div>                if (!$pos) {&nbsp;</div></li><li><div>                    //No nice break found, add a hard break&nbsp;</div></li><li><div>                    $pos = self::MAX_LINE_LENGTH - 1;&nbsp;</div></li><li><div>                    $lines_out[] = substr($line, 0, $pos);&nbsp;</div></li><li><div>                    $line = substr($line, $pos);&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    //Break at the found point&nbsp;</div></li><li><div>                    $lines_out[] = substr($line, 0, $pos);&nbsp;</div></li><li><div>                    //Move along by the amount we dealt with&nbsp;</div></li><li><div>                    $line = substr($line, $pos + 1);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                //If processing headers add a LWSP-char to the front of new line RFC822 section 3.1.1&nbsp;</div></li><li><div>                if ($in_headers) {&nbsp;</div></li><li><div>                    $line = &quot;\t&quot; . $line;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $lines_out[] = $line;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //Send the lines to the server&nbsp;</div></li><li><div>            foreach ($lines_out as $line_out) {&nbsp;</div></li><li><div>                //RFC2821 section 4.5.2&nbsp;</div></li><li><div>                if (!empty($line_out) and $line_out[0] == '.') {&nbsp;</div></li><li><div>                    $line_out = '.' . $line_out;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $this-&gt;client_send($line_out . self::CRLF);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //Message data has been sent, complete the command&nbsp;</div></li><li><div>        //Increase timelimit for end of DATA command&nbsp;</div></li><li><div>        $savetimelimit = $this-&gt;Timelimit;&nbsp;</div></li><li><div>        $this-&gt;Timelimit = $this-&gt;Timelimit * 2;&nbsp;</div></li><li><div>        $result = $this-&gt;sendCommand('DATA END', '.', 250);&nbsp;</div></li><li><div>        //Restore timelimit&nbsp;</div></li><li><div>        $this-&gt;Timelimit = $savetimelimit;&nbsp;</div></li><li><div>        return $result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP HELO or EHLO command.&nbsp;</div></li><li><div>     * Used to identify the sending server to the receiving server.&nbsp;</div></li><li><div>     * This makes sure that client and server are in a known state.&nbsp;</div></li><li><div>     * Implements RFC 821: HELO &lt;SP&gt; &lt;domain&gt; &lt;CRLF&gt;&nbsp;</div></li><li><div>     * and RFC 2821 EHLO.&nbsp;</div></li><li><div>     * @param string $host The host name or IP to connect to&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function hello($host = '')&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        //Try extended hello first (RFC 2821)&nbsp;</div></li><li><div>        return (boolean)($this-&gt;sendHello('EHLO', $host) or $this-&gt;sendHello('HELO', $host));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP HELO or EHLO command.&nbsp;</div></li><li><div>     * Low-level implementation used by hello()&nbsp;</div></li><li><div>     * @see hello()&nbsp;</div></li><li><div>     * @param string $hello The HELO string&nbsp;</div></li><li><div>     * @param string $host The hostname to say we are&nbsp;</div></li><li><div>     * @access protected&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function sendHello($hello, $host)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $noerror = $this-&gt;sendCommand($hello, $hello . ' ' . $host, 250);&nbsp;</div></li><li><div>        $this-&gt;helo_rply = $this-&gt;last_reply;&nbsp;</div></li><li><div>        if ($noerror) {&nbsp;</div></li><li><div>            $this-&gt;parseHelloFields($hello);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $this-&gt;server_caps = null;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $noerror;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parse a reply to HELO/EHLO command to discover server extensions.&nbsp;</div></li><li><div>     * In case of HELO, the only parameter that can be discovered is a server name.&nbsp;</div></li><li><div>     * @access protected&nbsp;</div></li><li><div>     * @param string $type - 'HELO' or 'EHLO'&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function parseHelloFields($type)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;server_caps = array();&nbsp;</div></li><li><div>        $lines = explode(&quot;\n&quot;, $this-&gt;last_reply);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($lines as $n =&gt; $s) {&nbsp;</div></li><li><div>            //First 4 chars contain response code followed by - or space&nbsp;</div></li><li><div>            $s = trim(substr($s, 4));&nbsp;</div></li><li><div>            if (empty($s)) {&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $fields = explode(' ', $s);&nbsp;</div></li><li><div>            if (!empty($fields)) {&nbsp;</div></li><li><div>                if (!$n) {&nbsp;</div></li><li><div>                    $name = $type;&nbsp;</div></li><li><div>                    $fields = $fields[0];&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $name = array_shift($fields);&nbsp;</div></li><li><div>                    switch ($name) {&nbsp;</div></li><li><div>                        case 'SIZE':&nbsp;</div></li><li><div>                            $fields = ($fields ? $fields[0] : 0);&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        case 'AUTH':&nbsp;</div></li><li><div>                            if (!is_array($fields)) {&nbsp;</div></li><li><div>                                $fields = array();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        default:&nbsp;</div></li><li><div>                            $fields = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $this-&gt;server_caps[$name] = $fields;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP MAIL command.&nbsp;</div></li><li><div>     * Starts a mail transaction from the email address specified in&nbsp;</div></li><li><div>     * $from. Returns true if successful or false otherwise. If True&nbsp;</div></li><li><div>     * the mail transaction is started and then one or more recipient&nbsp;</div></li><li><div>     * commands may be called followed by a data command.&nbsp;</div></li><li><div>     * Implements rfc 821: MAIL &lt;SP&gt; FROM:&lt;reverse-path&gt; &lt;CRLF&gt;&nbsp;</div></li><li><div>     * @param string $from Source address of this message&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function mail($from)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $useVerp = ($this-&gt;do_verp ? ' XVERP' : '');&nbsp;</div></li><li><div>        return $this-&gt;sendCommand(&nbsp;</div></li><li><div>            'MAIL FROM', &nbsp;</div></li><li><div>            'MAIL FROM:&lt;' . $from . '&gt;' . $useVerp, &nbsp;</div></li><li><div>            250&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP QUIT command.&nbsp;</div></li><li><div>     * Closes the socket if there is no error or the $close_on_error argument is true.&nbsp;</div></li><li><div>     * Implements from rfc 821: QUIT &lt;CRLF&gt;&nbsp;</div></li><li><div>     * @param boolean $close_on_error Should the connection close if an error occurs?&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function quit($close_on_error = true)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $noerror = $this-&gt;sendCommand('QUIT', 'QUIT', 221);&nbsp;</div></li><li><div>        $err = $this-&gt;error; //Save any error&nbsp;</div></li><li><div>        if ($noerror or $close_on_error) {&nbsp;</div></li><li><div>            $this-&gt;close();&nbsp;</div></li><li><div>            $this-&gt;error = $err; //Restore any error from the quit command&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $noerror;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP RCPT command.&nbsp;</div></li><li><div>     * Sets the TO argument to $toaddr.&nbsp;</div></li><li><div>     * Returns true if the recipient was accepted false if it was rejected.&nbsp;</div></li><li><div>     * Implements from rfc 821: RCPT &lt;SP&gt; TO:&lt;forward-path&gt; &lt;CRLF&gt;&nbsp;</div></li><li><div>     * @param string $address The address the message is being sent to&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function recipient($address)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;sendCommand(&nbsp;</div></li><li><div>            'RCPT TO', &nbsp;</div></li><li><div>            'RCPT TO:&lt;' . $address . '&gt;', &nbsp;</div></li><li><div>            array(250, 251)&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP RSET command.&nbsp;</div></li><li><div>     * Abort any transaction that is currently in progress.&nbsp;</div></li><li><div>     * Implements rfc 821: RSET &lt;CRLF&gt;&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean True on success.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function reset()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;sendCommand('RSET', 'RSET', 250);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send a command to an SMTP server and check its return code.&nbsp;</div></li><li><div>     * @param string $command The command name - not sent to the server&nbsp;</div></li><li><div>     * @param string $commandstring The actual command to send&nbsp;</div></li><li><div>     * @param integer|array $expect One or more expected integer success codes&nbsp;</div></li><li><div>     * @access protected&nbsp;</div></li><li><div>     * @return boolean True on success.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function sendCommand($command, $commandstring, $expect)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (!$this-&gt;connected()) {&nbsp;</div></li><li><div>            $this-&gt;setError(&quot;Called $command without being connected&quot;);&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        //Reject line breaks in all commands&nbsp;</div></li><li><div>        if (strpos($commandstring, &quot;\n&quot;) !== false or strpos($commandstring, &quot;\r&quot;) !== false) {&nbsp;</div></li><li><div>            $this-&gt;setError(&quot;Command '$command' contained line breaks&quot;);&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $this-&gt;client_send($commandstring . self::CRLF);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;last_reply = $this-&gt;get_lines();&nbsp;</div></li><li><div>        // Fetch SMTP code and possible error code explanation&nbsp;</div></li><li><div>        $matches = array();&nbsp;</div></li><li><div>        if (preg_match(&quot;/^([0-9]{3})[ -](?:([0-9]\\.[0-9]\\.[0-9]) )?/&quot;, $this-&gt;last_reply, $matches)) {&nbsp;</div></li><li><div>            $code = $matches[1];&nbsp;</div></li><li><div>            $code_ex = (count($matches) &gt; 2 ? $matches[2] : null);&nbsp;</div></li><li><div>            // Cut off error code from each response line&nbsp;</div></li><li><div>            $detail = preg_replace(&nbsp;</div></li><li><div>                &quot;/{$code}[ -]&quot;.($code_ex ? str_replace('.', '\\.', $code_ex).' ' : '').&quot;/m&quot;, &nbsp;</div></li><li><div>                '', &nbsp;</div></li><li><div>                $this-&gt;last_reply&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            // Fall back to simple parsing if regex fails&nbsp;</div></li><li><div>            $code = substr($this-&gt;last_reply, 0, 3);&nbsp;</div></li><li><div>            $code_ex = null;&nbsp;</div></li><li><div>            $detail = substr($this-&gt;last_reply, 4);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;edebug('SERVER -&gt; CLIENT: ' . $this-&gt;last_reply, self::DEBUG_SERVER);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (!in_array($code, (array)$expect)) {&nbsp;</div></li><li><div>            $this-&gt;setError(&nbsp;</div></li><li><div>                &quot;$command command failed&quot;, &nbsp;</div></li><li><div>                $detail, &nbsp;</div></li><li><div>                $code, &nbsp;</div></li><li><div>                $code_ex&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>            $this-&gt;edebug(&nbsp;</div></li><li><div>                'SMTP ERROR: ' . $this-&gt;error['error'] . ': ' . $this-&gt;last_reply, &nbsp;</div></li><li><div>                self::DEBUG_CLIENT&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;setError('');&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP SAML command.&nbsp;</div></li><li><div>     * Starts a mail transaction from the email address specified in $from.&nbsp;</div></li><li><div>     * Returns true if successful or false otherwise. If True&nbsp;</div></li><li><div>     * the mail transaction is started and then one or more recipient&nbsp;</div></li><li><div>     * commands may be called followed by a data command. This command&nbsp;</div></li><li><div>     * will send the message to the users terminal if they are logged&nbsp;</div></li><li><div>     * in and send them an email.&nbsp;</div></li><li><div>     * Implements rfc 821: SAML &lt;SP&gt; FROM:&lt;reverse-path&gt; &lt;CRLF&gt;&nbsp;</div></li><li><div>     * @param string $from The address the message is from&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function sendAndMail($from)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;sendCommand('SAML', &quot;SAML FROM:$from&quot;, 250);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP VRFY command.&nbsp;</div></li><li><div>     * @param string $name The name to verify&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function verify($name)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;sendCommand('VRFY', &quot;VRFY $name&quot;, array(250, 251));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP NOOP command.&nbsp;</div></li><li><div>     * Used to keep keep-alives alive, doesn't actually do anything&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function noop()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;sendCommand('NOOP', 'NOOP', 250);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an SMTP TURN command.&nbsp;</div></li><li><div>     * This is an optional command for SMTP that this class does not support.&nbsp;</div></li><li><div>     * This method is here to make the RFC821 Definition complete for this class&nbsp;</div></li><li><div>     * and _may_ be implemented in future&nbsp;</div></li><li><div>     * Implements from rfc 821: TURN &lt;CRLF&gt;&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function turn()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;setError('The SMTP TURN command is not implemented');&nbsp;</div></li><li><div>        $this-&gt;edebug('SMTP NOTICE: ' . $this-&gt;error['error'], self::DEBUG_CLIENT);&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send raw data to the server.&nbsp;</div></li><li><div>     * @param string $data The data to send&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return integer|boolean The number of bytes sent to the server or false on error&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function client_send($data)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;edebug(&quot;CLIENT -&gt; SERVER: $data&quot;, self::DEBUG_CLIENT);&nbsp;</div></li><li><div>        return fwrite($this-&gt;smtp_conn, $data);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get the latest error.&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getError()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;error;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get SMTP extensions available on the server&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return array|null&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getServerExtList()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;server_caps;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * A multipurpose method&nbsp;</div></li><li><div>     * The method works in three ways, dependent on argument value and current state&nbsp;</div></li><li><div>     *   1. HELO/EHLO was not sent - returns null and set up $this-&gt;error&nbsp;</div></li><li><div>     *   2. HELO was sent&nbsp;</div></li><li><div>     *     $name = 'HELO': returns server name&nbsp;</div></li><li><div>     *     $name = 'EHLO': returns boolean false&nbsp;</div></li><li><div>     *     $name = any string: returns null and set up $this-&gt;error&nbsp;</div></li><li><div>     *   3. EHLO was sent&nbsp;</div></li><li><div>     *     $name = 'HELO'|'EHLO': returns server name&nbsp;</div></li><li><div>     *     $name = any string: if extension $name exists, returns boolean True&nbsp;</div></li><li><div>     *       or its options. Otherwise returns boolean False&nbsp;</div></li><li><div>     * In other words, one can use this method to detect 3 conditions:&nbsp;</div></li><li><div>     *  - null returned: handshake was not or we don't know about ext (refer to $this-&gt;error)&nbsp;</div></li><li><div>     *  - false returned: the requested feature exactly not exists&nbsp;</div></li><li><div>     *  - positive value returned: the requested feature exists&nbsp;</div></li><li><div>     * @param string $name Name of SMTP extension or 'HELO'|'EHLO'&nbsp;</div></li><li><div>     * @return mixed&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getServerExt($name)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (!$this-&gt;server_caps) {&nbsp;</div></li><li><div>            $this-&gt;setError('No HELO/EHLO was sent');&nbsp;</div></li><li><div>            return null;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // the tight logic knot ;)&nbsp;</div></li><li><div>        if (!array_key_exists($name, $this-&gt;server_caps)) {&nbsp;</div></li><li><div>            if ($name == 'HELO') {&nbsp;</div></li><li><div>                return $this-&gt;server_caps['EHLO'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($name == 'EHLO' || array_key_exists('EHLO', $this-&gt;server_caps)) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $this-&gt;setError('HELO handshake was used. Client knows nothing about server extensions');&nbsp;</div></li><li><div>            return null;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;server_caps[$name];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get the last reply from the server.&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getLastReply()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;last_reply;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Read the SMTP server's response.&nbsp;</div></li><li><div>     * Either before eof or socket timeout occurs on the operation.&nbsp;</div></li><li><div>     * With SMTP we can tell if we have more lines to read if the&nbsp;</div></li><li><div>     * 4th character is '-' symbol. If it is a space then we don't&nbsp;</div></li><li><div>     * need to read anything else.&nbsp;</div></li><li><div>     * @access protected&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function get_lines()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // If the connection is bad, give up straight away&nbsp;</div></li><li><div>        if (!is_resource($this-&gt;smtp_conn)) {&nbsp;</div></li><li><div>            return '';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $data = '';&nbsp;</div></li><li><div>        $endtime = 0;&nbsp;</div></li><li><div>        stream_set_timeout($this-&gt;smtp_conn, $this-&gt;Timeout);&nbsp;</div></li><li><div>        if ($this-&gt;Timelimit &gt; 0) {&nbsp;</div></li><li><div>            $endtime = time() + $this-&gt;Timelimit;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        while (is_resource($this-&gt;smtp_conn) && !feof($this-&gt;smtp_conn)) {&nbsp;</div></li><li><div>            $str = @fgets($this-&gt;smtp_conn, 515);&nbsp;</div></li><li><div>            $this-&gt;edebug(&quot;SMTP -&gt; get_lines(): \$data is \&quot;$data\&quot;&quot;, self::DEBUG_LOWLEVEL);&nbsp;</div></li><li><div>            $this-&gt;edebug(&quot;SMTP -&gt; get_lines(): \$str is  \&quot;$str\&quot;&quot;, self::DEBUG_LOWLEVEL);&nbsp;</div></li><li><div>            $data .= $str;&nbsp;</div></li><li><div>            // If 4th character is a space, we are done reading, break the loop, micro-optimisation over strlen&nbsp;</div></li><li><div>            if ((isset($str[3]) and $str[3] == ' ')) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Timed-out? Log and break&nbsp;</div></li><li><div>            $info = stream_get_meta_data($this-&gt;smtp_conn);&nbsp;</div></li><li><div>            if ($info['timed_out']) {&nbsp;</div></li><li><div>                $this-&gt;edebug(&nbsp;</div></li><li><div>                    'SMTP -&gt; get_lines(): timed-out (' . $this-&gt;Timeout . ' sec)', &nbsp;</div></li><li><div>                    self::DEBUG_LOWLEVEL&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Now check if reads took too long&nbsp;</div></li><li><div>            if ($endtime and time() &gt; $endtime) {&nbsp;</div></li><li><div>                $this-&gt;edebug(&nbsp;</div></li><li><div>                    'SMTP -&gt; get_lines(): timelimit reached ('.&nbsp;</div></li><li><div>                    $this-&gt;Timelimit . ' sec)', &nbsp;</div></li><li><div>                    self::DEBUG_LOWLEVEL&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $data;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Enable or disable VERP address generation.&nbsp;</div></li><li><div>     * @param boolean $enabled&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function setVerp($enabled = false)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;do_verp = $enabled;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get VERP address generation mode.&nbsp;</div></li><li><div>     * @return boolean&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getVerp()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;do_verp;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set error messages and codes.&nbsp;</div></li><li><div>     * @param string $message The error message&nbsp;</div></li><li><div>     * @param string $detail Further detail on the error&nbsp;</div></li><li><div>     * @param string $smtp_code An associated SMTP error code&nbsp;</div></li><li><div>     * @param string $smtp_code_ex Extended SMTP code&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function setError($message, $detail = '', $smtp_code = '', $smtp_code_ex = '')&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;error = array(&nbsp;</div></li><li><div>            'error' =&gt; $message, &nbsp;</div></li><li><div>            'detail' =&gt; $detail, &nbsp;</div></li><li><div>            'smtp_code' =&gt; $smtp_code, &nbsp;</div></li><li><div>            'smtp_code_ex' =&gt; $smtp_code_ex&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set debug output method.&nbsp;</div></li><li><div>     * @param string|callable $method The name of the mechanism to use for debugging output, or a callable to handle it.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function setDebugOutput($method = 'echo')&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;Debugoutput = $method;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get debug output method.&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getDebugOutput()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;Debugoutput;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set debug output level.&nbsp;</div></li><li><div>     * @param integer $level&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function setDebugLevel($level = 0)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;do_debug = $level;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get debug output level.&nbsp;</div></li><li><div>     * @return integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getDebugLevel()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;do_debug;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set SMTP timeout.&nbsp;</div></li><li><div>     * @param integer $timeout&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function setTimeout($timeout = 0)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;Timeout = $timeout;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get SMTP timeout.&nbsp;</div></li><li><div>     * @return integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getTimeout()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return $this-&gt;Timeout;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 4.7</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/4.7.4/classes/smtp/" class="">4.7.4</a></li><li><a href="http://hookr.io/4.7.3/classes/smtp/" class="">4.7.3</a></li><li><a href="http://hookr.io/4.7.2/classes/smtp/" class="">4.7.2</a></li><li><a href="http://hookr.io/4.7.1/classes/smtp/" class="">4.7.1</a></li><li><a href="http://hookr.io/4.7/classes/smtp/" class="active">4.7</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>class</li><li><span></span>SMTP</li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2017 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer> <script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>