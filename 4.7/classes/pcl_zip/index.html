<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="wordpress" data-version="4.7" data-type="class" data-id="2823"><head xmlns="http://www.w3.org/1999/xhtml"><title> pclzip | class | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="PclZip, class, wordpress, 4.7" /><meta name="description" content="The WordPress Core PclZip class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.10"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=bda802fcb0b0fdff244255175bf3f41f' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.10' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/pcl_zip/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fpcl_zip%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fpcl_zip%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7-class-pcl_zip","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="pcl_zip" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7." href="http://hookr.io/4.7/" class="H_VERSION"><span property="name">4.7</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/4.7/classes/" class=""><span property="name">classes</span></a><meta property="position" content="3"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">pcl_zip</span><meta property="position" content="4"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="6307"><a href="http://hookr.io/4.7/all/" title="All">All <span class="count badge">6307</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/4.7/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="2531"><a href="http://hookr.io/4.7/hooks/" title="Hooks">Hooks <span class="count badge">2531</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1667"><a href="http://hookr.io/4.7/filters/" title="Filters">Filters <span class="count badge">1667</span></a></li><li class="active" data-id="class" data-count="351"><a href="http://hookr.io/4.7/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2851"><a href="http://hookr.io/4.7/functions/" title="Functions">Functions <span class="count badge">2851</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>PclZip</strong></h1><p>The WordPress Core <strong>PclZip</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/4.7/files/wp-admin-includes-class-pclzip/" class="file">/wp-admin/includes/class-pclzip.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="51" class="block" start="190"><li><div>class PclZip&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  // ----- Filename of the zip file&nbsp;</div></li><li><div>  var $zipname = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- File descriptor of the zip file&nbsp;</div></li><li><div>  var $zip_fd = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Internal error handling&nbsp;</div></li><li><div>  var $error_code = 1;&nbsp;</div></li><li><div>  var $error_string = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Current status of the magic_quotes_runtime&nbsp;</div></li><li><div>  // This value store the php configuration for magic_quotes&nbsp;</div></li><li><div>  // The class can then disable the magic_quotes and reset it after&nbsp;</div></li><li><div>  var $magic_quotes_status;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : PclZip()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   Creates a PclZip object and set the name of the associated Zip archive&nbsp;</div></li><li><div>//   filename.&nbsp;</div></li><li><div>//   Note that no real action is taken, if the archive does not exist it is not&nbsp;</div></li><li><div>//   created. Use create() for that.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function __construct($p_zipname)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Tests the zlib&nbsp;</div></li><li><div>  if (!function_exists('gzopen'))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    die('Abort '.basename(__FILE__).' : Missing zlib extensions');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set the attributes&nbsp;</div></li><li><div>  $this-&gt;zipname = $p_zipname;&nbsp;</div></li><li><div>  $this-&gt;zip_fd = 0;&nbsp;</div></li><li><div>  $this-&gt;magic_quotes_status = -1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>public function PclZip($p_zipname) {&nbsp;</div></li><li><div>  self::__construct($p_zipname);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function :&nbsp;</div></li><li><div>//   create($p_filelist, $p_add_dir=&quot;&quot;, $p_remove_dir=&quot;&quot;)&nbsp;</div></li><li><div>//   create($p_filelist, $p_option, $p_option_value, ...)&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method supports two different synopsis. The first one is historical.&nbsp;</div></li><li><div>//   This method creates a Zip Archive. The Zip file is created in the&nbsp;</div></li><li><div>//   filesystem. The files and directories indicated in $p_filelist&nbsp;</div></li><li><div>//   are added in the archive. See the parameters description for the&nbsp;</div></li><li><div>//   supported format of $p_filelist.&nbsp;</div></li><li><div>//   When a directory is in the list, the directory and its content is added&nbsp;</div></li><li><div>//   in the archive.&nbsp;</div></li><li><div>//   In this synopsis, the function takes an optional variable list of&nbsp;</div></li><li><div>//   options. See bellow the supported options.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_filelist : An array containing file or directory names, or&nbsp;</div></li><li><div>//                 a string containing one filename or one directory name, or&nbsp;</div></li><li><div>//                 a string containing a list of filenames and/or directory&nbsp;</div></li><li><div>//                 names separated by spaces.&nbsp;</div></li><li><div>//   $p_add_dir : A path to add before the real path of the archived file, &nbsp;</div></li><li><div>//                in order to have it memorized in the archive.&nbsp;</div></li><li><div>//   $p_remove_dir : A path to remove from the real path of the file to archive, &nbsp;</div></li><li><div>//                   in order to have a shorter path memorized in the archive.&nbsp;</div></li><li><div>//                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir&nbsp;</div></li><li><div>//                   is removed first, before $p_add_dir is added.&nbsp;</div></li><li><div>// Options :&nbsp;</div></li><li><div>//   PCLZIP_OPT_ADD_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_ALL_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_COMMENT :&nbsp;</div></li><li><div>//   PCLZIP_CB_PRE_ADD :&nbsp;</div></li><li><div>//   PCLZIP_CB_POST_ADD :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   0 on failure, &nbsp;</div></li><li><div>//   The list of the added files, with a status of the add action.&nbsp;</div></li><li><div>//   (see PclZip::listContent() for list entry format)&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function create($p_filelist)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set default values&nbsp;</div></li><li><div>  $v_options = array();&nbsp;</div></li><li><div>  $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for variable options arguments&nbsp;</div></li><li><div>  $v_size = func_num_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for arguments&nbsp;</div></li><li><div>  if ($v_size &gt; 1) {&nbsp;</div></li><li><div>    // ----- Get the arguments&nbsp;</div></li><li><div>    $v_arg_list = func_get_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Remove from the options list the first argument&nbsp;</div></li><li><div>    array_shift($v_arg_list);&nbsp;</div></li><li><div>    $v_size--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for first arg&nbsp;</div></li><li><div>    if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] &gt; 77000)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Parse the options&nbsp;</div></li><li><div>      $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, &nbsp;</div></li><li><div>                                          array (PCLZIP_OPT_REMOVE_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REMOVE_ALL_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_ADD_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_PRE_ADD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_POST_ADD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_NO_COMPRESSION =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_COMMENT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_ON =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_OFF =&gt; 'optional'&nbsp;</div></li><li><div>                                                 //, PCLZIP_OPT_CRYPT =&gt; 'optional'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>      if ($v_result != 1) {&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for 2 args&nbsp;</div></li><li><div>    // Here we need to support the first historic synopsis of the&nbsp;</div></li><li><div>    // method.&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Get the first argument&nbsp;</div></li><li><div>      $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for the optional second argument&nbsp;</div></li><li><div>      if ($v_size == 2) {&nbsp;</div></li><li><div>        $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else if ($v_size &gt; 2) {&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &nbsp;</div></li><li><div>                             &quot;Invalid number / type of arguments&quot;);&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for default option values&nbsp;</div></li><li><div>  $this-&gt;privOptionDefaultThreshold($v_options);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Init&nbsp;</div></li><li><div>  $v_string_list = array();&nbsp;</div></li><li><div>  $v_att_list = array();&nbsp;</div></li><li><div>  $v_filedescr_list = array();&nbsp;</div></li><li><div>  $p_result_list = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_filelist is really an array&nbsp;</div></li><li><div>  if (is_array($p_filelist)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look if the first element is also an array&nbsp;</div></li><li><div>    //       This will mean that this is a file description entry&nbsp;</div></li><li><div>    if (isset($p_filelist[0]) && is_array($p_filelist[0])) {&nbsp;</div></li><li><div>      $v_att_list = $p_filelist;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- The list is a list of string names&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>      $v_string_list = $p_filelist;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_filelist is a string&nbsp;</div></li><li><div>  else if (is_string($p_filelist)) {&nbsp;</div></li><li><div>    // ----- Create a list from the string&nbsp;</div></li><li><div>    $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Invalid variable type for $p_filelist&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type p_filelist&quot;);&nbsp;</div></li><li><div>    return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reformat the string list&nbsp;</div></li><li><div>  if (sizeof($v_string_list) != 0) {&nbsp;</div></li><li><div>    foreach ($v_string_list as $v_string) {&nbsp;</div></li><li><div>      if ($v_string != '') {&nbsp;</div></li><li><div>        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- For each file in the list check the attributes&nbsp;</div></li><li><div>  $v_supported_attributes&nbsp;</div></li><li><div> = array ( PCLZIP_ATT_FILE_NAME =&gt; 'mandatory'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_NEW_SHORT_NAME =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_NEW_FULL_NAME =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_MTIME =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_CONTENT =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_COMMENT =&gt; 'optional'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  foreach ($v_att_list as $v_entry) {&nbsp;</div></li><li><div>    $v_result = $this-&gt;privFileDescrParseAtt($v_entry, &nbsp;</div></li><li><div>                                             $v_filedescr_list[], &nbsp;</div></li><li><div>                                             $v_options, &nbsp;</div></li><li><div>                                             $v_supported_attributes);&nbsp;</div></li><li><div>    if ($v_result != 1) {&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Expand the filelist (expand directories)&nbsp;</div></li><li><div>  $v_result = $this-&gt;privFileDescrExpand($v_filedescr_list, $v_options);&nbsp;</div></li><li><div>  if ($v_result != 1) {&nbsp;</div></li><li><div>    return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Call the create fct&nbsp;</div></li><li><div>  $v_result = $this-&gt;privCreate($v_filedescr_list, $p_result_list, $v_options);&nbsp;</div></li><li><div>  if ($v_result != 1) {&nbsp;</div></li><li><div>    return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $p_result_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function :&nbsp;</div></li><li><div>//   add($p_filelist, $p_add_dir=&quot;&quot;, $p_remove_dir=&quot;&quot;)&nbsp;</div></li><li><div>//   add($p_filelist, $p_option, $p_option_value, ...)&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method supports two synopsis. The first one is historical.&nbsp;</div></li><li><div>//   This methods add the list of files in an existing archive.&nbsp;</div></li><li><div>//   If a file with the same name already exists, it is added at the end of the&nbsp;</div></li><li><div>//   archive, the first one is still present.&nbsp;</div></li><li><div>//   If the archive does not exist, it is created.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_filelist : An array containing file or directory names, or&nbsp;</div></li><li><div>//                 a string containing one filename or one directory name, or&nbsp;</div></li><li><div>//                 a string containing a list of filenames and/or directory&nbsp;</div></li><li><div>//                 names separated by spaces.&nbsp;</div></li><li><div>//   $p_add_dir : A path to add before the real path of the archived file, &nbsp;</div></li><li><div>//                in order to have it memorized in the archive.&nbsp;</div></li><li><div>//   $p_remove_dir : A path to remove from the real path of the file to archive, &nbsp;</div></li><li><div>//                   in order to have a shorter path memorized in the archive.&nbsp;</div></li><li><div>//                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir&nbsp;</div></li><li><div>//                   is removed first, before $p_add_dir is added.&nbsp;</div></li><li><div>// Options :&nbsp;</div></li><li><div>//   PCLZIP_OPT_ADD_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_ALL_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_COMMENT :&nbsp;</div></li><li><div>//   PCLZIP_OPT_ADD_COMMENT :&nbsp;</div></li><li><div>//   PCLZIP_OPT_PREPEND_COMMENT :&nbsp;</div></li><li><div>//   PCLZIP_CB_PRE_ADD :&nbsp;</div></li><li><div>//   PCLZIP_CB_POST_ADD :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   0 on failure, &nbsp;</div></li><li><div>//   The list of the added files, with a status of the add action.&nbsp;</div></li><li><div>//   (see PclZip::listContent() for list entry format)&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function add($p_filelist)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set default values&nbsp;</div></li><li><div>  $v_options = array();&nbsp;</div></li><li><div>  $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for variable options arguments&nbsp;</div></li><li><div>  $v_size = func_num_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for arguments&nbsp;</div></li><li><div>  if ($v_size &gt; 1) {&nbsp;</div></li><li><div>    // ----- Get the arguments&nbsp;</div></li><li><div>    $v_arg_list = func_get_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Remove form the options list the first argument&nbsp;</div></li><li><div>    array_shift($v_arg_list);&nbsp;</div></li><li><div>    $v_size--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for first arg&nbsp;</div></li><li><div>    if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] &gt; 77000)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Parse the options&nbsp;</div></li><li><div>      $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, &nbsp;</div></li><li><div>                                          array (PCLZIP_OPT_REMOVE_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REMOVE_ALL_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_ADD_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_PRE_ADD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_POST_ADD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_NO_COMPRESSION =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_COMMENT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_ADD_COMMENT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_PREPEND_COMMENT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_ON =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_OFF =&gt; 'optional'&nbsp;</div></li><li><div>                                                 //, PCLZIP_OPT_CRYPT =&gt; 'optional'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>      if ($v_result != 1) {&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for 2 args&nbsp;</div></li><li><div>    // Here we need to support the first historic synopsis of the&nbsp;</div></li><li><div>    // method.&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Get the first argument&nbsp;</div></li><li><div>      $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for the optional second argument&nbsp;</div></li><li><div>      if ($v_size == 2) {&nbsp;</div></li><li><div>        $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else if ($v_size &gt; 2) {&nbsp;</div></li><li><div>        // ----- Error log&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid number / type of arguments&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for default option values&nbsp;</div></li><li><div>  $this-&gt;privOptionDefaultThreshold($v_options);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Init&nbsp;</div></li><li><div>  $v_string_list = array();&nbsp;</div></li><li><div>  $v_att_list = array();&nbsp;</div></li><li><div>  $v_filedescr_list = array();&nbsp;</div></li><li><div>  $p_result_list = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_filelist is really an array&nbsp;</div></li><li><div>  if (is_array($p_filelist)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look if the first element is also an array&nbsp;</div></li><li><div>    //       This will mean that this is a file description entry&nbsp;</div></li><li><div>    if (isset($p_filelist[0]) && is_array($p_filelist[0])) {&nbsp;</div></li><li><div>      $v_att_list = $p_filelist;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- The list is a list of string names&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>      $v_string_list = $p_filelist;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_filelist is a string&nbsp;</div></li><li><div>  else if (is_string($p_filelist)) {&nbsp;</div></li><li><div>    // ----- Create a list from the string&nbsp;</div></li><li><div>    $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Invalid variable type for $p_filelist&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type '&quot;.gettype($p_filelist).&quot;' for p_filelist&quot;);&nbsp;</div></li><li><div>    return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reformat the string list&nbsp;</div></li><li><div>  if (sizeof($v_string_list) != 0) {&nbsp;</div></li><li><div>    foreach ($v_string_list as $v_string) {&nbsp;</div></li><li><div>      $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- For each file in the list check the attributes&nbsp;</div></li><li><div>  $v_supported_attributes&nbsp;</div></li><li><div> = array ( PCLZIP_ATT_FILE_NAME =&gt; 'mandatory'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_NEW_SHORT_NAME =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_NEW_FULL_NAME =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_MTIME =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_CONTENT =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_ATT_FILE_COMMENT =&gt; 'optional'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  foreach ($v_att_list as $v_entry) {&nbsp;</div></li><li><div>    $v_result = $this-&gt;privFileDescrParseAtt($v_entry, &nbsp;</div></li><li><div>                                             $v_filedescr_list[], &nbsp;</div></li><li><div>                                             $v_options, &nbsp;</div></li><li><div>                                             $v_supported_attributes);&nbsp;</div></li><li><div>    if ($v_result != 1) {&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Expand the filelist (expand directories)&nbsp;</div></li><li><div>  $v_result = $this-&gt;privFileDescrExpand($v_filedescr_list, $v_options);&nbsp;</div></li><li><div>  if ($v_result != 1) {&nbsp;</div></li><li><div>    return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Call the create fct&nbsp;</div></li><li><div>  $v_result = $this-&gt;privAdd($v_filedescr_list, $p_result_list, $v_options);&nbsp;</div></li><li><div>  if ($v_result != 1) {&nbsp;</div></li><li><div>    return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $p_result_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : listContent()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This public method, gives the list of the files and directories, with their&nbsp;</div></li><li><div>//   properties.&nbsp;</div></li><li><div>//   The properties of each entries in the list are (used also in other functions) :&nbsp;</div></li><li><div>//     filename : Name of the file. For a create or add action it is the filename&nbsp;</div></li><li><div>//                given by the user. For an extract function it is the filename&nbsp;</div></li><li><div>//                of the extracted file.&nbsp;</div></li><li><div>//     stored_filename : Name of the file / directory stored in the archive.&nbsp;</div></li><li><div>//     size : Size of the stored file.&nbsp;</div></li><li><div>//     compressed_size : Size of the file's data compressed in the archive&nbsp;</div></li><li><div>//                       (without the headers overhead)&nbsp;</div></li><li><div>//     mtime : Last known modification date of the file (UNIX timestamp)&nbsp;</div></li><li><div>//     comment : Comment associated with the file&nbsp;</div></li><li><div>//     folder : true | false&nbsp;</div></li><li><div>//     index : index of the file in the archive&nbsp;</div></li><li><div>//     status : status of the action (depending of the action) :&nbsp;</div></li><li><div>//              Values are :&nbsp;</div></li><li><div>//                ok : OK !&nbsp;</div></li><li><div>//                filtered : the file / dir is not extracted (filtered by user)&nbsp;</div></li><li><div>//                already_a_directory : the file can not be extracted because a&nbsp;</div></li><li><div>//                                      directory with the same name already exists&nbsp;</div></li><li><div>//                write_protected : the file can not be extracted because a file&nbsp;</div></li><li><div>//                                  with the same name already exists and is&nbsp;</div></li><li><div>//                                  write protected&nbsp;</div></li><li><div>//                newer_exist : the file was not extracted because a newer file exists&nbsp;</div></li><li><div>//                path_creation_fail : the file is not extracted because the folder&nbsp;</div></li><li><div>//                                     does not exist and can not be created&nbsp;</div></li><li><div>//                write_error : the file was not extracted because there was a&nbsp;</div></li><li><div>//                              error while writing the file&nbsp;</div></li><li><div>//                read_error : the file was not extracted because there was a error&nbsp;</div></li><li><div>//                             while reading the file&nbsp;</div></li><li><div>//                invalid_header : the file was not extracted because of an archive&nbsp;</div></li><li><div>//                                 format error (bad file header)&nbsp;</div></li><li><div>//   Note that each time a method can continue operating when there&nbsp;</div></li><li><div>//   is an action error on a file, the error is only logged in the file status.&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   0 on an unrecoverable failure, &nbsp;</div></li><li><div>//   The list of the files in the archive.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function listContent()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check archive&nbsp;</div></li><li><div>  if (!$this-&gt;privCheckFormat()) {&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Call the extracting fct&nbsp;</div></li><li><div>  $p_list = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privList($p_list)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    unset($p_list);&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $p_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function :&nbsp;</div></li><li><div>//   extract($p_path=&quot;./&quot;, $p_remove_path=&quot;&quot;)&nbsp;</div></li><li><div>//   extract([$p_option, $p_option_value, ...])&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method supports two synopsis. The first one is historical.&nbsp;</div></li><li><div>//   This method extract all the files / directories from the archive to the&nbsp;</div></li><li><div>//   folder indicated in $p_path.&nbsp;</div></li><li><div>//   If you want to ignore the 'root' part of path of the memorized files&nbsp;</div></li><li><div>//   you can indicate this in the optional $p_remove_path parameter.&nbsp;</div></li><li><div>//   By default, if a newer file with the same name already exists, the&nbsp;</div></li><li><div>//   file is not extracted.&nbsp;</div></li><li><div>//&nbsp;</div></li><li><div>//   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions&nbsp;</div></li><li><div>//   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append&nbsp;</div></li><li><div>//   at the end of the path value of PCLZIP_OPT_PATH.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_path : Path where the files and directories are to be extracted&nbsp;</div></li><li><div>//   $p_remove_path : First part ('root' part) of the memorized path&nbsp;</div></li><li><div>//                    (if any similar) to remove while extracting.&nbsp;</div></li><li><div>// Options :&nbsp;</div></li><li><div>//   PCLZIP_OPT_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_ADD_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_ALL_PATH :&nbsp;</div></li><li><div>//   PCLZIP_CB_PRE_EXTRACT :&nbsp;</div></li><li><div>//   PCLZIP_CB_POST_EXTRACT :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   0 or a negative value on failure, &nbsp;</div></li><li><div>//   The list of the extracted files, with a status of the action.&nbsp;</div></li><li><div>//   (see PclZip::listContent() for list entry format)&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function extract()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check archive&nbsp;</div></li><li><div>  if (!$this-&gt;privCheckFormat()) {&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set default values&nbsp;</div></li><li><div>  $v_options = array();&nbsp;</div></li><li><div>//    $v_path = &quot;./&quot;;&nbsp;</div></li><li><div>  $v_path = '';&nbsp;</div></li><li><div>  $v_remove_path = &quot;&quot;;&nbsp;</div></li><li><div>  $v_remove_all_path = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for variable options arguments&nbsp;</div></li><li><div>  $v_size = func_num_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Default values for option&nbsp;</div></li><li><div>  $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for arguments&nbsp;</div></li><li><div>  if ($v_size &gt; 0) {&nbsp;</div></li><li><div>    // ----- Get the arguments&nbsp;</div></li><li><div>    $v_arg_list = func_get_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for first arg&nbsp;</div></li><li><div>    if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] &gt; 77000)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Parse the options&nbsp;</div></li><li><div>      $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, &nbsp;</div></li><li><div>                                          array (PCLZIP_OPT_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REMOVE_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REMOVE_ALL_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_ADD_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_PRE_EXTRACT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_POST_EXTRACT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_SET_CHMOD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_BY_NAME =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_BY_EREG =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_BY_PREG =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_BY_INDEX =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_EXTRACT_AS_STRING =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_EXTRACT_IN_OUTPUT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REPLACE_NEWER =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_OPT_STOP_ON_ERROR =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_OPT_EXTRACT_DIR_RESTRICTION =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_ON =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_OFF =&gt; 'optional'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>      if ($v_result != 1) {&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Set the arguments&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_PATH])) {&nbsp;</div></li><li><div>        $v_path = $v_options[PCLZIP_OPT_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {&nbsp;</div></li><li><div>        $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {&nbsp;</div></li><li><div>        $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {&nbsp;</div></li><li><div>        // ----- Check for '/' in last path char&nbsp;</div></li><li><div>        if ((strlen($v_path) &gt; 0) && (substr($v_path, -1) != '/')) {&nbsp;</div></li><li><div>          $v_path .= '/';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for 2 args&nbsp;</div></li><li><div>    // Here we need to support the first historic synopsis of the&nbsp;</div></li><li><div>    // method.&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Get the first argument&nbsp;</div></li><li><div>      $v_path = $v_arg_list[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for the optional second argument&nbsp;</div></li><li><div>      if ($v_size == 2) {&nbsp;</div></li><li><div>        $v_remove_path = $v_arg_list[1];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else if ($v_size &gt; 2) {&nbsp;</div></li><li><div>        // ----- Error log&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid number / type of arguments&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for default option values&nbsp;</div></li><li><div>  $this-&gt;privOptionDefaultThreshold($v_options);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Trace&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Call the extracting fct&nbsp;</div></li><li><div>  $p_list = array();&nbsp;</div></li><li><div>  $v_result = $this-&gt;privExtractByRule($p_list, $v_path, $v_remove_path, &nbsp;</div></li><li><div>                                       $v_remove_all_path, $v_options);&nbsp;</div></li><li><div>  if ($v_result &lt; 1) {&nbsp;</div></li><li><div>    unset($p_list);&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $p_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function :&nbsp;</div></li><li><div>//   extractByIndex($p_index, $p_path=&quot;./&quot;, $p_remove_path=&quot;&quot;)&nbsp;</div></li><li><div>//   extractByIndex($p_index, [$p_option, $p_option_value, ...])&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method supports two synopsis. The first one is historical.&nbsp;</div></li><li><div>//   This method is doing a partial extract of the archive.&nbsp;</div></li><li><div>//   The extracted files or folders are identified by their index in the&nbsp;</div></li><li><div>//   archive (from 0 to n).&nbsp;</div></li><li><div>//   Note that if the index identify a folder, only the folder entry is&nbsp;</div></li><li><div>//   extracted, not all the files included in the archive.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_index : A single index (integer) or a string of indexes of files to&nbsp;</div></li><li><div>//              extract. The form of the string is &quot;0, 4-6, 8-12&quot; with only numbers&nbsp;</div></li><li><div>//              and '-' for range or ', ' to separate ranges. No spaces or ';'&nbsp;</div></li><li><div>//              are allowed.&nbsp;</div></li><li><div>//   $p_path : Path where the files and directories are to be extracted&nbsp;</div></li><li><div>//   $p_remove_path : First part ('root' part) of the memorized path&nbsp;</div></li><li><div>//                    (if any similar) to remove while extracting.&nbsp;</div></li><li><div>// Options :&nbsp;</div></li><li><div>//   PCLZIP_OPT_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_ADD_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_REMOVE_ALL_PATH :&nbsp;</div></li><li><div>//   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and&nbsp;</div></li><li><div>//     not as files.&nbsp;</div></li><li><div>//     The resulting content is in a new field 'content' in the file&nbsp;</div></li><li><div>//     structure.&nbsp;</div></li><li><div>//     This option must be used alone (any other options are ignored).&nbsp;</div></li><li><div>//   PCLZIP_CB_PRE_EXTRACT :&nbsp;</div></li><li><div>//   PCLZIP_CB_POST_EXTRACT :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   0 on failure, &nbsp;</div></li><li><div>//   The list of the extracted files, with a status of the action.&nbsp;</div></li><li><div>//   (see PclZip::listContent() for list entry format)&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>//function extractByIndex($p_index, options...)&nbsp;</div></li><li><div>function extractByIndex($p_index)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check archive&nbsp;</div></li><li><div>  if (!$this-&gt;privCheckFormat()) {&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set default values&nbsp;</div></li><li><div>  $v_options = array();&nbsp;</div></li><li><div>//    $v_path = &quot;./&quot;;&nbsp;</div></li><li><div>  $v_path = '';&nbsp;</div></li><li><div>  $v_remove_path = &quot;&quot;;&nbsp;</div></li><li><div>  $v_remove_all_path = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for variable options arguments&nbsp;</div></li><li><div>  $v_size = func_num_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Default values for option&nbsp;</div></li><li><div>  $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for arguments&nbsp;</div></li><li><div>  if ($v_size &gt; 1) {&nbsp;</div></li><li><div>    // ----- Get the arguments&nbsp;</div></li><li><div>    $v_arg_list = func_get_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Remove form the options list the first argument&nbsp;</div></li><li><div>    array_shift($v_arg_list);&nbsp;</div></li><li><div>    $v_size--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for first arg&nbsp;</div></li><li><div>    if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] &gt; 77000)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Parse the options&nbsp;</div></li><li><div>      $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, &nbsp;</div></li><li><div>                                          array (PCLZIP_OPT_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REMOVE_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REMOVE_ALL_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_EXTRACT_AS_STRING =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_ADD_PATH =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_PRE_EXTRACT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_CB_POST_EXTRACT =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_SET_CHMOD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_REPLACE_NEWER =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_OPT_STOP_ON_ERROR =&gt; 'optional'&nbsp;</div></li><li><div> , PCLZIP_OPT_EXTRACT_DIR_RESTRICTION =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_ON =&gt; 'optional', &nbsp;</div></li><li><div>                                                 PCLZIP_OPT_TEMP_FILE_OFF =&gt; 'optional'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>      if ($v_result != 1) {&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Set the arguments&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_PATH])) {&nbsp;</div></li><li><div>        $v_path = $v_options[PCLZIP_OPT_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {&nbsp;</div></li><li><div>        $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {&nbsp;</div></li><li><div>        $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {&nbsp;</div></li><li><div>        // ----- Check for '/' in last path char&nbsp;</div></li><li><div>        if ((strlen($v_path) &gt; 0) && (substr($v_path, -1) != '/')) {&nbsp;</div></li><li><div>          $v_path .= '/';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {&nbsp;</div></li><li><div>        $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for 2 args&nbsp;</div></li><li><div>    // Here we need to support the first historic synopsis of the&nbsp;</div></li><li><div>    // method.&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Get the first argument&nbsp;</div></li><li><div>      $v_path = $v_arg_list[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for the optional second argument&nbsp;</div></li><li><div>      if ($v_size == 2) {&nbsp;</div></li><li><div>        $v_remove_path = $v_arg_list[1];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else if ($v_size &gt; 2) {&nbsp;</div></li><li><div>        // ----- Error log&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid number / type of arguments&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Trace&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Trick&nbsp;</div></li><li><div>  // Here I want to reuse extractByRule(), so I need to parse the $p_index&nbsp;</div></li><li><div>  // with privParseOptions()&nbsp;</div></li><li><div>  $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);&nbsp;</div></li><li><div>  $v_options_trick = array();&nbsp;</div></li><li><div>  $v_result = $this-&gt;privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick, &nbsp;</div></li><li><div>                                      array (PCLZIP_OPT_BY_INDEX =&gt; 'optional' ));&nbsp;</div></li><li><div>  if ($v_result != 1) {&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for default option values&nbsp;</div></li><li><div>  $this-&gt;privOptionDefaultThreshold($v_options);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Call the extracting fct&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) &lt; 1) {&nbsp;</div></li><li><div>      return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $p_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function :&nbsp;</div></li><li><div>//   delete([$p_option, $p_option_value, ...])&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method removes files from the archive.&nbsp;</div></li><li><div>//   If no parameters are given, then all the archive is emptied.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   None or optional arguments.&nbsp;</div></li><li><div>// Options :&nbsp;</div></li><li><div>//   PCLZIP_OPT_BY_INDEX :&nbsp;</div></li><li><div>//   PCLZIP_OPT_BY_NAME :&nbsp;</div></li><li><div>//   PCLZIP_OPT_BY_EREG :&nbsp;</div></li><li><div>//   PCLZIP_OPT_BY_PREG :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   0 on failure, &nbsp;</div></li><li><div>//   The list of the files which are still present in the archive.&nbsp;</div></li><li><div>//   (see PclZip::listContent() for list entry format)&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function delete()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check archive&nbsp;</div></li><li><div>  if (!$this-&gt;privCheckFormat()) {&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set default values&nbsp;</div></li><li><div>  $v_options = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for variable options arguments&nbsp;</div></li><li><div>  $v_size = func_num_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for arguments&nbsp;</div></li><li><div>  if ($v_size &gt; 0) {&nbsp;</div></li><li><div>    // ----- Get the arguments&nbsp;</div></li><li><div>    $v_arg_list = func_get_args();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Parse the options&nbsp;</div></li><li><div>    $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, &nbsp;</div></li><li><div>                                      array (PCLZIP_OPT_BY_NAME =&gt; 'optional', &nbsp;</div></li><li><div>                                             PCLZIP_OPT_BY_EREG =&gt; 'optional', &nbsp;</div></li><li><div>                                             PCLZIP_OPT_BY_PREG =&gt; 'optional', &nbsp;</div></li><li><div>                                             PCLZIP_OPT_BY_INDEX =&gt; 'optional' ));&nbsp;</div></li><li><div>    if ($v_result != 1) {&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privDisableMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Call the delete fct&nbsp;</div></li><li><div>  $v_list = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privDeleteByRule($v_list, $v_options)) != 1) {&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>    unset($v_list);&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : deleteByIndex()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   ***** Deprecated *****&nbsp;</div></li><li><div>//   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function deleteByIndex($p_index)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $p_list = $this-&gt;delete(PCLZIP_OPT_BY_INDEX, $p_index);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $p_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : properties()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method gives the properties of the archive.&nbsp;</div></li><li><div>//   The properties are :&nbsp;</div></li><li><div>//     nb : Number of files in the archive&nbsp;</div></li><li><div>//     comment : Comment associated with the archive file&nbsp;</div></li><li><div>//     status : not_exist, ok&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   None&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   0 on failure, &nbsp;</div></li><li><div>//   An array with the archive properties.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function properties()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privDisableMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check archive&nbsp;</div></li><li><div>  if (!$this-&gt;privCheckFormat()) {&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Default properties&nbsp;</div></li><li><div>  $v_prop = array();&nbsp;</div></li><li><div>  $v_prop['comment'] = '';&nbsp;</div></li><li><div>  $v_prop['nb'] = 0;&nbsp;</div></li><li><div>  $v_prop['status'] = 'not_exist';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if file exists&nbsp;</div></li><li><div>  if (@is_file($this-&gt;zipname))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Open the zip file&nbsp;</div></li><li><div>    if (($this-&gt;zip_fd = @fopen($this-&gt;zipname, 'rb')) == 0)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this-&gt;zipname.'\' in binary read mode');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Read the central directory informations&nbsp;</div></li><li><div>    $v_central_dir = array();&nbsp;</div></li><li><div>    if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Close the zip file&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Set the user attributes&nbsp;</div></li><li><div>    $v_prop['comment'] = $v_central_dir['comment'];&nbsp;</div></li><li><div>    $v_prop['nb'] = $v_central_dir['entries'];&nbsp;</div></li><li><div>    $v_prop['status'] = 'ok';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_prop;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : duplicate()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method creates an archive by copying the content of an other one. If&nbsp;</div></li><li><div>//   the archive already exist, it is replaced by the new one without any warning.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_archive : The filename of a valid archive, or&nbsp;</div></li><li><div>//                a valid PclZip object.&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   1 on success.&nbsp;</div></li><li><div>//   0 or a negative value on error (error code).&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function duplicate($p_archive)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_archive is a PclZip object&nbsp;</div></li><li><div>  if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Duplicate the archive&nbsp;</div></li><li><div>    $v_result = $this-&gt;privDuplicate($p_archive-&gt;zipname);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_archive is a string (so a filename)&nbsp;</div></li><li><div>  else if (is_string($p_archive))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check that $p_archive is a valid zip file&nbsp;</div></li><li><div>    // TBC : Should also check the archive format&nbsp;</div></li><li><div>    if (!is_file($p_archive)) {&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;No file with filename '&quot;.$p_archive.&quot;'&quot;);&nbsp;</div></li><li><div>      $v_result = PCLZIP_ERR_MISSING_FILE;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>      // ----- Duplicate the archive&nbsp;</div></li><li><div>      $v_result = $this-&gt;privDuplicate($p_archive);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Invalid variable&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type p_archive_to_add&quot;);&nbsp;</div></li><li><div>    $v_result = PCLZIP_ERR_INVALID_PARAMETER;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : merge()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method merge the $p_archive_to_add archive at the end of the current&nbsp;</div></li><li><div>//   one ($this).&nbsp;</div></li><li><div>//   If the archive ($this) does not exist, the merge becomes a duplicate.&nbsp;</div></li><li><div>//   If the $p_archive_to_add archive does not exist, the merge is a success.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_archive_to_add : It can be directly the filename of a valid zip archive, &nbsp;</div></li><li><div>//                       or a PclZip object archive.&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   1 on success, &nbsp;</div></li><li><div>//   0 or negative values on error (see below).&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function merge($p_archive_to_add)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check archive&nbsp;</div></li><li><div>  if (!$this-&gt;privCheckFormat()) {&nbsp;</div></li><li><div>    return(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_archive_to_add is a PclZip object&nbsp;</div></li><li><div>  if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Merge the archive&nbsp;</div></li><li><div>    $v_result = $this-&gt;privMerge($p_archive_to_add);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_archive_to_add is a string (so a filename)&nbsp;</div></li><li><div>  else if (is_string($p_archive_to_add))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Create a temporary archive&nbsp;</div></li><li><div>    $v_object_archive = new PclZip($p_archive_to_add);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Merge the archive&nbsp;</div></li><li><div>    $v_result = $this-&gt;privMerge($v_object_archive);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Invalid variable&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type p_archive_to_add&quot;);&nbsp;</div></li><li><div>    $v_result = PCLZIP_ERR_INVALID_PARAMETER;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : errorCode()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function errorCode()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  if (PCLZIP_ERROR_EXTERNAL == 1) {&nbsp;</div></li><li><div>    return(PclErrorCode());&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    return($this-&gt;error_code);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : errorName()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function errorName($p_with_code=false)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_name = array ( PCLZIP_ERR_NO_ERROR =&gt; 'PCLZIP_ERR_NO_ERROR', &nbsp;</div></li><li><div>                    PCLZIP_ERR_WRITE_OPEN_FAIL =&gt; 'PCLZIP_ERR_WRITE_OPEN_FAIL', &nbsp;</div></li><li><div>                    PCLZIP_ERR_READ_OPEN_FAIL =&gt; 'PCLZIP_ERR_READ_OPEN_FAIL', &nbsp;</div></li><li><div>                    PCLZIP_ERR_INVALID_PARAMETER =&gt; 'PCLZIP_ERR_INVALID_PARAMETER', &nbsp;</div></li><li><div>                    PCLZIP_ERR_MISSING_FILE =&gt; 'PCLZIP_ERR_MISSING_FILE', &nbsp;</div></li><li><div>                    PCLZIP_ERR_FILENAME_TOO_LONG =&gt; 'PCLZIP_ERR_FILENAME_TOO_LONG', &nbsp;</div></li><li><div>                    PCLZIP_ERR_INVALID_ZIP =&gt; 'PCLZIP_ERR_INVALID_ZIP', &nbsp;</div></li><li><div>                    PCLZIP_ERR_BAD_EXTRACTED_FILE =&gt; 'PCLZIP_ERR_BAD_EXTRACTED_FILE', &nbsp;</div></li><li><div>                    PCLZIP_ERR_DIR_CREATE_FAIL =&gt; 'PCLZIP_ERR_DIR_CREATE_FAIL', &nbsp;</div></li><li><div>                    PCLZIP_ERR_BAD_EXTENSION =&gt; 'PCLZIP_ERR_BAD_EXTENSION', &nbsp;</div></li><li><div>                    PCLZIP_ERR_BAD_FORMAT =&gt; 'PCLZIP_ERR_BAD_FORMAT', &nbsp;</div></li><li><div>                    PCLZIP_ERR_DELETE_FILE_FAIL =&gt; 'PCLZIP_ERR_DELETE_FILE_FAIL', &nbsp;</div></li><li><div>                    PCLZIP_ERR_RENAME_FILE_FAIL =&gt; 'PCLZIP_ERR_RENAME_FILE_FAIL', &nbsp;</div></li><li><div>                    PCLZIP_ERR_BAD_CHECKSUM =&gt; 'PCLZIP_ERR_BAD_CHECKSUM', &nbsp;</div></li><li><div>                    PCLZIP_ERR_INVALID_ARCHIVE_ZIP =&gt; 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', &nbsp;</div></li><li><div>                    PCLZIP_ERR_MISSING_OPTION_VALUE =&gt; 'PCLZIP_ERR_MISSING_OPTION_VALUE', &nbsp;</div></li><li><div>                    PCLZIP_ERR_INVALID_OPTION_VALUE =&gt; 'PCLZIP_ERR_INVALID_OPTION_VALUE', &nbsp;</div></li><li><div>                    PCLZIP_ERR_UNSUPPORTED_COMPRESSION =&gt; 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', &nbsp;</div></li><li><div>                    PCLZIP_ERR_UNSUPPORTED_ENCRYPTION =&gt; 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'&nbsp;</div></li><li><div> , PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE =&gt; 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'&nbsp;</div></li><li><div> , PCLZIP_ERR_DIRECTORY_RESTRICTION =&gt; 'PCLZIP_ERR_DIRECTORY_RESTRICTION'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if (isset($v_name[$this-&gt;error_code])) {&nbsp;</div></li><li><div>    $v_value = $v_name[$this-&gt;error_code];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $v_value = 'NoName';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ($p_with_code) {&nbsp;</div></li><li><div>    return($v_value.' ('.$this-&gt;error_code.')');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    return($v_value);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : errorInfo()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function errorInfo($p_full=false)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  if (PCLZIP_ERROR_EXTERNAL == 1) {&nbsp;</div></li><li><div>    return(PclErrorString());&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    if ($p_full) {&nbsp;</div></li><li><div>      return($this-&gt;errorName(true).&quot; : &quot;.$this-&gt;error_string);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>      return($this-&gt;error_string.&quot; [code &quot;.$this-&gt;error_code.&quot;]&quot;);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****&nbsp;</div></li><li><div>// *****                                                        *****&nbsp;</div></li><li><div>// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privCheckFormat()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method check that the archive exists and is a valid zip archive.&nbsp;</div></li><li><div>//   Several level of check exists. (futur)&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_level : Level of check. Default 0.&nbsp;</div></li><li><div>//              0 : Check the first bytes (magic codes) (default value))&nbsp;</div></li><li><div>//              1 : 0 + Check the central directory (futur)&nbsp;</div></li><li><div>//              2 : 1 + Check each file header (futur)&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   true on success, &nbsp;</div></li><li><div>//   false on error, the error code is set.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privCheckFormat($p_level=0)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the file system cache&nbsp;</div></li><li><div>  clearstatcache();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reset the error handler&nbsp;</div></li><li><div>  $this-&gt;privErrorReset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the file exits&nbsp;</div></li><li><div>  if (!is_file($this-&gt;zipname)) {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;Missing archive file '&quot;.$this-&gt;zipname.&quot;'&quot;);&nbsp;</div></li><li><div>    return(false);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check that the file is readeable&nbsp;</div></li><li><div>  if (!is_readable($this-&gt;zipname)) {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &quot;Unable to read archive '&quot;.$this-&gt;zipname.&quot;'&quot;);&nbsp;</div></li><li><div>    return(false);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the magic code&nbsp;</div></li><li><div>  // TBC&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the central header&nbsp;</div></li><li><div>  // TBC&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check each file header&nbsp;</div></li><li><div>  // TBC&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privParseOptions()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This internal methods reads the variable list of arguments ($p_options_list, &nbsp;</div></li><li><div>//   $p_size) and generate an array with the options and values ($v_result_list).&nbsp;</div></li><li><div>//   $v_requested_options contains the options that can be present and those that&nbsp;</div></li><li><div>//   must be present.&nbsp;</div></li><li><div>//   $v_requested_options is an array, with the option value as key, and 'optional', &nbsp;</div></li><li><div>//   or 'mandatory' as value.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   See above.&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   1 on success.&nbsp;</div></li><li><div>//   0 on failure.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the options&nbsp;</div></li><li><div>  $i=0;&nbsp;</div></li><li><div>  while ($i&lt;$p_size) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check if the option is supported&nbsp;</div></li><li><div>    if (!isset($v_requested_options[$p_options_list[$i]])) {&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid optional parameter '&quot;.$p_options_list[$i].&quot;' for this method&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for next option&nbsp;</div></li><li><div>    switch ($p_options_list[$i]) {&nbsp;</div></li><li><div>      // ----- Look for options that request a path value&nbsp;</div></li><li><div>      case PCLZIP_OPT_PATH :&nbsp;</div></li><li><div>      case PCLZIP_OPT_REMOVE_PATH :&nbsp;</div></li><li><div>      case PCLZIP_OPT_ADD_PATH :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_OPT_TEMP_FILE_THRESHOLD :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Check for incompatible options&nbsp;</div></li><li><div>        if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Check the value&nbsp;</div></li><li><div>        $v_value = $p_options_list[$i+1];&nbsp;</div></li><li><div>        if ((!is_integer($v_value)) || ($v_value&lt;0)) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Integer expected for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value (and convert it in bytes)&nbsp;</div></li><li><div>        $v_result_list[$p_options_list[$i]] = $v_value*1048576;&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_OPT_TEMP_FILE_ON :&nbsp;</div></li><li><div>        // ----- Check for incompatible options&nbsp;</div></li><li><div>        if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $v_result_list[$p_options_list[$i]] = true;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_OPT_TEMP_FILE_OFF :&nbsp;</div></li><li><div>        // ----- Check for incompatible options&nbsp;</div></li><li><div>        if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // ----- Check for incompatible options&nbsp;</div></li><li><div>        if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $v_result_list[$p_options_list[$i]] = true;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        if (   is_string($p_options_list[$i+1])&nbsp;</div></li><li><div>            && ($p_options_list[$i+1] != '')) {&nbsp;</div></li><li><div>          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);&nbsp;</div></li><li><div>          $i++;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that request an array of string for value&nbsp;</div></li><li><div>      case PCLZIP_OPT_BY_NAME :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        if (is_string($p_options_list[$i+1])) {&nbsp;</div></li><li><div>            $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else if (is_array($p_options_list[$i+1])) {&nbsp;</div></li><li><div>            $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Wrong parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that request an EREG or PREG expression&nbsp;</div></li><li><div>      case PCLZIP_OPT_BY_EREG :&nbsp;</div></li><li><div>        // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG&nbsp;</div></li><li><div>        // to PCLZIP_OPT_BY_PREG&nbsp;</div></li><li><div>        $p_options_list[$i] = PCLZIP_OPT_BY_PREG;&nbsp;</div></li><li><div>      case PCLZIP_OPT_BY_PREG :&nbsp;</div></li><li><div>      //case PCLZIP_OPT_CRYPT :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        if (is_string($p_options_list[$i+1])) {&nbsp;</div></li><li><div>            $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Wrong parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that takes a string&nbsp;</div></li><li><div>      case PCLZIP_OPT_COMMENT :&nbsp;</div></li><li><div>      case PCLZIP_OPT_ADD_COMMENT :&nbsp;</div></li><li><div>      case PCLZIP_OPT_PREPEND_COMMENT :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &nbsp;</div></li><li><div>                               &quot;Missing parameter value for option '&quot;&nbsp;</div></li><li><div>                               .PclZipUtilOptionText($p_options_list[$i])&nbsp;</div></li><li><div>                               .&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        if (is_string($p_options_list[$i+1])) {&nbsp;</div></li><li><div>            $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &nbsp;</div></li><li><div>                               &quot;Wrong parameter value for option '&quot;&nbsp;</div></li><li><div>                               .PclZipUtilOptionText($p_options_list[$i])&nbsp;</div></li><li><div>                               .&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that request an array of index&nbsp;</div></li><li><div>      case PCLZIP_OPT_BY_INDEX :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        $v_work_list = array();&nbsp;</div></li><li><div>        if (is_string($p_options_list[$i+1])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Remove spaces&nbsp;</div></li><li><div>            $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Parse items&nbsp;</div></li><li><div>            $v_work_list = explode(&quot;, &quot;, $p_options_list[$i+1]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else if (is_integer($p_options_list[$i+1])) {&nbsp;</div></li><li><div>            $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else if (is_array($p_options_list[$i+1])) {&nbsp;</div></li><li><div>            $v_work_list = $p_options_list[$i+1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Value must be integer, string or array for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Reduce the index list&nbsp;</div></li><li><div>        // each index item in the list must be a couple with a start and&nbsp;</div></li><li><div>        // an end value : [0, 3], [5-5], [8-10], ...&nbsp;</div></li><li><div>        // ----- Check the format of each item&nbsp;</div></li><li><div>        $v_sort_flag=false;&nbsp;</div></li><li><div>        $v_sort_value=0;&nbsp;</div></li><li><div>        for ($j=0; $j&lt;sizeof($v_work_list); $j++) {&nbsp;</div></li><li><div>            // ----- Explode the item&nbsp;</div></li><li><div>            $v_item_list = explode(&quot;-&quot;, $v_work_list[$j]);&nbsp;</div></li><li><div>            $v_size_item_list = sizeof($v_item_list);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- TBC : Here we might check that each item is a&nbsp;</div></li><li><div>            // real integer ...&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Look for single value&nbsp;</div></li><li><div>            if ($v_size_item_list == 1) {&nbsp;</div></li><li><div>                // ----- Set the option value&nbsp;</div></li><li><div>                $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];&nbsp;</div></li><li><div>                $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            elseif ($v_size_item_list == 2) {&nbsp;</div></li><li><div>                // ----- Set the option value&nbsp;</div></li><li><div>                $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];&nbsp;</div></li><li><div>                $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                // ----- Error log&nbsp;</div></li><li><div>                PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Too many values in index range for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // ----- Return&nbsp;</div></li><li><div>                return PclZip::errorCode();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Look for list sort&nbsp;</div></li><li><div>            if ($v_result_list[$p_options_list[$i]][$j]['start'] &lt; $v_sort_value) {&nbsp;</div></li><li><div>                $v_sort_flag=true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // ----- TBC : An automatic sort should be writen ...&nbsp;</div></li><li><div>                // ----- Error log&nbsp;</div></li><li><div>                PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Invalid order of index range for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // ----- Return&nbsp;</div></li><li><div>                return PclZip::errorCode();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Sort the items&nbsp;</div></li><li><div>        if ($v_sort_flag) {&nbsp;</div></li><li><div>            // TBC : To Be Completed&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Next option&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that request no value&nbsp;</div></li><li><div>      case PCLZIP_OPT_REMOVE_ALL_PATH :&nbsp;</div></li><li><div>      case PCLZIP_OPT_EXTRACT_AS_STRING :&nbsp;</div></li><li><div>      case PCLZIP_OPT_NO_COMPRESSION :&nbsp;</div></li><li><div>      case PCLZIP_OPT_EXTRACT_IN_OUTPUT :&nbsp;</div></li><li><div>      case PCLZIP_OPT_REPLACE_NEWER :&nbsp;</div></li><li><div>      case PCLZIP_OPT_STOP_ON_ERROR :&nbsp;</div></li><li><div>        $v_result_list[$p_options_list[$i]] = true;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that request an octal value&nbsp;</div></li><li><div>      case PCLZIP_OPT_SET_CHMOD :&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that request a call-back&nbsp;</div></li><li><div>      case PCLZIP_CB_PRE_EXTRACT :&nbsp;</div></li><li><div>      case PCLZIP_CB_POST_EXTRACT :&nbsp;</div></li><li><div>      case PCLZIP_CB_PRE_ADD :&nbsp;</div></li><li><div>      case PCLZIP_CB_POST_ADD :&nbsp;</div></li><li><div>      /** for futur use&nbsp;</div></li><li><div>      case PCLZIP_CB_PRE_DELETE :&nbsp;</div></li><li><div>      case PCLZIP_CB_POST_DELETE :&nbsp;</div></li><li><div>      case PCLZIP_CB_PRE_LIST :&nbsp;</div></li><li><div>      case PCLZIP_CB_POST_LIST :&nbsp;</div></li><li><div>      */&nbsp;</div></li><li><div>        // ----- Check the number of parameters&nbsp;</div></li><li><div>        if (($i+1) &gt;= $p_size) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the value&nbsp;</div></li><li><div>        $v_function_name = $p_options_list[$i+1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Check that the value is a valid existing function&nbsp;</div></li><li><div>        if (!function_exists($v_function_name)) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Function '&quot;.$v_function_name.&quot;()' is not an existing function for option '&quot;.PclZipUtilOptionText($p_options_list[$i]).&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Set the attribute&nbsp;</div></li><li><div>        $v_result_list[$p_options_list[$i]] = $v_function_name;&nbsp;</div></li><li><div>        $i++;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      default :&nbsp;</div></li><li><div>        // ----- Error log&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &nbsp;</div></li><li><div>                             &quot;Unknown parameter '&quot;&nbsp;</div></li><li><div>                             .$p_options_list[$i].&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Next options&nbsp;</div></li><li><div>    $i++;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for mandatory options&nbsp;</div></li><li><div>  if ($v_requested_options !== false) {&nbsp;</div></li><li><div>    for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {&nbsp;</div></li><li><div>      // ----- Look for mandatory option&nbsp;</div></li><li><div>      if ($v_requested_options[$key] == 'mandatory') {&nbsp;</div></li><li><div>        // ----- Look if present&nbsp;</div></li><li><div>        if (!isset($v_result_list[$key])) {&nbsp;</div></li><li><div>          // ----- Error log&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Missing mandatory parameter &quot;.PclZipUtilOptionText($key).&quot;(&quot;.$key.&quot;)&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for default values&nbsp;</div></li><li><div>  if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privOptionDefaultThreshold()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privOptionDefaultThreshold(&$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])&nbsp;</div></li><li><div>      || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get 'memory_limit' configuration value&nbsp;</div></li><li><div>  $v_memory_limit = ini_get('memory_limit');&nbsp;</div></li><li><div>  $v_memory_limit = trim($v_memory_limit);&nbsp;</div></li><li><div>  $v_memory_limit_int = (int) $v_memory_limit;&nbsp;</div></li><li><div>  $last = strtolower(substr($v_memory_limit, -1));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if($last == 'g')&nbsp;</div></li><li><div>      //$v_memory_limit_int = $v_memory_limit_int*1024*1024*1024;&nbsp;</div></li><li><div>      $v_memory_limit_int = $v_memory_limit_int*1073741824;&nbsp;</div></li><li><div>  if($last == 'm')&nbsp;</div></li><li><div>      //$v_memory_limit_int = $v_memory_limit_int*1024*1024;&nbsp;</div></li><li><div>      $v_memory_limit_int = $v_memory_limit_int*1048576;&nbsp;</div></li><li><div>  if($last == 'k')&nbsp;</div></li><li><div>      $v_memory_limit_int = $v_memory_limit_int*1024;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit_int*PCLZIP_TEMPORARY_FILE_RATIO);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Sanity check : No threshold if value lower than 1M&nbsp;</div></li><li><div>  if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] &lt; 1048576) {&nbsp;</div></li><li><div>    unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privFileDescrParseAtt()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   1 on success.&nbsp;</div></li><li><div>//   0 on failure.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- For each file in the list check the attributes&nbsp;</div></li><li><div>  foreach ($p_file_list as $v_key =&gt; $v_value) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check if the option is supported&nbsp;</div></li><li><div>    if (!isset($v_requested_options[$v_key])) {&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid file attribute '&quot;.$v_key.&quot;' for this file&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for attribute&nbsp;</div></li><li><div>    switch ($v_key) {&nbsp;</div></li><li><div>      case PCLZIP_ATT_FILE_NAME :&nbsp;</div></li><li><div>        if (!is_string($v_value)) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot;.gettype($v_value).&quot;. String expected for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($p_filedescr['filename'] == '') {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid empty filename for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_ATT_FILE_NEW_SHORT_NAME :&nbsp;</div></li><li><div>        if (!is_string($v_value)) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot;.gettype($v_value).&quot;. String expected for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($p_filedescr['new_short_name'] == '') {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid empty short filename for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_ATT_FILE_NEW_FULL_NAME :&nbsp;</div></li><li><div>        if (!is_string($v_value)) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot;.gettype($v_value).&quot;. String expected for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($p_filedescr['new_full_name'] == '') {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid empty full filename for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for options that takes a string&nbsp;</div></li><li><div>      case PCLZIP_ATT_FILE_COMMENT :&nbsp;</div></li><li><div>        if (!is_string($v_value)) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot;.gettype($v_value).&quot;. String expected for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $p_filedescr['comment'] = $v_value;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_ATT_FILE_MTIME :&nbsp;</div></li><li><div>        if (!is_integer($v_value)) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot;.gettype($v_value).&quot;. Integer expected for attribute '&quot;.PclZipUtilOptionText($v_key).&quot;'&quot;);&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $p_filedescr['mtime'] = $v_value;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      case PCLZIP_ATT_FILE_CONTENT :&nbsp;</div></li><li><div>        $p_filedescr['content'] = $v_value;&nbsp;</div></li><li><div>      break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      default :&nbsp;</div></li><li><div>        // ----- Error log&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &nbsp;</div></li><li><div>                                 &quot;Unknown parameter '&quot;.$v_key.&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for mandatory options&nbsp;</div></li><li><div>    if ($v_requested_options !== false) {&nbsp;</div></li><li><div>      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {&nbsp;</div></li><li><div>        // ----- Look for mandatory option&nbsp;</div></li><li><div>        if ($v_requested_options[$key] == 'mandatory') {&nbsp;</div></li><li><div>          // ----- Look if present&nbsp;</div></li><li><div>          if (!isset($p_file_list[$key])) {&nbsp;</div></li><li><div>            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Missing mandatory parameter &quot;.PclZipUtilOptionText($key).&quot;(&quot;.$key.&quot;)&quot;);&nbsp;</div></li><li><div>            return PclZip::errorCode();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // end foreach&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privFileDescrExpand()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This method look for each item of the list to see if its a file, a folder&nbsp;</div></li><li><div>//   or a string to be added as file. For any other type of files (link, other)&nbsp;</div></li><li><div>//   just ignore the item.&nbsp;</div></li><li><div>//   Then prepare the information that will be stored for that file.&nbsp;</div></li><li><div>//   When its a folder, expand the folder with all the files that are in that&nbsp;</div></li><li><div>//   folder (recursively).&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   1 on success.&nbsp;</div></li><li><div>//   0 on failure.&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privFileDescrExpand(&$p_filedescr_list, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Create a result list&nbsp;</div></li><li><div>  $v_result_list = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look each entry&nbsp;</div></li><li><div>  for ($i=0; $i&lt;sizeof($p_filedescr_list); $i++) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Get filedescr&nbsp;</div></li><li><div>    $v_descr = $p_filedescr_list[$i];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Reduce the filename&nbsp;</div></li><li><div>    $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);&nbsp;</div></li><li><div>    $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for real file or folder&nbsp;</div></li><li><div>    if (file_exists($v_descr['filename'])) {&nbsp;</div></li><li><div>      if (@is_file($v_descr['filename'])) {&nbsp;</div></li><li><div>        $v_descr['type'] = 'file';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else if (@is_dir($v_descr['filename'])) {&nbsp;</div></li><li><div>        $v_descr['type'] = 'folder';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else if (@is_link($v_descr['filename'])) {&nbsp;</div></li><li><div>        // skip&nbsp;</div></li><li><div>        continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>        // skip&nbsp;</div></li><li><div>        continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for string added as file&nbsp;</div></li><li><div>    else if (isset($v_descr['content'])) {&nbsp;</div></li><li><div>      $v_descr['type'] = 'virtual_file';&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Missing file&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;File '&quot;.$v_descr['filename'].&quot;' does not exist&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Calculate the stored filename&nbsp;</div></li><li><div>    $this-&gt;privCalculateStoredFilename($v_descr, $p_options);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Add the descriptor in result list&nbsp;</div></li><li><div>    $v_result_list[sizeof($v_result_list)] = $v_descr;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for folder&nbsp;</div></li><li><div>    if ($v_descr['type'] == 'folder') {&nbsp;</div></li><li><div>      // ----- List of items in folder&nbsp;</div></li><li><div>      $v_dirlist_descr = array();&nbsp;</div></li><li><div>      $v_dirlist_nb = 0;&nbsp;</div></li><li><div>      if ($v_folder_handler = @opendir($v_descr['filename'])) {&nbsp;</div></li><li><div>        while (($v_item_handler = @readdir($v_folder_handler)) !== false) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Skip '.' and '..'&nbsp;</div></li><li><div>          if (($v_item_handler == '.') || ($v_item_handler == '..')) {&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Compose the full filename&nbsp;</div></li><li><div>          $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Look for different stored filename&nbsp;</div></li><li><div>          // Because the name of the folder was changed, the name of the&nbsp;</div></li><li><div>          // files/sub-folders also change&nbsp;</div></li><li><div>          if (($v_descr['stored_filename'] != $v_descr['filename'])&nbsp;</div></li><li><div>               && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {&nbsp;</div></li><li><div>            if ($v_descr['stored_filename'] != '') {&nbsp;</div></li><li><div>              $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>              $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $v_dirlist_nb++;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        @closedir($v_folder_handler);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>        // TBC : unable to open folder in read mode&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Expand each element of the list&nbsp;</div></li><li><div>      if ($v_dirlist_nb != 0) {&nbsp;</div></li><li><div>        // ----- Expand&nbsp;</div></li><li><div>        if (($v_result = $this-&gt;privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Concat the resulting list&nbsp;</div></li><li><div>        $v_result_list = array_merge($v_result_list, $v_dirlist_descr);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Free local array&nbsp;</div></li><li><div>      unset($v_dirlist_descr);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get the result list&nbsp;</div></li><li><div>  $p_filedescr_list = $v_result_list;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privCreate()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privCreate($p_filedescr_list, &$p_result_list, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>  $v_list_detail = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privDisableMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the file in write mode&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privOpenFd('wb')) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Add the list of files&nbsp;</div></li><li><div>  $v_result = $this-&gt;privAddList($p_filedescr_list, $p_result_list, $p_options);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close&nbsp;</div></li><li><div>  $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privAdd()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privAdd($p_filedescr_list, &$p_result_list, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>  $v_list_detail = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the archive exists or is empty&nbsp;</div></li><li><div>  if ((!is_file($this-&gt;zipname)) || (filesize($this-&gt;zipname) == 0))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Do a create&nbsp;</div></li><li><div>    $v_result = $this-&gt;privCreate($p_filedescr_list, $p_result_list, $p_options);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privDisableMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the zip file&nbsp;</div></li><li><div>  if (($v_result=$this-&gt;privOpenFd('rb')) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Magic quotes trick&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the central directory informations&nbsp;</div></li><li><div>  $v_central_dir = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Go to beginning of File&nbsp;</div></li><li><div>  @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Creates a temporay file&nbsp;</div></li><li><div>  $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the temporary file in write mode&nbsp;</div></li><li><div>  if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Copy the files from the archive to the temporary file&nbsp;</div></li><li><div>  // TBC : Here I should better append the file and go back to erase the central dir&nbsp;</div></li><li><div>  $v_size = $v_central_dir['offset'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = fread($this-&gt;zip_fd, $v_read_size);&nbsp;</div></li><li><div>    @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Swap the file descriptor&nbsp;</div></li><li><div>  // Here is a trick : I swap the temporary fd with the zip fd, in order to use&nbsp;</div></li><li><div>  // the following methods on the temporary fil and not the real archive&nbsp;</div></li><li><div>  $v_swap = $this-&gt;zip_fd;&nbsp;</div></li><li><div>  $this-&gt;zip_fd = $v_zip_temp_fd;&nbsp;</div></li><li><div>  $v_zip_temp_fd = $v_swap;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Add the files&nbsp;</div></li><li><div>  $v_header_list = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    fclose($v_zip_temp_fd);&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Store the offset of the central dir&nbsp;</div></li><li><div>  $v_offset = @ftell($this-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Copy the block of file headers from the old archive&nbsp;</div></li><li><div>  $v_size = $v_central_dir['size'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = @fread($v_zip_temp_fd, $v_read_size);&nbsp;</div></li><li><div>    @fwrite($this-&gt;zip_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Create the Central Dir files header&nbsp;</div></li><li><div>  for ($i=0, $v_count=0; $i&lt;sizeof($v_header_list); $i++)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Create the file header&nbsp;</div></li><li><div>    if ($v_header_list[$i]['status'] == 'ok') {&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privWriteCentralFileHeader($v_header_list[$i])) != 1) {&nbsp;</div></li><li><div>        fclose($v_zip_temp_fd);&nbsp;</div></li><li><div>        $this-&gt;privCloseFd();&nbsp;</div></li><li><div>        @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>        $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $v_count++;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Transform the header to a 'usable' info&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Zip file comment&nbsp;</div></li><li><div>  $v_comment = $v_central_dir['comment'];&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_COMMENT])) {&nbsp;</div></li><li><div>    $v_comment = $p_options[PCLZIP_OPT_COMMENT];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {&nbsp;</div></li><li><div>    $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {&nbsp;</div></li><li><div>    $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Calculate the size of the central header&nbsp;</div></li><li><div>  $v_size = @ftell($this-&gt;zip_fd)-$v_offset;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Create the central dir footer&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Reset the file list&nbsp;</div></li><li><div>    unset($v_header_list);&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Swap back the file descriptor&nbsp;</div></li><li><div>  $v_swap = $this-&gt;zip_fd;&nbsp;</div></li><li><div>  $this-&gt;zip_fd = $v_zip_temp_fd;&nbsp;</div></li><li><div>  $v_zip_temp_fd = $v_swap;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close&nbsp;</div></li><li><div>  $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the temporary file&nbsp;</div></li><li><div>  @fclose($v_zip_temp_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Delete the zip file&nbsp;</div></li><li><div>  // TBC : I should test the result ...&nbsp;</div></li><li><div>  @unlink($this-&gt;zipname);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Rename the temporary file&nbsp;</div></li><li><div>  // TBC : I should test the result ...&nbsp;</div></li><li><div>  //@rename($v_zip_temp_name, $this-&gt;zipname);&nbsp;</div></li><li><div>  PclZipUtilRename($v_zip_temp_name, $this-&gt;zipname);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privOpenFd()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privOpenFd($p_mode)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if already open&nbsp;</div></li><li><div>  if ($this-&gt;zip_fd != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \''.$this-&gt;zipname.'\' already open');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the zip file&nbsp;</div></li><li><div>  if (($this-&gt;zip_fd = @fopen($this-&gt;zipname, $p_mode)) == 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this-&gt;zipname.'\' in '.$p_mode.' mode');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privCloseFd()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privCloseFd()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ($this-&gt;zip_fd != 0)&nbsp;</div></li><li><div>    @fclose($this-&gt;zip_fd);&nbsp;</div></li><li><div>  $this-&gt;zip_fd = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privAddList()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is&nbsp;</div></li><li><div>//   different from the real path of the file. This is usefull if you want to have PclTar&nbsp;</div></li><li><div>//   running in any directory, and memorize relative path from an other directory.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_list : An array containing the file or directory names to add in the tar&nbsp;</div></li><li><div>//   $p_result_list : list of added files with their properties (specially the status field)&nbsp;</div></li><li><div>//   $p_add_dir : Path to add in the filename path archived&nbsp;</div></li><li><div>//   $p_remove_dir : Path to remove in the filename path archived&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)&nbsp;</div></li><li><div>function privAddList($p_filedescr_list, &$p_result_list, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Add the files&nbsp;</div></li><li><div>  $v_header_list = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Store the offset of the central dir&nbsp;</div></li><li><div>  $v_offset = @ftell($this-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Create the Central Dir files header&nbsp;</div></li><li><div>  for ($i=0, $v_count=0; $i&lt;sizeof($v_header_list); $i++)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Create the file header&nbsp;</div></li><li><div>    if ($v_header_list[$i]['status'] == 'ok') {&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privWriteCentralFileHeader($v_header_list[$i])) != 1) {&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $v_count++;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Transform the header to a 'usable' info&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Zip file comment&nbsp;</div></li><li><div>  $v_comment = '';&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_COMMENT])) {&nbsp;</div></li><li><div>    $v_comment = $p_options[PCLZIP_OPT_COMMENT];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Calculate the size of the central header&nbsp;</div></li><li><div>  $v_size = @ftell($this-&gt;zip_fd)-$v_offset;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Create the central dir footer&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Reset the file list&nbsp;</div></li><li><div>    unset($v_header_list);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privAddFileList()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_filedescr_list : An array containing the file description&nbsp;</div></li><li><div>//                      or directory names to add in the zip&nbsp;</div></li><li><div>//   $p_result_list : list of added files with their properties (specially the status field)&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>  $v_header = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Recuperate the current number of elt in list&nbsp;</div></li><li><div>  $v_nb = sizeof($p_result_list);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Loop on the files&nbsp;</div></li><li><div>  for ($j=0; ($j&lt;sizeof($p_filedescr_list)) && ($v_result==1); $j++) {&nbsp;</div></li><li><div>    // ----- Format the filename&nbsp;</div></li><li><div>    $p_filedescr_list[$j]['filename']&nbsp;</div></li><li><div> = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Skip empty file names&nbsp;</div></li><li><div>    // TBC : Can this be possible ? not checked in DescrParseAtt ?&nbsp;</div></li><li><div>    if ($p_filedescr_list[$j]['filename'] == &quot;&quot;) {&nbsp;</div></li><li><div>      continue;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check the filename&nbsp;</div></li><li><div>    if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')&nbsp;</div></li><li><div>        && (!file_exists($p_filedescr_list[$j]['filename']))) {&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;File '&quot;.$p_filedescr_list[$j]['filename'].&quot;' does not exist&quot;);&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look if it is a file or a dir with no all path remove option&nbsp;</div></li><li><div>    // or a dir with all its path removed&nbsp;</div></li><li><div>//      if (   (is_file($p_filedescr_list[$j]['filename']))&nbsp;</div></li><li><div>//          || (   is_dir($p_filedescr_list[$j]['filename'])&nbsp;</div></li><li><div>    if (   ($p_filedescr_list[$j]['type'] == 'file')&nbsp;</div></li><li><div>        || ($p_filedescr_list[$j]['type'] == 'virtual_file')&nbsp;</div></li><li><div>        || (   ($p_filedescr_list[$j]['type'] == 'folder')&nbsp;</div></li><li><div>            && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])&nbsp;</div></li><li><div>                || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Add the file&nbsp;</div></li><li><div>      $v_result = $this-&gt;privAddFile($p_filedescr_list[$j], $v_header, &nbsp;</div></li><li><div>                                     $p_options);&nbsp;</div></li><li><div>      if ($v_result != 1) {&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Store the file infos&nbsp;</div></li><li><div>      $p_result_list[$v_nb++] = $v_header;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privAddFile()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privAddFile($p_filedescr, &$p_header, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Working variable&nbsp;</div></li><li><div>  $p_filename = $p_filedescr['filename'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // TBC : Already done in the fileAtt check ... ?&nbsp;</div></li><li><div>  if ($p_filename == &quot;&quot;) {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid file list parameter (invalid or empty list)&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for a stored different filename&nbsp;</div></li><li><div>  /** TBC : Removed&nbsp;</div></li><li><div>  if (isset($p_filedescr['stored_filename'])) {&nbsp;</div></li><li><div>    $v_stored_filename = $p_filedescr['stored_filename'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $v_stored_filename = $p_filedescr['stored_filename'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set the file properties&nbsp;</div></li><li><div>  clearstatcache();&nbsp;</div></li><li><div>  $p_header['version'] = 20;&nbsp;</div></li><li><div>  $p_header['version_extracted'] = 10;&nbsp;</div></li><li><div>  $p_header['flag'] = 0;&nbsp;</div></li><li><div>  $p_header['compression'] = 0;&nbsp;</div></li><li><div>  $p_header['crc'] = 0;&nbsp;</div></li><li><div>  $p_header['compressed_size'] = 0;&nbsp;</div></li><li><div>  $p_header['filename_len'] = strlen($p_filename);&nbsp;</div></li><li><div>  $p_header['extra_len'] = 0;&nbsp;</div></li><li><div>  $p_header['disk'] = 0;&nbsp;</div></li><li><div>  $p_header['internal'] = 0;&nbsp;</div></li><li><div>  $p_header['offset'] = 0;&nbsp;</div></li><li><div>  $p_header['filename'] = $p_filename;&nbsp;</div></li><li><div>// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;&nbsp;</div></li><li><div>  $p_header['stored_filename'] = $p_filedescr['stored_filename'];&nbsp;</div></li><li><div>  $p_header['extra'] = '';&nbsp;</div></li><li><div>  $p_header['status'] = 'ok';&nbsp;</div></li><li><div>  $p_header['index'] = -1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for regular file&nbsp;</div></li><li><div>  if ($p_filedescr['type']=='file') {&nbsp;</div></li><li><div>    $p_header['external'] = 0x00000000;&nbsp;</div></li><li><div>    $p_header['size'] = filesize($p_filename);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for regular folder&nbsp;</div></li><li><div>  else if ($p_filedescr['type']=='folder') {&nbsp;</div></li><li><div>    $p_header['external'] = 0x00000010;&nbsp;</div></li><li><div>    $p_header['mtime'] = filemtime($p_filename);&nbsp;</div></li><li><div>    $p_header['size'] = filesize($p_filename);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for virtual file&nbsp;</div></li><li><div>  else if ($p_filedescr['type'] == 'virtual_file') {&nbsp;</div></li><li><div>    $p_header['external'] = 0x00000000;&nbsp;</div></li><li><div>    $p_header['size'] = strlen($p_filedescr['content']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for filetime&nbsp;</div></li><li><div>  if (isset($p_filedescr['mtime'])) {&nbsp;</div></li><li><div>    $p_header['mtime'] = $p_filedescr['mtime'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else if ($p_filedescr['type'] == 'virtual_file') {&nbsp;</div></li><li><div>    $p_header['mtime'] = time();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $p_header['mtime'] = filemtime($p_filename);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ------ Look for file comment&nbsp;</div></li><li><div>  if (isset($p_filedescr['comment'])) {&nbsp;</div></li><li><div>    $p_header['comment_len'] = strlen($p_filedescr['comment']);&nbsp;</div></li><li><div>    $p_header['comment'] = $p_filedescr['comment'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $p_header['comment_len'] = 0;&nbsp;</div></li><li><div>    $p_header['comment'] = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for pre-add callback&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_CB_PRE_ADD])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_header, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);&nbsp;</div></li><li><div>    if ($v_result == 0) {&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      $p_header['status'] = &quot;skipped&quot;;&nbsp;</div></li><li><div>      $v_result = 1;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Update the informations&nbsp;</div></li><li><div>    // Only some fields can be modified&nbsp;</div></li><li><div>    if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {&nbsp;</div></li><li><div>      $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for empty stored filename&nbsp;</div></li><li><div>  if ($p_header['stored_filename'] == &quot;&quot;) {&nbsp;</div></li><li><div>    $p_header['status'] = &quot;filtered&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the path length&nbsp;</div></li><li><div>  if (strlen($p_header['stored_filename']) &gt; 0xFF) {&nbsp;</div></li><li><div>    $p_header['status'] = 'filename_too_long';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if no error, or file not skipped&nbsp;</div></li><li><div>  if ($p_header['status'] == 'ok') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for a file&nbsp;</div></li><li><div>    if ($p_filedescr['type'] == 'file') {&nbsp;</div></li><li><div>      // ----- Look for using temporary file to zip&nbsp;</div></li><li><div>      if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))&nbsp;</div></li><li><div>          && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])&nbsp;</div></li><li><div>              || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])&nbsp;</div></li><li><div>                  && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] &lt;= $p_header['size'])) ) ) {&nbsp;</div></li><li><div>        $v_result = $this-&gt;privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);&nbsp;</div></li><li><div>        if ($v_result &lt; PCLZIP_ERR_NO_ERROR) {&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Use &quot;in memory&quot; zip algo&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Open the source file&nbsp;</div></li><li><div>      if (($v_file = @fopen($p_filename, &quot;rb&quot;)) == 0) {&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &quot;Unable to open file '$p_filename' in binary read mode&quot;);&nbsp;</div></li><li><div>        return PclZip::errorCode();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Read the file content&nbsp;</div></li><li><div>      $v_content = @fread($v_file, $p_header['size']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Close the file&nbsp;</div></li><li><div>      @fclose($v_file);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Calculate the CRC&nbsp;</div></li><li><div>      $p_header['crc'] = @crc32($v_content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for no compression&nbsp;</div></li><li><div>      if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {&nbsp;</div></li><li><div>        // ----- Set header parameters&nbsp;</div></li><li><div>        $p_header['compressed_size'] = $p_header['size'];&nbsp;</div></li><li><div>        $p_header['compression'] = 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for normal compression&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>        // ----- Compress the content&nbsp;</div></li><li><div>        $v_content = @gzdeflate($v_content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Set header parameters&nbsp;</div></li><li><div>        $p_header['compressed_size'] = strlen($v_content);&nbsp;</div></li><li><div>        $p_header['compression'] = 8;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Call the header generation&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1) {&nbsp;</div></li><li><div>        @fclose($v_file);&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Write the compressed (or not) content&nbsp;</div></li><li><div>      @fwrite($this-&gt;zip_fd, $v_content, $p_header['compressed_size']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for a virtual file (a file from string)&nbsp;</div></li><li><div>    else if ($p_filedescr['type'] == 'virtual_file') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $v_content = $p_filedescr['content'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Calculate the CRC&nbsp;</div></li><li><div>      $p_header['crc'] = @crc32($v_content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for no compression&nbsp;</div></li><li><div>      if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {&nbsp;</div></li><li><div>        // ----- Set header parameters&nbsp;</div></li><li><div>        $p_header['compressed_size'] = $p_header['size'];&nbsp;</div></li><li><div>        $p_header['compression'] = 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for normal compression&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>        // ----- Compress the content&nbsp;</div></li><li><div>        $v_content = @gzdeflate($v_content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Set header parameters&nbsp;</div></li><li><div>        $p_header['compressed_size'] = strlen($v_content);&nbsp;</div></li><li><div>        $p_header['compression'] = 8;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Call the header generation&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1) {&nbsp;</div></li><li><div>        @fclose($v_file);&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Write the compressed (or not) content&nbsp;</div></li><li><div>      @fwrite($this-&gt;zip_fd, $v_content, $p_header['compressed_size']);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for a directory&nbsp;</div></li><li><div>    else if ($p_filedescr['type'] == 'folder') {&nbsp;</div></li><li><div>      // ----- Look for directory last '/'&nbsp;</div></li><li><div>      if (@substr($p_header['stored_filename'], -1) != '/') {&nbsp;</div></li><li><div>        $p_header['stored_filename'] .= '/';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Set the file properties&nbsp;</div></li><li><div>      $p_header['size'] = 0;&nbsp;</div></li><li><div>      //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked&nbsp;</div></li><li><div>      $p_header['external'] = 0x00000010;   // Value for a folder : to be checked&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Call the header generation&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for post-add callback&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_CB_POST_ADD])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_header, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);&nbsp;</div></li><li><div>    if ($v_result == 0) {&nbsp;</div></li><li><div>      // ----- Ignored&nbsp;</div></li><li><div>      $v_result = 1;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Update the informations&nbsp;</div></li><li><div>    // Nothing can be modified&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privAddFileUsingTempFile()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=PCLZIP_ERR_NO_ERROR;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Working variable&nbsp;</div></li><li><div>  $p_filename = $p_filedescr['filename'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the source file&nbsp;</div></li><li><div>  if (($v_file = @fopen($p_filename, &quot;rb&quot;)) == 0) {&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &quot;Unable to open file '$p_filename' in binary read mode&quot;);&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Creates a compressed temporary file&nbsp;</div></li><li><div>  $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';&nbsp;</div></li><li><div>  if (($v_file_compressed = @gzopen($v_gzip_temp_name, &quot;wb&quot;)) == 0) {&nbsp;</div></li><li><div>    fclose($v_file);&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks&nbsp;</div></li><li><div>  $v_size = filesize($p_filename);&nbsp;</div></li><li><div>  while ($v_size != 0) {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = @fread($v_file, $v_read_size);&nbsp;</div></li><li><div>    //$v_binary_data = pack('a'.$v_read_size, $v_buffer);&nbsp;</div></li><li><div>    @gzputs($v_file_compressed, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the file&nbsp;</div></li><li><div>  @fclose($v_file);&nbsp;</div></li><li><div>  @gzclose($v_file_compressed);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the minimum file size&nbsp;</div></li><li><div>  if (filesize($v_gzip_temp_name) &lt; 18) {&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \''.$v_gzip_temp_name.'\' has invalid filesize - should be minimum 18 bytes');&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Extract the compressed attributes&nbsp;</div></li><li><div>  if (($v_file_compressed = @fopen($v_gzip_temp_name, &quot;rb&quot;)) == 0) {&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the gzip file header&nbsp;</div></li><li><div>  $v_binary_data = @fread($v_file_compressed, 10);&nbsp;</div></li><li><div>  $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check some parameters&nbsp;</div></li><li><div>  $v_data_header['os'] = bin2hex($v_data_header['os']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the gzip file footer&nbsp;</div></li><li><div>  @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);&nbsp;</div></li><li><div>  $v_binary_data = @fread($v_file_compressed, 8);&nbsp;</div></li><li><div>  $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set the attributes&nbsp;</div></li><li><div>  $p_header['compression'] = ord($v_data_header['cm']);&nbsp;</div></li><li><div>  //$p_header['mtime'] = $v_data_header['mtime'];&nbsp;</div></li><li><div>  $p_header['crc'] = $v_data_footer['crc'];&nbsp;</div></li><li><div>  $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the file&nbsp;</div></li><li><div>  @fclose($v_file_compressed);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Call the header generation&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1) {&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Add the compressed data&nbsp;</div></li><li><div>  if (($v_file_compressed = @fopen($v_gzip_temp_name, &quot;rb&quot;)) == 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks&nbsp;</div></li><li><div>  fseek($v_file_compressed, 10);&nbsp;</div></li><li><div>  $v_size = $p_header['compressed_size'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = @fread($v_file_compressed, $v_read_size);&nbsp;</div></li><li><div>    //$v_binary_data = pack('a'.$v_read_size, $v_buffer);&nbsp;</div></li><li><div>    @fwrite($this-&gt;zip_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the file&nbsp;</div></li><li><div>  @fclose($v_file_compressed);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Unlink the temporary file&nbsp;</div></li><li><div>  @unlink($v_gzip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privCalculateStoredFilename()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   Based on file descriptor properties and global options, this method&nbsp;</div></li><li><div>//   calculate the filename that will be stored in the archive.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privCalculateStoredFilename(&$p_filedescr, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Working variables&nbsp;</div></li><li><div>  $p_filename = $p_filedescr['filename'];&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {&nbsp;</div></li><li><div>    $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $p_add_dir = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {&nbsp;</div></li><li><div>    $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $p_remove_dir = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {&nbsp;</div></li><li><div>    $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $p_remove_all_dir = 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for full name change&nbsp;</div></li><li><div>  if (isset($p_filedescr['new_full_name'])) {&nbsp;</div></li><li><div>    // ----- Remove drive letter if any&nbsp;</div></li><li><div>    $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for path and/or short name change&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for short name change&nbsp;</div></li><li><div>    // Its when we cahnge just the filename but not the path&nbsp;</div></li><li><div>    if (isset($p_filedescr['new_short_name'])) {&nbsp;</div></li><li><div>      $v_path_info = pathinfo($p_filename);&nbsp;</div></li><li><div>      $v_dir = '';&nbsp;</div></li><li><div>      if ($v_path_info['dirname'] != '') {&nbsp;</div></li><li><div>        $v_dir = $v_path_info['dirname'].'/';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>      // ----- Calculate the stored filename&nbsp;</div></li><li><div>      $v_stored_filename = $p_filename;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for all path to remove&nbsp;</div></li><li><div>    if ($p_remove_all_dir) {&nbsp;</div></li><li><div>      $v_stored_filename = basename($p_filename);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // ----- Look for partial path remove&nbsp;</div></li><li><div>    else if ($p_remove_dir != &quot;&quot;) {&nbsp;</div></li><li><div>      if (substr($p_remove_dir, -1) != '/')&nbsp;</div></li><li><div>        $p_remove_dir .= &quot;/&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (   (substr($p_filename, 0, 2) == &quot;./&quot;)&nbsp;</div></li><li><div>          || (substr($p_remove_dir, 0, 2) == &quot;./&quot;)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (   (substr($p_filename, 0, 2) == &quot;./&quot;)&nbsp;</div></li><li><div>            && (substr($p_remove_dir, 0, 2) != &quot;./&quot;)) {&nbsp;</div></li><li><div>          $p_remove_dir = &quot;./&quot;.$p_remove_dir;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (   (substr($p_filename, 0, 2) != &quot;./&quot;)&nbsp;</div></li><li><div>            && (substr($p_remove_dir, 0, 2) == &quot;./&quot;)) {&nbsp;</div></li><li><div>          $p_remove_dir = substr($p_remove_dir, 2);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $v_compare = PclZipUtilPathInclusion($p_remove_dir, &nbsp;</div></li><li><div>                                           $v_stored_filename);&nbsp;</div></li><li><div>      if ($v_compare &gt; 0) {&nbsp;</div></li><li><div>        if ($v_compare == 2) {&nbsp;</div></li><li><div>          $v_stored_filename = &quot;&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>          $v_stored_filename = substr($v_stored_filename, &nbsp;</div></li><li><div>                                      strlen($p_remove_dir));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Remove drive letter if any&nbsp;</div></li><li><div>    $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for path to add&nbsp;</div></li><li><div>    if ($p_add_dir != &quot;&quot;) {&nbsp;</div></li><li><div>      if (substr($p_add_dir, -1) == &quot;/&quot;)&nbsp;</div></li><li><div>        $v_stored_filename = $p_add_dir.$v_stored_filename;&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>        $v_stored_filename = $p_add_dir.&quot;/&quot;.$v_stored_filename;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Filename (reduce the path of stored name)&nbsp;</div></li><li><div>  $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);&nbsp;</div></li><li><div>  $p_filedescr['stored_filename'] = $v_stored_filename;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privWriteFileHeader()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privWriteFileHeader(&$p_header)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Store the offset position of the file&nbsp;</div></li><li><div>  $p_header['offset'] = ftell($this-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Transform UNIX mtime to DOS format mdate/mtime&nbsp;</div></li><li><div>  $v_date = getdate($p_header['mtime']);&nbsp;</div></li><li><div>  $v_mtime = ($v_date['hours']&lt;&lt;11) + ($v_date['minutes']&lt;&lt;5) + $v_date['seconds']/2;&nbsp;</div></li><li><div>  $v_mdate = (($v_date['year']-1980)&lt;&lt;9) + ($v_date['mon']&lt;&lt;5) + $v_date['mday'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Packed data&nbsp;</div></li><li><div>  $v_binary_data = pack(&quot;VvvvvvVVVvv&quot;, 0x04034b50, &nbsp;</div></li><li><div>                        $p_header['version_extracted'], $p_header['flag'], &nbsp;</div></li><li><div>                        $p_header['compression'], $v_mtime, $v_mdate, &nbsp;</div></li><li><div>                        $p_header['crc'], $p_header['compressed_size'], &nbsp;</div></li><li><div>                        $p_header['size'], &nbsp;</div></li><li><div>                        strlen($p_header['stored_filename']), &nbsp;</div></li><li><div>                        $p_header['extra_len']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write the first 148 bytes of the header in the archive&nbsp;</div></li><li><div>  fputs($this-&gt;zip_fd, $v_binary_data, 30);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write the variable fields&nbsp;</div></li><li><div>  if (strlen($p_header['stored_filename']) != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    fputs($this-&gt;zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ($p_header['extra_len'] != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    fputs($this-&gt;zip_fd, $p_header['extra'], $p_header['extra_len']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privWriteCentralFileHeader()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privWriteCentralFileHeader(&$p_header)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // TBC&nbsp;</div></li><li><div>  //for(reset($p_header); $key = key($p_header); next($p_header)) {&nbsp;</div></li><li><div>  //}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Transform UNIX mtime to DOS format mdate/mtime&nbsp;</div></li><li><div>  $v_date = getdate($p_header['mtime']);&nbsp;</div></li><li><div>  $v_mtime = ($v_date['hours']&lt;&lt;11) + ($v_date['minutes']&lt;&lt;5) + $v_date['seconds']/2;&nbsp;</div></li><li><div>  $v_mdate = (($v_date['year']-1980)&lt;&lt;9) + ($v_date['mon']&lt;&lt;5) + $v_date['mday'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Packed data&nbsp;</div></li><li><div>  $v_binary_data = pack(&quot;VvvvvvvVVVvvvvvVV&quot;, 0x02014b50, &nbsp;</div></li><li><div>                        $p_header['version'], $p_header['version_extracted'], &nbsp;</div></li><li><div>                        $p_header['flag'], $p_header['compression'], &nbsp;</div></li><li><div>                        $v_mtime, $v_mdate, $p_header['crc'], &nbsp;</div></li><li><div>                        $p_header['compressed_size'], $p_header['size'], &nbsp;</div></li><li><div>                        strlen($p_header['stored_filename']), &nbsp;</div></li><li><div>                        $p_header['extra_len'], $p_header['comment_len'], &nbsp;</div></li><li><div>                        $p_header['disk'], $p_header['internal'], &nbsp;</div></li><li><div>                        $p_header['external'], $p_header['offset']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write the 42 bytes of the header in the zip file&nbsp;</div></li><li><div>  fputs($this-&gt;zip_fd, $v_binary_data, 46);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write the variable fields&nbsp;</div></li><li><div>  if (strlen($p_header['stored_filename']) != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    fputs($this-&gt;zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ($p_header['extra_len'] != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    fputs($this-&gt;zip_fd, $p_header['extra'], $p_header['extra_len']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ($p_header['comment_len'] != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    fputs($this-&gt;zip_fd, $p_header['comment'], $p_header['comment_len']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privWriteCentralHeader()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Packed data&nbsp;</div></li><li><div>  $v_binary_data = pack(&quot;VvvvvVVv&quot;, 0x06054b50, 0, 0, $p_nb_entries, &nbsp;</div></li><li><div>                        $p_nb_entries, $p_size, &nbsp;</div></li><li><div>                        $p_offset, strlen($p_comment));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write the 22 bytes of the header in the zip file&nbsp;</div></li><li><div>  fputs($this-&gt;zip_fd, $v_binary_data, 22);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write the variable fields&nbsp;</div></li><li><div>  if (strlen($p_comment) != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    fputs($this-&gt;zip_fd, $p_comment, strlen($p_comment));&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privList()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privList(&$p_list)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privDisableMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the zip file&nbsp;</div></li><li><div>  if (($this-&gt;zip_fd = @fopen($this-&gt;zipname, 'rb')) == 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Magic quotes trick&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this-&gt;zipname.'\' in binary read mode');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the central directory informations&nbsp;</div></li><li><div>  $v_central_dir = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Go to beginning of Central Dir&nbsp;</div></li><li><div>  @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>  if (@fseek($this-&gt;zip_fd, $v_central_dir['offset']))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read each entry&nbsp;</div></li><li><div>  for ($i=0; $i&lt;$v_central_dir['entries']; $i++)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Read the file header&nbsp;</div></li><li><div>    if (($v_result = $this-&gt;privReadCentralFileHeader($v_header)) != 1)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>      return $v_result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    $v_header['index'] = $i;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Get the only interesting attributes&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($v_header, $p_list[$i]);&nbsp;</div></li><li><div>    unset($v_header);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the zip file&nbsp;</div></li><li><div>  $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privConvertHeader2FileInfo()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   This function takes the file informations from the central directory&nbsp;</div></li><li><div>//   entries and extract the interesting parameters that will be given back.&nbsp;</div></li><li><div>//   The resulting file infos are set in the array $p_info&nbsp;</div></li><li><div>//     $p_info['filename'] : Filename with full path. Given by user (add), &nbsp;</div></li><li><div>//                           extracted in the filesystem (extract).&nbsp;</div></li><li><div>//     $p_info['stored_filename'] : Stored filename in the archive.&nbsp;</div></li><li><div>//     $p_info['size'] = Size of the file.&nbsp;</div></li><li><div>//     $p_info['compressed_size'] = Compressed size of the file.&nbsp;</div></li><li><div>//     $p_info['mtime'] = Last modification date of the file.&nbsp;</div></li><li><div>//     $p_info['comment'] = Comment associated with the file.&nbsp;</div></li><li><div>//     $p_info['folder'] = true/false : indicates if the entry is a folder or not.&nbsp;</div></li><li><div>//     $p_info['status'] = status of the action on the file.&nbsp;</div></li><li><div>//     $p_info['crc'] = CRC of the file content.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privConvertHeader2FileInfo($p_header, &$p_info)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get the interesting attributes&nbsp;</div></li><li><div>  $v_temp_path = PclZipUtilPathReduction($p_header['filename']);&nbsp;</div></li><li><div>  $p_info['filename'] = $v_temp_path;&nbsp;</div></li><li><div>  $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);&nbsp;</div></li><li><div>  $p_info['stored_filename'] = $v_temp_path;&nbsp;</div></li><li><div>  $p_info['size'] = $p_header['size'];&nbsp;</div></li><li><div>  $p_info['compressed_size'] = $p_header['compressed_size'];&nbsp;</div></li><li><div>  $p_info['mtime'] = $p_header['mtime'];&nbsp;</div></li><li><div>  $p_info['comment'] = $p_header['comment'];&nbsp;</div></li><li><div>  $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);&nbsp;</div></li><li><div>  $p_info['index'] = $p_header['index'];&nbsp;</div></li><li><div>  $p_info['status'] = $p_header['status'];&nbsp;</div></li><li><div>  $p_info['crc'] = $p_header['crc'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privExtractByRule()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   Extract a file or directory depending of rules (by index, by name, ...)&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_file_list : An array where will be placed the properties of each&nbsp;</div></li><li><div>//                  extracted file&nbsp;</div></li><li><div>//   $p_path : Path to add while writing the extracted files&nbsp;</div></li><li><div>//   $p_remove_path : Path to remove (from the file memorized path) while writing the&nbsp;</div></li><li><div>//                    extracted files. If the path does not match the file path, &nbsp;</div></li><li><div>//                    the file is extracted with its memorized path.&nbsp;</div></li><li><div>//                    $p_remove_path does not apply to 'list' mode.&nbsp;</div></li><li><div>//                    $p_path and $p_remove_path are commulative.&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   1 on success, 0 or less on error (see error code list)&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Magic quotes trick&nbsp;</div></li><li><div>  $this-&gt;privDisableMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the path&nbsp;</div></li><li><div>  if (   ($p_path == &quot;&quot;)&nbsp;</div></li><li><div>      || (   (substr($p_path, 0, 1) != &quot;/&quot;)&nbsp;</div></li><li><div>          && (substr($p_path, 0, 3) != &quot;../&quot;)&nbsp;</div></li><li><div>          && (substr($p_path, 1, 2)!=&quot;:/&quot;)))&nbsp;</div></li><li><div>    $p_path = &quot;./&quot;.$p_path;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Reduce the path last (and duplicated) '/'&nbsp;</div></li><li><div>  if (($p_path != &quot;./&quot;) && ($p_path != &quot;/&quot;))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Look for the path end '/'&nbsp;</div></li><li><div>    while (substr($p_path, -1) == &quot;/&quot;)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      $p_path = substr($p_path, 0, strlen($p_path)-1);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for path to remove format (should end by /)&nbsp;</div></li><li><div>  if (($p_remove_path != &quot;&quot;) && (substr($p_remove_path, -1) != '/'))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $p_remove_path .= '/';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $p_remove_path_size = strlen($p_remove_path);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the zip file&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privOpenFd('rb')) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the central directory informations&nbsp;</div></li><li><div>  $v_central_dir = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Close the zip file&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Start at beginning of Central Dir&nbsp;</div></li><li><div>  $v_pos_entry = $v_central_dir['offset'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read each entry&nbsp;</div></li><li><div>  $j_start = 0;&nbsp;</div></li><li><div>  for ($i=0, $v_nb_extracted=0; $i&lt;$v_central_dir['entries']; $i++)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Read next Central dir entry&nbsp;</div></li><li><div>    @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>    if (@fseek($this-&gt;zip_fd, $v_pos_entry))&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Close the zip file&nbsp;</div></li><li><div>      $this-&gt;privCloseFd();&nbsp;</div></li><li><div>      $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Read the file header&nbsp;</div></li><li><div>    $v_header = array();&nbsp;</div></li><li><div>    if (($v_result = $this-&gt;privReadCentralFileHeader($v_header)) != 1)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Close the zip file&nbsp;</div></li><li><div>      $this-&gt;privCloseFd();&nbsp;</div></li><li><div>      $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $v_result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Store the index&nbsp;</div></li><li><div>    $v_header['index'] = $i;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Store the file position&nbsp;</div></li><li><div>    $v_pos_entry = ftell($this-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for the specific extract rules&nbsp;</div></li><li><div>    $v_extract = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by name rule&nbsp;</div></li><li><div>    if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))&nbsp;</div></li><li><div>        && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look if the filename is in the list&nbsp;</div></li><li><div>        for ($j=0; ($j&lt;sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Look for a directory&nbsp;</div></li><li><div>            if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == &quot;/&quot;) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // ----- Look if the directory is in the filename path&nbsp;</div></li><li><div>                if (   (strlen($v_header['stored_filename']) &gt; strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))&nbsp;</div></li><li><div>                    && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {&nbsp;</div></li><li><div>                    $v_extract = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // ----- Look for a filename&nbsp;</div></li><li><div>            elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {&nbsp;</div></li><li><div>                $v_extract = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by ereg rule&nbsp;</div></li><li><div>    // ereg() is deprecated with PHP 5.3&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>    else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))&nbsp;</div></li><li><div>             && ($p_options[PCLZIP_OPT_BY_EREG] != &quot;&quot;)) {&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {&nbsp;</div></li><li><div>            $v_extract = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by preg rule&nbsp;</div></li><li><div>    else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))&nbsp;</div></li><li><div>             && ($p_options[PCLZIP_OPT_BY_PREG] != &quot;&quot;)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {&nbsp;</div></li><li><div>            $v_extract = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by index rule&nbsp;</div></li><li><div>    else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))&nbsp;</div></li><li><div>             && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look if the index is in the list&nbsp;</div></li><li><div>        for ($j=$j_start; ($j&lt;sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (($i&gt;=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i&lt;=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {&nbsp;</div></li><li><div>                $v_extract = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($i&gt;=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {&nbsp;</div></li><li><div>                $j_start = $j+1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']&gt;$i) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for no rule, which means extract all the archive&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>        $v_extract = true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check compression method&nbsp;</div></li><li><div>    if (   ($v_extract)&nbsp;</div></li><li><div>        && (   ($v_header['compression'] != 8)&nbsp;</div></li><li><div>            && ($v_header['compression'] != 0))) {&nbsp;</div></li><li><div>        $v_header['status'] = 'unsupported_compression';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR&nbsp;</div></li><li><div>        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))&nbsp;</div></li><li><div>            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION, &nbsp;</div></li><li><div>                                 &quot;Filename '&quot;.$v_header['stored_filename'].&quot;' is &quot;&nbsp;</div></li><li><div>                                     .&quot;compressed by an unsupported compression &quot;&nbsp;</div></li><li><div>                                     .&quot;method (&quot;.$v_header['compression'].&quot;) &quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check encrypted files&nbsp;</div></li><li><div>    if (($v_extract) && (($v_header['flag'] & 1) == 1)) {&nbsp;</div></li><li><div>        $v_header['status'] = 'unsupported_encryption';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR&nbsp;</div></li><li><div>        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))&nbsp;</div></li><li><div>            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, &nbsp;</div></li><li><div>                                 &quot;Unsupported encryption for &quot;&nbsp;</div></li><li><div>                                     .&quot; filename '&quot;.$v_header['stored_filename']&nbsp;</div></li><li><div>                                 .&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for real extraction&nbsp;</div></li><li><div>    if (($v_extract) && ($v_header['status'] != 'ok')) {&nbsp;</div></li><li><div>        $v_result = $this-&gt;privConvertHeader2FileInfo($v_header, &nbsp;</div></li><li><div>                                              $p_file_list[$v_nb_extracted++]);&nbsp;</div></li><li><div>        if ($v_result != 1) {&nbsp;</div></li><li><div>            $this-&gt;privCloseFd();&nbsp;</div></li><li><div>            $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>            return $v_result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $v_extract = false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for real extraction&nbsp;</div></li><li><div>    if ($v_extract)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Go to the file position&nbsp;</div></li><li><div>      @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>      if (@fseek($this-&gt;zip_fd, $v_header['offset']))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>        // ----- Close the zip file&nbsp;</div></li><li><div>        $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Error log&nbsp;</div></li><li><div>        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        return PclZip::errorCode();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for extraction as string&nbsp;</div></li><li><div>      if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $v_string = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Extracting the file&nbsp;</div></li><li><div>        $v_result1 = $this-&gt;privExtractFileAsString($v_header, $v_string, $p_options);&nbsp;</div></li><li><div>        if ($v_result1 &lt; 1) {&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>          $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>          return $v_result1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the only interesting attributes&nbsp;</div></li><li><div>        if (($v_result = $this-&gt;privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)&nbsp;</div></li><li><div>        {&nbsp;</div></li><li><div>          // ----- Close the zip file&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>          $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Set the file content&nbsp;</div></li><li><div>        $p_file_list[$v_nb_extracted]['content'] = $v_string;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Next extracted file&nbsp;</div></li><li><div>        $v_nb_extracted++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look for user callback abort&nbsp;</div></li><li><div>        if ($v_result1 == 2) {&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // ----- Look for extraction in standard output&nbsp;</div></li><li><div>      elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))&nbsp;</div></li><li><div>              && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {&nbsp;</div></li><li><div>        // ----- Extracting the file in standard output&nbsp;</div></li><li><div>        $v_result1 = $this-&gt;privExtractFileInOutput($v_header, $p_options);&nbsp;</div></li><li><div>        if ($v_result1 &lt; 1) {&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>          $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>          return $v_result1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the only interesting attributes&nbsp;</div></li><li><div>        if (($v_result = $this-&gt;privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>          $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look for user callback abort&nbsp;</div></li><li><div>        if ($v_result1 == 2) {&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // ----- Look for normal extraction&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>        // ----- Extracting the file&nbsp;</div></li><li><div>        $v_result1 = $this-&gt;privExtractFile($v_header, &nbsp;</div></li><li><div>                                            $p_path, $p_remove_path, &nbsp;</div></li><li><div>                                            $p_remove_all_path, &nbsp;</div></li><li><div>                                            $p_options);&nbsp;</div></li><li><div>        if ($v_result1 &lt; 1) {&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>          $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>          return $v_result1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Get the only interesting attributes&nbsp;</div></li><li><div>        if (($v_result = $this-&gt;privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)&nbsp;</div></li><li><div>        {&nbsp;</div></li><li><div>          // ----- Close the zip file&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>          $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look for user callback abort&nbsp;</div></li><li><div>        if ($v_result1 == 2) {&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the zip file&nbsp;</div></li><li><div>  $this-&gt;privCloseFd();&nbsp;</div></li><li><div>  $this-&gt;privSwapBackMagicQuotes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privExtractFile()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//&nbsp;</div></li><li><div>// 1 : ... ?&nbsp;</div></li><li><div>// PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the file header&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadFileHeader($v_header)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check that the file header is coherent with $p_entry info&nbsp;</div></li><li><div>  if ($this-&gt;privCheckFileHeaders($v_header, $p_entry) != 1) {&nbsp;</div></li><li><div>      // TBC&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for all path to remove&nbsp;</div></li><li><div>  if ($p_remove_all_path == true) {&nbsp;</div></li><li><div>      // ----- Look for folder entry that not need to be extracted&nbsp;</div></li><li><div>      if (($p_entry['external']&0x00000010)==0x00000010) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $p_entry['status'] = &quot;filtered&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Get the basename of the path&nbsp;</div></li><li><div>      $p_entry['filename'] = basename($p_entry['filename']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for path to remove&nbsp;</div></li><li><div>  else if ($p_remove_path != &quot;&quot;)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;filtered&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return $v_result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    $p_remove_path_size = strlen($p_remove_path);&nbsp;</div></li><li><div>    if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Remove the path&nbsp;</div></li><li><div>      $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Add the path&nbsp;</div></li><li><div>  if ($p_path != '') {&nbsp;</div></li><li><div>    $p_entry['filename'] = $p_path.&quot;/&quot;.$p_entry['filename'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check a base_dir_restriction&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {&nbsp;</div></li><li><div>    $v_inclusion&nbsp;</div></li><li><div> = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION], &nbsp;</div></li><li><div>                              $p_entry['filename']);&nbsp;</div></li><li><div>    if ($v_inclusion == 0) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION, &nbsp;</div></li><li><div>                               &quot;Filename '&quot;.$p_entry['filename'].&quot;' is &quot;&nbsp;</div></li><li><div>                               .&quot;outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for pre-extract callback&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);&nbsp;</div></li><li><div>    if ($v_result == 0) {&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;skipped&quot;;&nbsp;</div></li><li><div>      $v_result = 1;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for abort result&nbsp;</div></li><li><div>    if ($v_result == 2) {&nbsp;</div></li><li><div>      // ----- This status is internal and will be changed in 'skipped'&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;aborted&quot;;&nbsp;</div></li><li><div>        $v_result = PCLZIP_ERR_USER_ABORTED;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Update the informations&nbsp;</div></li><li><div>    // Only some fields can be modified&nbsp;</div></li><li><div>    $p_entry['filename'] = $v_local_header['filename'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if extraction should be done&nbsp;</div></li><li><div>  if ($p_entry['status'] == 'ok') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for specific actions while the file exist&nbsp;</div></li><li><div>  if (file_exists($p_entry['filename']))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look if file is a directory&nbsp;</div></li><li><div>    if (is_dir($p_entry['filename']))&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;already_a_directory&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for PCLZIP_OPT_STOP_ON_ERROR&nbsp;</div></li><li><div>      // For historical reason first PclZip implementation does not stop&nbsp;</div></li><li><div>      // when this kind of error occurs.&nbsp;</div></li><li><div>      if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))&nbsp;</div></li><li><div>          && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY, &nbsp;</div></li><li><div>                               &quot;Filename '&quot;.$p_entry['filename'].&quot;' is &quot;&nbsp;</div></li><li><div>                               .&quot;already used by an existing directory&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // ----- Look if file is write protected&nbsp;</div></li><li><div>    else if (!is_writeable($p_entry['filename']))&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;write_protected&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for PCLZIP_OPT_STOP_ON_ERROR&nbsp;</div></li><li><div>      // For historical reason first PclZip implementation does not stop&nbsp;</div></li><li><div>      // when this kind of error occurs.&nbsp;</div></li><li><div>      if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))&nbsp;</div></li><li><div>          && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, &nbsp;</div></li><li><div>                               &quot;Filename '&quot;.$p_entry['filename'].&quot;' exists &quot;&nbsp;</div></li><li><div>                               .&quot;and is write protected&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look if the extracted file is older&nbsp;</div></li><li><div>    else if (filemtime($p_entry['filename']) &gt; $p_entry['mtime'])&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))&nbsp;</div></li><li><div>          && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else {&nbsp;</div></li><li><div>          $p_entry['status'] = &quot;newer_exist&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR&nbsp;</div></li><li><div>          // For historical reason first PclZip implementation does not stop&nbsp;</div></li><li><div>          // when this kind of error occurs.&nbsp;</div></li><li><div>          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))&nbsp;</div></li><li><div>              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, &nbsp;</div></li><li><div>                       &quot;Newer version of '&quot;.$p_entry['filename'].&quot;' exists &quot;&nbsp;</div></li><li><div>                      .&quot;and option PCLZIP_OPT_REPLACE_NEWER is not selected&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              return PclZip::errorCode();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the directory availability and create it if necessary&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))&nbsp;</div></li><li><div>      $v_dir_to_check = $p_entry['filename'];&nbsp;</div></li><li><div>    else if (!strstr($p_entry['filename'], &quot;/&quot;))&nbsp;</div></li><li><div>      $v_dir_to_check = &quot;&quot;;&nbsp;</div></li><li><div>    else&nbsp;</div></li><li><div>      $v_dir_to_check = dirname($p_entry['filename']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Change the file status&nbsp;</div></li><li><div>        $p_entry['status'] = &quot;path_creation_fail&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Return&nbsp;</div></li><li><div>        //return $v_result;&nbsp;</div></li><li><div>        $v_result = 1;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if extraction should be done&nbsp;</div></li><li><div>  if ($p_entry['status'] == 'ok') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Do the extraction (if not a folder)&nbsp;</div></li><li><div>    if (!(($p_entry['external']&0x00000010)==0x00000010))&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Look for not compressed file&nbsp;</div></li><li><div>      if ($p_entry['compression'] == 0) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Opening destination file&nbsp;</div></li><li><div>        if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)&nbsp;</div></li><li><div>        {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Change the file status&nbsp;</div></li><li><div>          $p_entry['status'] = &quot;write_error&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks&nbsp;</div></li><li><div>        $v_size = $p_entry['compressed_size'];&nbsp;</div></li><li><div>        while ($v_size != 0)&nbsp;</div></li><li><div>        {&nbsp;</div></li><li><div>          $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>          $v_buffer = @fread($this-&gt;zip_fd, $v_read_size);&nbsp;</div></li><li><div>          /** Try to speed up the code&nbsp;</div></li><li><div>          $v_binary_data = pack('a'.$v_read_size, $v_buffer);&nbsp;</div></li><li><div>          @fwrite($v_dest_file, $v_binary_data, $v_read_size);&nbsp;</div></li><li><div>          */&nbsp;</div></li><li><div>          @fwrite($v_dest_file, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>          $v_size -= $v_read_size;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Closing the destination file&nbsp;</div></li><li><div>        fclose($v_dest_file);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Change the file mtime&nbsp;</div></li><li><div>        touch($p_entry['filename'], $p_entry['mtime']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>        // ----- TBC&nbsp;</div></li><li><div>        // Need to be finished&nbsp;</div></li><li><div>        if (($p_entry['flag'] & 1) == 1) {&nbsp;</div></li><li><div>          PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \''.$p_entry['filename'].'\' is encrypted. Encrypted files are not supported.');&nbsp;</div></li><li><div>          return PclZip::errorCode();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look for using temporary file to unzip&nbsp;</div></li><li><div>        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))&nbsp;</div></li><li><div>            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])&nbsp;</div></li><li><div>                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])&nbsp;</div></li><li><div>                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] &lt;= $p_entry['size'])) ) ) {&nbsp;</div></li><li><div>          $v_result = $this-&gt;privExtractFileUsingTempFile($p_entry, $p_options);&nbsp;</div></li><li><div>          if ($v_result &lt; PCLZIP_ERR_NO_ERROR) {&nbsp;</div></li><li><div>            return $v_result;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look for extract in memory&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Read the compressed file in a buffer (one shot)&nbsp;</div></li><li><div>          $v_buffer = @fread($this-&gt;zip_fd, $p_entry['compressed_size']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Decompress the file&nbsp;</div></li><li><div>          $v_file_content = @gzinflate($v_buffer);&nbsp;</div></li><li><div>          unset($v_buffer);&nbsp;</div></li><li><div>          if ($v_file_content === FALSE) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Change the file status&nbsp;</div></li><li><div>            // TBC&nbsp;</div></li><li><div>            $p_entry['status'] = &quot;error&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            return $v_result;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Opening destination file&nbsp;</div></li><li><div>          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Change the file status&nbsp;</div></li><li><div>            $p_entry['status'] = &quot;write_error&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            return $v_result;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Write the uncompressed data&nbsp;</div></li><li><div>          @fwrite($v_dest_file, $v_file_content, $p_entry['size']);&nbsp;</div></li><li><div>          unset($v_file_content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Closing the destination file&nbsp;</div></li><li><div>          @fclose($v_dest_file);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Change the file mtime&nbsp;</div></li><li><div>        @touch($p_entry['filename'], $p_entry['mtime']);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look for chmod option&nbsp;</div></li><li><div>      if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Change the mode of the file&nbsp;</div></li><li><div>        @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Change abort status&nbsp;</div></li><li><div>    if ($p_entry['status'] == &quot;aborted&quot;) {&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;skipped&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for post-extract callback&nbsp;</div></li><li><div>  elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for abort result&nbsp;</div></li><li><div>    if ($v_result == 2) {&nbsp;</div></li><li><div>        $v_result = PCLZIP_ERR_USER_ABORTED;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privExtractFileUsingTempFile()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privExtractFileUsingTempFile(&$p_entry, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Creates a temporary file&nbsp;</div></li><li><div>  $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';&nbsp;</div></li><li><div>  if (($v_dest_file = @fopen($v_gzip_temp_name, &quot;wb&quot;)) == 0) {&nbsp;</div></li><li><div>    fclose($v_file);&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write gz file format header&nbsp;</div></li><li><div>  $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));&nbsp;</div></li><li><div>  @fwrite($v_dest_file, $v_binary_data, 10);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks&nbsp;</div></li><li><div>  $v_size = $p_entry['compressed_size'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = @fread($this-&gt;zip_fd, $v_read_size);&nbsp;</div></li><li><div>    //$v_binary_data = pack('a'.$v_read_size, $v_buffer);&nbsp;</div></li><li><div>    @fwrite($v_dest_file, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Write gz file format footer&nbsp;</div></li><li><div>  $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);&nbsp;</div></li><li><div>  @fwrite($v_dest_file, $v_binary_data, 8);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the temporary file&nbsp;</div></li><li><div>  @fclose($v_dest_file);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Opening destination file&nbsp;</div></li><li><div>  if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {&nbsp;</div></li><li><div>    $p_entry['status'] = &quot;write_error&quot;;&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the temporary gz file&nbsp;</div></li><li><div>  if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {&nbsp;</div></li><li><div>    @fclose($v_dest_file);&nbsp;</div></li><li><div>    $p_entry['status'] = &quot;read_error&quot;;&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks&nbsp;</div></li><li><div>  $v_size = $p_entry['size'];&nbsp;</div></li><li><div>  while ($v_size != 0) {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = @gzread($v_src_file, $v_read_size);&nbsp;</div></li><li><div>    //$v_binary_data = pack('a'.$v_read_size, $v_buffer);&nbsp;</div></li><li><div>    @fwrite($v_dest_file, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  @fclose($v_dest_file);&nbsp;</div></li><li><div>  @gzclose($v_src_file);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Delete the temporary file&nbsp;</div></li><li><div>  @unlink($v_gzip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privExtractFileInOutput()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privExtractFileInOutput(&$p_entry, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the file header&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadFileHeader($v_header)) != 1) {&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check that the file header is coherent with $p_entry info&nbsp;</div></li><li><div>  if ($this-&gt;privCheckFileHeaders($v_header, $p_entry) != 1) {&nbsp;</div></li><li><div>      // TBC&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for pre-extract callback&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);&nbsp;</div></li><li><div>    if ($v_result == 0) {&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;skipped&quot;;&nbsp;</div></li><li><div>      $v_result = 1;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for abort result&nbsp;</div></li><li><div>    if ($v_result == 2) {&nbsp;</div></li><li><div>      // ----- This status is internal and will be changed in 'skipped'&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;aborted&quot;;&nbsp;</div></li><li><div>        $v_result = PCLZIP_ERR_USER_ABORTED;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Update the informations&nbsp;</div></li><li><div>    // Only some fields can be modified&nbsp;</div></li><li><div>    $p_entry['filename'] = $v_local_header['filename'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Trace&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if extraction should be done&nbsp;</div></li><li><div>  if ($p_entry['status'] == 'ok') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Do the extraction (if not a folder)&nbsp;</div></li><li><div>    if (!(($p_entry['external']&0x00000010)==0x00000010)) {&nbsp;</div></li><li><div>      // ----- Look for not compressed file&nbsp;</div></li><li><div>      if ($p_entry['compressed_size'] == $p_entry['size']) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Read the file in a buffer (one shot)&nbsp;</div></li><li><div>        $v_buffer = @fread($this-&gt;zip_fd, $p_entry['compressed_size']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Send the file to the output&nbsp;</div></li><li><div>        echo $v_buffer;&nbsp;</div></li><li><div>        unset($v_buffer);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Read the compressed file in a buffer (one shot)&nbsp;</div></li><li><div>        $v_buffer = @fread($this-&gt;zip_fd, $p_entry['compressed_size']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Decompress the file&nbsp;</div></li><li><div>        $v_file_content = gzinflate($v_buffer);&nbsp;</div></li><li><div>        unset($v_buffer);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Send the file to the output&nbsp;</div></li><li><div>        echo $v_file_content;&nbsp;</div></li><li><div>        unset($v_file_content);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Change abort status&nbsp;</div></li><li><div>  if ($p_entry['status'] == &quot;aborted&quot;) {&nbsp;</div></li><li><div>    $p_entry['status'] = &quot;skipped&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for post-extract callback&nbsp;</div></li><li><div>  elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for abort result&nbsp;</div></li><li><div>    if ($v_result == 2) {&nbsp;</div></li><li><div>        $v_result = PCLZIP_ERR_USER_ABORTED;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privExtractFileAsString()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the file header&nbsp;</div></li><li><div>  $v_header = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadFileHeader($v_header)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check that the file header is coherent with $p_entry info&nbsp;</div></li><li><div>  if ($this-&gt;privCheckFileHeaders($v_header, $p_entry) != 1) {&nbsp;</div></li><li><div>      // TBC&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for pre-extract callback&nbsp;</div></li><li><div>  if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);&nbsp;</div></li><li><div>    if ($v_result == 0) {&nbsp;</div></li><li><div>      // ----- Change the file status&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;skipped&quot;;&nbsp;</div></li><li><div>      $v_result = 1;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for abort result&nbsp;</div></li><li><div>    if ($v_result == 2) {&nbsp;</div></li><li><div>      // ----- This status is internal and will be changed in 'skipped'&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;aborted&quot;;&nbsp;</div></li><li><div>        $v_result = PCLZIP_ERR_USER_ABORTED;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Update the informations&nbsp;</div></li><li><div>    // Only some fields can be modified&nbsp;</div></li><li><div>    $p_entry['filename'] = $v_local_header['filename'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if extraction should be done&nbsp;</div></li><li><div>  if ($p_entry['status'] == 'ok') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Do the extraction (if not a folder)&nbsp;</div></li><li><div>    if (!(($p_entry['external']&0x00000010)==0x00000010)) {&nbsp;</div></li><li><div>      // ----- Look for not compressed file&nbsp;</div></li><li><div>//      if ($p_entry['compressed_size'] == $p_entry['size'])&nbsp;</div></li><li><div>      if ($p_entry['compression'] == 0) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Reading the file&nbsp;</div></li><li><div>        $p_string = @fread($this-&gt;zip_fd, $p_entry['compressed_size']);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Reading the file&nbsp;</div></li><li><div>        $v_data = @fread($this-&gt;zip_fd, $p_entry['compressed_size']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Decompress the file&nbsp;</div></li><li><div>        if (($p_string = @gzinflate($v_data)) === FALSE) {&nbsp;</div></li><li><div>            // TBC&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Trace&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>        // TBC : error : can not extract a folder in a string&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Change abort status&nbsp;</div></li><li><div>    if ($p_entry['status'] == &quot;aborted&quot;) {&nbsp;</div></li><li><div>      $p_entry['status'] = &quot;skipped&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for post-extract callback&nbsp;</div></li><li><div>  elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Generate a local information&nbsp;</div></li><li><div>    $v_local_header = array();&nbsp;</div></li><li><div>    $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Swap the content to header&nbsp;</div></li><li><div>    $v_local_header['content'] = $p_string;&nbsp;</div></li><li><div>    $p_string = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Call the callback&nbsp;</div></li><li><div>    // Here I do not use call_user_func() because I need to send a reference to the&nbsp;</div></li><li><div>    // header.&nbsp;</div></li><li><div>    $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Swap back the content to header&nbsp;</div></li><li><div>    $p_string = $v_local_header['content'];&nbsp;</div></li><li><div>    unset($v_local_header['content']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for abort result&nbsp;</div></li><li><div>    if ($v_result == 2) {&nbsp;</div></li><li><div>        $v_result = PCLZIP_ERR_USER_ABORTED;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privReadFileHeader()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privReadFileHeader(&$p_header)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the 4 bytes signature&nbsp;</div></li><li><div>  $v_binary_data = @fread($this-&gt;zip_fd, 4);&nbsp;</div></li><li><div>  $v_data = unpack('Vid', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check signature&nbsp;</div></li><li><div>  if ($v_data['id'] != 0x04034b50)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the first 42 bytes of the header&nbsp;</div></li><li><div>  $v_binary_data = fread($this-&gt;zip_fd, 26);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for invalid block size&nbsp;</div></li><li><div>  if (strlen($v_binary_data) != 26)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $p_header['filename'] = &quot;&quot;;&nbsp;</div></li><li><div>    $p_header['status'] = &quot;invalid_header&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Invalid block size : &quot;.strlen($v_binary_data));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Extract the values&nbsp;</div></li><li><div>  $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get filename&nbsp;</div></li><li><div>  $p_header['filename'] = fread($this-&gt;zip_fd, $v_data['filename_len']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get extra_fields&nbsp;</div></li><li><div>  if ($v_data['extra_len'] != 0) {&nbsp;</div></li><li><div>    $p_header['extra'] = fread($this-&gt;zip_fd, $v_data['extra_len']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $p_header['extra'] = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Extract properties&nbsp;</div></li><li><div>  $p_header['version_extracted'] = $v_data['version'];&nbsp;</div></li><li><div>  $p_header['compression'] = $v_data['compression'];&nbsp;</div></li><li><div>  $p_header['size'] = $v_data['size'];&nbsp;</div></li><li><div>  $p_header['compressed_size'] = $v_data['compressed_size'];&nbsp;</div></li><li><div>  $p_header['crc'] = $v_data['crc'];&nbsp;</div></li><li><div>  $p_header['flag'] = $v_data['flag'];&nbsp;</div></li><li><div>  $p_header['filename_len'] = $v_data['filename_len'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Recuperate date in UNIX format&nbsp;</div></li><li><div>  $p_header['mdate'] = $v_data['mdate'];&nbsp;</div></li><li><div>  $p_header['mtime'] = $v_data['mtime'];&nbsp;</div></li><li><div>  if ($p_header['mdate'] && $p_header['mtime'])&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Extract time&nbsp;</div></li><li><div>    $v_hour = ($p_header['mtime'] & 0xF800) &gt;&gt; 11;&nbsp;</div></li><li><div>    $v_minute = ($p_header['mtime'] & 0x07E0) &gt;&gt; 5;&nbsp;</div></li><li><div>    $v_seconde = ($p_header['mtime'] & 0x001F)*2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Extract date&nbsp;</div></li><li><div>    $v_year = (($p_header['mdate'] & 0xFE00) &gt;&gt; 9) + 1980;&nbsp;</div></li><li><div>    $v_month = ($p_header['mdate'] & 0x01E0) &gt;&gt; 5;&nbsp;</div></li><li><div>    $v_day = $p_header['mdate'] & 0x001F;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Get UNIX date format&nbsp;</div></li><li><div>    $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $p_header['mtime'] = time();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // TBC&nbsp;</div></li><li><div>  //for(reset($v_data); $key = key($v_data); next($v_data)) {&nbsp;</div></li><li><div>  //}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set the stored filename&nbsp;</div></li><li><div>  $p_header['stored_filename'] = $p_header['filename'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set the status field&nbsp;</div></li><li><div>  $p_header['status'] = &quot;ok&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privReadCentralFileHeader()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privReadCentralFileHeader(&$p_header)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the 4 bytes signature&nbsp;</div></li><li><div>  $v_binary_data = @fread($this-&gt;zip_fd, 4);&nbsp;</div></li><li><div>  $v_data = unpack('Vid', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check signature&nbsp;</div></li><li><div>  if ($v_data['id'] != 0x02014b50)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the first 42 bytes of the header&nbsp;</div></li><li><div>  $v_binary_data = fread($this-&gt;zip_fd, 42);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for invalid block size&nbsp;</div></li><li><div>  if (strlen($v_binary_data) != 42)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $p_header['filename'] = &quot;&quot;;&nbsp;</div></li><li><div>    $p_header['status'] = &quot;invalid_header&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Invalid block size : &quot;.strlen($v_binary_data));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Extract the values&nbsp;</div></li><li><div>  $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get filename&nbsp;</div></li><li><div>  if ($p_header['filename_len'] != 0)&nbsp;</div></li><li><div>    $p_header['filename'] = fread($this-&gt;zip_fd, $p_header['filename_len']);&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>    $p_header['filename'] = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get extra&nbsp;</div></li><li><div>  if ($p_header['extra_len'] != 0)&nbsp;</div></li><li><div>    $p_header['extra'] = fread($this-&gt;zip_fd, $p_header['extra_len']);&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>    $p_header['extra'] = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get comment&nbsp;</div></li><li><div>  if ($p_header['comment_len'] != 0)&nbsp;</div></li><li><div>    $p_header['comment'] = fread($this-&gt;zip_fd, $p_header['comment_len']);&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>    $p_header['comment'] = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Extract properties&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Recuperate date in UNIX format&nbsp;</div></li><li><div>  //if ($p_header['mdate'] && $p_header['mtime'])&nbsp;</div></li><li><div>  // TBC : bug : this was ignoring time with 0/0/0&nbsp;</div></li><li><div>  if (1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Extract time&nbsp;</div></li><li><div>    $v_hour = ($p_header['mtime'] & 0xF800) &gt;&gt; 11;&nbsp;</div></li><li><div>    $v_minute = ($p_header['mtime'] & 0x07E0) &gt;&gt; 5;&nbsp;</div></li><li><div>    $v_seconde = ($p_header['mtime'] & 0x001F)*2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Extract date&nbsp;</div></li><li><div>    $v_year = (($p_header['mdate'] & 0xFE00) &gt;&gt; 9) + 1980;&nbsp;</div></li><li><div>    $v_month = ($p_header['mdate'] & 0x01E0) &gt;&gt; 5;&nbsp;</div></li><li><div>    $v_day = $p_header['mdate'] & 0x001F;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Get UNIX date format&nbsp;</div></li><li><div>    $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $p_header['mtime'] = time();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set the stored filename&nbsp;</div></li><li><div>  $p_header['stored_filename'] = $p_header['filename'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Set default status to ok&nbsp;</div></li><li><div>  $p_header['status'] = 'ok';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if it is a directory&nbsp;</div></li><li><div>  if (substr($p_header['filename'], -1) == '/') {&nbsp;</div></li><li><div>    //$p_header['external'] = 0x41FF0010;&nbsp;</div></li><li><div>    $p_header['external'] = 0x00000010;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privCheckFileHeaders()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//   1 on success, &nbsp;</div></li><li><div>//   0 on error;&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privCheckFileHeaders(&$p_local_header, &$p_central_header)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check the static values&nbsp;</div></li><li><div>    // TBC&nbsp;</div></li><li><div>    if ($p_local_header['filename'] != $p_central_header['filename']) {&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if ($p_local_header['flag'] != $p_central_header['flag']) {&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if ($p_local_header['compression'] != $p_central_header['compression']) {&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if ($p_local_header['mtime'] != $p_central_header['mtime']) {&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for flag bit 3&nbsp;</div></li><li><div>    if (($p_local_header['flag'] & 8) == 8) {&nbsp;</div></li><li><div>        $p_local_header['size'] = $p_central_header['size'];&nbsp;</div></li><li><div>        $p_local_header['compressed_size'] = $p_central_header['compressed_size'];&nbsp;</div></li><li><div>        $p_local_header['crc'] = $p_central_header['crc'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privReadEndCentralDir()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privReadEndCentralDir(&$p_central_dir)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Go to the end of the zip file&nbsp;</div></li><li><div>  $v_size = filesize($this-&gt;zipname);&nbsp;</div></li><li><div>  @fseek($this-&gt;zip_fd, $v_size);&nbsp;</div></li><li><div>  if (@ftell($this-&gt;zip_fd) != $v_size)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \''.$this-&gt;zipname.'\'');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- First try : look if this is an archive with no commentaries (most of the time)&nbsp;</div></li><li><div>  // in this case the end of central dir is at 22 bytes of the file end&nbsp;</div></li><li><div>  $v_found = 0;&nbsp;</div></li><li><div>  if ($v_size &gt; 26) {&nbsp;</div></li><li><div>    @fseek($this-&gt;zip_fd, $v_size-22);&nbsp;</div></li><li><div>    if (($v_pos = @ftell($this-&gt;zip_fd)) != ($v_size-22))&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this-&gt;zipname.'\'');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Read for bytes&nbsp;</div></li><li><div>    $v_binary_data = @fread($this-&gt;zip_fd, 4);&nbsp;</div></li><li><div>    $v_data = @unpack('Vid', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Check signature&nbsp;</div></li><li><div>    if ($v_data['id'] == 0x06054b50) {&nbsp;</div></li><li><div>      $v_found = 1;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    $v_pos = ftell($this-&gt;zip_fd);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Go back to the maximum possible size of the Central Dir End Record&nbsp;</div></li><li><div>  if (!$v_found) {&nbsp;</div></li><li><div>    $v_maximum_size = 65557; // 0xFFFF + 22;&nbsp;</div></li><li><div>    if ($v_maximum_size &gt; $v_size)&nbsp;</div></li><li><div>      $v_maximum_size = $v_size;&nbsp;</div></li><li><div>    @fseek($this-&gt;zip_fd, $v_size-$v_maximum_size);&nbsp;</div></li><li><div>    if (@ftell($this-&gt;zip_fd) != ($v_size-$v_maximum_size))&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this-&gt;zipname.'\'');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Read byte per byte in order to find the signature&nbsp;</div></li><li><div>    $v_pos = ftell($this-&gt;zip_fd);&nbsp;</div></li><li><div>    $v_bytes = 0x00000000;&nbsp;</div></li><li><div>    while ($v_pos &lt; $v_size)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Read a byte&nbsp;</div></li><li><div>      $v_byte = @fread($this-&gt;zip_fd, 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // -----  Add the byte&nbsp;</div></li><li><div>      //$v_bytes = ($v_bytes &lt;&lt; 8) | Ord($v_byte);&nbsp;</div></li><li><div>      // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number&nbsp;</div></li><li><div>      // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.&nbsp;</div></li><li><div>      $v_bytes = ( ($v_bytes & 0xFFFFFF) &lt;&lt; 8) | Ord($v_byte);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Compare the bytes&nbsp;</div></li><li><div>      if ($v_bytes == 0x504b0506)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>        $v_pos++;&nbsp;</div></li><li><div>        break;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $v_pos++;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look if not found end of central dir&nbsp;</div></li><li><div>    if ($v_pos == $v_size)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Error log&nbsp;</div></li><li><div>      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Unable to find End of Central Dir Record signature&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Return&nbsp;</div></li><li><div>      return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the first 18 bytes of the header&nbsp;</div></li><li><div>  $v_binary_data = fread($this-&gt;zip_fd, 18);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look for invalid block size&nbsp;</div></li><li><div>  if (strlen($v_binary_data) != 18)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Invalid End of Central Dir Record size : &quot;.strlen($v_binary_data));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Extract the values&nbsp;</div></li><li><div>  $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the global size&nbsp;</div></li><li><div>  if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Removed in release 2.2 see readme file&nbsp;</div></li><li><div>    // The check of the file size is a little too strict.&nbsp;</div></li><li><div>    // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.&nbsp;</div></li><li><div>    // While decrypted, zip has training 0 bytes&nbsp;</div></li><li><div>    if (0) {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &nbsp;</div></li><li><div>                         'The central dir is not at the end of the archive.'&nbsp;</div></li><li><div>                         .' Some trailing bytes exists after the archive.');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get comment&nbsp;</div></li><li><div>  if ($v_data['comment_size'] != 0) {&nbsp;</div></li><li><div>    $p_central_dir['comment'] = fread($this-&gt;zip_fd, $v_data['comment_size']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>    $p_central_dir['comment'] = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $p_central_dir['entries'] = $v_data['entries'];&nbsp;</div></li><li><div>  $p_central_dir['disk_entries'] = $v_data['disk_entries'];&nbsp;</div></li><li><div>  $p_central_dir['offset'] = $v_data['offset'];&nbsp;</div></li><li><div>  $p_central_dir['size'] = $v_data['size'];&nbsp;</div></li><li><div>  $p_central_dir['disk'] = $v_data['disk'];&nbsp;</div></li><li><div>  $p_central_dir['disk_start'] = $v_data['disk_start'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // TBC&nbsp;</div></li><li><div>  //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {&nbsp;</div></li><li><div>  //}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privDeleteByRule()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privDeleteByRule(&$p_result_list, &$p_options)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>  $v_list_detail = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the zip file&nbsp;</div></li><li><div>  if (($v_result=$this-&gt;privOpenFd('rb')) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the central directory informations&nbsp;</div></li><li><div>  $v_central_dir = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Go to beginning of File&nbsp;</div></li><li><div>  @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Scan all the files&nbsp;</div></li><li><div>  // ----- Start at beginning of Central Dir&nbsp;</div></li><li><div>  $v_pos_entry = $v_central_dir['offset'];&nbsp;</div></li><li><div>  @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>  if (@fseek($this-&gt;zip_fd, $v_pos_entry))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Close the zip file&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read each entry&nbsp;</div></li><li><div>  $v_header_list = array();&nbsp;</div></li><li><div>  $j_start = 0;&nbsp;</div></li><li><div>  for ($i=0, $v_nb_extracted=0; $i&lt;$v_central_dir['entries']; $i++)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Read the file header&nbsp;</div></li><li><div>    $v_header_list[$v_nb_extracted] = array();&nbsp;</div></li><li><div>    if (($v_result = $this-&gt;privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      // ----- Close the zip file&nbsp;</div></li><li><div>      $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $v_result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Store the index&nbsp;</div></li><li><div>    $v_header_list[$v_nb_extracted]['index'] = $i;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for the specific extract rules&nbsp;</div></li><li><div>    $v_found = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by name rule&nbsp;</div></li><li><div>    if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))&nbsp;</div></li><li><div>        && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look if the filename is in the list&nbsp;</div></li><li><div>        for ($j=0; ($j&lt;sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ----- Look for a directory&nbsp;</div></li><li><div>            if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == &quot;/&quot;) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // ----- Look if the directory is in the filename path&nbsp;</div></li><li><div>                if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) &gt; strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))&nbsp;</div></li><li><div>                    && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {&nbsp;</div></li><li><div>                    $v_found = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /** Indicates a folder */&nbsp;</div></li><li><div>                        && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {&nbsp;</div></li><li><div>                    $v_found = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // ----- Look for a filename&nbsp;</div></li><li><div>            elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {&nbsp;</div></li><li><div>                $v_found = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by ereg rule&nbsp;</div></li><li><div>    // ereg() is deprecated with PHP 5.3&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>    else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))&nbsp;</div></li><li><div>             && ($p_options[PCLZIP_OPT_BY_EREG] != &quot;&quot;)) {&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {&nbsp;</div></li><li><div>            $v_found = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by preg rule&nbsp;</div></li><li><div>    else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))&nbsp;</div></li><li><div>             && ($p_options[PCLZIP_OPT_BY_PREG] != &quot;&quot;)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {&nbsp;</div></li><li><div>            $v_found = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for extract by index rule&nbsp;</div></li><li><div>    else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))&nbsp;</div></li><li><div>             && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----- Look if the index is in the list&nbsp;</div></li><li><div>        for ($j=$j_start; ($j&lt;sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (($i&gt;=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i&lt;=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {&nbsp;</div></li><li><div>                $v_found = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($i&gt;=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {&nbsp;</div></li><li><div>                $j_start = $j+1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']&gt;$i) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    else {&nbsp;</div></li><li><div>        $v_found = true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Look for deletion&nbsp;</div></li><li><div>    if ($v_found)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      unset($v_header_list[$v_nb_extracted]);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    else&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      $v_nb_extracted++;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if something need to be deleted&nbsp;</div></li><li><div>  if ($v_nb_extracted &gt; 0) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Creates a temporay file&nbsp;</div></li><li><div>      $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Creates a temporary zip archive&nbsp;</div></li><li><div>      $v_temp_zip = new PclZip($v_zip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Open the temporary zip file in write mode&nbsp;</div></li><li><div>      if (($v_result = $v_temp_zip-&gt;privOpenFd('wb')) != 1) {&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Look which file need to be kept&nbsp;</div></li><li><div>      for ($i=0; $i&lt;sizeof($v_header_list); $i++) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Calculate the position of the header&nbsp;</div></li><li><div>          @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>          if (@fseek($this-&gt;zip_fd, $v_header_list[$i]['offset'])) {&nbsp;</div></li><li><div>              // ----- Close the zip file&nbsp;</div></li><li><div>              $this-&gt;privCloseFd();&nbsp;</div></li><li><div>              $v_temp_zip-&gt;privCloseFd();&nbsp;</div></li><li><div>              @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              // ----- Error log&nbsp;</div></li><li><div>              PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              // ----- Return&nbsp;</div></li><li><div>              return PclZip::errorCode();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Read the file header&nbsp;</div></li><li><div>          $v_local_header = array();&nbsp;</div></li><li><div>          if (($v_result = $this-&gt;privReadFileHeader($v_local_header)) != 1) {&nbsp;</div></li><li><div>              // ----- Close the zip file&nbsp;</div></li><li><div>              $this-&gt;privCloseFd();&nbsp;</div></li><li><div>              $v_temp_zip-&gt;privCloseFd();&nbsp;</div></li><li><div>              @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              // ----- Return&nbsp;</div></li><li><div>              return $v_result;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Check that local file header is same as central file header&nbsp;</div></li><li><div>          if ($this-&gt;privCheckFileHeaders($v_local_header, &nbsp;</div></li><li><div>                                          $v_header_list[$i]) != 1) {&nbsp;</div></li><li><div>              // TBC&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          unset($v_local_header);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Write the file header&nbsp;</div></li><li><div>          if (($v_result = $v_temp_zip-&gt;privWriteFileHeader($v_header_list[$i])) != 1) {&nbsp;</div></li><li><div>              // ----- Close the zip file&nbsp;</div></li><li><div>              $this-&gt;privCloseFd();&nbsp;</div></li><li><div>              $v_temp_zip-&gt;privCloseFd();&nbsp;</div></li><li><div>              @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              // ----- Return&nbsp;</div></li><li><div>              return $v_result;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Read/write the data block&nbsp;</div></li><li><div>          if (($v_result = PclZipUtilCopyBlock($this-&gt;zip_fd, $v_temp_zip-&gt;zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {&nbsp;</div></li><li><div>              // ----- Close the zip file&nbsp;</div></li><li><div>              $this-&gt;privCloseFd();&nbsp;</div></li><li><div>              $v_temp_zip-&gt;privCloseFd();&nbsp;</div></li><li><div>              @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              // ----- Return&nbsp;</div></li><li><div>              return $v_result;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Store the offset of the central dir&nbsp;</div></li><li><div>      $v_offset = @ftell($v_temp_zip-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Re-Create the Central Dir files header&nbsp;</div></li><li><div>      for ($i=0; $i&lt;sizeof($v_header_list); $i++) {&nbsp;</div></li><li><div>          // ----- Create the file header&nbsp;</div></li><li><div>          if (($v_result = $v_temp_zip-&gt;privWriteCentralFileHeader($v_header_list[$i])) != 1) {&nbsp;</div></li><li><div>              $v_temp_zip-&gt;privCloseFd();&nbsp;</div></li><li><div>              $this-&gt;privCloseFd();&nbsp;</div></li><li><div>              @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              // ----- Return&nbsp;</div></li><li><div>              return $v_result;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Transform the header to a 'usable' info&nbsp;</div></li><li><div>          $v_temp_zip-&gt;privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Zip file comment&nbsp;</div></li><li><div>      $v_comment = '';&nbsp;</div></li><li><div>      if (isset($p_options[PCLZIP_OPT_COMMENT])) {&nbsp;</div></li><li><div>        $v_comment = $p_options[PCLZIP_OPT_COMMENT];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Calculate the size of the central header&nbsp;</div></li><li><div>      $v_size = @ftell($v_temp_zip-&gt;zip_fd)-$v_offset;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Create the central dir footer&nbsp;</div></li><li><div>      if (($v_result = $v_temp_zip-&gt;privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {&nbsp;</div></li><li><div>          // ----- Reset the file list&nbsp;</div></li><li><div>          unset($v_header_list);&nbsp;</div></li><li><div>          $v_temp_zip-&gt;privCloseFd();&nbsp;</div></li><li><div>          $this-&gt;privCloseFd();&nbsp;</div></li><li><div>          @unlink($v_zip_temp_name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          // ----- Return&nbsp;</div></li><li><div>          return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Close&nbsp;</div></li><li><div>      $v_temp_zip-&gt;privCloseFd();&nbsp;</div></li><li><div>      $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Delete the zip file&nbsp;</div></li><li><div>      // TBC : I should test the result ...&nbsp;</div></li><li><div>      @unlink($this-&gt;zipname);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Rename the temporary file&nbsp;</div></li><li><div>      // TBC : I should test the result ...&nbsp;</div></li><li><div>      //@rename($v_zip_temp_name, $this-&gt;zipname);&nbsp;</div></li><li><div>      PclZipUtilRename($v_zip_temp_name, $this-&gt;zipname);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      // ----- Destroy the temporary archive&nbsp;</div></li><li><div>      unset($v_temp_zip);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Remove every files : reset the file&nbsp;</div></li><li><div>  else if ($v_central_dir['entries'] != 0) {&nbsp;</div></li><li><div>      $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privOpenFd('wb')) != 1) {&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privWriteCentralHeader(0, 0, 0, '')) != 1) {&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;privCloseFd();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privDirCheck()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   Check if a directory exists, if not it creates it and all the parents directory&nbsp;</div></li><li><div>//   which may be useful.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>//   $p_dir : Directory path to check.&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>//    1 : OK&nbsp;</div></li><li><div>//   -1 : Unable to create directory&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privDirCheck($p_dir, $p_is_dir=false)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Remove the final '/'&nbsp;</div></li><li><div>  if (($p_is_dir) && (substr($p_dir, -1)=='/'))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $p_dir = substr($p_dir, 0, strlen($p_dir)-1);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Check the directory availability&nbsp;</div></li><li><div>  if ((is_dir($p_dir)) || ($p_dir == &quot;&quot;))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    return 1;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Extract parent directory&nbsp;</div></li><li><div>  $p_parent_dir = dirname($p_dir);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Just a check&nbsp;</div></li><li><div>  if ($p_parent_dir != $p_dir)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Look for parent directory&nbsp;</div></li><li><div>    if ($p_parent_dir != &quot;&quot;)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>      if (($v_result = $this-&gt;privDirCheck($p_parent_dir)) != 1)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>        return $v_result;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Create the directory&nbsp;</div></li><li><div>  if (!@mkdir($p_dir, 0777))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Error log&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, &quot;Unable to create directory '$p_dir'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privMerge()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>//   If $p_archive_to_add does not exist, the function exit with a success result.&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privMerge(&$p_archive_to_add)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the archive_to_add exists&nbsp;</div></li><li><div>  if (!is_file($p_archive_to_add-&gt;zipname))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Nothing to merge, so merge is a success&nbsp;</div></li><li><div>    $v_result = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the archive exists&nbsp;</div></li><li><div>  if (!is_file($this-&gt;zipname))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Do a duplicate&nbsp;</div></li><li><div>    $v_result = $this-&gt;privDuplicate($p_archive_to_add-&gt;zipname);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the zip file&nbsp;</div></li><li><div>  if (($v_result=$this-&gt;privOpenFd('rb')) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the central directory informations&nbsp;</div></li><li><div>  $v_central_dir = array();&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Go to beginning of File&nbsp;</div></li><li><div>  @rewind($this-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the archive_to_add file&nbsp;</div></li><li><div>  if (($v_result=$p_archive_to_add-&gt;privOpenFd('rb')) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Read the central directory informations&nbsp;</div></li><li><div>  $v_central_dir_to_add = array();&nbsp;</div></li><li><div>  if (($v_result = $p_archive_to_add-&gt;privReadEndCentralDir($v_central_dir_to_add)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    $p_archive_to_add-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Go to beginning of File&nbsp;</div></li><li><div>  @rewind($p_archive_to_add-&gt;zip_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Creates a temporay file&nbsp;</div></li><li><div>  $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the temporary file in write mode&nbsp;</div></li><li><div>  if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    $p_archive_to_add-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Copy the files from the archive to the temporary file&nbsp;</div></li><li><div>  // TBC : Here I should better append the file and go back to erase the central dir&nbsp;</div></li><li><div>  $v_size = $v_central_dir['offset'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = fread($this-&gt;zip_fd, $v_read_size);&nbsp;</div></li><li><div>    @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Copy the files from the archive_to_add into the temporary file&nbsp;</div></li><li><div>  $v_size = $v_central_dir_to_add['offset'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = fread($p_archive_to_add-&gt;zip_fd, $v_read_size);&nbsp;</div></li><li><div>    @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Store the offset of the central dir&nbsp;</div></li><li><div>  $v_offset = @ftell($v_zip_temp_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Copy the block of file headers from the old archive&nbsp;</div></li><li><div>  $v_size = $v_central_dir['size'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = @fread($this-&gt;zip_fd, $v_read_size);&nbsp;</div></li><li><div>    @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Copy the block of file headers from the archive_to_add&nbsp;</div></li><li><div>  $v_size = $v_central_dir_to_add['size'];&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = @fread($p_archive_to_add-&gt;zip_fd, $v_read_size);&nbsp;</div></li><li><div>    @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Merge the file comments&nbsp;</div></li><li><div>  $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Calculate the size of the (new) central header&nbsp;</div></li><li><div>  $v_size = @ftell($v_zip_temp_fd)-$v_offset;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Swap the file descriptor&nbsp;</div></li><li><div>  // Here is a trick : I swap the temporary fd with the zip fd, in order to use&nbsp;</div></li><li><div>  // the following methods on the temporary fil and not the real archive fd&nbsp;</div></li><li><div>  $v_swap = $this-&gt;zip_fd;&nbsp;</div></li><li><div>  $this-&gt;zip_fd = $v_zip_temp_fd;&nbsp;</div></li><li><div>  $v_zip_temp_fd = $v_swap;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Create the central dir footer&nbsp;</div></li><li><div>  if (($v_result = $this-&gt;privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>    $p_archive_to_add-&gt;privCloseFd();&nbsp;</div></li><li><div>    @fclose($v_zip_temp_fd);&nbsp;</div></li><li><div>    $this-&gt;zip_fd = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Reset the file list&nbsp;</div></li><li><div>    unset($v_header_list);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Swap back the file descriptor&nbsp;</div></li><li><div>  $v_swap = $this-&gt;zip_fd;&nbsp;</div></li><li><div>  $this-&gt;zip_fd = $v_zip_temp_fd;&nbsp;</div></li><li><div>  $v_zip_temp_fd = $v_swap;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close&nbsp;</div></li><li><div>  $this-&gt;privCloseFd();&nbsp;</div></li><li><div>  $p_archive_to_add-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the temporary file&nbsp;</div></li><li><div>  @fclose($v_zip_temp_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Delete the zip file&nbsp;</div></li><li><div>  // TBC : I should test the result ...&nbsp;</div></li><li><div>  @unlink($this-&gt;zipname);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Rename the temporary file&nbsp;</div></li><li><div>  // TBC : I should test the result ...&nbsp;</div></li><li><div>  //@rename($v_zip_temp_name, $this-&gt;zipname);&nbsp;</div></li><li><div>  PclZipUtilRename($v_zip_temp_name, $this-&gt;zipname);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privDuplicate()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privDuplicate($p_archive_filename)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if the $p_archive_filename exists&nbsp;</div></li><li><div>  if (!is_file($p_archive_filename))&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Nothing to duplicate, so duplicate is a success.&nbsp;</div></li><li><div>    $v_result = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the zip file&nbsp;</div></li><li><div>  if (($v_result=$this-&gt;privOpenFd('wb')) != 1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Open the temporary file in write mode&nbsp;</div></li><li><div>  if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \''.$p_archive_filename.'\' in binary write mode');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ----- Return&nbsp;</div></li><li><div>    return PclZip::errorCode();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Copy the files from the archive to the temporary file&nbsp;</div></li><li><div>  // TBC : Here I should better append the file and go back to erase the central dir&nbsp;</div></li><li><div>  $v_size = filesize($p_archive_filename);&nbsp;</div></li><li><div>  while ($v_size != 0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>    $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);&nbsp;</div></li><li><div>    $v_buffer = fread($v_zip_temp_fd, $v_read_size);&nbsp;</div></li><li><div>    @fwrite($this-&gt;zip_fd, $v_buffer, $v_read_size);&nbsp;</div></li><li><div>    $v_size -= $v_read_size;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close&nbsp;</div></li><li><div>  $this-&gt;privCloseFd();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Close the temporary file&nbsp;</div></li><li><div>  @fclose($v_zip_temp_fd);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privErrorLog()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privErrorLog($p_error_code=0, $p_error_string='')&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  if (PCLZIP_ERROR_EXTERNAL == 1) {&nbsp;</div></li><li><div>    PclError($p_error_code, $p_error_string);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $this-&gt;error_code = $p_error_code;&nbsp;</div></li><li><div>    $this-&gt;error_string = $p_error_string;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privErrorReset()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privErrorReset()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  if (PCLZIP_ERROR_EXTERNAL == 1) {&nbsp;</div></li><li><div>    PclErrorReset();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>    $this-&gt;error_code = 0;&nbsp;</div></li><li><div>    $this-&gt;error_string = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privDisableMagicQuotes()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privDisableMagicQuotes()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if function exists&nbsp;</div></li><li><div>  if (   (!function_exists(&quot;get_magic_quotes_runtime&quot;))&nbsp;</div></li><li><div>      || (!function_exists(&quot;set_magic_quotes_runtime&quot;))) {&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if already done&nbsp;</div></li><li><div>  if ($this-&gt;magic_quotes_status != -1) {&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Get and memorize the magic_quote value&nbsp;</div></li><li><div>  $this-&gt;magic_quotes_status = @get_magic_quotes_runtime();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Disable magic_quotes&nbsp;</div></li><li><div>  if ($this-&gt;magic_quotes_status == 1) {&nbsp;</div></li><li><div>    @set_magic_quotes_runtime(0);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>// Function : privSwapBackMagicQuotes()&nbsp;</div></li><li><div>// Description :&nbsp;</div></li><li><div>// Parameters :&nbsp;</div></li><li><div>// Return Values :&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>function privSwapBackMagicQuotes()&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $v_result=1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if function exists&nbsp;</div></li><li><div>  if (   (!function_exists(&quot;get_magic_quotes_runtime&quot;))&nbsp;</div></li><li><div>      || (!function_exists(&quot;set_magic_quotes_runtime&quot;))) {&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Look if something to do&nbsp;</div></li><li><div>  if ($this-&gt;magic_quotes_status != -1) {&nbsp;</div></li><li><div>    return $v_result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Swap back magic_quotes&nbsp;</div></li><li><div>  if ($this-&gt;magic_quotes_status == 1) {&nbsp;</div></li><li><div>      @set_magic_quotes_runtime($this-&gt;magic_quotes_status);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  // ----- Return&nbsp;</div></li><li><div>  return $v_result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>// --------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 4.7</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/4.7.4/classes/pcl_zip/" class="">4.7.4</a></li><li><a href="http://hookr.io/4.7.3/classes/pcl_zip/" class="">4.7.3</a></li><li><a href="http://hookr.io/4.7.2/classes/pcl_zip/" class="">4.7.2</a></li><li><a href="http://hookr.io/4.7.1/classes/pcl_zip/" class="">4.7.1</a></li><li><a href="http://hookr.io/4.7/classes/pcl_zip/" class="active">4.7</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>class</li><li><span></span>PclZip</li><li><span></span>wp-admin</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2017 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer> <script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>