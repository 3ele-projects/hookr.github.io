<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="wordpress" data-version="4.7.2" data-type="file" data-id="4753"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp-includes-date | file | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, wordpress, 4.7.2" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.10"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=bd9c53c5b63eb725ef0d0d38ac244b6e' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.10' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/wp-includes-date/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-date%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-date%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.2-file-wp-includes-date","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp-includes-date" class="blog single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.2." href="http://hookr.io/4.7.2/" class="H_VERSION"><span property="name">4.7.2</span></a><meta property="position" content="2"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp-includes-date</span><meta property="position" content="3"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="6308"><a href="http://hookr.io/4.7.2/all/" title="All">All <span class="count badge">6308</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/4.7.2/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="2531"><a href="http://hookr.io/4.7.2/hooks/" title="Hooks">Hooks <span class="count badge">2531</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.2/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1667"><a href="http://hookr.io/4.7.2/filters/" title="Filters">Filters <span class="count badge">1667</span></a></li><li class="" data-id="class" data-count="351"><a href="http://hookr.io/4.7.2/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.2/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2852"><a href="http://hookr.io/4.7.2/functions/" title="Functions">Functions <span class="count badge">2852</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.2/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/wp-includes/date.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Class for generating SQL clauses that filter a primary query according to date.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * WP_Date_Query is a helper that allows primary query classes, such as WP_Query, to filter</span>&nbsp;</div></li><li><div><span class="comment"> * their results by date columns, by generating `WHERE` subclauses to be attached to the</span>&nbsp;</div></li><li><div><span class="comment"> * primary SQL query string.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Attempting to filter by an invalid date value (eg month=13) will generate SQL that will</span>&nbsp;</div></li><li><div><span class="comment"> * return no results. In these cases, a _doing_it_wrong() error notice is also thrown.</span>&nbsp;</div></li><li><div><span class="comment"> * See WP_Date_Query::validate_date_values().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @link https://codex.wordpress.org/Function_Reference/WP_Query Codex page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>class WP_Date_Query {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Array of date queries.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * See WP_Date_Query::__construct() for information on date query arguments.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $queries = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The default relation between top-level queries. Can be either 'AND' or 'OR'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $relation = 'AND';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The column to query against. Can be changed via the query arguments.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $column = 'post_date';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The value comparison operator. Can be changed via the query arguments.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $compare = '=';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Supported time-related parameter keys.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $time_keys = array( 'after', 'before', 'year', 'month', 'monthnum', 'week', 'w', 'dayofyear', 'day', 'dayofweek', 'dayofweek_iso', 'hour', 'minute', 'second' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Constructor.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Time-related parameters that normally require integer values ('year', 'month', 'week', 'dayofyear', 'day', </span>&nbsp;</div></li><li><div><span class="comment">   * 'dayofweek', 'dayofweek_iso', 'hour', 'minute', 'second') accept arrays of integers for some values of</span>&nbsp;</div></li><li><div><span class="comment">   * 'compare'. When 'compare' is 'IN' or 'NOT IN', arrays are accepted; when 'compare' is 'BETWEEN' or 'NOT</span>&nbsp;</div></li><li><div><span class="comment">   * BETWEEN', arrays of two valid values are required. See individual argument descriptions for accepted values.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.0.0 The $inclusive logic was updated to include all times within the date range.</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0 Introduced 'dayofweek_iso' time type parameter.</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $date_query {</span>&nbsp;</div></li><li><div><span class="comment">   *     Array of date query clauses.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type array {</span>&nbsp;</div></li><li><div><span class="comment">   *         @type string $column   Optional. The column to query against. If undefined, inherits the value of</span>&nbsp;</div></li><li><div><span class="comment">   *                                the `$default_column` parameter. Accepts 'post_date', 'post_date_gmt', </span>&nbsp;</div></li><li><div><span class="comment">   *                                'post_modified', 'post_modified_gmt', 'comment_date', 'comment_date_gmt'.</span>&nbsp;</div></li><li><div><span class="comment">   *                                Default 'post_date'.</span>&nbsp;</div></li><li><div><span class="comment">   *         @type string $compare  Optional. The comparison operator. Accepts '=', '!=', '&gt;', '&gt;=', '&lt;', '&lt;=', </span>&nbsp;</div></li><li><div><span class="comment">   *                                'IN', 'NOT IN', 'BETWEEN', 'NOT BETWEEN'. Default '='.</span>&nbsp;</div></li><li><div><span class="comment">   *         @type string $relation Optional. The boolean relationship between the date queries. Accepts 'OR' or 'AND'.</span>&nbsp;</div></li><li><div><span class="comment">   *                                Default 'OR'.</span>&nbsp;</div></li><li><div><span class="comment">   *         @type array {</span>&nbsp;</div></li><li><div><span class="comment">   *             Optional. An array of first-order clause parameters, or another fully-formed date query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *             @type string|array $before {</span>&nbsp;</div></li><li><div><span class="comment">   *                 Optional. Date to retrieve posts before. Accepts `strtotime()`-compatible string, </span>&nbsp;</div></li><li><div><span class="comment">   *                 or array of 'year', 'month', 'day' values.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *                 @type string $year  The four-digit year. Default empty. Accepts any four-digit year.</span>&nbsp;</div></li><li><div><span class="comment">   *                 @type string $month Optional when passing array.The month of the year.</span>&nbsp;</div></li><li><div><span class="comment">   *                                     Default (string:empty)|(array:1). Accepts numbers 1-12.</span>&nbsp;</div></li><li><div><span class="comment">   *                 @type string $day   Optional when passing array.The day of the month.</span>&nbsp;</div></li><li><div><span class="comment">   *                                     Default (string:empty)|(array:1). Accepts numbers 1-31.</span>&nbsp;</div></li><li><div><span class="comment">   *             }</span>&nbsp;</div></li><li><div><span class="comment">   *             @type string|array $after {</span>&nbsp;</div></li><li><div><span class="comment">   *                 Optional. Date to retrieve posts after. Accepts `strtotime()`-compatible string, </span>&nbsp;</div></li><li><div><span class="comment">   *                 or array of 'year', 'month', 'day' values.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *                 @type string $year  The four-digit year. Accepts any four-digit year. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *                 @type string $month Optional when passing array. The month of the year. Accepts numbers 1-12.</span>&nbsp;</div></li><li><div><span class="comment">   *                                     Default (string:empty)|(array:12).</span>&nbsp;</div></li><li><div><span class="comment">   *                 @type string $day   Optional when passing array.The day of the month. Accepts numbers 1-31.</span>&nbsp;</div></li><li><div><span class="comment">   *                                     Default (string:empty)|(array:last day of month).</span>&nbsp;</div></li><li><div><span class="comment">   *             }</span>&nbsp;</div></li><li><div><span class="comment">   *             @type string       $column        Optional. Used to add a clause comparing a column other than the</span>&nbsp;</div></li><li><div><span class="comment">   *                                               column specified in the top-level `$column` parameter. Accepts</span>&nbsp;</div></li><li><div><span class="comment">   *                                               'post_date', 'post_date_gmt', 'post_modified', 'post_modified_gmt', </span>&nbsp;</div></li><li><div><span class="comment">   *                                               'comment_date', 'comment_date_gmt'. Default is the value of</span>&nbsp;</div></li><li><div><span class="comment">   *                                               top-level `$column`.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type string       $compare       Optional. The comparison operator. Accepts '=', '!=', '&gt;', '&gt;=', </span>&nbsp;</div></li><li><div><span class="comment">   *                                               '&lt;', '&lt;=', 'IN', 'NOT IN', 'BETWEEN', 'NOT BETWEEN'. 'IN', </span>&nbsp;</div></li><li><div><span class="comment">   *                                               'NOT IN', 'BETWEEN', and 'NOT BETWEEN'. Comparisons support</span>&nbsp;</div></li><li><div><span class="comment">   *                                               arrays in some time-related parameters. Default '='.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type bool         $inclusive     Optional. Include results from dates specified in 'before' or</span>&nbsp;</div></li><li><div><span class="comment">   *                                               'after'. Default false.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $year          Optional. The four-digit year number. Accepts any four-digit year</span>&nbsp;</div></li><li><div><span class="comment">   *                                               or an array of years if `$compare` supports it. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $month         Optional. The two-digit month number. Accepts numbers 1-12 or an</span>&nbsp;</div></li><li><div><span class="comment">   *                                               array of valid numbers if `$compare` supports it. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $week          Optional. The week number of the year. Accepts numbers 0-53 or an</span>&nbsp;</div></li><li><div><span class="comment">   *                                               array of valid numbers if `$compare` supports it. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $dayofyear     Optional. The day number of the year. Accepts numbers 1-366 or an</span>&nbsp;</div></li><li><div><span class="comment">   *                                               array of valid numbers if `$compare` supports it.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $day           Optional. The day of the month. Accepts numbers 1-31 or an array</span>&nbsp;</div></li><li><div><span class="comment">   *                                               of valid numbers if `$compare` supports it. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $dayofweek     Optional. The day number of the week. Accepts numbers 1-7 (1 is</span>&nbsp;</div></li><li><div><span class="comment">   *                                               Sunday) or an array of valid numbers if `$compare` supports it.</span>&nbsp;</div></li><li><div><span class="comment">   *                                               Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $dayofweek_iso Optional. The day number of the week (ISO). Accepts numbers 1-7</span>&nbsp;</div></li><li><div><span class="comment">   *                                               (1 is Monday) or an array of valid numbers if `$compare` supports it.</span>&nbsp;</div></li><li><div><span class="comment">   *                                               Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $hour          Optional. The hour of the day. Accepts numbers 0-23 or an array</span>&nbsp;</div></li><li><div><span class="comment">   *                                               of valid numbers if `$compare` supports it. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $minute        Optional. The minute of the hour. Accepts numbers 0-60 or an array</span>&nbsp;</div></li><li><div><span class="comment">   *                                               of valid numbers if `$compare` supports it. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *             @type int|array    $second        Optional. The second of the minute. Accepts numbers 0-60 or an</span>&nbsp;</div></li><li><div><span class="comment">   *                                               array of valid numbers if `$compare` supports it. Default empty.</span>&nbsp;</div></li><li><div><span class="comment">   *         }</span>&nbsp;</div></li><li><div><span class="comment">   *     }</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $default_column Optional. Default column to query against. Default 'post_date'.</span>&nbsp;</div></li><li><div><span class="comment">   *                              Accepts 'post_date', 'post_date_gmt', 'post_modified', 'post_modified_gmt', </span>&nbsp;</div></li><li><div><span class="comment">   *                              'comment_date', 'comment_date_gmt'.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function __construct( $date_query, $default_column = 'post_date' ) {&nbsp;</div></li><li><div>      if ( isset( $date_query['relation'] ) && 'OR' === strtoupper( $date_query['relation'] ) ) {&nbsp;</div></li><li><div>          $this-&gt;relation = 'OR';&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $this-&gt;relation = 'AND';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! is_array( $date_query ) ) {&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Support for passing time-based keys in the top level of the $date_query array.</span>&nbsp;</div></li><li><div>      if ( ! isset( $date_query[0] ) && ! empty( $date_query ) ) {&nbsp;</div></li><li><div>          $date_query = array( $date_query );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty( $date_query ) ) {&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty( $date_query['column'] ) ) {&nbsp;</div></li><li><div>          $date_query['column'] = esc_sql( $date_query['column'] );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $date_query['column'] = esc_sql( $default_column );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;column = $this-&gt;validate_column( $this-&gt;column );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;compare = $this-&gt;get_compare( $date_query );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;queries = $this-&gt;sanitize_query( $date_query );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Recursive-friendly query sanitizer.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Ensures that each query-level clause has a 'relation' key, and that</span>&nbsp;</div></li><li><div><span class="comment">   * each first-order clause contains all the necessary keys from</span>&nbsp;</div></li><li><div><span class="comment">   * `$defaults`.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $queries</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $parent_query</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Sanitized queries.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function sanitize_query( $queries, $parent_query = null ) {&nbsp;</div></li><li><div>      $cleaned_query = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array(&nbsp;</div></li><li><div>          'column' =&gt; 'post_date', &nbsp;</div></li><li><div>          'compare' =&gt; '=', &nbsp;</div></li><li><div>          'relation' =&gt; 'AND', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Numeric keys should always have array values.</span>&nbsp;</div></li><li><div>      foreach ( $queries as $qkey =&gt; $qvalue ) {&nbsp;</div></li><li><div>          if ( is_numeric( $qkey ) && ! is_array( $qvalue ) ) {&nbsp;</div></li><li><div>              unset( $queries[ $qkey ] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Each query should have a value for each default key. Inherit from the parent when possible.</span>&nbsp;</div></li><li><div>      foreach ( $defaults as $dkey =&gt; $dvalue ) {&nbsp;</div></li><li><div>          if ( isset( $queries[ $dkey ] ) ) {&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( isset( $parent_query[ $dkey ] ) ) {&nbsp;</div></li><li><div>              $queries[ $dkey ] = $parent_query[ $dkey ];&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $queries[ $dkey ] = $dvalue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Validate the dates passed in the query.</span>&nbsp;</div></li><li><div>      if ( $this-&gt;is_first_order_clause( $queries ) ) {&nbsp;</div></li><li><div>          $this-&gt;validate_date_values( $queries );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $queries as $key =&gt; $q ) {&nbsp;</div></li><li><div>          if ( ! is_array( $q ) || in_array( $key, $this-&gt;time_keys, true ) ) {&nbsp;</div></li><li><div>              <span class="comment">// This is a first-order query. Trust the values and sanitize when building SQL.</span>&nbsp;</div></li><li><div>              $cleaned_query[ $key ] = $q;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              <span class="comment">// Any array without a time key is another query, so we recurse.</span>&nbsp;</div></li><li><div>              $cleaned_query[] = $this-&gt;sanitize_query( $q, $queries );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $cleaned_query;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Determine whether this is a first-order clause.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Checks to see if the current clause has any time-related keys.</span>&nbsp;</div></li><li><div><span class="comment">   * If so, it's first-order.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param  array $query Query clause.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool True if this is a first-order clause.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  protected function is_first_order_clause( $query ) {&nbsp;</div></li><li><div>      $time_keys = array_intersect( $this-&gt;time_keys, array_keys( $query ) );&nbsp;</div></li><li><div>      return ! empty( $time_keys );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Determines and validates what comparison operator to use.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $query A date query or a date subquery.</span>&nbsp;</div></li><li><div><span class="comment">   * @return string The comparison operator.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_compare( $query ) {&nbsp;</div></li><li><div>      if ( ! empty( $query['compare'] ) && in_array( $query['compare'], array( '=', '!=', '&gt;', '&gt;=', '&lt;', '&lt;=', 'IN', 'NOT IN', 'BETWEEN', 'NOT BETWEEN' ) ) )&nbsp;</div></li><li><div>          return strtoupper( $query['compare'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;compare;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Validates the given date_query values and triggers errors if something is not valid.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Note that date queries with invalid date ranges are allowed to</span>&nbsp;</div></li><li><div><span class="comment">   * continue (though of course no items will be found for impossible dates).</span>&nbsp;</div></li><li><div><span class="comment">   * This method only generates debug notices for these cases.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since  4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param  array $date_query The date_query array.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool  True if all values in the query are valid, false if one or more fail.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function validate_date_values( $date_query = array() ) {&nbsp;</div></li><li><div>      if ( empty( $date_query ) ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $valid = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Validate 'before' and 'after' up front, then let the</span>&nbsp;</div></li><li><div><span class="comment">       * validation routine continue to be sure that all invalid</span>&nbsp;</div></li><li><div><span class="comment">       * values generate errors too.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( array_key_exists( 'before', $date_query ) && is_array( $date_query['before'] ) ) {&nbsp;</div></li><li><div>          $valid = $this-&gt;validate_date_values( $date_query['before'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( array_key_exists( 'after', $date_query ) && is_array( $date_query['after'] ) ) {&nbsp;</div></li><li><div>          $valid = $this-&gt;validate_date_values( $date_query['after'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Array containing all min-max checks.</span>&nbsp;</div></li><li><div>      $min_max_checks = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Days per year.</span>&nbsp;</div></li><li><div>      if ( array_key_exists( 'year', $date_query ) ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * If a year exists in the date query, we can use it to get the days.</span>&nbsp;</div></li><li><div><span class="comment">           * If multiple years are provided (as in a BETWEEN), use the first one.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          if ( is_array( $date_query['year'] ) ) {&nbsp;</div></li><li><div>              $_year = reset( $date_query['year'] );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $_year = $date_query['year'];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $max_days_of_year = date( 'z', mktime( 0, 0, 0, 12, 31, $_year ) ) + 1;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment">// otherwise we use the max of 366 (leap-year)</span>&nbsp;</div></li><li><div>          $max_days_of_year = 366;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $min_max_checks['dayofyear'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 1, &nbsp;</div></li><li><div>          'max' =&gt; $max_days_of_year&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// Days per week.</span></span>&nbsp;</div></li><li><div>      $min_max_checks['dayofweek'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 1, &nbsp;</div></li><li><div>          'max' =&gt; 7&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// Days per week.</span></span>&nbsp;</div></li><li><div>      $min_max_checks['dayofweek_iso'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 1, &nbsp;</div></li><li><div>          'max' =&gt; 7&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Months per year.</span>&nbsp;</div></li><li><div>      $min_max_checks['month'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 1, &nbsp;</div></li><li><div>          'max' =&gt; 12&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Weeks per year.</span>&nbsp;</div></li><li><div>      if ( isset( $_year ) ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * If we have a specific year, use it to calculate number of weeks.</span>&nbsp;</div></li><li><div><span class="comment">           * Note: the number of weeks in a year is the date in which Dec 28 appears.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $week_count = date( 'W', mktime( 0, 0, 0, 12, 28, $_year ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment">// Otherwise set the week-count to a maximum of 53.</span>&nbsp;</div></li><li><div>          $week_count = 53;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $min_max_checks['week'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 1, &nbsp;</div></li><li><div>          'max' =&gt; $week_count&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Days per month.</span>&nbsp;</div></li><li><div>      $min_max_checks['day'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 1, &nbsp;</div></li><li><div>          'max' =&gt; 31&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// Hour</span>s per day.</span>&nbsp;</div></li><li><div>      $min_max_checks['hour'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 0, &nbsp;</div></li><li><div>          'max' =&gt; 23&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// Minute</span>s per hour.</span>&nbsp;</div></li><li><div>      $min_max_checks['minute'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 0, &nbsp;</div></li><li><div>          'max' =&gt; 59&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Seconds per minute.</span>&nbsp;</div></li><li><div>      $min_max_checks['second'] = array(&nbsp;</div></li><li><div>          'min' =&gt; 0, &nbsp;</div></li><li><div>          'max' =&gt; 59&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Concatenate and throw a notice for each invalid value.</span>&nbsp;</div></li><li><div>      foreach ( $min_max_checks as $key =&gt; $check ) {&nbsp;</div></li><li><div>          if ( ! array_key_exists( $key, $date_query ) ) {&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Throw a notice for each failing value.</span>&nbsp;</div></li><li><div>          foreach ( (array) $date_query[ $key ] as $_value ) {&nbsp;</div></li><li><div>              $is_between = $_value &gt;= $check['min'] && $_value &lt;= $check['max'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( ! is_numeric( $_value ) || ! $is_between ) {&nbsp;</div></li><li><div>                  $error = sprintf(&nbsp;</div></li><li><div>                      <span class="comment">/** translators: Date query invalid date message: 1: invalid value, 2: type of value, 3: minimum valid value, 4: maximum valid value */</span>&nbsp;</div></li><li><div>                      __( 'Invalid value %1$s for %2$s. Expected value should be between %3$s and %4$s.' ), &nbsp;</div></li><li><div>                      '&lt;code&gt;' . esc_html( $_value ) . '&lt;/code&gt;', &nbsp;</div></li><li><div>                      '&lt;code&gt;' . esc_html( $key ) . '&lt;/code&gt;', &nbsp;</div></li><li><div>                      '&lt;code&gt;' . esc_html( $check['min'] ) . '&lt;/code&gt;', &nbsp;</div></li><li><div>                      '&lt;code&gt;' . esc_html( $check['max'] ) . '&lt;/code&gt;'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  _doing_it_wrong( __CLASS__, $error, '4.1.0' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  $valid = false;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If we already have invalid date messages, don't bother running through checkdate().</span>&nbsp;</div></li><li><div>      if ( ! $valid ) {&nbsp;</div></li><li><div>          return $valid;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $day_month_year_error_msg = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $day_exists = array_key_exists( 'day', $date_query ) && is_numeric( $date_query['day'] );&nbsp;</div></li><li><div>      $month_exists = array_key_exists( 'month', $date_query ) && is_numeric( $date_query['month'] );&nbsp;</div></li><li><div>      $year_exists = array_key_exists( 'year', $date_query ) && is_numeric( $date_query['year'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $day_exists && $month_exists && $year_exists ) {&nbsp;</div></li><li><div>          <span class="comment">// 1. Checking day, month, year combination.</span>&nbsp;</div></li><li><div>          if ( ! wp_checkdate( $date_query['month'], $date_query['day'], $date_query['year'], sprintf( '%s-%s-%s', $date_query['year'], $date_query['month'], $date_query['day'] ) ) ) {&nbsp;</div></li><li><div>              <span class="comment">/** translators: 1: year, 2: month, 3: day of month */</span>&nbsp;</div></li><li><div>              $day_month_year_error_msg = sprintf(&nbsp;</div></li><li><div>                  __( 'The following values do not describe a valid date: year %1$s, month %2$s, day %3$s.' ), &nbsp;</div></li><li><div>                  '&lt;code&gt;' . esc_html( $date_query['year'] ) . '&lt;/code&gt;', &nbsp;</div></li><li><div>                  '&lt;code&gt;' . esc_html( $date_query['month'] ) . '&lt;/code&gt;', &nbsp;</div></li><li><div>                  '&lt;code&gt;' . esc_html( $date_query['day'] ) . '&lt;/code&gt;'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $valid = false;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      } elseif ( $day_exists && $month_exists ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * 2. checking day, month combination</span>&nbsp;</div></li><li><div><span class="comment">           * We use 2012 because, as a leap year, it's the most permissive.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          if ( ! wp_checkdate( $date_query['month'], $date_query['day'], 2012, sprintf( '2012-%s-%s', $date_query['month'], $date_query['day'] ) ) ) {&nbsp;</div></li><li><div>              <span class="comment">/** translators: 1: month, 2: day of month */</span>&nbsp;</div></li><li><div>              $day_month_year_error_msg = sprintf(&nbsp;</div></li><li><div>                  __( 'The following values do not describe a valid date: month %1$s, day %2$s.' ), &nbsp;</div></li><li><div>                  '&lt;code&gt;' . esc_html( $date_query['month'] ) . '&lt;/code&gt;', &nbsp;</div></li><li><div>                  '&lt;code&gt;' . esc_html( $date_query['day'] ) . '&lt;/code&gt;'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $valid = false;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty( $day_month_year_error_msg ) ) {&nbsp;</div></li><li><div>          _doing_it_wrong( __CLASS__, $day_month_year_error_msg, '4.1.0' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $valid;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Validates a column name parameter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Column names without a table prefix (like 'post_date') are checked against a whitelist of</span>&nbsp;</div></li><li><div><span class="comment">   * known tables, and then, if found, have a table prefix (such as 'wp_posts.') prepended.</span>&nbsp;</div></li><li><div><span class="comment">   * Prefixed column names (such as 'wp_posts.post_date') bypass this whitelist check, </span>&nbsp;</div></li><li><div><span class="comment">   * and are only sanitized to remove illegal characters.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $column The user-supplied column name.</span>&nbsp;</div></li><li><div><span class="comment">   * @return string A validated column name value.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function validate_column( $column ) {&nbsp;</div></li><li><div>      global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $valid_columns = array(&nbsp;</div></li><li><div>          'post_date', 'post_date_gmt', 'post_modified', &nbsp;</div></li><li><div>          'post_modified_gmt', 'comment_date', 'comment_date_gmt', &nbsp;</div></li><li><div>          'user_registered', 'registered', 'last_updated', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Attempt to detect a table prefix.</span>&nbsp;</div></li><li><div>      if ( false === strpos( $column, '.' ) ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the list of valid date query columns.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">           * @since 4.1.0 Added 'user_registered' to the default recognized columns.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param array $valid_columns An array of valid date query columns. Defaults</span>&nbsp;</div></li><li><div><span class="comment">           *                             are 'post_date', 'post_date_gmt', 'post_modified', </span>&nbsp;</div></li><li><div><span class="comment">           *                             'post_modified_gmt', 'comment_date', 'comment_date_gmt', </span>&nbsp;</div></li><li><div><span class="comment">           *                               'user_registered'</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          if ( ! in_array( $column, apply_filters( 'date_query_valid_columns', $valid_columns ) ) ) {&nbsp;</div></li><li><div>              $column = 'post_date';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $known_columns = array(&nbsp;</div></li><li><div>              $wpdb-&gt;posts =&gt; array(&nbsp;</div></li><li><div>                  'post_date', &nbsp;</div></li><li><div>                  'post_date_gmt', &nbsp;</div></li><li><div>                  'post_modified', &nbsp;</div></li><li><div>                  'post_modified_gmt', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>              $wpdb-&gt;comments =&gt; array(&nbsp;</div></li><li><div>                  'comment_date', &nbsp;</div></li><li><div>                  'comment_date_gmt', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>              $wpdb-&gt;users =&gt; array(&nbsp;</div></li><li><div>                  'user_registered', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>              $wpdb-&gt;blogs =&gt; array(&nbsp;</div></li><li><div>                  'registered', &nbsp;</div></li><li><div>                  'last_updated', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If it's a known column name, add the appropriate table prefix.</span>&nbsp;</div></li><li><div>          foreach ( $known_columns as $table_name =&gt; $table_columns ) {&nbsp;</div></li><li><div>              if ( in_array( $column, $table_columns ) ) {&nbsp;</div></li><li><div>                  $column = $table_name . '.' . $column;&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Remove unsafe characters.</span>&nbsp;</div></li><li><div>      return preg_replace( '/[^a-zA-Z0-9_$\.]/', '', $column );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Generate WHERE clause to be appended to a main query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string MySQL WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_sql() {&nbsp;</div></li><li><div>      $sql = $this-&gt;get_sql_clauses();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $where = $sql['where'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the date query WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string        $where WHERE clause of the date query.</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Date_Query $this  The WP_Date_Query instance.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'get_date_sql', $where, $this );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Generate SQL clauses to be appended to a main query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Called by the public WP_Date_Query::get_sql(), this method is abstracted</span>&nbsp;</div></li><li><div><span class="comment">   * out to maintain parity with the other Query classes.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access protected</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return array {</span>&nbsp;</div></li><li><div><span class="comment">   *     Array containing JOIN and WHERE SQL clauses to append to the main query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $join  SQL fragment to append to the main JOIN clause.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $where SQL fragment to append to the main WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  protected function get_sql_clauses() {&nbsp;</div></li><li><div>      $sql = $this-&gt;get_sql_for_query( $this-&gt;queries );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty( $sql['where'] ) ) {&nbsp;</div></li><li><div>          $sql['where'] = ' AND ' . $sql['where'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $sql;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Generate SQL clauses for a single query array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If nested subqueries are found, this method recurses the tree to</span>&nbsp;</div></li><li><div><span class="comment">   * produce the properly nested SQL.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access protected</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $query Query to parse.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $depth Optional. Number of tree levels deep we currently are.</span>&nbsp;</div></li><li><div><span class="comment">   *                     Used to calculate indentation. Default 0.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array {</span>&nbsp;</div></li><li><div><span class="comment">   *     Array containing JOIN and WHERE SQL clauses to append to a single query array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $join  SQL fragment to append to the main JOIN clause.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $where SQL fragment to append to the main WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  protected function get_sql_for_query( $query, $depth = 0 ) {&nbsp;</div></li><li><div>      $sql_chunks = array(&nbsp;</div></li><li><div>          'join' =&gt; array(), &nbsp;</div></li><li><div>          'where' =&gt; array(), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $sql = array(&nbsp;</div></li><li><div>          'join' =&gt; '', &nbsp;</div></li><li><div>          'where' =&gt; '', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $indent = '';&nbsp;</div></li><li><div>      for ( $i = 0; $i &lt; $depth; $i++ ) {&nbsp;</div></li><li><div>          $indent .= &quot;  &quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $query as $key =&gt; $clause ) {&nbsp;</div></li><li><div>          if ( 'relation' === $key ) {&nbsp;</div></li><li><div>              $relation = $query['relation'];&nbsp;</div></li><li><div>          } elseif ( is_array( $clause ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// This is a first-order clause.</span>&nbsp;</div></li><li><div>              if ( $this-&gt;is_first_order_clause( $clause ) ) {&nbsp;</div></li><li><div>                  $clause_sql = $this-&gt;get_sql_for_clause( $clause, $query );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  $where_count = count( $clause_sql['where'] );&nbsp;</div></li><li><div>                  if ( ! $where_count ) {&nbsp;</div></li><li><div>                      $sql_chunks['where'][] = '';&nbsp;</div></li><li><div>                  } elseif ( 1 === $where_count ) {&nbsp;</div></li><li><div>                      $sql_chunks['where'][] = $clause_sql['where'][0];&nbsp;</div></li><li><div>                  } else {&nbsp;</div></li><li><div>                      $sql_chunks['where'][] = '( ' . implode( ' AND ', $clause_sql['where'] ) . ' )';&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  $sql_chunks['join'] = array_merge( $sql_chunks['join'], $clause_sql['join'] );&nbsp;</div></li><li><div>              <span class="comment">// This is a subquery, so we recurse.</span>&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $clause_sql = $this-&gt;get_sql_for_query( $clause, $depth + 1 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  $sql_chunks['where'][] = $clause_sql['where'];&nbsp;</div></li><li><div>                  $sql_chunks['join'][] = $clause_sql['join'];&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Filter to remove empties.</span>&nbsp;</div></li><li><div>      $sql_chunks['join'] = array_filter( $sql_chunks['join'] );&nbsp;</div></li><li><div>      $sql_chunks['where'] = array_filter( $sql_chunks['where'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty( $relation ) ) {&nbsp;</div></li><li><div>          $relation = 'AND';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Filter duplicate JOIN clauses and combine into a single string.</span>&nbsp;</div></li><li><div>      if ( ! empty( $sql_chunks['join'] ) ) {&nbsp;</div></li><li><div>          $sql['join'] = implode( ' ', array_unique( $sql_chunks['join'] ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Generate a single WHERE clause with proper brackets and indentation.</span>&nbsp;</div></li><li><div>      if ( ! empty( $sql_chunks['where'] ) ) {&nbsp;</div></li><li><div>          $sql['where'] = '( ' . &quot;\n  &quot; . $indent . implode( ' ' . &quot;\n  &quot; . $indent . $relation . ' ' . &quot;\n  &quot; . $indent, $sql_chunks['where'] ) . &quot;\n&quot; . $indent . ')';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $sql;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Turns a single date clause into pieces for a WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * A wrapper for get_sql_for_clause(), included here for backward</span>&nbsp;</div></li><li><div><span class="comment">   * compatibility while retaining the naming convention across Query classes.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since  3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access protected</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param  array $query Date query arguments.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array {</span>&nbsp;</div></li><li><div><span class="comment">   *     Array containing JOIN and WHERE SQL clauses to append to the main query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $join  SQL fragment to append to the main JOIN clause.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $where SQL fragment to append to the main WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  protected function get_sql_for_subquery( $query ) {&nbsp;</div></li><li><div>      return $this-&gt;get_sql_for_clause( $query, '' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Turns a first-order date query into SQL for a WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since  4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access protected</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param  array $query        Date query clause.</span>&nbsp;</div></li><li><div><span class="comment">   * @param  array $parent_query Parent query of the current date query.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array {</span>&nbsp;</div></li><li><div><span class="comment">   *     Array containing JOIN and WHERE SQL clauses to append to the main query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $join  SQL fragment to append to the main JOIN clause.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string $where SQL fragment to append to the main WHERE clause.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  protected function get_sql_for_clause( $query, $parent_query ) {&nbsp;</div></li><li><div>      global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// The sub-parts of a $where part.</span>&nbsp;</div></li><li><div>      $where_parts = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $column = ( ! empty( $query['column'] ) ) ? esc_sql( $query['column'] ) : $this-&gt;column;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $column = $this-&gt;validate_column( $column );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $compare = $this-&gt;get_compare( $query );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $inclusive = ! empty( $query['inclusive'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Assign greater- and less-than values.</span>&nbsp;</div></li><li><div>      $lt = '&lt;';&nbsp;</div></li><li><div>      $gt = '&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $inclusive ) {&nbsp;</div></li><li><div>          $lt .= '=';&nbsp;</div></li><li><div>          $gt .= '=';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Range queries.</span>&nbsp;</div></li><li><div>      if ( ! empty( $query['after'] ) ) {&nbsp;</div></li><li><div>          $where_parts[] = $wpdb-&gt;prepare( &quot;$column $gt %s&quot;, $this-&gt;build_mysql_datetime( $query['after'], ! $inclusive ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( ! empty( $query['before'] ) ) {&nbsp;</div></li><li><div>          $where_parts[] = $wpdb-&gt;prepare( &quot;$column $lt %s&quot;, $this-&gt;build_mysql_datetime( $query['before'], $inclusive ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      <span class="comment">// Specific value queries.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $query['year'] ) && $value = $this-&gt;build_value( $compare, $query['year'] ) )&nbsp;</div></li><li><div>          $where_parts[] = &quot;YEAR( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $query['month'] ) && $value = $this-&gt;build_value( $compare, $query['month'] ) ) {&nbsp;</div></li><li><div>          $where_parts[] = &quot;MONTH( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>      } elseif ( isset( $query['monthnum'] ) && $value = $this-&gt;build_value( $compare, $query['monthnum'] ) ) {&nbsp;</div></li><li><div>          $where_parts[] = &quot;MONTH( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( isset( $query['week'] ) && false !== ( $value = $this-&gt;build_value( $compare, $query['week'] ) ) ) {&nbsp;</div></li><li><div>          $where_parts[] = _wp_mysql_week( $column ) . &quot; $compare $value&quot;;&nbsp;</div></li><li><div>      } elseif ( isset( $query['w'] ) && false !== ( $value = $this-&gt;build_value( $compare, $query['w'] ) ) ) {&nbsp;</div></li><li><div>          $where_parts[] = _wp_mysql_week( $column ) . &quot; $compare $value&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( isset( $query['dayofyear'] ) && $value = $this-&gt;build_value( $compare, $query['dayofyear'] ) )&nbsp;</div></li><li><div>          $where_parts[] = &quot;DAYOFYEAR( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $query['day'] ) && $value = $this-&gt;build_value( $compare, $query['day'] ) )&nbsp;</div></li><li><div>          $where_parts[] = &quot;DAYOFMONTH( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $query['dayofweek'] ) && $value = $this-&gt;build_value( $compare, $query['dayofweek'] ) )&nbsp;</div></li><li><div>          $where_parts[] = &quot;DAYOFWEEK( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $query['dayofweek_iso'] ) && $value = $this-&gt;build_value( $compare, $query['dayofweek_iso'] ) )&nbsp;</div></li><li><div>          $where_parts[] = &quot;WEEKDAY( $column ) + 1 $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $query['hour'] ) || isset( $query['minute'] ) || isset( $query['second'] ) ) {&nbsp;</div></li><li><div>          <span class="comment">// Avoid notices.</span>&nbsp;</div></li><li><div>          foreach ( array( 'hour', 'minute', 'second' ) as $unit ) {&nbsp;</div></li><li><div>              if ( ! isset( $query[ $unit ] ) ) {&nbsp;</div></li><li><div>                  $query[ $unit ] = null;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $time_query = $this-&gt;build_time_query( $column, $compare, $query['hour'], $query['minute'], $query['second'] ) ) {&nbsp;</div></li><li><div>              $where_parts[] = $time_query;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Return an array of 'join' and 'where' for compatibility</span>&nbsp;</div></li><li><div><span class="comment">       * with other query classes.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return array(&nbsp;</div></li><li><div>          'where' =&gt; $where_parts, &nbsp;</div></li><li><div>          'join' =&gt; array(), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Builds and validates a value string based on the comparison operator.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $compare The compare operator to use</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $value The value</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false|int The value to be used in SQL or false on error.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function build_value( $compare, $value ) {&nbsp;</div></li><li><div>      if ( ! isset( $value ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      switch ( $compare ) {&nbsp;</div></li><li><div>          case 'IN':&nbsp;</div></li><li><div>          case 'NOT IN':&nbsp;</div></li><li><div>              $value = (array) $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// Remove non-numeric values.</span>&nbsp;</div></li><li><div>              $value = array_filter( $value, 'is_numeric' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( empty( $value ) ) {&nbsp;</div></li><li><div>                  return false;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              return '(' . implode( ', ', array_map( 'intval', $value ) ) . ')';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          case 'BETWEEN':&nbsp;</div></li><li><div>          case 'NOT BETWEEN':&nbsp;</div></li><li><div>              if ( ! is_array( $value ) || 2 != count( $value ) ) {&nbsp;</div></li><li><div>                  $value = array( $value, $value );&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $value = array_values( $value );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// If either value is non-numeric, bail.</span>&nbsp;</div></li><li><div>              foreach ( $value as $v ) {&nbsp;</div></li><li><div>                  if ( ! is_numeric( $v ) ) {&nbsp;</div></li><li><div>                      return false;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $value = array_map( 'intval', $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              return $value[0] . ' AND ' . $value[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          default;&nbsp;</div></li><li><div>              if ( ! is_numeric( $value ) ) {&nbsp;</div></li><li><div>                  return false;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              return (int) $value;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Builds a MySQL format date/time based on some query parameters.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * You can pass an array of values (year, month, etc.) with missing parameter values being defaulted to</span>&nbsp;</div></li><li><div><span class="comment">   * either the maximum or minimum values (controlled by the $default_to parameter). Alternatively you can</span>&nbsp;</div></li><li><div><span class="comment">   * pass a string that will be run through strtotime().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $datetime       An array of parameters or a strotime() string</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool         $default_to_max Whether to round up incomplete dates. Supported by values</span>&nbsp;</div></li><li><div><span class="comment">   *                                     of $datetime that are arrays, or string values that are a</span>&nbsp;</div></li><li><div><span class="comment">   *                                     subset of MySQL date format ('Y', 'Y-m', 'Y-m-d', 'Y-m-d H:i').</span>&nbsp;</div></li><li><div><span class="comment">   *                                     Default: false.</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false A MySQL format date/time or false on failure</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function build_mysql_datetime( $datetime, $default_to_max = false ) {&nbsp;</div></li><li><div>      $now = current_time( 'timestamp' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! is_array( $datetime ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Try to parse some common date formats, so we can detect</span>&nbsp;</div></li><li><div><span class="comment">           * the level of precision and support the 'inclusive' parameter.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          if ( preg_match( '/^(\d{4})$/', $datetime, $matches ) ) {&nbsp;</div></li><li><div>              <span class="comment">// Y</span>&nbsp;</div></li><li><div>              $datetime = array(&nbsp;</div></li><li><div>                  'year' =&gt; intval( $matches[1] ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          } elseif ( preg_match( '/^(\d{4})\-(\d{2})$/', $datetime, $matches ) ) {&nbsp;</div></li><li><div>              <span class="comment">// Y</span>-m&nbsp;</div></li><li><div>              $datetime = array(&nbsp;</div></li><li><div>                  'year' =&gt; intval( $matches[1] ), &nbsp;</div></li><li><div>                  'month' =&gt; intval( $matches[2] ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          } elseif ( preg_match( '/^(\d{4})\-(\d{2})\-(\d{2})$/', $datetime, $matches ) ) {&nbsp;</div></li><li><div>              <span class="comment">// Y</span>-m-d&nbsp;</div></li><li><div>              $datetime = array(&nbsp;</div></li><li><div>                  'year' =&gt; intval( $matches[1] ), &nbsp;</div></li><li><div>                  'month' =&gt; intval( $matches[2] ), &nbsp;</div></li><li><div>                  'day' =&gt; intval( $matches[3] ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          } elseif ( preg_match( '/^(\d{4})\-(\d{2})\-(\d{2}) (\d{2}):(\d{2})$/', $datetime, $matches ) ) {&nbsp;</div></li><li><div>              <span class="comment">// Y</span>-m-d H:i&nbsp;</div></li><li><div>              $datetime = array(&nbsp;</div></li><li><div>                  'year' =&gt; intval( $matches[1] ), &nbsp;</div></li><li><div>                  'month' =&gt; intval( $matches[2] ), &nbsp;</div></li><li><div>                  'day' =&gt; intval( $matches[3] ), &nbsp;</div></li><li><div>                  'hour' =&gt; intval( $matches[4] ), &nbsp;</div></li><li><div>                  'minute' =&gt; intval( $matches[5] ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If no match is found, we don't support default_to_max.</span>&nbsp;</div></li><li><div>          if ( ! is_array( $datetime ) ) {&nbsp;</div></li><li><div>              <span class="comment">// @todo Timezone issues here possibly</span>&nbsp;</div></li><li><div>              return gmdate( 'Y-m-d H:i:s', strtotime( $datetime, $now ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $datetime = array_map( 'absint', $datetime );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $datetime['year'] ) )&nbsp;</div></li><li><div>          $datetime['year'] = gmdate( 'Y', $now );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $datetime['month'] ) )&nbsp;</div></li><li><div>          $datetime['month'] = ( $default_to_max ) ? 12 : 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $datetime['day'] ) )&nbsp;</div></li><li><div>          $datetime['day'] = ( $default_to_max ) ? (int) date( 't', mktime( 0, 0, 0, $datetime['month'], 1, $datetime['year'] ) ) : 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $datetime['hour'] ) )&nbsp;</div></li><li><div>          $datetime['hour'] = ( $default_to_max ) ? 23 : 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $datetime['minute'] ) )&nbsp;</div></li><li><div>          $datetime['minute'] = ( $default_to_max ) ? 59 : 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $datetime['second'] ) )&nbsp;</div></li><li><div>          $datetime['second'] = ( $default_to_max ) ? 59 : 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return sprintf( '%04d-%02d-%02d %02d:%02d:%02d', $datetime['year'], $datetime['month'], $datetime['day'], $datetime['hour'], $datetime['minute'], $datetime['second'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Builds a query string for comparing time values (hour, minute, second).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If just hour, minute, or second is set than a normal comparison will be done.</span>&nbsp;</div></li><li><div><span class="comment">   * However if multiple values are passed, a pseudo-decimal time will be created</span>&nbsp;</div></li><li><div><span class="comment">   * in order to be able to accurately compare against.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $column The column to query against. Needs to be pre-validated!</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $compare The comparison operator. Needs to be pre-validated!</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|null $hour Optional. An hour value (0-23).</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|null $minute Optional. A minute value (0-59).</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|null $second Optional. A second value (0-59).</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false A query part or false on failure.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function build_time_query( $column, $compare, $hour = null, $minute = null, $second = null ) {&nbsp;</div></li><li><div>      global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Have to have at least one</span>&nbsp;</div></li><li><div>      if ( ! isset( $hour ) && ! isset( $minute ) && ! isset( $second ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Complex combined queries aren't supported for multi-value queries</span>&nbsp;</div></li><li><div>      if ( in_array( $compare, array( 'IN', 'NOT IN', 'BETWEEN', 'NOT BETWEEN' ) ) ) {&nbsp;</div></li><li><div>          $return = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( isset( $hour ) && false !== ( $value = $this-&gt;build_value( $compare, $hour ) ) )&nbsp;</div></li><li><div>              $return[] = &quot;HOUR( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( isset( $minute ) && false !== ( $value = $this-&gt;build_value( $compare, $minute ) ) )&nbsp;</div></li><li><div>              $return[] = &quot;MINUTE( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( isset( $second ) && false !== ( $value = $this-&gt;build_value( $compare, $second ) ) )&nbsp;</div></li><li><div>              $return[] = &quot;SECOND( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return implode( ' AND ', $return );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Cases where just one unit is set</span>&nbsp;</div></li><li><div>      if ( isset( $hour ) && ! isset( $minute ) && ! isset( $second ) && false !== ( $value = $this-&gt;build_value( $compare, $hour ) ) ) {&nbsp;</div></li><li><div>          return &quot;HOUR( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>      } elseif ( ! isset( $hour ) && isset( $minute ) && ! isset( $second ) && false !== ( $value = $this-&gt;build_value( $compare, $minute ) ) ) {&nbsp;</div></li><li><div>          return &quot;MINUTE( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>      } elseif ( ! isset( $hour ) && ! isset( $minute ) && isset( $second ) && false !== ( $value = $this-&gt;build_value( $compare, $second ) ) ) {&nbsp;</div></li><li><div>          return &quot;SECOND( $column ) $compare $value&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Single units were already handled. Since hour & second isn't allowed, minute must to be set.</span>&nbsp;</div></li><li><div>      if ( ! isset( $minute ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $format = $time = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Hour</span>&nbsp;</div></li><li><div>      if ( null !== $hour ) {&nbsp;</div></li><li><div>          $format .= '%H.';&nbsp;</div></li><li><div>          $time   .= sprintf( '%02d', $hour ) . '.';&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $format .= '0.';&nbsp;</div></li><li><div>          $time   .= '0.';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Minute</span>&nbsp;</div></li><li><div>      $format .= '%i';&nbsp;</div></li><li><div>      $time   .= sprintf( '%02d', $minute );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $second ) ) {&nbsp;</div></li><li><div>          $format .= '%s';&nbsp;</div></li><li><div>          $time   .= sprintf( '%02d', $second );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $wpdb-&gt;prepare( &quot;DATE_FORMAT( $column, %s ) $compare %f&quot;, $format, $time );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>file</li><li><span></span></li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2017 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer> <script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>