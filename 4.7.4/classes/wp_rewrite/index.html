<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="wordpress" data-version="4.7.4" data-type="class" data-id="6116"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp_rewrite | class | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="WP_Rewrite, class, wordpress, 4.7.4" /><meta name="description" content="Core class used to implement a rewrite component API." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=28ccb701b0d61e4ef0f6c2132ada5b88' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/wp_rewrite/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fwp_rewrite%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fwp_rewrite%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-class-wp_rewrite","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp_rewrite" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="http://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/4.7.4/classes/" class=""><span property="name">classes</span></a><meta property="position" content="3"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp_rewrite</span><meta property="position" content="4"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="http://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="http://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="http://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="http://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="active" data-id="class" data-count="351"><a href="http://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="http://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>WP_Rewrite</strong></h1><p>Core class used to implement a rewrite component API.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/4.7.4/files/wp-includes-class-wp-rewrite/" class="file">/wp-includes/class-wp-rewrite.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="25" class="block" start="25"><li><div>class WP_Rewrite {&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Permalink structure for posts.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $permalink_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Whether to add trailing slashes.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.2.0&nbsp;</div></li><li><div>     * @var bool&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $use_trailing_slashes;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Base for the author permalink structure (example.com/$author_base/authorname).&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $author_base = 'author';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Permalink structure for author archives.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $author_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Permalink structure for date archives.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $date_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Permalink structure for pages.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $page_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Base of the search permalink structure (example.com/$search_base/query).&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $search_base = 'search';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Permalink structure for searches.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $search_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Comments permalink base.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $comments_base = 'comments';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Pagination permalink base.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 3.1.0&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $pagination_base = 'page';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Comments pagination permalink base.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 4.2.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $comments_pagination_base = 'comment-page';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Feed permalink base.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $feed_base = 'feed';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Comments feed permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $comment_feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Feed request permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The static portion of the post permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If the permalink structure is &quot;/archive/%post_id%&quot; then the front&nbsp;</div></li><li><div>     * is &quot;/archive/&quot;. If the permalink structure is &quot;/%year%/%postname%/&quot;&nbsp;</div></li><li><div>     * then the front is &quot;/&quot;.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see WP_Rewrite::init()&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $front;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The prefix for all permalink structures.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If PATHINFO/index permalinks are in use then the root is the value of&nbsp;</div></li><li><div>     * `WP_Rewrite::$index` with a trailing slash appended. Otherwise the root&nbsp;</div></li><li><div>     * will be empty.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see WP_Rewrite::init()&nbsp;</div></li><li><div>     * @see WP_Rewrite::using_index_permalinks()&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $root = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * The name of the index file which is the entry point to all requests.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $index = 'index.php';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Variable name to use for regex matches in the rewritten query.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $matches = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Rewrite rules to match against the request to find the redirect or query.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $rules;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Additional rules added external to the rewrite class.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Those not generated by the class, see add_rewrite_rule().&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.1.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $extra_rules = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Additional rules that belong at the beginning to match first.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Those not generated by the class, see add_rewrite_rule().&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.3.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $extra_rules_top = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Rules that don't redirect to WordPress' index.php.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * These rules are written to the mod_rewrite portion of the .htaccess, &nbsp;</div></li><li><div>     * and are added by add_external_rule().&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.1.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $non_wp_rules = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Extra permalink structures, e.g. categories, added by add_permastruct().&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.1.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $extra_permastructs = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Endpoints (like /trackback/) added by add_rewrite_endpoint().&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.1.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $endpoints;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Whether to write every mod_rewrite rule for WordPress into the .htaccess file.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * This is off by default, turning it on might print a lot of rewrite rules&nbsp;</div></li><li><div>     * to the .htaccess file.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.0.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @var bool&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see WP_Rewrite::mod_rewrite_rules()&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $use_verbose_rules = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Could post permalinks be confused with those of pages?&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If the first rewrite tag in the post permalink structure is one that could&nbsp;</div></li><li><div>     * also match a page name (e.g. %postname% or %author%) then this flag is&nbsp;</div></li><li><div>     * set to true. Prior to WordPress 3.3 this flag indicated that every page&nbsp;</div></li><li><div>     * would have a set of rules added to the top of the rewrite rules array.&nbsp;</div></li><li><div>     * Now it tells WP::parse_request() to check if a URL matching the page&nbsp;</div></li><li><div>     * permastruct is actually a page before accepting it.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @var bool&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see WP_Rewrite::init()&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $use_verbose_page_rules = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Rewrite tags that can be used in permalink structures.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * These are translated into the regular expressions stored in&nbsp;</div></li><li><div>     * `WP_Rewrite::$rewritereplace` and are rewritten to the query&nbsp;</div></li><li><div>     * variables listed in WP_Rewrite::$queryreplace.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Additional tags can be added with add_rewrite_tag().&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $rewritecode = array(&nbsp;</div></li><li><div>        '%year%', &nbsp;</div></li><li><div>        '%monthnum%', &nbsp;</div></li><li><div>        '%day%', &nbsp;</div></li><li><div>        '%hour%', &nbsp;</div></li><li><div>        '%minute%', &nbsp;</div></li><li><div>        '%second%', &nbsp;</div></li><li><div>        '%postname%', &nbsp;</div></li><li><div>        '%post_id%', &nbsp;</div></li><li><div>        '%author%', &nbsp;</div></li><li><div>        '%pagename%', &nbsp;</div></li><li><div>        '%search%'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Regular expressions to be substituted into rewrite rules in place&nbsp;</div></li><li><div>     * of rewrite tags, see WP_Rewrite::$rewritecode.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $rewritereplace = array(&nbsp;</div></li><li><div>        '([0-9]{4})', &nbsp;</div></li><li><div>        '([0-9]{1, 2})', &nbsp;</div></li><li><div>        '([0-9]{1, 2})', &nbsp;</div></li><li><div>        '([0-9]{1, 2})', &nbsp;</div></li><li><div>        '([0-9]{1, 2})', &nbsp;</div></li><li><div>        '([0-9]{1, 2})', &nbsp;</div></li><li><div>        '([^/]+)', &nbsp;</div></li><li><div>        '([0-9]+)', &nbsp;</div></li><li><div>        '([^/]+)', &nbsp;</div></li><li><div>        '([^/]+?)', &nbsp;</div></li><li><div>        '(.+)'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Query variables that rewrite tags map to, see WP_Rewrite::$rewritecode.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    var $queryreplace = array(&nbsp;</div></li><li><div>        'year=', &nbsp;</div></li><li><div>        'monthnum=', &nbsp;</div></li><li><div>        'day=', &nbsp;</div></li><li><div>        'hour=', &nbsp;</div></li><li><div>        'minute=', &nbsp;</div></li><li><div>        'second=', &nbsp;</div></li><li><div>        'name=', &nbsp;</div></li><li><div>        'p=', &nbsp;</div></li><li><div>        'author_name=', &nbsp;</div></li><li><div>        'pagename=', &nbsp;</div></li><li><div>        's='&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Supported default feeds.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public $feeds = array( 'feed', 'rdf', 'rss', 'rss2', 'atom' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Determines whether permalinks are being used.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * This can be either rewrite module or permalink in the HTTP query string.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return bool True, if permalinks are enabled.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function using_permalinks() {&nbsp;</div></li><li><div>        return ! empty($this-&gt;permalink_structure);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Determines whether permalinks are being used and rewrite module is not enabled.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Means that permalink links are enabled and index.php is in the URL.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return bool Whether permalink links are enabled and index.php is in the URL.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function using_index_permalinks() {&nbsp;</div></li><li><div>        if ( empty( $this-&gt;permalink_structure ) ) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If the index is not in the permalink, we're using mod_rewrite.&nbsp;</div></li><li><div>        return preg_match( '#^/*' . $this-&gt;index . '#', $this-&gt;permalink_structure );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Determines whether permalinks are being used and rewrite module is enabled.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Using permalinks and index.php is not in the URL.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return bool Whether permalink links are enabled and index.php is NOT in the URL.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function using_mod_rewrite_permalinks() {&nbsp;</div></li><li><div>        return $this-&gt;using_permalinks() && ! $this-&gt;using_index_permalinks();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Indexes for matches for usage in preg_*() functions.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The format of the string is, with empty matches property value, '$NUM'.&nbsp;</div></li><li><div>     * The 'NUM' will be replaced with the value in the $number parameter. With&nbsp;</div></li><li><div>     * the matches property not empty, the value of the returned string will&nbsp;</div></li><li><div>     * contain that value of the matches property. The format then will be&nbsp;</div></li><li><div>     * '$MATCHES[NUM]', with MATCHES as the value in the property and NUM the&nbsp;</div></li><li><div>     * value of the $number parameter.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param int $number Index number.&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function preg_index($number) {&nbsp;</div></li><li><div>        $match_prefix = '$';&nbsp;</div></li><li><div>        $match_suffix = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( ! empty($this-&gt;matches) ) {&nbsp;</div></li><li><div>            $match_prefix = '$' . $this-&gt;matches . '[';&nbsp;</div></li><li><div>            $match_suffix = ']';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return &quot;$match_prefix$number$match_suffix&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves all page and attachments for pages URIs.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The attachments are for those that have pages as parents and will be&nbsp;</div></li><li><div>     * retrieved.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @global wpdb $wpdb WordPress database abstraction object.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return array Array of page URIs as first element and attachment URIs as second element.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function page_uri_index() {&nbsp;</div></li><li><div>        global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Get pages in order of hierarchy, i.e. children after parents.&nbsp;</div></li><li><div>        $pages = $wpdb-&gt;get_results(&quot;SELECT ID, post_name, post_parent FROM $wpdb-&gt;posts WHERE post_type = 'page' AND post_status != 'auto-draft'&quot;);&nbsp;</div></li><li><div>        $posts = get_page_hierarchy( $pages );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If we have no pages get out quick.&nbsp;</div></li><li><div>        if ( !$posts )&nbsp;</div></li><li><div>            return array( array(), array() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Now reverse it, because we need parents after children for rewrite rules to work properly.&nbsp;</div></li><li><div>        $posts = array_reverse($posts, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $page_uris = array();&nbsp;</div></li><li><div>        $page_attachment_uris = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ( $posts as $id =&gt; $post ) {&nbsp;</div></li><li><div>            // URL =&gt; page name&nbsp;</div></li><li><div>            $uri = get_page_uri($id);&nbsp;</div></li><li><div>            $attachments = $wpdb-&gt;get_results( $wpdb-&gt;prepare( &quot;SELECT ID, post_name, post_parent FROM $wpdb-&gt;posts WHERE post_type = 'attachment' AND post_parent = %d&quot;, $id ));&nbsp;</div></li><li><div>            if ( !empty($attachments) ) {&nbsp;</div></li><li><div>                foreach ( $attachments as $attachment ) {&nbsp;</div></li><li><div>                    $attach_uri = get_page_uri($attachment-&gt;ID);&nbsp;</div></li><li><div>                    $page_attachment_uris[$attach_uri] = $attachment-&gt;ID;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $page_uris[$uri] = $id;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return array( $page_uris, $page_attachment_uris );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves all of the rewrite rules for pages.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return array Page rewrite rules.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function page_rewrite_rules() {&nbsp;</div></li><li><div>        // The extra .? at the beginning prevents clashes with other regular expressions in the rules array.&nbsp;</div></li><li><div>        $this-&gt;add_rewrite_tag( '%pagename%', '(.?.+?)', 'pagename=' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;generate_rewrite_rules( $this-&gt;get_page_permastruct(), EP_PAGES, true, true, false, false );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves date permalink structure, with year, month, and day.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The permalink structure for the date, if not set already depends on the&nbsp;</div></li><li><div>     * permalink structure. It can be one of three formats. The first is year, &nbsp;</div></li><li><div>     * month, day; the second is day, month, year; and the last format is month, &nbsp;</div></li><li><div>     * day, year. These are matched against the permalink structure for which&nbsp;</div></li><li><div>     * one is used. If none matches, then the default will be used, which is&nbsp;</div></li><li><div>     * year, month, day.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Prevents post ID and date permalinks from overlapping. In the case of&nbsp;</div></li><li><div>     * post_id, the date permalink will be prepended with front permalink with&nbsp;</div></li><li><div>     * 'date/' before the actual permalink to form the complete date permalink&nbsp;</div></li><li><div>     * structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False on no permalink structure. Date permalink structure.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_date_permastruct() {&nbsp;</div></li><li><div>        if ( isset($this-&gt;date_structure) )&nbsp;</div></li><li><div>            return $this-&gt;date_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>            $this-&gt;date_structure = '';&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // The date permalink must have year, month, and day separated by slashes.&nbsp;</div></li><li><div>        $endians = array('%year%/%monthnum%/%day%', '%day%/%monthnum%/%year%', '%monthnum%/%day%/%year%');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;date_structure = '';&nbsp;</div></li><li><div>        $date_endian = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ( $endians as $endian ) {&nbsp;</div></li><li><div>            if ( false !== strpos($this-&gt;permalink_structure, $endian) ) {&nbsp;</div></li><li><div>                $date_endian= $endian;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($date_endian) )&nbsp;</div></li><li><div>            $date_endian = '%year%/%monthnum%/%day%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Do not allow the date tags and %post_id% to overlap in the permalink&nbsp;</div></li><li><div>         * structure. If they do, move the date tags to $front/date/.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $front = $this-&gt;front;&nbsp;</div></li><li><div>        preg_match_all('/%.+?%/', $this-&gt;permalink_structure, $tokens);&nbsp;</div></li><li><div>        $tok_index = 1;&nbsp;</div></li><li><div>        foreach ( (array) $tokens[0] as $token) {&nbsp;</div></li><li><div>            if ( '%post_id%' == $token && ($tok_index &lt;= 3) ) {&nbsp;</div></li><li><div>                $front = $front . 'date/';&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $tok_index++;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;date_structure = $front . $date_endian;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;date_structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the year permalink structure without month and day.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Gets the date permalink structure and strips out the month and day&nbsp;</div></li><li><div>     * permalink structures.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return false|string False on failure. Year structure on success.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_year_permastruct() {&nbsp;</div></li><li><div>        $structure = $this-&gt;get_date_permastruct();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($structure) )&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $structure = str_replace('%monthnum%', '', $structure);&nbsp;</div></li><li><div>        $structure = str_replace('%day%', '', $structure);&nbsp;</div></li><li><div>        $structure = preg_replace('#/+#', '/', $structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the month permalink structure without day and with year.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Gets the date permalink structure and strips out the day permalink&nbsp;</div></li><li><div>     * structures. Keeps the year permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return false|string False on failure. Year/Month structure on success.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_month_permastruct() {&nbsp;</div></li><li><div>        $structure = $this-&gt;get_date_permastruct();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($structure) )&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $structure = str_replace('%day%', '', $structure);&nbsp;</div></li><li><div>        $structure = preg_replace('#/+#', '/', $structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the day permalink structure with month and year.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Keeps date permalink structure with all year, month, and day.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False on failure. Year/Month/Day structure on success.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_day_permastruct() {&nbsp;</div></li><li><div>        return $this-&gt;get_date_permastruct();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the permalink structure for categories.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If the category_base property has no value, then the category structure&nbsp;</div></li><li><div>     * will have the front property value, followed by 'category', and finally&nbsp;</div></li><li><div>     * '%category%'. If it does, then the root property will be used, along with&nbsp;</div></li><li><div>     * the category_base property value.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False on failure. Category permalink structure.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_category_permastruct() {&nbsp;</div></li><li><div>        return $this-&gt;get_extra_permastruct('category');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieve the permalink structure for tags.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If the tag_base property has no value, then the tag structure will have&nbsp;</div></li><li><div>     * the front property value, followed by 'tag', and finally '%tag%'. If it&nbsp;</div></li><li><div>     * does, then the root property will be used, along with the tag_base&nbsp;</div></li><li><div>     * property value.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.3.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False on failure. Tag permalink structure.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_tag_permastruct() {&nbsp;</div></li><li><div>        return $this-&gt;get_extra_permastruct('post_tag');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves an extra permalink structure by name.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $name Permalink structure name.&nbsp;</div></li><li><div>     * @return string|false False if not found. Permalink structure string.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_extra_permastruct($name) {&nbsp;</div></li><li><div>        if ( empty($this-&gt;permalink_structure) )&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( isset($this-&gt;extra_permastructs[$name]) )&nbsp;</div></li><li><div>            return $this-&gt;extra_permastructs[$name]['struct'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the author permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The permalink structure is front property, author base, and finally&nbsp;</div></li><li><div>     * '/%author%'. Will set the author_structure property and then return it&nbsp;</div></li><li><div>     * without attempting to set the value again.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False if not found. Permalink structure string.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_author_permastruct() {&nbsp;</div></li><li><div>        if ( isset($this-&gt;author_structure) )&nbsp;</div></li><li><div>            return $this-&gt;author_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>            $this-&gt;author_structure = '';&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;author_structure = $this-&gt;front . $this-&gt;author_base . '/%author%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;author_structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the search permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The permalink structure is root property, search base, and finally&nbsp;</div></li><li><div>     * '/%search%'. Will set the search_structure property and then return it&nbsp;</div></li><li><div>     * without attempting to set the value again.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False if not found. Permalink structure string.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_search_permastruct() {&nbsp;</div></li><li><div>        if ( isset($this-&gt;search_structure) )&nbsp;</div></li><li><div>            return $this-&gt;search_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>            $this-&gt;search_structure = '';&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;search_structure = $this-&gt;root . $this-&gt;search_base . '/%search%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;search_structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the page permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The permalink structure is root property, and '%pagename%'. Will set the&nbsp;</div></li><li><div>     * page_structure property and then return it without attempting to set the&nbsp;</div></li><li><div>     * value again.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False if not found. Permalink structure string.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_page_permastruct() {&nbsp;</div></li><li><div>        if ( isset($this-&gt;page_structure) )&nbsp;</div></li><li><div>            return $this-&gt;page_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (empty($this-&gt;permalink_structure)) {&nbsp;</div></li><li><div>            $this-&gt;page_structure = '';&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;page_structure = $this-&gt;root . '%pagename%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;page_structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the feed permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The permalink structure is root property, feed base, and finally&nbsp;</div></li><li><div>     * '/%feed%'. Will set the feed_structure property and then return it&nbsp;</div></li><li><div>     * without attempting to set the value again.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False if not found. Permalink structure string.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_feed_permastruct() {&nbsp;</div></li><li><div>        if ( isset($this-&gt;feed_structure) )&nbsp;</div></li><li><div>            return $this-&gt;feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>            $this-&gt;feed_structure = '';&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;feed_structure = $this-&gt;root . $this-&gt;feed_base . '/%feed%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;feed_structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the comment feed permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The permalink structure is root property, comment base property, feed&nbsp;</div></li><li><div>     * base and finally '/%feed%'. Will set the comment_feed_structure property&nbsp;</div></li><li><div>     * and then return it without attempting to set the value again.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false False if not found. Permalink structure string.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get_comment_feed_permastruct() {&nbsp;</div></li><li><div>        if ( isset($this-&gt;comment_feed_structure) )&nbsp;</div></li><li><div>            return $this-&gt;comment_feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (empty($this-&gt;permalink_structure)) {&nbsp;</div></li><li><div>            $this-&gt;comment_feed_structure = '';&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;comment_feed_structure = $this-&gt;root . $this-&gt;comments_base . '/' . $this-&gt;feed_base . '/%feed%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;comment_feed_structure;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Adds or updates existing rewrite tags (e.g. %postname%).&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If the tag already exists, replace the existing pattern and query for&nbsp;</div></li><li><div>     * that tag, otherwise add the new tag.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see WP_Rewrite::$rewritecode&nbsp;</div></li><li><div>     * @see WP_Rewrite::$rewritereplace&nbsp;</div></li><li><div>     * @see WP_Rewrite::$queryreplace&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $tag   Name of the rewrite tag to add or update.&nbsp;</div></li><li><div>     * @param string $regex Regular expression to substitute the tag for in rewrite rules.&nbsp;</div></li><li><div>     * @param string $query String to append to the rewritten query. Must end in '='.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function add_rewrite_tag( $tag, $regex, $query ) {&nbsp;</div></li><li><div>        $position = array_search( $tag, $this-&gt;rewritecode );&nbsp;</div></li><li><div>        if ( false !== $position && null !== $position ) {&nbsp;</div></li><li><div>            $this-&gt;rewritereplace[ $position ] = $regex;&nbsp;</div></li><li><div>            $this-&gt;queryreplace[ $position ] = $query;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $this-&gt;rewritecode[] = $tag;&nbsp;</div></li><li><div>            $this-&gt;rewritereplace[] = $regex;&nbsp;</div></li><li><div>            $this-&gt;queryreplace[] = $query;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Removes an existing rewrite tag.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 4.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see WP_Rewrite::$rewritecode&nbsp;</div></li><li><div>     * @see WP_Rewrite::$rewritereplace&nbsp;</div></li><li><div>     * @see WP_Rewrite::$queryreplace&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $tag Name of the rewrite tag to remove.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function remove_rewrite_tag( $tag ) {&nbsp;</div></li><li><div>        $position = array_search( $tag, $this-&gt;rewritecode );&nbsp;</div></li><li><div>        if ( false !== $position && null !== $position ) {&nbsp;</div></li><li><div>            unset( $this-&gt;rewritecode[ $position ] );&nbsp;</div></li><li><div>            unset( $this-&gt;rewritereplace[ $position ] );&nbsp;</div></li><li><div>            unset( $this-&gt;queryreplace[ $position ] );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Generates rewrite rules from a permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The main WP_Rewrite function for building the rewrite rule list. The&nbsp;</div></li><li><div>     * contents of the function is a mix of black magic and regular expressions, &nbsp;</div></li><li><div>     * so best just ignore the contents and move to the parameters.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $permalink_structure The permalink structure.&nbsp;</div></li><li><div>     * @param int    $ep_mask             Optional. Endpoint mask defining what endpoints are added to the structure.&nbsp;</div></li><li><div>     *                                    Accepts `EP_NONE`, `EP_PERMALINK`, `EP_ATTACHMENT`, `EP_DATE`, `EP_YEAR`, &nbsp;</div></li><li><div>     *                                    `EP_MONTH`, `EP_DAY`, `EP_ROOT`, `EP_COMMENTS`, `EP_SEARCH`, `EP_CATEGORIES`, &nbsp;</div></li><li><div>     *                                    `EP_TAGS`, `EP_AUTHORS`, `EP_PAGES`, `EP_ALL_ARCHIVES`, and `EP_ALL`.&nbsp;</div></li><li><div>     *                                    Default `EP_NONE`.&nbsp;</div></li><li><div>     * @param bool   $paged               Optional. Whether archive pagination rules should be added for the structure.&nbsp;</div></li><li><div>     *                                    Default true.&nbsp;</div></li><li><div>     * @param bool   $feed                Optional Whether feed rewrite rules should be added for the structure.&nbsp;</div></li><li><div>     *                                    Default true.&nbsp;</div></li><li><div>     * @param bool   $forcomments         Optional. Whether the feed rules should be a query for a comments feed.&nbsp;</div></li><li><div>     *                                    Default false.&nbsp;</div></li><li><div>     * @param bool   $walk_dirs           Optional. Whether the 'directories' making up the structure should be walked&nbsp;</div></li><li><div>     *                                    over and rewrite rules built for each in-turn. Default true.&nbsp;</div></li><li><div>     * @param bool   $endpoints           Optional. Whether endpoints should be applied to the generated rewrite rules.&nbsp;</div></li><li><div>     *                                    Default true.&nbsp;</div></li><li><div>     * @return array Rewrite rule list.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function generate_rewrite_rules($permalink_structure, $ep_mask = EP_NONE, $paged = true, $feed = true, $forcomments = false, $walk_dirs = true, $endpoints = true) {&nbsp;</div></li><li><div>        // Build a regex to match the feed section of URLs, something like (feed|atom|rss|rss2)/?&nbsp;</div></li><li><div>        $feedregex2 = '';&nbsp;</div></li><li><div>        foreach ( (array) $this-&gt;feeds as $feed_name)&nbsp;</div></li><li><div>            $feedregex2 .= $feed_name . '|';&nbsp;</div></li><li><div>        $feedregex2 = '(' . trim($feedregex2, '|') . ')/?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * $feedregex is identical but with /feed/ added on as well, so URLs like &lt;permalink&gt;/feed/atom&nbsp;</div></li><li><div>         * and &lt;permalink&gt;/atom are both possible&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $feedregex = $this-&gt;feed_base . '/' . $feedregex2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Build a regex to match the trackback and page/xx parts of URLs.&nbsp;</div></li><li><div>        $trackbackregex = 'trackback/?$';&nbsp;</div></li><li><div>        $pageregex = $this-&gt;pagination_base . '/?([0-9]{1, })/?$';&nbsp;</div></li><li><div>        $commentregex = $this-&gt;comments_pagination_base . '-([0-9]{1, })/?$';&nbsp;</div></li><li><div>        $embedregex = 'embed/?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Build up an array of endpoint regexes to append =&gt; queries to append.&nbsp;</div></li><li><div>        if ( $endpoints ) {&nbsp;</div></li><li><div>            $ep_query_append = array ();&nbsp;</div></li><li><div>            foreach ( (array) $this-&gt;endpoints as $endpoint) {&nbsp;</div></li><li><div>                // Match everything after the endpoint name, but allow for nothing to appear there.&nbsp;</div></li><li><div>                $epmatch = $endpoint[1] . '(/(.*))?/?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // This will be appended on to the rest of the query for each dir.&nbsp;</div></li><li><div>                $epquery = '&' . $endpoint[2] . '=';&nbsp;</div></li><li><div>                $ep_query_append[$epmatch] = array ( $endpoint[0], $epquery );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Get everything up to the first rewrite tag.&nbsp;</div></li><li><div>        $front = substr($permalink_structure, 0, strpos($permalink_structure, '%'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Build an array of the tags (note that said array ends up being in $tokens[0]).&nbsp;</div></li><li><div>        preg_match_all('/%.+?%/', $permalink_structure, $tokens);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $num_tokens = count($tokens[0]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $index = $this-&gt;index; //probably 'index.php'&nbsp;</div></li><li><div>        $feedindex = $index;&nbsp;</div></li><li><div>        $trackbackindex = $index;&nbsp;</div></li><li><div>        $embedindex = $index;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Build a list from the rewritecode and queryreplace arrays, that will look something&nbsp;</div></li><li><div>         * like tagname=$matches[i] where i is the current $i.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $queries = array();&nbsp;</div></li><li><div>        for ( $i = 0; $i &lt; $num_tokens; ++$i ) {&nbsp;</div></li><li><div>            if ( 0 &lt; $i )&nbsp;</div></li><li><div>                $queries[$i] = $queries[$i - 1] . '&';&nbsp;</div></li><li><div>            else&nbsp;</div></li><li><div>                $queries[$i] = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $query_token = str_replace($this-&gt;rewritecode, $this-&gt;queryreplace, $tokens[0][$i]) . $this-&gt;preg_index($i+1);&nbsp;</div></li><li><div>            $queries[$i] .= $query_token;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Get the structure, minus any cruft (stuff that isn't tags) at the front.&nbsp;</div></li><li><div>        $structure = $permalink_structure;&nbsp;</div></li><li><div>        if ( $front != '/' )&nbsp;</div></li><li><div>            $structure = str_replace($front, '', $structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Create a list of dirs to walk over, making rewrite rules for each level&nbsp;</div></li><li><div>         * so for example, a $structure of /%year%/%monthnum%/%postname% would create&nbsp;</div></li><li><div>         * rewrite rules for /%year%/, /%year%/%monthnum%/ and /%year%/%monthnum%/%postname%&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $structure = trim($structure, '/');&nbsp;</div></li><li><div>        $dirs = $walk_dirs ? explode('/', $structure) : array( $structure );&nbsp;</div></li><li><div>        $num_dirs = count($dirs);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Strip slashes from the front of $front.&nbsp;</div></li><li><div>        $front = preg_replace('|^/+|', '', $front);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // The main workhorse loop.&nbsp;</div></li><li><div>        $post_rewrite = array();&nbsp;</div></li><li><div>        $struct = $front;&nbsp;</div></li><li><div>        for ( $j = 0; $j &lt; $num_dirs; ++$j ) {&nbsp;</div></li><li><div>            // Get the struct for this dir, and trim slashes off the front.&nbsp;</div></li><li><div>            $struct .= $dirs[$j] . '/'; // Accumulate. see comment near explode('/', $structure) above.&nbsp;</div></li><li><div>            $struct = ltrim($struct, '/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Replace tags with regexes.&nbsp;</div></li><li><div>            $match = str_replace($this-&gt;rewritecode, $this-&gt;rewritereplace, $struct);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Make a list of tags, and store how many there are in $num_toks.&nbsp;</div></li><li><div>            $num_toks = preg_match_all('/%.+?%/', $struct, $toks);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Get the 'tagname=$matches[i]'.&nbsp;</div></li><li><div>            $query = ( ! empty( $num_toks ) && isset( $queries[$num_toks - 1] ) ) ? $queries[$num_toks - 1] : '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Set up $ep_mask_specific which is used to match more specific URL types.&nbsp;</div></li><li><div>            switch ( $dirs[$j] ) {&nbsp;</div></li><li><div>                case '%year%':&nbsp;</div></li><li><div>                    $ep_mask_specific = EP_YEAR;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                case '%monthnum%':&nbsp;</div></li><li><div>                    $ep_mask_specific = EP_MONTH;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                case '%day%':&nbsp;</div></li><li><div>                    $ep_mask_specific = EP_DAY;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                default:&nbsp;</div></li><li><div>                    $ep_mask_specific = EP_NONE;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Create query for /page/xx.&nbsp;</div></li><li><div>            $pagematch = $match . $pageregex;&nbsp;</div></li><li><div>            $pagequery = $index . '?' . $query . '&paged=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Create query for /comment-page-xx.&nbsp;</div></li><li><div>            $commentmatch = $match . $commentregex;&nbsp;</div></li><li><div>            $commentquery = $index . '?' . $query . '&cpage=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( get_option('page_on_front') ) {&nbsp;</div></li><li><div>                // Create query for Root /comment-page-xx.&nbsp;</div></li><li><div>                $rootcommentmatch = $match . $commentregex;&nbsp;</div></li><li><div>                $rootcommentquery = $index . '?' . $query . '&page_id=' . get_option('page_on_front') . '&cpage=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Create query for /feed/(feed|atom|rss|rss2|rdf).&nbsp;</div></li><li><div>            $feedmatch = $match . $feedregex;&nbsp;</div></li><li><div>            $feedquery = $feedindex . '?' . $query . '&feed=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Create query for /(feed|atom|rss|rss2|rdf) (see comment near creation of $feedregex).&nbsp;</div></li><li><div>            $feedmatch2 = $match . $feedregex2;&nbsp;</div></li><li><div>            $feedquery2 = $feedindex . '?' . $query . '&feed=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Create query and regex for embeds.&nbsp;</div></li><li><div>            $embedmatch = $match . $embedregex;&nbsp;</div></li><li><div>            $embedquery = $embedindex . '?' . $query . '&embed=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // If asked to, turn the feed queries into comment feed ones.&nbsp;</div></li><li><div>            if ( $forcomments ) {&nbsp;</div></li><li><div>                $feedquery .= '&withcomments=1';&nbsp;</div></li><li><div>                $feedquery2 .= '&withcomments=1';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Start creating the array of rewrites for this dir.&nbsp;</div></li><li><div>            $rewrite = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ...adding on /feed/ regexes =&gt; queries&nbsp;</div></li><li><div>            if ( $feed ) {&nbsp;</div></li><li><div>                $rewrite = array( $feedmatch =&gt; $feedquery, $feedmatch2 =&gt; $feedquery2, $embedmatch =&gt; $embedquery );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //...and /page/xx ones&nbsp;</div></li><li><div>            if ( $paged ) {&nbsp;</div></li><li><div>                $rewrite = array_merge( $rewrite, array( $pagematch =&gt; $pagequery ) );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Only on pages with comments add ../comment-page-xx/.&nbsp;</div></li><li><div>            if ( EP_PAGES & $ep_mask || EP_PERMALINK & $ep_mask ) {&nbsp;</div></li><li><div>                $rewrite = array_merge($rewrite, array($commentmatch =&gt; $commentquery));&nbsp;</div></li><li><div>            } elseif ( EP_ROOT & $ep_mask && get_option('page_on_front') ) {&nbsp;</div></li><li><div>                $rewrite = array_merge($rewrite, array($rootcommentmatch =&gt; $rootcommentquery));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Do endpoints.&nbsp;</div></li><li><div>            if ( $endpoints ) {&nbsp;</div></li><li><div>                foreach ( (array) $ep_query_append as $regex =&gt; $ep) {&nbsp;</div></li><li><div>                    // Add the endpoints on if the mask fits.&nbsp;</div></li><li><div>                    if ( $ep[0] & $ep_mask || $ep[0] & $ep_mask_specific )&nbsp;</div></li><li><div>                        $rewrite[$match . $regex] = $index . '?' . $query . $ep[1] . $this-&gt;preg_index($num_toks + 2);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // If we've got some tags in this dir.&nbsp;</div></li><li><div>            if ( $num_toks ) {&nbsp;</div></li><li><div>                $post = false;&nbsp;</div></li><li><div>                $page = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /**&nbsp;</div></li><li><div>                 * Check to see if this dir is permalink-level: i.e. the structure specifies an&nbsp;</div></li><li><div>                 * individual post. Do this by checking it contains at least one of 1) post name, &nbsp;</div></li><li><div>                 * 2) post ID, 3) page name, 4) timestamp (year, month, day, hour, second and&nbsp;</div></li><li><div>                 * minute all present). Set these flags now as we need them for the endpoints.&nbsp;</div></li><li><div>                 */&nbsp;</div></li><li><div>                if ( strpos($struct, '%postname%') !== false&nbsp;</div></li><li><div>                        || strpos($struct, '%post_id%') !== false&nbsp;</div></li><li><div>                        || strpos($struct, '%pagename%') !== false&nbsp;</div></li><li><div>                        || (strpos($struct, '%year%') !== false && strpos($struct, '%monthnum%') !== false && strpos($struct, '%day%') !== false && strpos($struct, '%hour%') !== false && strpos($struct, '%minute%') !== false && strpos($struct, '%second%') !== false)&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                    $post = true;&nbsp;</div></li><li><div>                    if ( strpos($struct, '%pagename%') !== false )&nbsp;</div></li><li><div>                        $page = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ( ! $post ) {&nbsp;</div></li><li><div>                    // For custom post types, we need to add on endpoints as well.&nbsp;</div></li><li><div>                    foreach ( get_post_types( array('_builtin' =&gt; false ) ) as $ptype ) {&nbsp;</div></li><li><div>                        if ( strpos($struct, &quot;%$ptype%&quot;) !== false ) {&nbsp;</div></li><li><div>                            $post = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // This is for page style attachment URLs.&nbsp;</div></li><li><div>                            $page = is_post_type_hierarchical( $ptype );&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // If creating rules for a permalink, do all the endpoints like attachments etc.&nbsp;</div></li><li><div>                if ( $post ) {&nbsp;</div></li><li><div>                    // Create query and regex for trackback.&nbsp;</div></li><li><div>                    $trackbackmatch = $match . $trackbackregex;&nbsp;</div></li><li><div>                    $trackbackquery = $trackbackindex . '?' . $query . '&tb=1';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Create query and regex for embeds.&nbsp;</div></li><li><div>                    $embedmatch = $match . $embedregex;&nbsp;</div></li><li><div>                    $embedquery = $embedindex . '?' . $query . '&embed=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Trim slashes from the end of the regex for this dir.&nbsp;</div></li><li><div>                    $match = rtrim($match, '/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Get rid of brackets.&nbsp;</div></li><li><div>                    $submatchbase = str_replace( array('(', ')'), '', $match);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Add a rule for at attachments, which take the form of &lt;permalink&gt;/some-text.&nbsp;</div></li><li><div>                    $sub1 = $submatchbase . '/([^/]+)/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Add trackback regex &lt;permalink&gt;/trackback/...&nbsp;</div></li><li><div>                    $sub1tb = $sub1 . $trackbackregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And &lt;permalink&gt;/feed/(atom|...)&nbsp;</div></li><li><div>                    $sub1feed = $sub1 . $feedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And &lt;permalink&gt;/(feed|atom...)&nbsp;</div></li><li><div>                    $sub1feed2 = $sub1 . $feedregex2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And &lt;permalink&gt;/comment-page-xx&nbsp;</div></li><li><div>                    $sub1comment = $sub1 . $commentregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And &lt;permalink&gt;/embed/...&nbsp;</div></li><li><div>                    $sub1embed = $sub1 . $embedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /**&nbsp;</div></li><li><div>                     * Add another rule to match attachments in the explicit form:&nbsp;</div></li><li><div>                     * &lt;permalink&gt;/attachment/some-text&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>                    $sub2 = $submatchbase . '/attachment/([^/]+)/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And add trackbacks &lt;permalink&gt;/attachment/trackback.&nbsp;</div></li><li><div>                    $sub2tb = $sub2 . $trackbackregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Feeds, &lt;permalink&gt;/attachment/feed/(atom|...)&nbsp;</div></li><li><div>                    $sub2feed = $sub2 . $feedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And feeds again on to this &lt;permalink&gt;/attachment/(feed|atom...)&nbsp;</div></li><li><div>                    $sub2feed2 = $sub2 . $feedregex2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And &lt;permalink&gt;/comment-page-xx&nbsp;</div></li><li><div>                    $sub2comment = $sub2 . $commentregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // And &lt;permalink&gt;/embed/...&nbsp;</div></li><li><div>                    $sub2embed = $sub2 . $embedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Create queries for these extra tag-ons we've just dealt with.&nbsp;</div></li><li><div>                    $subquery = $index . '?attachment=' . $this-&gt;preg_index(1);&nbsp;</div></li><li><div>                    $subtbquery = $subquery . '&tb=1';&nbsp;</div></li><li><div>                    $subfeedquery = $subquery . '&feed=' . $this-&gt;preg_index(2);&nbsp;</div></li><li><div>                    $subcommentquery = $subquery . '&cpage=' . $this-&gt;preg_index(2);&nbsp;</div></li><li><div>                    $subembedquery = $subquery . '&embed=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Do endpoints for attachments.&nbsp;</div></li><li><div>                    if ( !empty($endpoints) ) {&nbsp;</div></li><li><div>                        foreach ( (array) $ep_query_append as $regex =&gt; $ep ) {&nbsp;</div></li><li><div>                            if ( $ep[0] & EP_ATTACHMENT ) {&nbsp;</div></li><li><div>                                $rewrite[$sub1 . $regex] = $subquery . $ep[1] . $this-&gt;preg_index(3);&nbsp;</div></li><li><div>                                $rewrite[$sub2 . $regex] = $subquery . $ep[1] . $this-&gt;preg_index(3);&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /**&nbsp;</div></li><li><div>                     * Now we've finished with endpoints, finish off the $sub1 and $sub2 matches&nbsp;</div></li><li><div>                     * add a ? as we don't have to match that last slash, and finally a $ so we&nbsp;</div></li><li><div>                     * match to the end of the URL&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>                    $sub1 .= '?$';&nbsp;</div></li><li><div>                    $sub2 .= '?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /**&nbsp;</div></li><li><div>                     * Post pagination, e.g. &lt;permalink&gt;/2/&nbsp;</div></li><li><div>                     * Previously: '(/[0-9]+)?/?$', which produced '/2' for page.&nbsp;</div></li><li><div>                     * When cast to int, returned 0.&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>                    $match = $match . '(?:/([0-9]+))?/?$';&nbsp;</div></li><li><div>                    $query = $index . '?' . $query . '&page=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Not matching a permalink so this is a lot simpler.&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    // Close the match and finalise the query.&nbsp;</div></li><li><div>                    $match .= '?$';&nbsp;</div></li><li><div>                    $query = $index . '?' . $query;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /**&nbsp;</div></li><li><div>                 * Create the final array for this dir by joining the $rewrite array (which currently&nbsp;</div></li><li><div>                 * only contains rules/queries for trackback, pages etc) to the main regex/query for&nbsp;</div></li><li><div>                 * this dir&nbsp;</div></li><li><div>                 */&nbsp;</div></li><li><div>                $rewrite = array_merge($rewrite, array($match =&gt; $query));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // If we're matching a permalink, add those extras (attachments etc) on.&nbsp;</div></li><li><div>                if ( $post ) {&nbsp;</div></li><li><div>                    // Add trackback.&nbsp;</div></li><li><div>                    $rewrite = array_merge(array($trackbackmatch =&gt; $trackbackquery), $rewrite);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Add embed.&nbsp;</div></li><li><div>                    $rewrite = array_merge( array( $embedmatch =&gt; $embedquery ), $rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Add regexes/queries for attachments, attachment trackbacks and so on.&nbsp;</div></li><li><div>                    if ( ! $page ) {&nbsp;</div></li><li><div>                        // Require &lt;permalink&gt;/attachment/stuff form for pages because of confusion with subpages.&nbsp;</div></li><li><div>                        $rewrite = array_merge( $rewrite, array(&nbsp;</div></li><li><div>                            $sub1 =&gt; $subquery, &nbsp;</div></li><li><div>                            $sub1tb =&gt; $subtbquery, &nbsp;</div></li><li><div>                            $sub1feed =&gt; $subfeedquery, &nbsp;</div></li><li><div>                            $sub1feed2 =&gt; $subfeedquery, &nbsp;</div></li><li><div>                            $sub1comment =&gt; $subcommentquery, &nbsp;</div></li><li><div>                            $sub1embed =&gt; $subembedquery&nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $rewrite = array_merge( array( $sub2 =&gt; $subquery, $sub2tb =&gt; $subtbquery, $sub2feed =&gt; $subfeedquery, $sub2feed2 =&gt; $subfeedquery, $sub2comment =&gt; $subcommentquery, $sub2embed =&gt; $subembedquery ), $rewrite );&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Add the rules for this dir to the accumulating $post_rewrite.&nbsp;</div></li><li><div>            $post_rewrite = array_merge($rewrite, $post_rewrite);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // The finished rules. phew!&nbsp;</div></li><li><div>        return $post_rewrite;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Generates rewrite rules with permalink structure and walking directory only.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Shorten version of WP_Rewrite::generate_rewrite_rules() that allows for shorter&nbsp;</div></li><li><div>     * list of parameters. See the method for longer description of what generating&nbsp;</div></li><li><div>     * rewrite rules does.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see WP_Rewrite::generate_rewrite_rules() See for long description and rest of parameters.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $permalink_structure The permalink structure to generate rules.&nbsp;</div></li><li><div>     * @param bool   $walk_dirs           Optional, default is false. Whether to create list of directories to walk over.&nbsp;</div></li><li><div>     * @return array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function generate_rewrite_rule($permalink_structure, $walk_dirs = false) {&nbsp;</div></li><li><div>        return $this-&gt;generate_rewrite_rules($permalink_structure, EP_NONE, false, false, false, $walk_dirs);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Constructs rewrite matches and queries from permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Runs the action {@see 'generate_rewrite_rules'} with the parameter that is an&nbsp;</div></li><li><div>     * reference to the current WP_Rewrite instance to further manipulate the&nbsp;</div></li><li><div>     * permalink structures and rewrite rules. Runs the {@see 'rewrite_rules_array'}&nbsp;</div></li><li><div>     * filter on the full rewrite rule array.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * There are two ways to manipulate the rewrite rules, one by hooking into&nbsp;</div></li><li><div>     * the {@see 'generate_rewrite_rules'} action and gaining full control of the&nbsp;</div></li><li><div>     * object or just manipulating the rewrite rule array before it is passed&nbsp;</div></li><li><div>     * from the function.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return array An associate array of matches and queries.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function rewrite_rules() {&nbsp;</div></li><li><div>        $rewrite = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty($this-&gt;permalink_structure) )&nbsp;</div></li><li><div>            return $rewrite;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // robots.txt -only if installed at the root&nbsp;</div></li><li><div>        $home_path = parse_url( home_url() );&nbsp;</div></li><li><div>        $robots_rewrite = ( empty( $home_path['path'] ) || '/' == $home_path['path'] ) ? array( 'robots\.txt$' =&gt; $this-&gt;index . '?robots=1' ) : array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Old feed and service files.&nbsp;</div></li><li><div>        $deprecated_files = array(&nbsp;</div></li><li><div>            '.*wp-(atom|rdf|rss|rss2|feed|commentsrss2)\.php$' =&gt; $this-&gt;index . '?feed=old', &nbsp;</div></li><li><div>            '.*wp-app\.php(/.*)?$' =&gt; $this-&gt;index . '?error=403', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Registration rules.&nbsp;</div></li><li><div>        $registration_pages = array();&nbsp;</div></li><li><div>        if ( is_multisite() && is_main_site() ) {&nbsp;</div></li><li><div>            $registration_pages['.*wp-signup.php$'] = $this-&gt;index . '?signup=true';&nbsp;</div></li><li><div>            $registration_pages['.*wp-activate.php$'] = $this-&gt;index . '?activate=true';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Deprecated.&nbsp;</div></li><li><div>        $registration_pages['.*wp-register.php$'] = $this-&gt;index . '?register=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Post rewrite rules.&nbsp;</div></li><li><div>        $post_rewrite = $this-&gt;generate_rewrite_rules( $this-&gt;permalink_structure, EP_PERMALINK );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters rewrite rules used for &quot;post&quot; archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $post_rewrite The rewrite rules for posts.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $post_rewrite = apply_filters( 'post_rewrite_rules', $post_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Date rewrite rules.&nbsp;</div></li><li><div>        $date_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;get_date_permastruct(), EP_DATE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters rewrite rules used for date archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Likely date archives would include /yyyy/, /yyyy/mm/, and /yyyy/mm/dd/.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $date_rewrite The rewrite rules for date archives.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $date_rewrite = apply_filters( 'date_rewrite_rules', $date_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Root-level rewrite rules.&nbsp;</div></li><li><div>        $root_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;root . '/', EP_ROOT);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters rewrite rules used for root-level archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Likely root-level archives would include pagination rules for the homepage&nbsp;</div></li><li><div>         * as well as site-wide post feeds (e.g. /feed/, and /feed/atom/).&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $root_rewrite The root-level rewrite rules.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $root_rewrite = apply_filters( 'root_rewrite_rules', $root_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Comments rewrite rules.&nbsp;</div></li><li><div>        $comments_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;root . $this-&gt;comments_base, EP_COMMENTS, false, true, true, false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters rewrite rules used for comment feed archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Likely comments feed archives include /comments/feed/, and /comments/feed/atom/.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $comments_rewrite The rewrite rules for the site-wide comments feeds.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $comments_rewrite = apply_filters( 'comments_rewrite_rules', $comments_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Search rewrite rules.&nbsp;</div></li><li><div>        $search_structure = $this-&gt;get_search_permastruct();&nbsp;</div></li><li><div>        $search_rewrite = $this-&gt;generate_rewrite_rules($search_structure, EP_SEARCH);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters rewrite rules used for search archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Likely search-related archives include /search/search+query/ as well as&nbsp;</div></li><li><div>         * pagination and feed paths for a search.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $search_rewrite The rewrite rules for search queries.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $search_rewrite = apply_filters( 'search_rewrite_rules', $search_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Author rewrite rules.&nbsp;</div></li><li><div>        $author_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;get_author_permastruct(), EP_AUTHORS);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters rewrite rules used for author archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Likely author archives would include /author/author-name/, as well as&nbsp;</div></li><li><div>         * pagination and feed paths for author archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $author_rewrite The rewrite rules for author archives.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $author_rewrite = apply_filters( 'author_rewrite_rules', $author_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Pages rewrite rules.&nbsp;</div></li><li><div>        $page_rewrite = $this-&gt;page_rewrite_rules();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters rewrite rules used for &quot;page&quot; post type archives.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $page_rewrite The rewrite rules for the &quot;page&quot; post type.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $page_rewrite = apply_filters( 'page_rewrite_rules', $page_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Extra permastructs.&nbsp;</div></li><li><div>        foreach ( $this-&gt;extra_permastructs as $permastructname =&gt; $struct ) {&nbsp;</div></li><li><div>            if ( is_array( $struct ) ) {&nbsp;</div></li><li><div>                if ( count( $struct ) == 2 )&nbsp;</div></li><li><div>                    $rules = $this-&gt;generate_rewrite_rules( $struct[0], $struct[1] );&nbsp;</div></li><li><div>                else&nbsp;</div></li><li><div>                    $rules = $this-&gt;generate_rewrite_rules( $struct['struct'], $struct['ep_mask'], $struct['paged'], $struct['feed'], $struct['forcomments'], $struct['walk_dirs'], $struct['endpoints'] );&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $rules = $this-&gt;generate_rewrite_rules( $struct );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Filters rewrite rules used for individual permastructs.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * The dynamic portion of the hook name, `$permastructname`, refers&nbsp;</div></li><li><div>             * to the name of the registered permastruct, e.g. 'post_tag' (tags), &nbsp;</div></li><li><div>             * 'category' (categories), etc.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 3.1.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param array $rules The rewrite rules generated for the current permastruct.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            $rules = apply_filters( &quot;{$permastructname}_rewrite_rules&quot;, $rules );&nbsp;</div></li><li><div>            if ( 'post_tag' == $permastructname ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /**&nbsp;</div></li><li><div>                 * Filters rewrite rules used specifically for Tags.&nbsp;</div></li><li><div>                 *&nbsp;</div></li><li><div>                 * @since 2.3.0&nbsp;</div></li><li><div>                 * @deprecated 3.1.0 Use 'post_tag_rewrite_rules' instead&nbsp;</div></li><li><div>                 *&nbsp;</div></li><li><div>                 * @param array $rules The rewrite rules generated for tags.&nbsp;</div></li><li><div>                 */&nbsp;</div></li><li><div>                $rules = apply_filters( 'tag_rewrite_rules', $rules );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;extra_rules_top = array_merge($this-&gt;extra_rules_top, $rules);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Put them together.&nbsp;</div></li><li><div>        if ( $this-&gt;use_verbose_page_rules )&nbsp;</div></li><li><div>            $this-&gt;rules = array_merge($this-&gt;extra_rules_top, $robots_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite, $author_rewrite, $date_rewrite, $page_rewrite, $post_rewrite, $this-&gt;extra_rules);&nbsp;</div></li><li><div>        else&nbsp;</div></li><li><div>            $this-&gt;rules = array_merge($this-&gt;extra_rules_top, $robots_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite, $author_rewrite, $date_rewrite, $post_rewrite, $page_rewrite, $this-&gt;extra_rules);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Fires after the rewrite rules are generated.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param WP_Rewrite $this Current WP_Rewrite instance, passed by reference.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        do_action_ref_array( 'generate_rewrite_rules', array( &$this ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters the full set of generated rewrite rules.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array $this-&gt;rules The compiled array of rewrite rules.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $this-&gt;rules = apply_filters( 'rewrite_rules_array', $this-&gt;rules );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;rules;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves the rewrite rules.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The difference between this method and WP_Rewrite::rewrite_rules() is that&nbsp;</div></li><li><div>     * this method stores the rewrite rules in the 'rewrite_rules' option and retrieves&nbsp;</div></li><li><div>     * it. This prevents having to process all of the permalinks to get the rewrite rules&nbsp;</div></li><li><div>     * in the form of caching.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return array Rewrite rules.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function wp_rewrite_rules() {&nbsp;</div></li><li><div>        $this-&gt;rules = get_option('rewrite_rules');&nbsp;</div></li><li><div>        if ( empty($this-&gt;rules) ) {&nbsp;</div></li><li><div>            $this-&gt;matches = 'matches';&nbsp;</div></li><li><div>            $this-&gt;rewrite_rules();&nbsp;</div></li><li><div>            if ( ! did_action( 'wp_loaded' ) ) {&nbsp;</div></li><li><div>                add_action( 'wp_loaded', array( $this, 'flush_rules' ) );&nbsp;</div></li><li><div>                return $this-&gt;rules;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            update_option('rewrite_rules', $this-&gt;rules);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;rules;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves mod_rewrite-formatted rewrite rules to write to .htaccess.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Does not actually write to the .htaccess file, but creates the rules for&nbsp;</div></li><li><div>     * the process that will.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Will add the non_wp_rules property rules to the .htaccess file before&nbsp;</div></li><li><div>     * the WordPress rewrite rules one.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function mod_rewrite_rules() {&nbsp;</div></li><li><div>        if ( ! $this-&gt;using_permalinks() )&nbsp;</div></li><li><div>            return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $site_root = parse_url( site_url() );&nbsp;</div></li><li><div>        if ( isset( $site_root['path'] ) )&nbsp;</div></li><li><div>            $site_root = trailingslashit($site_root['path']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $home_root = parse_url(home_url());&nbsp;</div></li><li><div>        if ( isset( $home_root['path'] ) )&nbsp;</div></li><li><div>            $home_root = trailingslashit($home_root['path']);&nbsp;</div></li><li><div>        else&nbsp;</div></li><li><div>            $home_root = '/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $rules = &quot;&lt;IfModule mod_rewrite.c&gt;\n&quot;;&nbsp;</div></li><li><div>        $rules .= &quot;RewriteEngine On\n&quot;;&nbsp;</div></li><li><div>        $rules .= &quot;RewriteBase $home_root\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Prevent -f checks on index.php.&nbsp;</div></li><li><div>        $rules .= &quot;RewriteRule ^index\.php$ - [L]\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Add in the rules that don't redirect to WP's index.php (and thus shouldn't be handled by WP at all).&nbsp;</div></li><li><div>        foreach ( (array) $this-&gt;non_wp_rules as $match =&gt; $query) {&nbsp;</div></li><li><div>            // Apache 1.3 does not support the reluctant (non-greedy) modifier.&nbsp;</div></li><li><div>            $match = str_replace('.+?', '.+', $match);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . &quot; [QSA, L]\n&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( $this-&gt;use_verbose_rules ) {&nbsp;</div></li><li><div>            $this-&gt;matches = '';&nbsp;</div></li><li><div>            $rewrite = $this-&gt;rewrite_rules();&nbsp;</div></li><li><div>            $num_rules = count($rewrite);&nbsp;</div></li><li><div>            $rules .= &quot;RewriteCond %{REQUEST_FILENAME} -f [OR]\n&quot; .&nbsp;</div></li><li><div>                &quot;RewriteCond %{REQUEST_FILENAME} -d\n&quot; .&nbsp;</div></li><li><div>                &quot;RewriteRule ^.*$ - [S=$num_rules]\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            foreach ( (array) $rewrite as $match =&gt; $query) {&nbsp;</div></li><li><div>                // Apache 1.3 does not support the reluctant (non-greedy) modifier.&nbsp;</div></li><li><div>                $match = str_replace('.+?', '.+', $match);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ( strpos($query, $this-&gt;index) !== false )&nbsp;</div></li><li><div>                    $rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . &quot; [QSA, L]\n&quot;;&nbsp;</div></li><li><div>                else&nbsp;</div></li><li><div>                    $rules .= 'RewriteRule ^' . $match . ' ' . $site_root . $query . &quot; [QSA, L]\n&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $rules .= &quot;RewriteCond %{REQUEST_FILENAME} !-f\n&quot; .&nbsp;</div></li><li><div>                &quot;RewriteCond %{REQUEST_FILENAME} !-d\n&quot; .&nbsp;</div></li><li><div>                &quot;RewriteRule . {$home_root}{$this-&gt;index} [L]\n&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $rules .= &quot;&lt;/IfModule&gt;\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters the list of rewrite rules formatted for output to an .htaccess file.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $rules = apply_filters( 'mod_rewrite_rules', $rules );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters the list of rewrite rules formatted for output to an .htaccess file.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 1.5.0&nbsp;</div></li><li><div>         * @deprecated 1.5.0 Use the mod_rewrite_rules filter instead.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        return apply_filters( 'rewrite_rules', $rules );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Retrieves IIS7 URL Rewrite formatted rewrite rules to write to web.config file.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Does not actually write to the web.config file, but creates the rules for&nbsp;</div></li><li><div>     * the process that will.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.8.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param bool $add_parent_tags Optional. Whether to add parent tags to the rewrite rule sets.&nbsp;</div></li><li><div>     *                              Default false.&nbsp;</div></li><li><div>     * @return string IIS7 URL rewrite rule sets.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function iis7_url_rewrite_rules( $add_parent_tags = false ) {&nbsp;</div></li><li><div>        if ( ! $this-&gt;using_permalinks() )&nbsp;</div></li><li><div>            return '';&nbsp;</div></li><li><div>        $rules = '';&nbsp;</div></li><li><div>        if ( $add_parent_tags ) {&nbsp;</div></li><li><div>            $rules .= '&lt;configuration&gt;&nbsp;</div></li><li><div>    &lt;system.webServer&gt;&nbsp;</div></li><li><div>        &lt;rewrite&gt;&nbsp;</div></li><li><div>            &lt;rules&gt;';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $rules .= '&nbsp;</div></li><li><div>            &lt;rule name=&quot;WordPress: ' . esc_attr( home_url() ) . '&quot; patternSyntax=&quot;Wildcard&quot;&gt;&nbsp;</div></li><li><div>                &lt;match url=&quot;*&quot; /&gt;&nbsp;</div></li><li><div>                    &lt;conditions&gt;&nbsp;</div></li><li><div>                        &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot; /&gt;&nbsp;</div></li><li><div>                        &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot; /&gt;&nbsp;</div></li><li><div>                    &lt;/conditions&gt;&nbsp;</div></li><li><div>                &lt;action type=&quot;Rewrite&quot; url=&quot;index.php&quot; /&gt;&nbsp;</div></li><li><div>            &lt;/rule&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( $add_parent_tags ) {&nbsp;</div></li><li><div>            $rules .= '&nbsp;</div></li><li><div>            &lt;/rules&gt;&nbsp;</div></li><li><div>        &lt;/rewrite&gt;&nbsp;</div></li><li><div>    &lt;/system.webServer&gt;&nbsp;</div></li><li><div>&lt;/configuration&gt;';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters the list of rewrite rules formatted for output to a web.config.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 2.8.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param string $rules Rewrite rules formatted for IIS web.config.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        return apply_filters( 'iis7_url_rewrite_rules', $rules );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Adds a rewrite rule that transforms a URL structure to a set of query vars.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Any value in the $after parameter that isn't 'bottom' will result in the rule&nbsp;</div></li><li><div>     * being placed at the top of the rewrite rules.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.1.0&nbsp;</div></li><li><div>     * @since 4.4.0 Array support was added to the `$query` parameter.&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string       $regex Regular expression to match request against.&nbsp;</div></li><li><div>     * @param string|array $query The corresponding query vars for this rewrite rule.&nbsp;</div></li><li><div>     * @param string       $after Optional. Priority of the new rule. Accepts 'top'&nbsp;</div></li><li><div>     *                            or 'bottom'. Default 'bottom'.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function add_rule( $regex, $query, $after = 'bottom' ) {&nbsp;</div></li><li><div>        if ( is_array( $query ) ) {&nbsp;</div></li><li><div>            $external = false;&nbsp;</div></li><li><div>            $query = add_query_arg( $query, 'index.php' );&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $index = false === strpos( $query, '?' ) ? strlen( $query ) : strpos( $query, '?' );&nbsp;</div></li><li><div>            $front = substr( $query, 0, $index );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $external = $front != $this-&gt;index;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // &quot;external&quot; = it doesn't correspond to index.php.&nbsp;</div></li><li><div>        if ( $external ) {&nbsp;</div></li><li><div>            $this-&gt;add_external_rule( $regex, $query );&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            if ( 'bottom' == $after ) {&nbsp;</div></li><li><div>                $this-&gt;extra_rules = array_merge( $this-&gt;extra_rules, array( $regex =&gt; $query ) );&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $this-&gt;extra_rules_top = array_merge( $this-&gt;extra_rules_top, array( $regex =&gt; $query ) );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Adds a rewrite rule that doesn't correspond to index.php.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.1.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $regex Regular expression to match request against.&nbsp;</div></li><li><div>     * @param string $query The corresponding query vars for this rewrite rule.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function add_external_rule( $regex, $query ) {&nbsp;</div></li><li><div>        $this-&gt;non_wp_rules[ $regex ] = $query;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Adds an endpoint, like /trackback/.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.1.0&nbsp;</div></li><li><div>     * @since 3.9.0 $query_var parameter added.&nbsp;</div></li><li><div>     * @since 4.3.0 Added support for skipping query var registration by passing `false` to `$query_var`.&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see add_rewrite_endpoint() for full documentation.&nbsp;</div></li><li><div>     * @global WP $wp&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string      $name      Name of the endpoint.&nbsp;</div></li><li><div>     * @param int         $places    Endpoint mask describing the places the endpoint should be added.&nbsp;</div></li><li><div>     * @param string|bool $query_var Optional. Name of the corresponding query variable. Pass `false` to&nbsp;</div></li><li><div>     *                               skip registering a query_var for this endpoint. Defaults to the&nbsp;</div></li><li><div>     *                               value of `$name`.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function add_endpoint( $name, $places, $query_var = true ) {&nbsp;</div></li><li><div>        global $wp;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // For backward compatibility, if null has explicitly been passed as `$query_var`, assume `true`.&nbsp;</div></li><li><div>        if ( true === $query_var || null === func_get_arg( 2 ) ) {&nbsp;</div></li><li><div>            $query_var = $name;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $this-&gt;endpoints[] = array( $places, $name, $query_var );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( $query_var ) {&nbsp;</div></li><li><div>            $wp-&gt;add_query_var( $query_var );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Adds a new permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * A permalink structure (permastruct) is an abstract definition of a set of rewrite rules;&nbsp;</div></li><li><div>     * it is an easy way of expressing a set of regular expressions that rewrite to a set of&nbsp;</div></li><li><div>     * query strings. The new permastruct is added to the WP_Rewrite::$extra_permastructs array.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * When the rewrite rules are built by WP_Rewrite::rewrite_rules(), all of these extra&nbsp;</div></li><li><div>     * permastructs are passed to WP_Rewrite::generate_rewrite_rules() which transforms them&nbsp;</div></li><li><div>     * into the regular expressions that many love to hate.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The `$args` parameter gives you control over how WP_Rewrite::generate_rewrite_rules()&nbsp;</div></li><li><div>     * works on the new permastruct.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $name   Name for permalink structure.&nbsp;</div></li><li><div>     * @param string $struct Permalink structure (e.g. category/%category%)&nbsp;</div></li><li><div>     * @param array  $args   {&nbsp;</div></li><li><div>     *     Optional. Arguments for building rewrite rules based on the permalink structure.&nbsp;</div></li><li><div>     *     Default empty array.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     *     @type bool $with_front  Whether the structure should be prepended with `WP_Rewrite::$front`.&nbsp;</div></li><li><div>     *                             Default true.&nbsp;</div></li><li><div>     *     @type int  $ep_mask     The endpoint mask defining which endpoints are added to the structure.&nbsp;</div></li><li><div>     *                             Accepts `EP_NONE`, `EP_PERMALINK`, `EP_ATTACHMENT`, `EP_DATE`, `EP_YEAR`, &nbsp;</div></li><li><div>     *                             `EP_MONTH`, `EP_DAY`, `EP_ROOT`, `EP_COMMENTS`, `EP_SEARCH`, `EP_CATEGORIES`, &nbsp;</div></li><li><div>     *                             `EP_TAGS`, `EP_AUTHORS`, `EP_PAGES`, `EP_ALL_ARCHIVES`, and `EP_ALL`.&nbsp;</div></li><li><div>     *                             Default `EP_NONE`.&nbsp;</div></li><li><div>     *     @type bool $paged       Whether archive pagination rules should be added for the structure.&nbsp;</div></li><li><div>     *                             Default true.&nbsp;</div></li><li><div>     *     @type bool $feed        Whether feed rewrite rules should be added for the structure. Default true.&nbsp;</div></li><li><div>     *     @type bool $forcomments Whether the feed rules should be a query for a comments feed. Default false.&nbsp;</div></li><li><div>     *     @type bool $walk_dirs   Whether the 'directories' making up the structure should be walked over&nbsp;</div></li><li><div>     *                             and rewrite rules built for each in-turn. Default true.&nbsp;</div></li><li><div>     *     @type bool $endpoints   Whether endpoints should be applied to the generated rules. Default true.&nbsp;</div></li><li><div>     * }&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function add_permastruct( $name, $struct, $args = array() ) {&nbsp;</div></li><li><div>        // Back-compat for the old parameters: $with_front and $ep_mask.&nbsp;</div></li><li><div>        if ( ! is_array( $args ) )&nbsp;</div></li><li><div>            $args = array( 'with_front' =&gt; $args );&nbsp;</div></li><li><div>        if ( func_num_args() == 4 )&nbsp;</div></li><li><div>            $args['ep_mask'] = func_get_arg( 3 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $defaults = array(&nbsp;</div></li><li><div>            'with_front' =&gt; true, &nbsp;</div></li><li><div>            'ep_mask' =&gt; EP_NONE, &nbsp;</div></li><li><div>            'paged' =&gt; true, &nbsp;</div></li><li><div>            'feed' =&gt; true, &nbsp;</div></li><li><div>            'forcomments' =&gt; false, &nbsp;</div></li><li><div>            'walk_dirs' =&gt; true, &nbsp;</div></li><li><div>            'endpoints' =&gt; true, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        $args = array_intersect_key( $args, $defaults );&nbsp;</div></li><li><div>        $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( $args['with_front'] )&nbsp;</div></li><li><div>            $struct = $this-&gt;front . $struct;&nbsp;</div></li><li><div>        else&nbsp;</div></li><li><div>            $struct = $this-&gt;root . $struct;&nbsp;</div></li><li><div>        $args['struct'] = $struct;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;extra_permastructs[ $name ] = $args;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Removes a permalink structure.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 4.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $name Name for permalink structure.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function remove_permastruct( $name ) {&nbsp;</div></li><li><div>        unset( $this-&gt;extra_permastructs[ $name ] );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Removes rewrite rules and then recreate rewrite rules.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Calls WP_Rewrite::wp_rewrite_rules() after removing the 'rewrite_rules' option.&nbsp;</div></li><li><div>     * If the function named 'save_mod_rewrite_rules' exists, it will be called.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.0.1&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @staticvar bool $do_hard_later&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param bool $hard Whether to update .htaccess (hard flush) or just update rewrite_rules option (soft flush). Default is true (hard).&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function flush_rules( $hard = true ) {&nbsp;</div></li><li><div>        static $do_hard_later = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Prevent this action from running before everyone has registered their rewrites.&nbsp;</div></li><li><div>        if ( ! did_action( 'wp_loaded' ) ) {&nbsp;</div></li><li><div>            add_action( 'wp_loaded', array( $this, 'flush_rules' ) );&nbsp;</div></li><li><div>            $do_hard_later = ( isset( $do_hard_later ) ) ? $do_hard_later || $hard : $hard;&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( isset( $do_hard_later ) ) {&nbsp;</div></li><li><div>            $hard = $do_hard_later;&nbsp;</div></li><li><div>            unset( $do_hard_later );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        update_option( 'rewrite_rules', '' );&nbsp;</div></li><li><div>        $this-&gt;wp_rewrite_rules();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters whether a &quot;hard&quot; rewrite rule flush should be performed when requested.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * A &quot;hard&quot; flush updates .htaccess (Apache) or web.config (IIS).&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 3.7.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param bool $hard Whether to flush rewrite rules &quot;hard&quot;. Default true.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        if ( ! $hard || ! apply_filters( 'flush_rewrite_rules_hard', true ) ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ( function_exists( 'save_mod_rewrite_rules' ) )&nbsp;</div></li><li><div>            save_mod_rewrite_rules();&nbsp;</div></li><li><div>        if ( function_exists( 'iis7_save_url_rewrite_rules' ) )&nbsp;</div></li><li><div>            iis7_save_url_rewrite_rules();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Sets up the object's properties.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The 'use_verbose_page_rules' object property will be set to true if the&nbsp;</div></li><li><div>     * permalink structure begins with one of the following: '%postname%', '%category%', &nbsp;</div></li><li><div>     * '%tag%', or '%author%'.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function init() {&nbsp;</div></li><li><div>        $this-&gt;extra_rules = $this-&gt;non_wp_rules = $this-&gt;endpoints = array();&nbsp;</div></li><li><div>        $this-&gt;permalink_structure = get_option('permalink_structure');&nbsp;</div></li><li><div>        $this-&gt;front = substr($this-&gt;permalink_structure, 0, strpos($this-&gt;permalink_structure, '%'));&nbsp;</div></li><li><div>        $this-&gt;root = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( $this-&gt;using_index_permalinks() )&nbsp;</div></li><li><div>            $this-&gt;root = $this-&gt;index . '/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        unset($this-&gt;author_structure);&nbsp;</div></li><li><div>        unset($this-&gt;date_structure);&nbsp;</div></li><li><div>        unset($this-&gt;page_structure);&nbsp;</div></li><li><div>        unset($this-&gt;search_structure);&nbsp;</div></li><li><div>        unset($this-&gt;feed_structure);&nbsp;</div></li><li><div>        unset($this-&gt;comment_feed_structure);&nbsp;</div></li><li><div>        $this-&gt;use_trailing_slashes = ( '/' == substr($this-&gt;permalink_structure, -1, 1) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Enable generic rules for pages if permalink structure doesn't begin with a wildcard.&nbsp;</div></li><li><div>        if ( preg_match(&quot;/^[^%]*%(?:postname|category|tag|author)%/&quot;, $this-&gt;permalink_structure) )&nbsp;</div></li><li><div>             $this-&gt;use_verbose_page_rules = true;&nbsp;</div></li><li><div>        else&nbsp;</div></li><li><div>            $this-&gt;use_verbose_page_rules = false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Sets the main permalink structure for the site.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Will update the 'permalink_structure' option, if there is a difference&nbsp;</div></li><li><div>     * between the current permalink structure and the parameter value. Calls&nbsp;</div></li><li><div>     * WP_Rewrite::init() after the option is updated.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Fires the {@see 'permalink_structure_changed'} action once the init call has&nbsp;</div></li><li><div>     * processed passing the old and new values&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $permalink_structure Permalink structure.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function set_permalink_structure($permalink_structure) {&nbsp;</div></li><li><div>        if ( $permalink_structure != $this-&gt;permalink_structure ) {&nbsp;</div></li><li><div>            $old_permalink_structure = $this-&gt;permalink_structure;&nbsp;</div></li><li><div>            update_option('permalink_structure', $permalink_structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;init();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Fires after the permalink structure is updated.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 2.8.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param string $old_permalink_structure The previous permalink structure.&nbsp;</div></li><li><div>             * @param string $permalink_structure     The new permalink structure.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            do_action( 'permalink_structure_changed', $old_permalink_structure, $permalink_structure );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Sets the category base for the category permalink.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Will update the 'category_base' option, if there is a difference between&nbsp;</div></li><li><div>     * the current category base and the parameter value. Calls WP_Rewrite::init()&nbsp;</div></li><li><div>     * after the option is updated.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $category_base Category permalink structure base.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function set_category_base($category_base) {&nbsp;</div></li><li><div>        if ( $category_base != get_option('category_base') ) {&nbsp;</div></li><li><div>            update_option('category_base', $category_base);&nbsp;</div></li><li><div>            $this-&gt;init();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Sets the tag base for the tag permalink.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Will update the 'tag_base' option, if there is a difference between the&nbsp;</div></li><li><div>     * current tag base and the parameter value. Calls WP_Rewrite::init() after&nbsp;</div></li><li><div>     * the option is updated.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.3.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $tag_base Tag permalink structure base.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function set_tag_base( $tag_base ) {&nbsp;</div></li><li><div>        if ( $tag_base != get_option( 'tag_base') ) {&nbsp;</div></li><li><div>            update_option( 'tag_base', $tag_base );&nbsp;</div></li><li><div>            $this-&gt;init();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Constructor - Calls init(), which runs setup.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 1.5.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function __construct() {&nbsp;</div></li><li><div>        $this-&gt;init();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 1.5.0</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/4.7.4/classes/wp_rewrite/" class="active">4.7.4</a></li><li><a href="http://hookr.io/4.7.3/classes/wp_rewrite/" class="">4.7.3</a></li><li><a href="http://hookr.io/4.7.2/classes/wp_rewrite/" class="">4.7.2</a></li><li><a href="http://hookr.io/4.7.1/classes/wp_rewrite/" class="">4.7.1</a></li><li><a href="http://hookr.io/4.7/classes/wp_rewrite/" class="">4.7</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>class</li><li><span></span>WP_Rewrite</li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>