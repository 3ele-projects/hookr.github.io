<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="wordpress" data-version="4.7.4" data-type="class" data-id="1326"><head xmlns="http://www.w3.org/1999/xhtml"><title> getid3_riff | class | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="getid3_riff, class, wordpress, 4.7.4" /><meta name="description" content="The WordPress Core getid3 riff class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=a934be7969411c3f52ae7e3971e7ecad' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/getid3_riff/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fgetid3_riff%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fgetid3_riff%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-class-getid3_riff","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="getid3_riff" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="http://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/4.7.4/classes/" class=""><span property="name">classes</span></a><meta property="position" content="3"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">getid3_riff</span><meta property="position" content="4"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="http://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="http://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="http://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="http://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="active" data-id="class" data-count="351"><a href="http://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="http://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>getid3_riff</strong></h1><p>The WordPress Core <strong>getid3 riff</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/4.7.4/files/wp-includes-id3-module-audio-video-riff/" class="file">/wp-includes/ID3/module.audio-video.riff.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="30" class="block" start="30"><li><div>class getid3_riff extends getid3_handler {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    protected $container = 'riff'; // default&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function Analyze() {&nbsp;</div></li><li><div>        $info = &$this-&gt;getid3-&gt;info;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // initialize these values to an empty array, otherwise they default to NULL&nbsp;</div></li><li><div>        // and you can't append array values to a NULL value&nbsp;</div></li><li><div>        $info['riff'] = array('raw'=&gt;array());&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Shortcuts&nbsp;</div></li><li><div>        $thisfile_riff = &$info['riff'];&nbsp;</div></li><li><div>        $thisfile_riff_raw = &$thisfile_riff['raw'];&nbsp;</div></li><li><div>        $thisfile_audio = &$info['audio'];&nbsp;</div></li><li><div>        $thisfile_video = &$info['video'];&nbsp;</div></li><li><div>        $thisfile_audio_dataformat = &$thisfile_audio['dataformat'];&nbsp;</div></li><li><div>        $thisfile_riff_audio = &$thisfile_riff['audio'];&nbsp;</div></li><li><div>        $thisfile_riff_video = &$thisfile_riff['video'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $Original['avdataoffset'] = $info['avdataoffset'];&nbsp;</div></li><li><div>        $Original['avdataend'] = $info['avdataend'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;fseek($info['avdataoffset']);&nbsp;</div></li><li><div>        $RIFFheader = $this-&gt;fread(12);&nbsp;</div></li><li><div>        $offset = $this-&gt;ftell();&nbsp;</div></li><li><div>        $RIFFtype = substr($RIFFheader, 0, 4);&nbsp;</div></li><li><div>        $RIFFsize = substr($RIFFheader, 4, 4);&nbsp;</div></li><li><div>        $RIFFsubtype = substr($RIFFheader, 8, 4);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        switch ($RIFFtype) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'FORM':  // AIFF, AIFC&nbsp;</div></li><li><div>                //$info['fileformat'] = 'aiff';&nbsp;</div></li><li><div>                $this-&gt;container = 'aiff';&nbsp;</div></li><li><div>                $thisfile_riff['header_size'] = $this-&gt;EitherEndian2Int($RIFFsize);&nbsp;</div></li><li><div>                $thisfile_riff[$RIFFsubtype] = $this-&gt;ParseRIFF($offset, ($offset + $thisfile_riff['header_size'] - 4));&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'RIFF':  // AVI, WAV, etc&nbsp;</div></li><li><div>            case 'SDSS':  // SDSS is identical to RIFF, just renamed. Used by SmartSound QuickTracks (www.smartsound.com)&nbsp;</div></li><li><div>            case 'RMP3':  // RMP3 is identical to RIFF, just renamed. Used by [unknown program] when creating RIFF-MP3s&nbsp;</div></li><li><div>                //$info['fileformat'] = 'riff';&nbsp;</div></li><li><div>                $this-&gt;container = 'riff';&nbsp;</div></li><li><div>                $thisfile_riff['header_size'] = $this-&gt;EitherEndian2Int($RIFFsize);&nbsp;</div></li><li><div>                if ($RIFFsubtype == 'RMP3') {&nbsp;</div></li><li><div>                    // RMP3 is identical to WAVE, just renamed. Used by [unknown program] when creating RIFF-MP3s&nbsp;</div></li><li><div>                    $RIFFsubtype = 'WAVE';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($RIFFsubtype != 'AMV ') {&nbsp;</div></li><li><div>                    // AMV files are RIFF-AVI files with parts of the spec deliberately broken, such as chunk size fields hardcoded to zero (because players known in hardware that these fields are always a certain size&nbsp;</div></li><li><div>                    // Handled separately in ParseRIFFAMV()&nbsp;</div></li><li><div>                    $thisfile_riff[$RIFFsubtype] = $this-&gt;ParseRIFF($offset, ($offset + $thisfile_riff['header_size'] - 4));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (($info['avdataend'] - $info['filesize']) == 1) {&nbsp;</div></li><li><div>                    // LiteWave appears to incorrectly *not* pad actual output file&nbsp;</div></li><li><div>                    // to nearest WORD boundary so may appear to be short by one&nbsp;</div></li><li><div>                    // byte, in which case - skip warning&nbsp;</div></li><li><div>                    $info['avdataend'] = $info['filesize'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $nextRIFFoffset = $Original['avdataoffset'] + 8 + $thisfile_riff['header_size']; // 8 = &quot;RIFF&quot; + 32-bit offset&nbsp;</div></li><li><div>                while ($nextRIFFoffset &lt; min($info['filesize'], $info['avdataend'])) {&nbsp;</div></li><li><div>                    try {&nbsp;</div></li><li><div>                        $this-&gt;fseek($nextRIFFoffset);&nbsp;</div></li><li><div>                    } catch (getid3_exception $e) {&nbsp;</div></li><li><div>                        if ($e-&gt;getCode() == 10) {&nbsp;</div></li><li><div>                            //$this-&gt;warning('RIFF parser: '.$e-&gt;getMessage());&nbsp;</div></li><li><div>                            $this-&gt;error('AVI extends beyond '.round(PHP_INT_MAX / 1073741824).'GB and PHP filesystem functions cannot read that far, playtime may be wrong');&nbsp;</div></li><li><div>                            $this-&gt;warning('[avdataend] value may be incorrect, multiple AVIX chunks may be present');&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            throw $e;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $nextRIFFheader = $this-&gt;fread(12);&nbsp;</div></li><li><div>                    if ($nextRIFFoffset == ($info['avdataend'] - 1)) {&nbsp;</div></li><li><div>                        if (substr($nextRIFFheader, 0, 1) == &quot;\x00&quot;) {&nbsp;</div></li><li><div>                            // RIFF padded to WORD boundary, we're actually already at the end&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $nextRIFFheaderID =                         substr($nextRIFFheader, 0, 4);&nbsp;</div></li><li><div>                    $nextRIFFsize = $this-&gt;EitherEndian2Int(substr($nextRIFFheader, 4, 4));&nbsp;</div></li><li><div>                    $nextRIFFtype =                         substr($nextRIFFheader, 8, 4);&nbsp;</div></li><li><div>                    $chunkdata = array();&nbsp;</div></li><li><div>                    $chunkdata['offset'] = $nextRIFFoffset + 8;&nbsp;</div></li><li><div>                    $chunkdata['size'] = $nextRIFFsize;&nbsp;</div></li><li><div>                    $nextRIFFoffset = $chunkdata['offset'] + $chunkdata['size'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    switch ($nextRIFFheaderID) {&nbsp;</div></li><li><div>                        case 'RIFF':&nbsp;</div></li><li><div>                            $chunkdata['chunks'] = $this-&gt;ParseRIFF($chunkdata['offset'] + 4, $nextRIFFoffset);&nbsp;</div></li><li><div>                            if (!isset($thisfile_riff[$nextRIFFtype])) {&nbsp;</div></li><li><div>                                $thisfile_riff[$nextRIFFtype] = array();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $thisfile_riff[$nextRIFFtype][] = $chunkdata;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        case 'AMV ':&nbsp;</div></li><li><div>                            unset($info['riff']);&nbsp;</div></li><li><div>                            $info['amv'] = $this-&gt;ParseRIFFAMV($chunkdata['offset'] + 4, $nextRIFFoffset);&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        case 'JUNK':&nbsp;</div></li><li><div>                            // ignore&nbsp;</div></li><li><div>                            $thisfile_riff[$nextRIFFheaderID][] = $chunkdata;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        case 'IDVX':&nbsp;</div></li><li><div>                            $info['divxtag']['comments'] = self::ParseDIVXTAG($this-&gt;fread($chunkdata['size']));&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        default:&nbsp;</div></li><li><div>                            if ($info['filesize'] == ($chunkdata['offset'] - 8 + 128)) {&nbsp;</div></li><li><div>                                $DIVXTAG = $nextRIFFheader.$this-&gt;fread(128 - 12);&nbsp;</div></li><li><div>                                if (substr($DIVXTAG, -7) == 'DIVXTAG') {&nbsp;</div></li><li><div>                                    // DIVXTAG is supposed to be inside an IDVX chunk in a LIST chunk, but some bad encoders just slap it on the end of a file&nbsp;</div></li><li><div>                                    $this-&gt;warning('Found wrongly-structured DIVXTAG at offset '.($this-&gt;ftell() - 128).', parsing anyway');&nbsp;</div></li><li><div>                                    $info['divxtag']['comments'] = self::ParseDIVXTAG($DIVXTAG);&nbsp;</div></li><li><div>                                    break 2;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $this-&gt;warning('Expecting &quot;RIFF|JUNK|IDVX&quot; at '.$nextRIFFoffset.', found &quot;'.$nextRIFFheaderID.'&quot; ('.getid3_lib::PrintHexBytes($nextRIFFheaderID).') - skipping rest of file');&nbsp;</div></li><li><div>                            break 2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($RIFFsubtype == 'WAVE') {&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE = &$thisfile_riff['WAVE'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                $this-&gt;error('Cannot parse RIFF (this is maybe not a RIFF / WAV / AVI file?) - expecting &quot;FORM|RIFF|SDSS|RMP3&quot; found &quot;'.$RIFFsubtype.'&quot; instead');&nbsp;</div></li><li><div>                //unset($info['fileformat']);&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $streamindex = 0;&nbsp;</div></li><li><div>        switch ($RIFFsubtype) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // http://en.wikipedia.org/wiki/Wav&nbsp;</div></li><li><div>            case 'WAVE':&nbsp;</div></li><li><div>                $info['fileformat'] = 'wav';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (empty($thisfile_audio['bitrate_mode'])) {&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate_mode'] = 'cbr';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (empty($thisfile_audio_dataformat)) {&nbsp;</div></li><li><div>                    $thisfile_audio_dataformat = 'wav';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['data'][0]['offset'])) {&nbsp;</div></li><li><div>                    $info['avdataoffset'] = $thisfile_riff_WAVE['data'][0]['offset'] + 8;&nbsp;</div></li><li><div>                    $info['avdataend'] = $info['avdataoffset'] + $thisfile_riff_WAVE['data'][0]['size'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['fmt '][0]['data'])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_audio[$streamindex] = self::parseWAVEFORMATex($thisfile_riff_WAVE['fmt '][0]['data']);&nbsp;</div></li><li><div>                    $thisfile_audio['wformattag'] = $thisfile_riff_audio[$streamindex]['raw']['wFormatTag'];&nbsp;</div></li><li><div>                    if (!isset($thisfile_riff_audio[$streamindex]['bitrate']) || ($thisfile_riff_audio[$streamindex]['bitrate'] == 0)) {&nbsp;</div></li><li><div>                        $info['error'][] = 'Corrupt RIFF file: bitrate_audio == zero';&nbsp;</div></li><li><div>                        return false;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $thisfile_riff_raw['fmt '] = $thisfile_riff_audio[$streamindex]['raw'];&nbsp;</div></li><li><div>                    unset($thisfile_riff_audio[$streamindex]['raw']);&nbsp;</div></li><li><div>                    $thisfile_audio['streams'][$streamindex] = $thisfile_riff_audio[$streamindex];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_audio = getid3_lib::array_merge_noclobber($thisfile_audio, $thisfile_riff_audio[$streamindex]);&nbsp;</div></li><li><div>                    if (substr($thisfile_audio['codec'], 0, strlen('unknown: 0x')) == 'unknown: 0x') {&nbsp;</div></li><li><div>                        $info['warning'][] = 'Audio codec = '.$thisfile_audio['codec'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate'] = $thisfile_riff_audio[$streamindex]['bitrate'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if (empty($info['playtime_seconds'])) { // may already be set (e.g. DTS-WAV)&nbsp;</div></li><li><div>                        $info['playtime_seconds'] = (float) ((($info['avdataend'] - $info['avdataoffset']) * 8) / $thisfile_audio['bitrate']);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_audio['lossless'] = false;&nbsp;</div></li><li><div>                    if (isset($thisfile_riff_WAVE['data'][0]['offset']) && isset($thisfile_riff_raw['fmt ']['wFormatTag'])) {&nbsp;</div></li><li><div>                        switch ($thisfile_riff_raw['fmt ']['wFormatTag']) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            case 0x0001:  // PCM&nbsp;</div></li><li><div>                                $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            case 0x2000:  // AC-3&nbsp;</div></li><li><div>                                $thisfile_audio_dataformat = 'ac3';&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            default:&nbsp;</div></li><li><div>                                // do nothing&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $thisfile_audio['streams'][$streamindex]['wformattag'] = $thisfile_audio['wformattag'];&nbsp;</div></li><li><div>                    $thisfile_audio['streams'][$streamindex]['bitrate_mode'] = $thisfile_audio['bitrate_mode'];&nbsp;</div></li><li><div>                    $thisfile_audio['streams'][$streamindex]['lossless'] = $thisfile_audio['lossless'];&nbsp;</div></li><li><div>                    $thisfile_audio['streams'][$streamindex]['dataformat'] = $thisfile_audio_dataformat;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['rgad'][0]['data'])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // shortcuts&nbsp;</div></li><li><div>                    $rgadData = &$thisfile_riff_WAVE['rgad'][0]['data'];&nbsp;</div></li><li><div>                    $thisfile_riff_raw['rgad'] = array('track'=&gt;array(), 'album'=&gt;array());&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad = &$thisfile_riff_raw['rgad'];&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_track = &$thisfile_riff_raw_rgad['track'];&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_album = &$thisfile_riff_raw_rgad['album'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad['fPeakAmplitude'] = getid3_lib::LittleEndian2Float(substr($rgadData, 0, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad['nRadioRgAdjust'] =        $this-&gt;EitherEndian2Int(substr($rgadData, 4, 2));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad['nAudiophileRgAdjust'] =        $this-&gt;EitherEndian2Int(substr($rgadData, 6, 2));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $nRadioRgAdjustBitstring = str_pad(getid3_lib::Dec2Bin($thisfile_riff_raw_rgad['nRadioRgAdjust']), 16, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>                    $nAudiophileRgAdjustBitstring = str_pad(getid3_lib::Dec2Bin($thisfile_riff_raw_rgad['nAudiophileRgAdjust']), 16, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_track['name'] = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 0, 3));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_track['originator'] = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 3, 3));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_track['signbit'] = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 6, 1));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_track['adjustment'] = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 7, 9));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_album['name'] = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 0, 3));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_album['originator'] = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 3, 3));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_album['signbit'] = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 6, 1));&nbsp;</div></li><li><div>                    $thisfile_riff_raw_rgad_album['adjustment'] = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 7, 9));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff['rgad']['peakamplitude'] = $thisfile_riff_raw_rgad['fPeakAmplitude'];&nbsp;</div></li><li><div>                    if (($thisfile_riff_raw_rgad_track['name'] != 0) && ($thisfile_riff_raw_rgad_track['originator'] != 0)) {&nbsp;</div></li><li><div>                        $thisfile_riff['rgad']['track']['name'] = getid3_lib::RGADnameLookup($thisfile_riff_raw_rgad_track['name']);&nbsp;</div></li><li><div>                        $thisfile_riff['rgad']['track']['originator'] = getid3_lib::RGADoriginatorLookup($thisfile_riff_raw_rgad_track['originator']);&nbsp;</div></li><li><div>                        $thisfile_riff['rgad']['track']['adjustment'] = getid3_lib::RGADadjustmentLookup($thisfile_riff_raw_rgad_track['adjustment'], $thisfile_riff_raw_rgad_track['signbit']);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if (($thisfile_riff_raw_rgad_album['name'] != 0) && ($thisfile_riff_raw_rgad_album['originator'] != 0)) {&nbsp;</div></li><li><div>                        $thisfile_riff['rgad']['album']['name'] = getid3_lib::RGADnameLookup($thisfile_riff_raw_rgad_album['name']);&nbsp;</div></li><li><div>                        $thisfile_riff['rgad']['album']['originator'] = getid3_lib::RGADoriginatorLookup($thisfile_riff_raw_rgad_album['originator']);&nbsp;</div></li><li><div>                        $thisfile_riff['rgad']['album']['adjustment'] = getid3_lib::RGADadjustmentLookup($thisfile_riff_raw_rgad_album['adjustment'], $thisfile_riff_raw_rgad_album['signbit']);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['fact'][0]['data'])) {&nbsp;</div></li><li><div>                    $thisfile_riff_raw['fact']['NumberOfSamples'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_WAVE['fact'][0]['data'], 0, 4));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // This should be a good way of calculating exact playtime, &nbsp;</div></li><li><div>                    // but some sample files have had incorrect number of samples, &nbsp;</div></li><li><div>                    // so cannot use this method&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // if (!empty($thisfile_riff_raw['fmt ']['nSamplesPerSec'])) {&nbsp;</div></li><li><div>                    //     $info['playtime_seconds'] = (float) $thisfile_riff_raw['fact']['NumberOfSamples'] / $thisfile_riff_raw['fmt ']['nSamplesPerSec'];&nbsp;</div></li><li><div>                    // }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (!empty($thisfile_riff_raw['fmt ']['nAvgBytesPerSec'])) {&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate'] = getid3_lib::CastAsInt($thisfile_riff_raw['fmt ']['nAvgBytesPerSec'] * 8);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['bext'][0]['data'])) {&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0 = &$thisfile_riff_WAVE['bext'][0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['title'] =                         trim(substr($thisfile_riff_WAVE_bext_0['data'], 0, 256));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['author'] =                         trim(substr($thisfile_riff_WAVE_bext_0['data'], 256, 32));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['reference'] =                         trim(substr($thisfile_riff_WAVE_bext_0['data'], 288, 32));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['origin_date'] =                              substr($thisfile_riff_WAVE_bext_0['data'], 320, 10);&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['origin_time'] =                              substr($thisfile_riff_WAVE_bext_0['data'], 330, 8);&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['time_reference'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_bext_0['data'], 338, 8));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['bwf_version'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_bext_0['data'], 346, 1));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['reserved'] =                              substr($thisfile_riff_WAVE_bext_0['data'], 347, 254);&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_bext_0['coding_history'] =         explode(&quot;\r\n&quot;, trim(substr($thisfile_riff_WAVE_bext_0['data'], 601)));&nbsp;</div></li><li><div>                    if (preg_match('#^([0-9]{4}).([0-9]{2}).([0-9]{2})$#', $thisfile_riff_WAVE_bext_0['origin_date'], $matches_bext_date)) {&nbsp;</div></li><li><div>                        if (preg_match('#^([0-9]{2}).([0-9]{2}).([0-9]{2})$#', $thisfile_riff_WAVE_bext_0['origin_time'], $matches_bext_time)) {&nbsp;</div></li><li><div>                            list($dummy, $bext_timestamp['year'], $bext_timestamp['month'], $bext_timestamp['day']) = $matches_bext_date;&nbsp;</div></li><li><div>                            list($dummy, $bext_timestamp['hour'], $bext_timestamp['minute'], $bext_timestamp['second']) = $matches_bext_time;&nbsp;</div></li><li><div>                            $thisfile_riff_WAVE_bext_0['origin_date_unix'] = gmmktime($bext_timestamp['hour'], $bext_timestamp['minute'], $bext_timestamp['second'], $bext_timestamp['month'], $bext_timestamp['day'], $bext_timestamp['year']);&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $info['warning'][] = 'RIFF.WAVE.BEXT.origin_time is invalid';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $info['warning'][] = 'RIFF.WAVE.BEXT.origin_date is invalid';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $thisfile_riff['comments']['author'][] = $thisfile_riff_WAVE_bext_0['author'];&nbsp;</div></li><li><div>                    $thisfile_riff['comments']['title'][] = $thisfile_riff_WAVE_bext_0['title'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['MEXT'][0]['data'])) {&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0 = &$thisfile_riff_WAVE['MEXT'][0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 0, 2));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0['flags']['homogenous'] = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] & 0x0001);&nbsp;</div></li><li><div>                    if ($thisfile_riff_WAVE_MEXT_0['flags']['homogenous']) {&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE_MEXT_0['flags']['padding'] = ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] & 0x0002) ? false : true;&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE_MEXT_0['flags']['22_or_44'] =        (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] & 0x0004);&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE_MEXT_0['flags']['free_format'] =        (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] & 0x0008);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE_MEXT_0['nominal_frame_size'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 2, 2));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0['anciliary_data_length'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 6, 2));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 8, 2));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0['flags']['anciliary_data_left'] = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def'] & 0x0001);&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0['flags']['anciliary_data_free'] = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def'] & 0x0002);&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_MEXT_0['flags']['anciliary_data_right'] = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def'] & 0x0004);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['cart'][0]['data'])) {&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0 = &$thisfile_riff_WAVE['cart'][0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['version'] =                              substr($thisfile_riff_WAVE_cart_0['data'], 0, 4);&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['title'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 4, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['artist'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 68, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['cut_id'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 132, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['client_id'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 196, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['category'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 260, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['classification'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 324, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['out_cue'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 388, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['start_date'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 452, 10));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['start_time'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 462, 8));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['end_date'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 470, 10));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['end_time'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 480, 8));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['producer_app_id'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 488, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['producer_app_version'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 552, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['user_defined_text'] =                         trim(substr($thisfile_riff_WAVE_cart_0['data'], 616, 64));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['zero_db_reference'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_cart_0['data'], 680, 4), true);&nbsp;</div></li><li><div>                    for ($i = 0; $i &lt; 8; $i++) {&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE_cart_0['post_time'][$i]['usage_fourcc'] =                  substr($thisfile_riff_WAVE_cart_0['data'], 684 + ($i * 8), 4);&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE_cart_0['post_time'][$i]['timer_value'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_cart_0['data'], 684 + ($i * 8) + 4, 4));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['url'] =                 trim(substr($thisfile_riff_WAVE_cart_0['data'], 748, 1024));&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_cart_0['tag_text'] = explode(&quot;\r\n&quot;, trim(substr($thisfile_riff_WAVE_cart_0['data'], 1772)));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff['comments']['artist'][] = $thisfile_riff_WAVE_cart_0['artist'];&nbsp;</div></li><li><div>                    $thisfile_riff['comments']['title'][] = $thisfile_riff_WAVE_cart_0['title'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['SNDM'][0]['data'])) {&nbsp;</div></li><li><div>                    // SoundMiner metadata&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // shortcuts&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_SNDM_0 = &$thisfile_riff_WAVE['SNDM'][0];&nbsp;</div></li><li><div>                    $thisfile_riff_WAVE_SNDM_0_data = &$thisfile_riff_WAVE_SNDM_0['data'];&nbsp;</div></li><li><div>                    $SNDM_startoffset = 0;&nbsp;</div></li><li><div>                    $SNDM_endoffset = $thisfile_riff_WAVE_SNDM_0['size'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    while ($SNDM_startoffset &lt; $SNDM_endoffset) {&nbsp;</div></li><li><div>                        $SNDM_thisTagOffset = 0;&nbsp;</div></li><li><div>                        $SNDM_thisTagSize = getid3_lib::BigEndian2Int(substr($thisfile_riff_WAVE_SNDM_0_data, $SNDM_startoffset + $SNDM_thisTagOffset, 4));&nbsp;</div></li><li><div>                        $SNDM_thisTagOffset += 4;&nbsp;</div></li><li><div>                        $SNDM_thisTagKey =                           substr($thisfile_riff_WAVE_SNDM_0_data, $SNDM_startoffset + $SNDM_thisTagOffset, 4);&nbsp;</div></li><li><div>                        $SNDM_thisTagOffset += 4;&nbsp;</div></li><li><div>                        $SNDM_thisTagDataSize = getid3_lib::BigEndian2Int(substr($thisfile_riff_WAVE_SNDM_0_data, $SNDM_startoffset + $SNDM_thisTagOffset, 2));&nbsp;</div></li><li><div>                        $SNDM_thisTagOffset += 2;&nbsp;</div></li><li><div>                        $SNDM_thisTagDataFlags = getid3_lib::BigEndian2Int(substr($thisfile_riff_WAVE_SNDM_0_data, $SNDM_startoffset + $SNDM_thisTagOffset, 2));&nbsp;</div></li><li><div>                        $SNDM_thisTagOffset += 2;&nbsp;</div></li><li><div>                        $SNDM_thisTagDataText =                            substr($thisfile_riff_WAVE_SNDM_0_data, $SNDM_startoffset + $SNDM_thisTagOffset, $SNDM_thisTagDataSize);&nbsp;</div></li><li><div>                        $SNDM_thisTagOffset += $SNDM_thisTagDataSize;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ($SNDM_thisTagSize != (4 + 4 + 2 + 2 + $SNDM_thisTagDataSize)) {&nbsp;</div></li><li><div>                            $info['warning'][] = 'RIFF.WAVE.SNDM.data contains tag not expected length (expected: '.$SNDM_thisTagSize.', found: '.(4 + 4 + 2 + 2 + $SNDM_thisTagDataSize).') at offset '.$SNDM_startoffset.' (file offset '.($thisfile_riff_WAVE_SNDM_0['offset'] + $SNDM_startoffset).')';&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        } elseif ($SNDM_thisTagSize &lt;= 0) {&nbsp;</div></li><li><div>                            $info['warning'][] = 'RIFF.WAVE.SNDM.data contains zero-size tag at offset '.$SNDM_startoffset.' (file offset '.($thisfile_riff_WAVE_SNDM_0['offset'] + $SNDM_startoffset).')';&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $SNDM_startoffset += $SNDM_thisTagSize;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE_SNDM_0['parsed_raw'][$SNDM_thisTagKey] = $SNDM_thisTagDataText;&nbsp;</div></li><li><div>                        if ($parsedkey = self::waveSNDMtagLookup($SNDM_thisTagKey)) {&nbsp;</div></li><li><div>                            $thisfile_riff_WAVE_SNDM_0['parsed'][$parsedkey] = $SNDM_thisTagDataText;&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $info['warning'][] = 'RIFF.WAVE.SNDM contains unknown tag &quot;'.$SNDM_thisTagKey.'&quot; at offset '.$SNDM_startoffset.' (file offset '.($thisfile_riff_WAVE_SNDM_0['offset'] + $SNDM_startoffset).')';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $tagmapping = array(&nbsp;</div></li><li><div>                        'tracktitle'=&gt;'title', &nbsp;</div></li><li><div>                        'category' =&gt;'genre', &nbsp;</div></li><li><div>                        'cdtitle' =&gt;'album', &nbsp;</div></li><li><div>                        'tracktitle'=&gt;'title', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                    foreach ($tagmapping as $fromkey =&gt; $tokey) {&nbsp;</div></li><li><div>                        if (isset($thisfile_riff_WAVE_SNDM_0['parsed'][$fromkey])) {&nbsp;</div></li><li><div>                            $thisfile_riff['comments'][$tokey][] = $thisfile_riff_WAVE_SNDM_0['parsed'][$fromkey];&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_WAVE['iXML'][0]['data'])) {&nbsp;</div></li><li><div>                    // requires functions simplexml_load_string and get_object_vars&nbsp;</div></li><li><div>                    if ($parsedXML = getid3_lib::XML2array($thisfile_riff_WAVE['iXML'][0]['data'])) {&nbsp;</div></li><li><div>                        $thisfile_riff_WAVE['iXML'][0]['parsed'] = $parsedXML;&nbsp;</div></li><li><div>                        if (isset($parsedXML['SPEED']['MASTER_SPEED'])) {&nbsp;</div></li><li><div>                            @list($numerator, $denominator) = explode('/', $parsedXML['SPEED']['MASTER_SPEED']);&nbsp;</div></li><li><div>                            $thisfile_riff_WAVE['iXML'][0]['master_speed'] = $numerator / ($denominator ? $denominator : 1000);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        if (isset($parsedXML['SPEED']['TIMECODE_RATE'])) {&nbsp;</div></li><li><div>                            @list($numerator, $denominator) = explode('/', $parsedXML['SPEED']['TIMECODE_RATE']);&nbsp;</div></li><li><div>                            $thisfile_riff_WAVE['iXML'][0]['timecode_rate'] = $numerator / ($denominator ? $denominator : 1000);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        if (isset($parsedXML['SPEED']['TIMESTAMP_SAMPLES_SINCE_MIDNIGHT_LO']) && !empty($parsedXML['SPEED']['TIMESTAMP_SAMPLE_RATE']) && !empty($thisfile_riff_WAVE['iXML'][0]['timecode_rate'])) {&nbsp;</div></li><li><div>                            $samples_since_midnight = floatval(ltrim($parsedXML['SPEED']['TIMESTAMP_SAMPLES_SINCE_MIDNIGHT_HI'].$parsedXML['SPEED']['TIMESTAMP_SAMPLES_SINCE_MIDNIGHT_LO'], '0'));&nbsp;</div></li><li><div>                            $thisfile_riff_WAVE['iXML'][0]['timecode_seconds'] = $samples_since_midnight / $parsedXML['SPEED']['TIMESTAMP_SAMPLE_RATE'];&nbsp;</div></li><li><div>                            $h = floor( $thisfile_riff_WAVE['iXML'][0]['timecode_seconds']       / 3600);&nbsp;</div></li><li><div>                            $m = floor(($thisfile_riff_WAVE['iXML'][0]['timecode_seconds'] - ($h * 3600))      / 60);&nbsp;</div></li><li><div>                            $s = floor( $thisfile_riff_WAVE['iXML'][0]['timecode_seconds'] - ($h * 3600) - ($m * 60));&nbsp;</div></li><li><div>                            $f =       ($thisfile_riff_WAVE['iXML'][0]['timecode_seconds'] - ($h * 3600) - ($m * 60) - $s) * $thisfile_riff_WAVE['iXML'][0]['timecode_rate'];&nbsp;</div></li><li><div>                            $thisfile_riff_WAVE['iXML'][0]['timecode_string'] = sprintf('%02d:%02d:%02d:%05.2f', $h, $m, $s, $f);&nbsp;</div></li><li><div>                            $thisfile_riff_WAVE['iXML'][0]['timecode_string_round'] = sprintf('%02d:%02d:%02d:%02d', $h, $m, $s, round($f));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        unset($parsedXML);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!isset($thisfile_audio['bitrate']) && isset($thisfile_riff_audio[$streamindex]['bitrate'])) {&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate'] = $thisfile_riff_audio[$streamindex]['bitrate'];&nbsp;</div></li><li><div>                    $info['playtime_seconds'] = (float) ((($info['avdataend'] - $info['avdataoffset']) * 8) / $thisfile_audio['bitrate']);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!empty($info['wavpack'])) {&nbsp;</div></li><li><div>                    $thisfile_audio_dataformat = 'wavpack';&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate_mode'] = 'vbr';&nbsp;</div></li><li><div>                    $thisfile_audio['encoder'] = 'WavPack v'.$info['wavpack']['version'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Reset to the way it was - RIFF parsing will have messed this up&nbsp;</div></li><li><div>                    $info['avdataend'] = $Original['avdataend'];&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate'] = (($info['avdataend'] - $info['avdataoffset']) * 8) / $info['playtime_seconds'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;fseek($info['avdataoffset'] - 44);&nbsp;</div></li><li><div>                    $RIFFdata = $this-&gt;fread(44);&nbsp;</div></li><li><div>                    $OrignalRIFFheaderSize = getid3_lib::LittleEndian2Int(substr($RIFFdata, 4, 4)) +  8;&nbsp;</div></li><li><div>                    $OrignalRIFFdataSize = getid3_lib::LittleEndian2Int(substr($RIFFdata, 40, 4)) + 44;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($OrignalRIFFheaderSize &gt; $OrignalRIFFdataSize) {&nbsp;</div></li><li><div>                        $info['avdataend'] -= ($OrignalRIFFheaderSize - $OrignalRIFFdataSize);&nbsp;</div></li><li><div>                        $this-&gt;fseek($info['avdataend']);&nbsp;</div></li><li><div>                        $RIFFdata .= $this-&gt;fread($OrignalRIFFheaderSize - $OrignalRIFFdataSize);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // move the data chunk after all other chunks (if any)&nbsp;</div></li><li><div>                    // so that the RIFF parser doesn't see EOF when trying&nbsp;</div></li><li><div>                    // to skip over the data chunk&nbsp;</div></li><li><div>                    $RIFFdata = substr($RIFFdata, 0, 36).substr($RIFFdata, 44).substr($RIFFdata, 36, 8);&nbsp;</div></li><li><div>                    $getid3_riff = new getid3_riff($this-&gt;getid3);&nbsp;</div></li><li><div>                    $getid3_riff-&gt;ParseRIFFdata($RIFFdata);&nbsp;</div></li><li><div>                    unset($getid3_riff);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff_raw['fmt ']['wFormatTag'])) {&nbsp;</div></li><li><div>                    switch ($thisfile_riff_raw['fmt ']['wFormatTag']) {&nbsp;</div></li><li><div>                        case 0x0001: // PCM&nbsp;</div></li><li><div>                            if (!empty($info['ac3'])) {&nbsp;</div></li><li><div>                                // Dolby Digital WAV files masquerade as PCM-WAV, but they're not&nbsp;</div></li><li><div>                                $thisfile_audio['wformattag'] = 0x2000;&nbsp;</div></li><li><div>                                $thisfile_audio['codec'] = self::wFormatTagLookup($thisfile_audio['wformattag']);&nbsp;</div></li><li><div>                                $thisfile_audio['lossless'] = false;&nbsp;</div></li><li><div>                                $thisfile_audio['bitrate'] = $info['ac3']['bitrate'];&nbsp;</div></li><li><div>                                $thisfile_audio['sample_rate'] = $info['ac3']['sample_rate'];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if (!empty($info['dts'])) {&nbsp;</div></li><li><div>                                // Dolby DTS files masquerade as PCM-WAV, but they're not&nbsp;</div></li><li><div>                                $thisfile_audio['wformattag'] = 0x2001;&nbsp;</div></li><li><div>                                $thisfile_audio['codec'] = self::wFormatTagLookup($thisfile_audio['wformattag']);&nbsp;</div></li><li><div>                                $thisfile_audio['lossless'] = false;&nbsp;</div></li><li><div>                                $thisfile_audio['bitrate'] = $info['dts']['bitrate'];&nbsp;</div></li><li><div>                                $thisfile_audio['sample_rate'] = $info['dts']['sample_rate'];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        case 0x08AE: // ClearJump LiteWave&nbsp;</div></li><li><div>                            $thisfile_audio['bitrate_mode'] = 'vbr';&nbsp;</div></li><li><div>                            $thisfile_audio_dataformat = 'litewave';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            //typedef struct tagSLwFormat {&nbsp;</div></li><li><div>                            //  WORD    m_wCompFormat;     // low byte defines compression method, high byte is compression flags&nbsp;</div></li><li><div>                            //  DWORD   m_dwScale;         // scale factor for lossy compression&nbsp;</div></li><li><div>                            //  DWORD   m_dwBlockSize;     // number of samples in encoded blocks&nbsp;</div></li><li><div>                            //  WORD    m_wQuality;        // alias for the scale factor&nbsp;</div></li><li><div>                            //  WORD    m_wMarkDistance;   // distance between marks in bytes&nbsp;</div></li><li><div>                            //  WORD    m_wReserved;&nbsp;</div></li><li><div>                            //&nbsp;</div></li><li><div>                            //  //following paramters are ignored if CF_FILESRC is not set&nbsp;</div></li><li><div>                            //  DWORD   m_dwOrgSize;       // original file size in bytes&nbsp;</div></li><li><div>                            //  WORD    m_bFactExists;     // indicates if 'fact' chunk exists in the original file&nbsp;</div></li><li><div>                            //  DWORD   m_dwRiffChunkSize; // riff chunk size in the original file&nbsp;</div></li><li><div>                            //&nbsp;</div></li><li><div>                            //  PCMWAVEFORMAT m_OrgWf;     // original wave format&nbsp;</div></li><li><div>                            // }SLwFormat, *PSLwFormat;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // shortcut&nbsp;</div></li><li><div>                            $thisfile_riff['litewave']['raw'] = array();&nbsp;</div></li><li><div>                            $riff_litewave = &$thisfile_riff['litewave'];&nbsp;</div></li><li><div>                            $riff_litewave_raw = &$riff_litewave['raw'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $flags = array(&nbsp;</div></li><li><div>                                'compression_method' =&gt; 1, &nbsp;</div></li><li><div>                                'compression_flags' =&gt; 1, &nbsp;</div></li><li><div>                                'm_dwScale' =&gt; 4, &nbsp;</div></li><li><div>                                'm_dwBlockSize' =&gt; 4, &nbsp;</div></li><li><div>                                'm_wQuality' =&gt; 2, &nbsp;</div></li><li><div>                                'm_wMarkDistance' =&gt; 2, &nbsp;</div></li><li><div>                                'm_wReserved' =&gt; 2, &nbsp;</div></li><li><div>                                'm_dwOrgSize' =&gt; 4, &nbsp;</div></li><li><div>                                'm_bFactExists' =&gt; 2, &nbsp;</div></li><li><div>                                'm_dwRiffChunkSize' =&gt; 4, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                            $litewave_offset = 18;&nbsp;</div></li><li><div>                            foreach ($flags as $flag =&gt; $length) {&nbsp;</div></li><li><div>                                $riff_litewave_raw[$flag] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], $litewave_offset, $length));&nbsp;</div></li><li><div>                                $litewave_offset += $length;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            //$riff_litewave['quality_factor'] = intval(round((2000 - $riff_litewave_raw['m_dwScale']) / 20));&nbsp;</div></li><li><div>                            $riff_litewave['quality_factor'] = $riff_litewave_raw['m_wQuality'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $riff_litewave['flags']['raw_source'] = ($riff_litewave_raw['compression_flags'] & 0x01) ? false : true;&nbsp;</div></li><li><div>                            $riff_litewave['flags']['vbr_blocksize'] = ($riff_litewave_raw['compression_flags'] & 0x02) ? false : true;&nbsp;</div></li><li><div>                            $riff_litewave['flags']['seekpoints'] =        (bool) ($riff_litewave_raw['compression_flags'] & 0x04);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $thisfile_audio['lossless'] = (($riff_litewave_raw['m_wQuality'] == 100) ? true : false);&nbsp;</div></li><li><div>                            $thisfile_audio['encoder_options'] = '-q'.$riff_litewave['quality_factor'];&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        default:&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($info['avdataend'] &gt; $info['filesize']) {&nbsp;</div></li><li><div>                    switch (!empty($thisfile_audio_dataformat) ? $thisfile_audio_dataformat : '') {&nbsp;</div></li><li><div>                        case 'wavpack': // WavPack&nbsp;</div></li><li><div>                        case 'lpac':    // LPAC&nbsp;</div></li><li><div>                        case 'ofr':     // OptimFROG&nbsp;</div></li><li><div>                        case 'ofs':     // OptimFROG DualStream&nbsp;</div></li><li><div>                            // lossless compressed audio formats that keep original RIFF headers - skip warning&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        case 'litewave':&nbsp;</div></li><li><div>                            if (($info['avdataend'] - $info['filesize']) == 1) {&nbsp;</div></li><li><div>                                // LiteWave appears to incorrectly *not* pad actual output file&nbsp;</div></li><li><div>                                // to nearest WORD boundary so may appear to be short by one&nbsp;</div></li><li><div>                                // byte, in which case - skip warning&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                // Short by more than one byte, throw warning&nbsp;</div></li><li><div>                                $info['warning'][] = 'Probably truncated file - expecting '.$thisfile_riff[$RIFFsubtype]['data'][0]['size'].' bytes of data, only found '.($info['filesize'] - $info['avdataoffset']).' (short by '.($thisfile_riff[$RIFFsubtype]['data'][0]['size'] - ($info['filesize'] - $info['avdataoffset'])).' bytes)';&nbsp;</div></li><li><div>                                $info['avdataend'] = $info['filesize'];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        default:&nbsp;</div></li><li><div>                            if ((($info['avdataend'] - $info['filesize']) == 1) && (($thisfile_riff[$RIFFsubtype]['data'][0]['size'] % 2) == 0) && ((($info['filesize'] - $info['avdataoffset']) % 2) == 1)) {&nbsp;</div></li><li><div>                                // output file appears to be incorrectly *not* padded to nearest WORD boundary&nbsp;</div></li><li><div>                                // Output less severe warning&nbsp;</div></li><li><div>                                $info['warning'][] = 'File should probably be padded to nearest WORD boundary, but it is not (expecting '.$thisfile_riff[$RIFFsubtype]['data'][0]['size'].' bytes of data, only found '.($info['filesize'] - $info['avdataoffset']).' therefore short by '.($thisfile_riff[$RIFFsubtype]['data'][0]['size'] - ($info['filesize'] - $info['avdataoffset'])).' bytes)';&nbsp;</div></li><li><div>                                $info['avdataend'] = $info['filesize'];&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                // Short by more than one byte, throw warning&nbsp;</div></li><li><div>                                $info['warning'][] = 'Probably truncated file - expecting '.$thisfile_riff[$RIFFsubtype]['data'][0]['size'].' bytes of data, only found '.($info['filesize'] - $info['avdataoffset']).' (short by '.($thisfile_riff[$RIFFsubtype]['data'][0]['size'] - ($info['filesize'] - $info['avdataoffset'])).' bytes)';&nbsp;</div></li><li><div>                                $info['avdataend'] = $info['filesize'];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (!empty($info['mpeg']['audio']['LAME']['audio_bytes'])) {&nbsp;</div></li><li><div>                    if ((($info['avdataend'] - $info['avdataoffset']) - $info['mpeg']['audio']['LAME']['audio_bytes']) == 1) {&nbsp;</div></li><li><div>                        $info['avdataend']--;&nbsp;</div></li><li><div>                        $info['warning'][] = 'Extra null byte at end of MP3 data assumed to be RIFF padding and therefore ignored';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($thisfile_audio_dataformat) && ($thisfile_audio_dataformat == 'ac3')) {&nbsp;</div></li><li><div>                    unset($thisfile_audio['bits_per_sample']);&nbsp;</div></li><li><div>                    if (!empty($info['ac3']['bitrate']) && ($info['ac3']['bitrate'] != $thisfile_audio['bitrate'])) {&nbsp;</div></li><li><div>                        $thisfile_audio['bitrate'] = $info['ac3']['bitrate'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // http://en.wikipedia.org/wiki/Audio_Video_Interleave&nbsp;</div></li><li><div>            case 'AVI ':&nbsp;</div></li><li><div>                $info['fileformat'] = 'avi';&nbsp;</div></li><li><div>                $info['mime_type'] = 'video/avi';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $thisfile_video['bitrate_mode'] = 'vbr'; // maybe not, but probably&nbsp;</div></li><li><div>                $thisfile_video['dataformat'] = 'avi';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['movi']['offset'])) {&nbsp;</div></li><li><div>                    $info['avdataoffset'] = $thisfile_riff[$RIFFsubtype]['movi']['offset'] + 8;&nbsp;</div></li><li><div>                    if (isset($thisfile_riff['AVIX'])) {&nbsp;</div></li><li><div>                        $info['avdataend'] = $thisfile_riff['AVIX'][(count($thisfile_riff['AVIX']) - 1)]['chunks']['movi']['offset'] + $thisfile_riff['AVIX'][(count($thisfile_riff['AVIX']) - 1)]['chunks']['movi']['size'];&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $info['avdataend'] = $thisfile_riff['AVI ']['movi']['offset'] + $thisfile_riff['AVI ']['movi']['size'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($info['avdataend'] &gt; $info['filesize']) {&nbsp;</div></li><li><div>                        $info['warning'][] = 'Probably truncated file - expecting '.($info['avdataend'] - $info['avdataoffset']).' bytes of data, only found '.($info['filesize'] - $info['avdataoffset']).' (short by '.($info['avdataend'] - $info['filesize']).' bytes)';&nbsp;</div></li><li><div>                        $info['avdataend'] = $info['filesize'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff['AVI ']['hdrl']['strl']['indx'])) {&nbsp;</div></li><li><div>                    //$bIndexType = array(&nbsp;</div></li><li><div>                    //    0x00 =&gt; 'AVI_INDEX_OF_INDEXES', &nbsp;</div></li><li><div>                    //    0x01 =&gt; 'AVI_INDEX_OF_CHUNKS', &nbsp;</div></li><li><div>                    //    0x80 =&gt; 'AVI_INDEX_IS_DATA', &nbsp;</div></li><li><div>                    //);&nbsp;</div></li><li><div>                    //$bIndexSubtype = array(&nbsp;</div></li><li><div>                    //    0x01 =&gt; array(&nbsp;</div></li><li><div>                    //        0x01 =&gt; 'AVI_INDEX_2FIELD', &nbsp;</div></li><li><div>                    // ), &nbsp;</div></li><li><div>                    //);&nbsp;</div></li><li><div>                    foreach ($thisfile_riff['AVI ']['hdrl']['strl']['indx'] as $streamnumber =&gt; $steamdataarray) {&nbsp;</div></li><li><div>                        $ahsisd = &$thisfile_riff['AVI ']['hdrl']['strl']['indx'][$streamnumber]['data'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $thisfile_riff_raw['indx'][$streamnumber]['wLongsPerEntry'] = $this-&gt;EitherEndian2Int(substr($ahsisd, 0, 2));&nbsp;</div></li><li><div>                        $thisfile_riff_raw['indx'][$streamnumber]['bIndexSubType'] = $this-&gt;EitherEndian2Int(substr($ahsisd, 2, 1));&nbsp;</div></li><li><div>                        $thisfile_riff_raw['indx'][$streamnumber]['bIndexType'] = $this-&gt;EitherEndian2Int(substr($ahsisd, 3, 1));&nbsp;</div></li><li><div>                        $thisfile_riff_raw['indx'][$streamnumber]['nEntriesInUse'] = $this-&gt;EitherEndian2Int(substr($ahsisd, 4, 4));&nbsp;</div></li><li><div>                        $thisfile_riff_raw['indx'][$streamnumber]['dwChunkId'] =                         substr($ahsisd, 8, 4);&nbsp;</div></li><li><div>                        $thisfile_riff_raw['indx'][$streamnumber]['dwReserved'] = $this-&gt;EitherEndian2Int(substr($ahsisd, 12, 4));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        //$thisfile_riff_raw['indx'][$streamnumber]['bIndexType_name'] =    $bIndexType[$thisfile_riff_raw['indx'][$streamnumber]['bIndexType']];&nbsp;</div></li><li><div>                        //$thisfile_riff_raw['indx'][$streamnumber]['bIndexSubType_name'] = $bIndexSubtype[$thisfile_riff_raw['indx'][$streamnumber]['bIndexType']][$thisfile_riff_raw['indx'][$streamnumber]['bIndexSubType']];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        unset($ahsisd);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($thisfile_riff['AVI ']['hdrl']['avih'][$streamindex]['data'])) {&nbsp;</div></li><li><div>                    $avihData = $thisfile_riff['AVI ']['hdrl']['avih'][$streamindex]['data'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_raw['avih'] = array();&nbsp;</div></li><li><div>                    $thisfile_riff_raw_avih = &$thisfile_riff_raw['avih'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_raw_avih['dwMicroSecPerFrame'] = $this-&gt;EitherEndian2Int(substr($avihData, 0, 4)); // frame display rate (or 0L)&nbsp;</div></li><li><div>                    if ($thisfile_riff_raw_avih['dwMicroSecPerFrame'] == 0) {&nbsp;</div></li><li><div>                        $info['error'][] = 'Corrupt RIFF file: avih.dwMicroSecPerFrame == zero';&nbsp;</div></li><li><div>                        return false;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $flags = array(&nbsp;</div></li><li><div>                        'dwMaxBytesPerSec', // max. transfer rate&nbsp;</div></li><li><div>                        'dwPaddingGranularity', // pad to multiples of this size; normally 2K.&nbsp;</div></li><li><div>                        'dwFlags', // the ever-present flags&nbsp;</div></li><li><div>                        'dwTotalFrames', // # frames in file&nbsp;</div></li><li><div>                        'dwInitialFrames', //&nbsp;</div></li><li><div>                        'dwStreams', //&nbsp;</div></li><li><div>                        'dwSuggestedBufferSize', //&nbsp;</div></li><li><div>                        'dwWidth', //&nbsp;</div></li><li><div>                        'dwHeight', //&nbsp;</div></li><li><div>                        'dwScale', //&nbsp;</div></li><li><div>                        'dwRate', //&nbsp;</div></li><li><div>                        'dwStart', //&nbsp;</div></li><li><div>                        'dwLength', //&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                    $avih_offset = 4;&nbsp;</div></li><li><div>                    foreach ($flags as $flag) {&nbsp;</div></li><li><div>                        $thisfile_riff_raw_avih[$flag] = $this-&gt;EitherEndian2Int(substr($avihData, $avih_offset, 4));&nbsp;</div></li><li><div>                        $avih_offset += 4;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $flags = array(&nbsp;</div></li><li><div>                        'hasindex' =&gt; 0x00000010, &nbsp;</div></li><li><div>                        'mustuseindex' =&gt; 0x00000020, &nbsp;</div></li><li><div>                        'interleaved' =&gt; 0x00000100, &nbsp;</div></li><li><div>                        'trustcktype' =&gt; 0x00000800, &nbsp;</div></li><li><div>                        'capturedfile' =&gt; 0x00010000, &nbsp;</div></li><li><div>                        'copyrighted' =&gt; 0x00020010, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                    foreach ($flags as $flag =&gt; $value) {&nbsp;</div></li><li><div>                        $thisfile_riff_raw_avih['flags'][$flag] = (bool) ($thisfile_riff_raw_avih['dwFlags'] & $value);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_video[$streamindex] = array();&nbsp;</div></li><li><div>                    $thisfile_riff_video_current = &$thisfile_riff_video[$streamindex];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($thisfile_riff_raw_avih['dwWidth'] &gt; 0) {&nbsp;</div></li><li><div>                        $thisfile_riff_video_current['frame_width'] = $thisfile_riff_raw_avih['dwWidth'];&nbsp;</div></li><li><div>                        $thisfile_video['resolution_x'] = $thisfile_riff_video_current['frame_width'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($thisfile_riff_raw_avih['dwHeight'] &gt; 0) {&nbsp;</div></li><li><div>                        $thisfile_riff_video_current['frame_height'] = $thisfile_riff_raw_avih['dwHeight'];&nbsp;</div></li><li><div>                        $thisfile_video['resolution_y'] = $thisfile_riff_video_current['frame_height'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($thisfile_riff_raw_avih['dwTotalFrames'] &gt; 0) {&nbsp;</div></li><li><div>                        $thisfile_riff_video_current['total_frames'] = $thisfile_riff_raw_avih['dwTotalFrames'];&nbsp;</div></li><li><div>                        $thisfile_video['total_frames'] = $thisfile_riff_video_current['total_frames'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_video_current['frame_rate'] = round(1000000 / $thisfile_riff_raw_avih['dwMicroSecPerFrame'], 3);&nbsp;</div></li><li><div>                    $thisfile_video['frame_rate'] = $thisfile_riff_video_current['frame_rate'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($thisfile_riff['AVI ']['hdrl']['strl']['strh'][0]['data'])) {&nbsp;</div></li><li><div>                    if (is_array($thisfile_riff['AVI ']['hdrl']['strl']['strh'])) {&nbsp;</div></li><li><div>                        for ($i = 0; $i &lt; count($thisfile_riff['AVI ']['hdrl']['strl']['strh']); $i++) {&nbsp;</div></li><li><div>                            if (isset($thisfile_riff['AVI ']['hdrl']['strl']['strh'][$i]['data'])) {&nbsp;</div></li><li><div>                                $strhData = $thisfile_riff['AVI ']['hdrl']['strl']['strh'][$i]['data'];&nbsp;</div></li><li><div>                                $strhfccType = substr($strhData, 0, 4);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                if (isset($thisfile_riff['AVI ']['hdrl']['strl']['strf'][$i]['data'])) {&nbsp;</div></li><li><div>                                    $strfData = $thisfile_riff['AVI ']['hdrl']['strl']['strf'][$i]['data'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    // shortcut&nbsp;</div></li><li><div>                                    $thisfile_riff_raw_strf_strhfccType_streamindex = &$thisfile_riff_raw['strf'][$strhfccType][$streamindex];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    switch ($strhfccType) {&nbsp;</div></li><li><div>                                        case 'auds':&nbsp;</div></li><li><div>                                            $thisfile_audio['bitrate_mode'] = 'cbr';&nbsp;</div></li><li><div>                                            $thisfile_audio_dataformat = 'wav';&nbsp;</div></li><li><div>                                            if (isset($thisfile_riff_audio) && is_array($thisfile_riff_audio)) {&nbsp;</div></li><li><div>                                                $streamindex = count($thisfile_riff_audio);&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            $thisfile_riff_audio[$streamindex] = self::parseWAVEFORMATex($strfData);&nbsp;</div></li><li><div>                                            $thisfile_audio['wformattag'] = $thisfile_riff_audio[$streamindex]['raw']['wFormatTag'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            // shortcut&nbsp;</div></li><li><div>                                            $thisfile_audio['streams'][$streamindex] = $thisfile_riff_audio[$streamindex];&nbsp;</div></li><li><div>                                            $thisfile_audio_streams_currentstream = &$thisfile_audio['streams'][$streamindex];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            if ($thisfile_audio_streams_currentstream['bits_per_sample'] == 0) {&nbsp;</div></li><li><div>                                                unset($thisfile_audio_streams_currentstream['bits_per_sample']);&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                            $thisfile_audio_streams_currentstream['wformattag'] = $thisfile_audio_streams_currentstream['raw']['wFormatTag'];&nbsp;</div></li><li><div>                                            unset($thisfile_audio_streams_currentstream['raw']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            // shortcut&nbsp;</div></li><li><div>                                            $thisfile_riff_raw['strf'][$strhfccType][$streamindex] = $thisfile_riff_audio[$streamindex]['raw'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            unset($thisfile_riff_audio[$streamindex]['raw']);&nbsp;</div></li><li><div>                                            $thisfile_audio = getid3_lib::array_merge_noclobber($thisfile_audio, $thisfile_riff_audio[$streamindex]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            $thisfile_audio['lossless'] = false;&nbsp;</div></li><li><div>                                            switch ($thisfile_riff_raw_strf_strhfccType_streamindex['wFormatTag']) {&nbsp;</div></li><li><div>                                                case 0x0001:  // PCM&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'wav';&nbsp;</div></li><li><div>                                                    $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                case 0x0050: // MPEG Layer 2 or Layer 1&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'mp2'; // Assume Layer-2&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                case 0x0055: // MPEG Layer 3&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'mp3';&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                case 0x00FF: // AAC&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'aac';&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                case 0x0161: // Windows Media v7 / v8 / v9&nbsp;</div></li><li><div>                                                case 0x0162: // Windows Media Professional v9&nbsp;</div></li><li><div>                                                case 0x0163: // Windows Media Lossess v9&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'wma';&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                case 0x2000: // AC-3&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'ac3';&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                case 0x2001: // DTS&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'dts';&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                default:&nbsp;</div></li><li><div>                                                    $thisfile_audio_dataformat = 'wav';&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                            $thisfile_audio_streams_currentstream['dataformat'] = $thisfile_audio_dataformat;&nbsp;</div></li><li><div>                                            $thisfile_audio_streams_currentstream['lossless'] = $thisfile_audio['lossless'];&nbsp;</div></li><li><div>                                            $thisfile_audio_streams_currentstream['bitrate_mode'] = $thisfile_audio['bitrate_mode'];&nbsp;</div></li><li><div>                                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                        case 'iavs':&nbsp;</div></li><li><div>                                        case 'vids':&nbsp;</div></li><li><div>                                            // shortcut&nbsp;</div></li><li><div>                                            $thisfile_riff_raw['strh'][$i] = array();&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current = &$thisfile_riff_raw['strh'][$i];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['fccType'] =                         substr($strhData, 0, 4);  // same as $strhfccType;&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['fccHandler'] =                         substr($strhData, 4, 4);&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwFlags'] = $this-&gt;EitherEndian2Int(substr($strhData, 8, 4)); // Contains AVITF_* flags&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['wPriority'] = $this-&gt;EitherEndian2Int(substr($strhData, 12, 2));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['wLanguage'] = $this-&gt;EitherEndian2Int(substr($strhData, 14, 2));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwInitialFrames'] = $this-&gt;EitherEndian2Int(substr($strhData, 16, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwScale'] = $this-&gt;EitherEndian2Int(substr($strhData, 20, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwRate'] = $this-&gt;EitherEndian2Int(substr($strhData, 24, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwStart'] = $this-&gt;EitherEndian2Int(substr($strhData, 28, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwLength'] = $this-&gt;EitherEndian2Int(substr($strhData, 32, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwSuggestedBufferSize'] = $this-&gt;EitherEndian2Int(substr($strhData, 36, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwQuality'] = $this-&gt;EitherEndian2Int(substr($strhData, 40, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['dwSampleSize'] = $this-&gt;EitherEndian2Int(substr($strhData, 44, 4));&nbsp;</div></li><li><div>                                            $thisfile_riff_raw_strh_current['rcFrame'] = $this-&gt;EitherEndian2Int(substr($strhData, 48, 4));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            $thisfile_riff_video_current['codec'] = self::fourccLookup($thisfile_riff_raw_strh_current['fccHandler']);&nbsp;</div></li><li><div>                                            $thisfile_video['fourcc'] = $thisfile_riff_raw_strh_current['fccHandler'];&nbsp;</div></li><li><div>                                            if (!$thisfile_riff_video_current['codec'] && isset($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']) && self::fourccLookup($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'])) {&nbsp;</div></li><li><div>                                                $thisfile_riff_video_current['codec'] = self::fourccLookup($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']);&nbsp;</div></li><li><div>                                                $thisfile_video['fourcc'] = $thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'];&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                            $thisfile_video['codec'] = $thisfile_riff_video_current['codec'];&nbsp;</div></li><li><div>                                            $thisfile_video['pixel_aspect_ratio'] = (float) 1;&nbsp;</div></li><li><div>                                            switch ($thisfile_riff_raw_strh_current['fccHandler']) {&nbsp;</div></li><li><div>                                                case 'HFYU': // Huffman Lossless Codec&nbsp;</div></li><li><div>                                                case 'IRAW': // Intel YUV Uncompressed&nbsp;</div></li><li><div>                                                case 'YUY2': // Uncompressed YUV 4:2:2&nbsp;</div></li><li><div>                                                    $thisfile_video['lossless'] = true;&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                default:&nbsp;</div></li><li><div>                                                    $thisfile_video['lossless'] = false;&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                            switch ($strhfccType) {&nbsp;</div></li><li><div>                                                case 'vids':&nbsp;</div></li><li><div>                                                    $thisfile_riff_raw_strf_strhfccType_streamindex = self::ParseBITMAPINFOHEADER(substr($strfData, 0, 40), ($this-&gt;container == 'riff'));&nbsp;</div></li><li><div>                                                    $thisfile_video['bits_per_sample'] = $thisfile_riff_raw_strf_strhfccType_streamindex['biBitCount'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                    if ($thisfile_riff_video_current['codec'] == 'DV') {&nbsp;</div></li><li><div>                                                        $thisfile_riff_video_current['dv_type'] = 2;&nbsp;</div></li><li><div>                                                    }&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                                case 'iavs':&nbsp;</div></li><li><div>                                                    $thisfile_riff_video_current['dv_type'] = 1;&nbsp;</div></li><li><div>                                                    break;&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                        default:&nbsp;</div></li><li><div>                                            $info['warning'][] = 'Unhandled fccType for stream ('.$i.'): &quot;'.$strhfccType.'&quot;';&nbsp;</div></li><li><div>                                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if (isset($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $thisfile_video['fourcc'] = $thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'];&nbsp;</div></li><li><div>                                if (self::fourccLookup($thisfile_video['fourcc'])) {&nbsp;</div></li><li><div>                                    $thisfile_riff_video_current['codec'] = self::fourccLookup($thisfile_video['fourcc']);&nbsp;</div></li><li><div>                                    $thisfile_video['codec'] = $thisfile_riff_video_current['codec'];&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                switch ($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']) {&nbsp;</div></li><li><div>                                    case 'HFYU': // Huffman Lossless Codec&nbsp;</div></li><li><div>                                    case 'IRAW': // Intel YUV Uncompressed&nbsp;</div></li><li><div>                                    case 'YUY2': // Uncompressed YUV 4:2:2&nbsp;</div></li><li><div>                                        $thisfile_video['lossless'] = true;&nbsp;</div></li><li><div>                                        //$thisfile_video['bits_per_sample'] = 24;&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    default:&nbsp;</div></li><li><div>                                        $thisfile_video['lossless'] = false;&nbsp;</div></li><li><div>                                        //$thisfile_video['bits_per_sample'] = 24;&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'AMV ':&nbsp;</div></li><li><div>                $info['fileformat'] = 'amv';&nbsp;</div></li><li><div>                $info['mime_type'] = 'video/amv';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $thisfile_video['bitrate_mode'] = 'vbr'; // it's MJPEG, presumably contant-quality encoding, thereby VBR&nbsp;</div></li><li><div>                $thisfile_video['dataformat'] = 'mjpeg';&nbsp;</div></li><li><div>                $thisfile_video['codec'] = 'mjpeg';&nbsp;</div></li><li><div>                $thisfile_video['lossless'] = false;&nbsp;</div></li><li><div>                $thisfile_video['bits_per_sample'] = 24;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $thisfile_audio['dataformat'] = 'adpcm';&nbsp;</div></li><li><div>                $thisfile_audio['lossless'] = false;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // http://en.wikipedia.org/wiki/CD-DA&nbsp;</div></li><li><div>            case 'CDDA':&nbsp;</div></li><li><div>                $info['fileformat'] = 'cda';&nbsp;</div></li><li><div>                unset($info['mime_type']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $thisfile_audio_dataformat = 'cda';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $info['avdataoffset'] = 44;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff['CDDA']['fmt '][0]['data'])) {&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0 = &$thisfile_riff['CDDA']['fmt '][0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['unknown1'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_CDDA_fmt_0['data'], 0, 2));&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['track_num'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_CDDA_fmt_0['data'], 2, 2));&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['disc_id'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_CDDA_fmt_0['data'], 4, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['start_offset_frame'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_CDDA_fmt_0['data'], 8, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['playtime_frames'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_CDDA_fmt_0['data'], 12, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['unknown6'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_CDDA_fmt_0['data'], 16, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['unknown7'] = $this-&gt;EitherEndian2Int(substr($thisfile_riff_CDDA_fmt_0['data'], 20, 4));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['start_offset_seconds'] = (float) $thisfile_riff_CDDA_fmt_0['start_offset_frame'] / 75;&nbsp;</div></li><li><div>                    $thisfile_riff_CDDA_fmt_0['playtime_seconds'] = (float) $thisfile_riff_CDDA_fmt_0['playtime_frames'] / 75;&nbsp;</div></li><li><div>                    $info['comments']['track'] = $thisfile_riff_CDDA_fmt_0['track_num'];&nbsp;</div></li><li><div>                    $info['playtime_seconds'] = $thisfile_riff_CDDA_fmt_0['playtime_seconds'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // hardcoded data for CD-audio&nbsp;</div></li><li><div>                    $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>                    $thisfile_audio['sample_rate'] = 44100;&nbsp;</div></li><li><div>                    $thisfile_audio['channels'] = 2;&nbsp;</div></li><li><div>                    $thisfile_audio['bits_per_sample'] = 16;&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate'] = $thisfile_audio['sample_rate'] * $thisfile_audio['channels'] * $thisfile_audio['bits_per_sample'];&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate_mode'] = 'cbr';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // http://en.wikipedia.org/wiki/AIFF&nbsp;</div></li><li><div>            case 'AIFF':&nbsp;</div></li><li><div>            case 'AIFC':&nbsp;</div></li><li><div>                $info['fileformat'] = 'aiff';&nbsp;</div></li><li><div>                $info['mime_type'] = 'audio/x-aiff';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $thisfile_audio['bitrate_mode'] = 'cbr';&nbsp;</div></li><li><div>                $thisfile_audio_dataformat = 'aiff';&nbsp;</div></li><li><div>                $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['SSND'][0]['offset'])) {&nbsp;</div></li><li><div>                    $info['avdataoffset'] = $thisfile_riff[$RIFFsubtype]['SSND'][0]['offset'] + 8;&nbsp;</div></li><li><div>                    $info['avdataend'] = $info['avdataoffset'] + $thisfile_riff[$RIFFsubtype]['SSND'][0]['size'];&nbsp;</div></li><li><div>                    if ($info['avdataend'] &gt; $info['filesize']) {&nbsp;</div></li><li><div>                        if (($info['avdataend'] == ($info['filesize'] + 1)) && (($info['filesize'] % 2) == 1)) {&nbsp;</div></li><li><div>                            // structures rounded to 2-byte boundary, but dumb encoders&nbsp;</div></li><li><div>                            // forget to pad end of file to make this actually work&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $info['warning'][] = 'Probable truncated AIFF file: expecting '.$thisfile_riff[$RIFFsubtype]['SSND'][0]['size'].' bytes of audio data, only '.($info['filesize'] - $info['avdataoffset']).' bytes found';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $info['avdataend'] = $info['filesize'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['COMM'][0]['data'])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_COMM_0_data = &$thisfile_riff[$RIFFsubtype]['COMM'][0]['data'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_audio['channels'] =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data, 0, 2), true);&nbsp;</div></li><li><div>                    $thisfile_riff_audio['total_samples'] =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data, 2, 4), false);&nbsp;</div></li><li><div>                    $thisfile_riff_audio['bits_per_sample'] =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data, 6, 2), true);&nbsp;</div></li><li><div>                    $thisfile_riff_audio['sample_rate'] = (int) getid3_lib::BigEndian2Float(substr($thisfile_riff_RIFFsubtype_COMM_0_data, 8, 10));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($thisfile_riff[$RIFFsubtype]['COMM'][0]['size'] &gt; 18) {&nbsp;</div></li><li><div>                        $thisfile_riff_audio['codec_fourcc'] =                                   substr($thisfile_riff_RIFFsubtype_COMM_0_data, 18, 4);&nbsp;</div></li><li><div>                        $CodecNameSize =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data, 22, 1), false);&nbsp;</div></li><li><div>                        $thisfile_riff_audio['codec_name'] =                                   substr($thisfile_riff_RIFFsubtype_COMM_0_data, 23, $CodecNameSize);&nbsp;</div></li><li><div>                        switch ($thisfile_riff_audio['codec_name']) {&nbsp;</div></li><li><div>                            case 'NONE':&nbsp;</div></li><li><div>                                $thisfile_audio['codec'] = 'Pulse Code Modulation (PCM)';&nbsp;</div></li><li><div>                                $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            case '':&nbsp;</div></li><li><div>                                switch ($thisfile_riff_audio['codec_fourcc']) {&nbsp;</div></li><li><div>                                    // http://developer.apple.com/qa/snd/snd07.html&nbsp;</div></li><li><div>                                    case 'sowt':&nbsp;</div></li><li><div>                                        $thisfile_riff_audio['codec_name'] = 'Two\'s Compliment Little-Endian PCM';&nbsp;</div></li><li><div>                                        $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    case 'twos':&nbsp;</div></li><li><div>                                        $thisfile_riff_audio['codec_name'] = 'Two\'s Compliment Big-Endian PCM';&nbsp;</div></li><li><div>                                        $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    default:&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            default:&nbsp;</div></li><li><div>                                $thisfile_audio['codec'] = $thisfile_riff_audio['codec_name'];&nbsp;</div></li><li><div>                                $thisfile_audio['lossless'] = false;&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_audio['channels'] = $thisfile_riff_audio['channels'];&nbsp;</div></li><li><div>                    if ($thisfile_riff_audio['bits_per_sample'] &gt; 0) {&nbsp;</div></li><li><div>                        $thisfile_audio['bits_per_sample'] = $thisfile_riff_audio['bits_per_sample'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $thisfile_audio['sample_rate'] = $thisfile_riff_audio['sample_rate'];&nbsp;</div></li><li><div>                    if ($thisfile_audio['sample_rate'] == 0) {&nbsp;</div></li><li><div>                        $info['error'][] = 'Corrupted AIFF file: sample_rate == zero';&nbsp;</div></li><li><div>                        return false;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $info['playtime_seconds'] = $thisfile_riff_audio['total_samples'] / $thisfile_audio['sample_rate'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['COMT'])) {&nbsp;</div></li><li><div>                    $offset = 0;&nbsp;</div></li><li><div>                    $CommentCount = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 2), false);&nbsp;</div></li><li><div>                    $offset += 2;&nbsp;</div></li><li><div>                    for ($i = 0; $i &lt; $CommentCount; $i++) {&nbsp;</div></li><li><div>                        $info['comments_raw'][$i]['timestamp'] = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 4), false);&nbsp;</div></li><li><div>                        $offset += 4;&nbsp;</div></li><li><div>                        $info['comments_raw'][$i]['marker_id'] = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 2), true);&nbsp;</div></li><li><div>                        $offset += 2;&nbsp;</div></li><li><div>                        $CommentLength = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 2), false);&nbsp;</div></li><li><div>                        $offset += 2;&nbsp;</div></li><li><div>                        $info['comments_raw'][$i]['comment'] =                           substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, $CommentLength);&nbsp;</div></li><li><div>                        $offset += $CommentLength;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $info['comments_raw'][$i]['timestamp_unix'] = getid3_lib::DateMac2Unix($info['comments_raw'][$i]['timestamp']);&nbsp;</div></li><li><div>                        $thisfile_riff['comments']['comment'][] = $info['comments_raw'][$i]['comment'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $CommentsChunkNames = array('NAME'=&gt;'title', 'author'=&gt;'artist', '(c) '=&gt;'copyright', 'ANNO'=&gt;'comment');&nbsp;</div></li><li><div>                foreach ($CommentsChunkNames as $key =&gt; $value) {&nbsp;</div></li><li><div>                    if (isset($thisfile_riff[$RIFFsubtype][$key][0]['data'])) {&nbsp;</div></li><li><div>                        $thisfile_riff['comments'][$value][] = $thisfile_riff[$RIFFsubtype][$key][0]['data'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['ID3 '])) {&nbsp;</div></li><li><div>                    getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v2.php', __FILE__, true);&nbsp;</div></li><li><div>                    $getid3_temp = new getID3();&nbsp;</div></li><li><div>                    $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                    $getid3_id3v2 = new getid3_id3v2($getid3_temp);&nbsp;</div></li><li><div>                    $getid3_id3v2-&gt;StartingOffset = $thisfile_riff[$RIFFsubtype]['ID3 '][0]['offset'] + 8;&nbsp;</div></li><li><div>                    if ($thisfile_riff[$RIFFsubtype]['ID3 '][0]['valid'] = $getid3_id3v2-&gt;Analyze()) {&nbsp;</div></li><li><div>                        $info['id3v2'] = $getid3_temp-&gt;info['id3v2'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    unset($getid3_temp, $getid3_id3v2);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>*/&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // http://en.wikipedia.org/wiki/8SVX&nbsp;</div></li><li><div>            case '8SVX':&nbsp;</div></li><li><div>                $info['fileformat'] = '8svx';&nbsp;</div></li><li><div>                $info['mime_type'] = 'audio/8svx';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $thisfile_audio['bitrate_mode'] = 'cbr';&nbsp;</div></li><li><div>                $thisfile_audio_dataformat = '8svx';&nbsp;</div></li><li><div>                $thisfile_audio['bits_per_sample'] = 8;&nbsp;</div></li><li><div>                $thisfile_audio['channels'] = 1; // overridden below, if need be&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['BODY'][0]['offset'])) {&nbsp;</div></li><li><div>                    $info['avdataoffset'] = $thisfile_riff[$RIFFsubtype]['BODY'][0]['offset'] + 8;&nbsp;</div></li><li><div>                    $info['avdataend'] = $info['avdataoffset'] + $thisfile_riff[$RIFFsubtype]['BODY'][0]['size'];&nbsp;</div></li><li><div>                    if ($info['avdataend'] &gt; $info['filesize']) {&nbsp;</div></li><li><div>                        $info['warning'][] = 'Probable truncated AIFF file: expecting '.$thisfile_riff[$RIFFsubtype]['BODY'][0]['size'].' bytes of audio data, only '.($info['filesize'] - $info['avdataoffset']).' bytes found';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['VHDR'][0]['offset'])) {&nbsp;</div></li><li><div>                    // shortcut&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0 = &$thisfile_riff[$RIFFsubtype]['VHDR'][0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0['oneShotHiSamples'] =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 0, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0['repeatHiSamples'] =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 4, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0['samplesPerHiCycle'] =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 8, 4));&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0['samplesPerSec'] =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 12, 2));&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0['ctOctave'] =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 14, 1));&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0['sCompression'] =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 15, 1));&nbsp;</div></li><li><div>                    $thisfile_riff_RIFFsubtype_VHDR_0['Volume'] = getid3_lib::FixedPoint16_16(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 16, 4));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $thisfile_audio['sample_rate'] = $thisfile_riff_RIFFsubtype_VHDR_0['samplesPerSec'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    switch ($thisfile_riff_RIFFsubtype_VHDR_0['sCompression']) {&nbsp;</div></li><li><div>                        case 0:&nbsp;</div></li><li><div>                            $thisfile_audio['codec'] = 'Pulse Code Modulation (PCM)';&nbsp;</div></li><li><div>                            $thisfile_audio['lossless'] = true;&nbsp;</div></li><li><div>                            $ActualBitsPerSample = 8;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        case 1:&nbsp;</div></li><li><div>                            $thisfile_audio['codec'] = 'Fibonacci-delta encoding';&nbsp;</div></li><li><div>                            $thisfile_audio['lossless'] = false;&nbsp;</div></li><li><div>                            $ActualBitsPerSample = 4;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        default:&nbsp;</div></li><li><div>                            $info['warning'][] = 'Unexpected sCompression value in 8SVX.VHDR chunk - expecting 0 or 1, found &quot;'.sCompression.'&quot;';&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['CHAN'][0]['data'])) {&nbsp;</div></li><li><div>                    $ChannelsIndex = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['CHAN'][0]['data'], 0, 4));&nbsp;</div></li><li><div>                    switch ($ChannelsIndex) {&nbsp;</div></li><li><div>                        case 6: // Stereo&nbsp;</div></li><li><div>                            $thisfile_audio['channels'] = 2;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        case 2: // Left channel only&nbsp;</div></li><li><div>                        case 4: // Right channel only&nbsp;</div></li><li><div>                            $thisfile_audio['channels'] = 1;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        default:&nbsp;</div></li><li><div>                            $info['warning'][] = 'Unexpected value in 8SVX.CHAN chunk - expecting 2 or 4 or 6, found &quot;'.$ChannelsIndex.'&quot;';&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $CommentsChunkNames = array('NAME'=&gt;'title', 'author'=&gt;'artist', '(c) '=&gt;'copyright', 'ANNO'=&gt;'comment');&nbsp;</div></li><li><div>                foreach ($CommentsChunkNames as $key =&gt; $value) {&nbsp;</div></li><li><div>                    if (isset($thisfile_riff[$RIFFsubtype][$key][0]['data'])) {&nbsp;</div></li><li><div>                        $thisfile_riff['comments'][$value][] = $thisfile_riff[$RIFFsubtype][$key][0]['data'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $thisfile_audio['bitrate'] = $thisfile_audio['sample_rate'] * $ActualBitsPerSample * $thisfile_audio['channels'];&nbsp;</div></li><li><div>                if (!empty($thisfile_audio['bitrate'])) {&nbsp;</div></li><li><div>                    $info['playtime_seconds'] = ($info['avdataend'] - $info['avdataoffset']) / ($thisfile_audio['bitrate'] / 8);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'CDXA':&nbsp;</div></li><li><div>                $info['fileformat'] = 'vcd'; // Asume Video CD&nbsp;</div></li><li><div>                $info['mime_type'] = 'video/mpeg';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!empty($thisfile_riff['CDXA']['data'][0]['size'])) {&nbsp;</div></li><li><div>                    getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.mpeg.php', __FILE__, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $getid3_temp = new getID3();&nbsp;</div></li><li><div>                    $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                    $getid3_mpeg = new getid3_mpeg($getid3_temp);&nbsp;</div></li><li><div>                    $getid3_mpeg-&gt;Analyze();&nbsp;</div></li><li><div>                    if (empty($getid3_temp-&gt;info['error'])) {&nbsp;</div></li><li><div>                        $info['audio'] = $getid3_temp-&gt;info['audio'];&nbsp;</div></li><li><div>                        $info['video'] = $getid3_temp-&gt;info['video'];&nbsp;</div></li><li><div>                        $info['mpeg'] = $getid3_temp-&gt;info['mpeg'];&nbsp;</div></li><li><div>                        $info['warning'] = $getid3_temp-&gt;info['warning'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    unset($getid3_temp, $getid3_mpeg);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                $info['error'][] = 'Unknown RIFF type: expecting one of (WAVE|RMP3|AVI |CDDA|AIFF|AIFC|8SVX|CDXA), found &quot;'.$RIFFsubtype.'&quot; instead';&nbsp;</div></li><li><div>                //unset($info['fileformat']);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        switch ($RIFFsubtype) {&nbsp;</div></li><li><div>            case 'WAVE':&nbsp;</div></li><li><div>            case 'AIFF':&nbsp;</div></li><li><div>            case 'AIFC':&nbsp;</div></li><li><div>                $ID3v2_key_good = 'id3 ';&nbsp;</div></li><li><div>                $ID3v2_keys_bad = array('ID3 ', 'tag ');&nbsp;</div></li><li><div>                foreach ($ID3v2_keys_bad as $ID3v2_key_bad) {&nbsp;</div></li><li><div>                    if (isset($thisfile_riff[$RIFFsubtype][$ID3v2_key_bad]) && !array_key_exists($ID3v2_key_good, $thisfile_riff[$RIFFsubtype])) {&nbsp;</div></li><li><div>                        $thisfile_riff[$RIFFsubtype][$ID3v2_key_good] = $thisfile_riff[$RIFFsubtype][$ID3v2_key_bad];&nbsp;</div></li><li><div>                        $info['warning'][] = 'mapping &quot;'.$ID3v2_key_bad.'&quot; chunk to &quot;'.$ID3v2_key_good.'&quot;';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (isset($thisfile_riff[$RIFFsubtype]['id3 '])) {&nbsp;</div></li><li><div>                    getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v2.php', __FILE__, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $getid3_temp = new getID3();&nbsp;</div></li><li><div>                    $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                    $getid3_id3v2 = new getid3_id3v2($getid3_temp);&nbsp;</div></li><li><div>                    $getid3_id3v2-&gt;StartingOffset = $thisfile_riff[$RIFFsubtype]['id3 '][0]['offset'] + 8;&nbsp;</div></li><li><div>                    if ($thisfile_riff[$RIFFsubtype]['id3 '][0]['valid'] = $getid3_id3v2-&gt;Analyze()) {&nbsp;</div></li><li><div>                        $info['id3v2'] = $getid3_temp-&gt;info['id3v2'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    unset($getid3_temp, $getid3_id3v2);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($thisfile_riff_WAVE['DISP']) && is_array($thisfile_riff_WAVE['DISP'])) {&nbsp;</div></li><li><div>            $thisfile_riff['comments']['title'][] = trim(substr($thisfile_riff_WAVE['DISP'][count($thisfile_riff_WAVE['DISP']) - 1]['data'], 4));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (isset($thisfile_riff_WAVE['INFO']) && is_array($thisfile_riff_WAVE['INFO'])) {&nbsp;</div></li><li><div>            self::parseComments($thisfile_riff_WAVE['INFO'], $thisfile_riff['comments']);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (isset($thisfile_riff['AVI ']['INFO']) && is_array($thisfile_riff['AVI ']['INFO'])) {&nbsp;</div></li><li><div>            self::parseComments($thisfile_riff['AVI ']['INFO'], $thisfile_riff['comments']);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (empty($thisfile_audio['encoder']) && !empty($info['mpeg']['audio']['LAME']['short_version'])) {&nbsp;</div></li><li><div>            $thisfile_audio['encoder'] = $info['mpeg']['audio']['LAME']['short_version'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (!isset($info['playtime_seconds'])) {&nbsp;</div></li><li><div>            $info['playtime_seconds'] = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (isset($thisfile_riff_raw['strh'][0]['dwLength']) && isset($thisfile_riff_raw['avih']['dwMicroSecPerFrame'])) {&nbsp;</div></li><li><div>            // needed for &gt;2GB AVIs where 'avih' chunk only lists number of frames in that chunk, not entire movie&nbsp;</div></li><li><div>            $info['playtime_seconds'] = $thisfile_riff_raw['strh'][0]['dwLength'] * ($thisfile_riff_raw['avih']['dwMicroSecPerFrame'] / 1000000);&nbsp;</div></li><li><div>        } elseif (isset($thisfile_riff_raw['avih']['dwTotalFrames']) && isset($thisfile_riff_raw['avih']['dwMicroSecPerFrame'])) {&nbsp;</div></li><li><div>            $info['playtime_seconds'] = $thisfile_riff_raw['avih']['dwTotalFrames'] * ($thisfile_riff_raw['avih']['dwMicroSecPerFrame'] / 1000000);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($info['playtime_seconds'] &gt; 0) {&nbsp;</div></li><li><div>            if (isset($thisfile_riff_audio) && isset($thisfile_riff_video)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!isset($info['bitrate'])) {&nbsp;</div></li><li><div>                    $info['bitrate'] = ((($info['avdataend'] - $info['avdataoffset']) / $info['playtime_seconds']) * 8);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            } elseif (isset($thisfile_riff_audio) && !isset($thisfile_riff_video)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!isset($thisfile_audio['bitrate'])) {&nbsp;</div></li><li><div>                    $thisfile_audio['bitrate'] = ((($info['avdataend'] - $info['avdataoffset']) / $info['playtime_seconds']) * 8);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            } elseif (!isset($thisfile_riff_audio) && isset($thisfile_riff_video)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!isset($thisfile_video['bitrate'])) {&nbsp;</div></li><li><div>                    $thisfile_video['bitrate'] = ((($info['avdataend'] - $info['avdataoffset']) / $info['playtime_seconds']) * 8);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($thisfile_riff_video) && isset($thisfile_audio['bitrate']) && ($thisfile_audio['bitrate'] &gt; 0) && ($info['playtime_seconds'] &gt; 0)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $info['bitrate'] = ((($info['avdataend'] - $info['avdataoffset']) / $info['playtime_seconds']) * 8);&nbsp;</div></li><li><div>            $thisfile_audio['bitrate'] = 0;&nbsp;</div></li><li><div>            $thisfile_video['bitrate'] = $info['bitrate'];&nbsp;</div></li><li><div>            foreach ($thisfile_riff_audio as $channelnumber =&gt; $audioinfoarray) {&nbsp;</div></li><li><div>                $thisfile_video['bitrate'] -= $audioinfoarray['bitrate'];&nbsp;</div></li><li><div>                $thisfile_audio['bitrate'] += $audioinfoarray['bitrate'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($thisfile_video['bitrate'] &lt;= 0) {&nbsp;</div></li><li><div>                unset($thisfile_video['bitrate']);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($thisfile_audio['bitrate'] &lt;= 0) {&nbsp;</div></li><li><div>                unset($thisfile_audio['bitrate']);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($info['mpeg']['audio'])) {&nbsp;</div></li><li><div>            $thisfile_audio_dataformat = 'mp'.$info['mpeg']['audio']['layer'];&nbsp;</div></li><li><div>            $thisfile_audio['sample_rate'] = $info['mpeg']['audio']['sample_rate'];&nbsp;</div></li><li><div>            $thisfile_audio['channels'] = $info['mpeg']['audio']['channels'];&nbsp;</div></li><li><div>            $thisfile_audio['bitrate'] = $info['mpeg']['audio']['bitrate'];&nbsp;</div></li><li><div>            $thisfile_audio['bitrate_mode'] = strtolower($info['mpeg']['audio']['bitrate_mode']);&nbsp;</div></li><li><div>            if (!empty($info['mpeg']['audio']['codec'])) {&nbsp;</div></li><li><div>                $thisfile_audio['codec'] = $info['mpeg']['audio']['codec'].' '.$thisfile_audio['codec'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (!empty($thisfile_audio['streams'])) {&nbsp;</div></li><li><div>                foreach ($thisfile_audio['streams'] as $streamnumber =&gt; $streamdata) {&nbsp;</div></li><li><div>                    if ($streamdata['dataformat'] == $thisfile_audio_dataformat) {&nbsp;</div></li><li><div>                        $thisfile_audio['streams'][$streamnumber]['sample_rate'] = $thisfile_audio['sample_rate'];&nbsp;</div></li><li><div>                        $thisfile_audio['streams'][$streamnumber]['channels'] = $thisfile_audio['channels'];&nbsp;</div></li><li><div>                        $thisfile_audio['streams'][$streamnumber]['bitrate'] = $thisfile_audio['bitrate'];&nbsp;</div></li><li><div>                        $thisfile_audio['streams'][$streamnumber]['bitrate_mode'] = $thisfile_audio['bitrate_mode'];&nbsp;</div></li><li><div>                        $thisfile_audio['streams'][$streamnumber]['codec'] = $thisfile_audio['codec'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $getid3_mp3 = new getid3_mp3($this-&gt;getid3);&nbsp;</div></li><li><div>            $thisfile_audio['encoder_options'] = $getid3_mp3-&gt;GuessEncoderOptions();&nbsp;</div></li><li><div>            unset($getid3_mp3);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (!empty($thisfile_riff_raw['fmt ']['wBitsPerSample']) && ($thisfile_riff_raw['fmt ']['wBitsPerSample'] &gt; 0)) {&nbsp;</div></li><li><div>            switch ($thisfile_audio_dataformat) {&nbsp;</div></li><li><div>                case 'ac3':&nbsp;</div></li><li><div>                    // ignore bits_per_sample&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                default:&nbsp;</div></li><li><div>                    $thisfile_audio['bits_per_sample'] = $thisfile_riff_raw['fmt ']['wBitsPerSample'];&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (empty($thisfile_riff_raw)) {&nbsp;</div></li><li><div>            unset($thisfile_riff['raw']);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (empty($thisfile_riff_audio)) {&nbsp;</div></li><li><div>            unset($thisfile_riff['audio']);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (empty($thisfile_riff_video)) {&nbsp;</div></li><li><div>            unset($thisfile_riff['video']);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function ParseRIFFAMV($startoffset, $maxoffset) {&nbsp;</div></li><li><div>        // AMV files are RIFF-AVI files with parts of the spec deliberately broken, such as chunk size fields hardcoded to zero (because players known in hardware that these fields are always a certain size&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // https://code.google.com/p/amv-codec-tools/wiki/AmvDocumentation&nbsp;</div></li><li><div>        //typedef struct _amvmainheader {&nbsp;</div></li><li><div>        //FOURCC fcc; // 'amvh'&nbsp;</div></li><li><div>        //DWORD cb;&nbsp;</div></li><li><div>        //DWORD dwMicroSecPerFrame;&nbsp;</div></li><li><div>        //BYTE reserve[28];&nbsp;</div></li><li><div>        //DWORD dwWidth;&nbsp;</div></li><li><div>        //DWORD dwHeight;&nbsp;</div></li><li><div>        //DWORD dwSpeed;&nbsp;</div></li><li><div>        //DWORD reserve0;&nbsp;</div></li><li><div>        //DWORD reserve1;&nbsp;</div></li><li><div>        //BYTE bTimeSec;&nbsp;</div></li><li><div>        //BYTE bTimeMin;&nbsp;</div></li><li><div>        //WORD wTimeHour;&nbsp;</div></li><li><div>        //} AMVMAINHEADER;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $info = &$this-&gt;getid3-&gt;info;&nbsp;</div></li><li><div>        $RIFFchunk = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        try {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;fseek($startoffset);&nbsp;</div></li><li><div>            $maxoffset = min($maxoffset, $info['avdataend']);&nbsp;</div></li><li><div>            $AMVheader = $this-&gt;fread(284);&nbsp;</div></li><li><div>            if (substr($AMVheader, 0, 8) != 'hdrlamvh') {&nbsp;</div></li><li><div>                throw new Exception('expecting &quot;hdrlamv&quot; at offset '.($startoffset +   0).', found &quot;'.substr($AMVheader, 0, 8).'&quot;');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (substr($AMVheader, 8, 4) != &quot;\x38\x00\x00\x00&quot;) { // &quot;amvh&quot; chunk size, hardcoded to 0x38 = 56 bytes&nbsp;</div></li><li><div>                throw new Exception('expecting &quot;0x38000000&quot; at offset '.($startoffset +   8).', found &quot;'.getid3_lib::PrintHexBytes(substr($AMVheader, 8, 4)).'&quot;');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $RIFFchunk = array();&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['us_per_frame'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 12, 4));&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['reserved28'] =                              substr($AMVheader, 16, 28);  // null? reserved?&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['resolution_x'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 44, 4));&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['resolution_y'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 48, 4));&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['frame_rate_int'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 52, 4));&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['reserved0'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 56, 4)); // 1? reserved?&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['reserved1'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 60, 4)); // 0? reserved?&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['runtime_sec'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 64, 1));&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['runtime_min'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 65, 1));&nbsp;</div></li><li><div>            $RIFFchunk['amvh']['runtime_hrs'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 66, 2));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $info['video']['frame_rate'] = 1000000 / $RIFFchunk['amvh']['us_per_frame'];&nbsp;</div></li><li><div>            $info['video']['resolution_x'] = $RIFFchunk['amvh']['resolution_x'];&nbsp;</div></li><li><div>            $info['video']['resolution_y'] = $RIFFchunk['amvh']['resolution_y'];&nbsp;</div></li><li><div>            $info['playtime_seconds'] = ($RIFFchunk['amvh']['runtime_hrs'] * 3600) + ($RIFFchunk['amvh']['runtime_min'] * 60) + $RIFFchunk['amvh']['runtime_sec'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // the rest is all hardcoded(?) and does not appear to be useful until you get to audio info at offset 256, even then everything is probably hardcoded&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (substr($AMVheader, 68, 20) != 'LIST'.&quot;\x00\x00\x00\x00&quot;.'strlstrh'.&quot;\x38\x00\x00\x00&quot;) {&nbsp;</div></li><li><div>                throw new Exception('expecting &quot;LIST&lt;0x00000000&gt;strlstrh&lt;0x38000000&gt;&quot; at offset '.($startoffset +  68).', found &quot;'.getid3_lib::PrintHexBytes(substr($AMVheader, 68, 20)).'&quot;');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // followed by 56 bytes of null: substr($AMVheader, 88, 56) -&gt; 144&nbsp;</div></li><li><div>            if (substr($AMVheader, 144, 8) != 'strf'.&quot;\x24\x00\x00\x00&quot;) {&nbsp;</div></li><li><div>                throw new Exception('expecting &quot;strf&lt;0x24000000&gt;&quot; at offset '.($startoffset + 144).', found &quot;'.getid3_lib::PrintHexBytes(substr($AMVheader, 144, 8)).'&quot;');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // followed by 36 bytes of null: substr($AMVheader, 144, 36) -&gt; 180&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (substr($AMVheader, 188, 20) != 'LIST'.&quot;\x00\x00\x00\x00&quot;.'strlstrh'.&quot;\x30\x00\x00\x00&quot;) {&nbsp;</div></li><li><div>                throw new Exception('expecting &quot;LIST&lt;0x00000000&gt;strlstrh&lt;0x30000000&gt;&quot; at offset '.($startoffset + 188).', found &quot;'.getid3_lib::PrintHexBytes(substr($AMVheader, 188, 20)).'&quot;');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // followed by 48 bytes of null: substr($AMVheader, 208, 48) -&gt; 256&nbsp;</div></li><li><div>            if (substr($AMVheader, 256, 8) != 'strf'.&quot;\x14\x00\x00\x00&quot;) {&nbsp;</div></li><li><div>                throw new Exception('expecting &quot;strf&lt;0x14000000&gt;&quot; at offset '.($startoffset + 256).', found &quot;'.getid3_lib::PrintHexBytes(substr($AMVheader, 256, 8)).'&quot;');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // followed by 20 bytes of a modified WAVEFORMATEX:&nbsp;</div></li><li><div>            // typedef struct {&nbsp;</div></li><li><div>            // WORD wFormatTag;       //(Fixme: this is equal to PCM's 0x01 format code)&nbsp;</div></li><li><div>            // WORD nChannels;        //(Fixme: this is always 1)&nbsp;</div></li><li><div>            // DWORD nSamplesPerSec;  //(Fixme: for all known sample files this is equal to 22050)&nbsp;</div></li><li><div>            // DWORD nAvgBytesPerSec; //(Fixme: for all known sample files this is equal to 44100)&nbsp;</div></li><li><div>            // WORD nBlockAlign;      //(Fixme: this seems to be 2 in AMV files, is this correct ?)&nbsp;</div></li><li><div>            // WORD wBitsPerSample;   //(Fixme: this seems to be 16 in AMV files instead of the expected 4)&nbsp;</div></li><li><div>            // WORD cbSize;           //(Fixme: this seems to be 0 in AMV files)&nbsp;</div></li><li><div>            // WORD reserved;&nbsp;</div></li><li><div>            // } WAVEFORMATEX;&nbsp;</div></li><li><div>            $RIFFchunk['strf']['wformattag'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 264, 2));&nbsp;</div></li><li><div>            $RIFFchunk['strf']['nchannels'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 266, 2));&nbsp;</div></li><li><div>            $RIFFchunk['strf']['nsamplespersec'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 268, 4));&nbsp;</div></li><li><div>            $RIFFchunk['strf']['navgbytespersec'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 272, 4));&nbsp;</div></li><li><div>            $RIFFchunk['strf']['nblockalign'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 276, 2));&nbsp;</div></li><li><div>            $RIFFchunk['strf']['wbitspersample'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 278, 2));&nbsp;</div></li><li><div>            $RIFFchunk['strf']['cbsize'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 280, 2));&nbsp;</div></li><li><div>            $RIFFchunk['strf']['reserved'] = getid3_lib::LittleEndian2Int(substr($AMVheader, 282, 2));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $info['audio']['lossless'] = false;&nbsp;</div></li><li><div>            $info['audio']['sample_rate'] = $RIFFchunk['strf']['nsamplespersec'];&nbsp;</div></li><li><div>            $info['audio']['channels'] = $RIFFchunk['strf']['nchannels'];&nbsp;</div></li><li><div>            $info['audio']['bits_per_sample'] = $RIFFchunk['strf']['wbitspersample'];&nbsp;</div></li><li><div>            $info['audio']['bitrate'] = $info['audio']['sample_rate'] * $info['audio']['channels'] * $info['audio']['bits_per_sample'];&nbsp;</div></li><li><div>            $info['audio']['bitrate_mode'] = 'cbr';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        } catch (getid3_exception $e) {&nbsp;</div></li><li><div>            if ($e-&gt;getCode() == 10) {&nbsp;</div></li><li><div>                $this-&gt;warning('RIFFAMV parser: '.$e-&gt;getMessage());&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                throw $e;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $RIFFchunk;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function ParseRIFF($startoffset, $maxoffset) {&nbsp;</div></li><li><div>        $info = &$this-&gt;getid3-&gt;info;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $RIFFchunk = false;&nbsp;</div></li><li><div>        $FoundAllChunksWeNeed = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        try {&nbsp;</div></li><li><div>            $this-&gt;fseek($startoffset);&nbsp;</div></li><li><div>            $maxoffset = min($maxoffset, $info['avdataend']);&nbsp;</div></li><li><div>            while ($this-&gt;ftell() &lt; $maxoffset) {&nbsp;</div></li><li><div>                $chunknamesize = $this-&gt;fread(8);&nbsp;</div></li><li><div>                //$chunkname =                          substr($chunknamesize, 0, 4);&nbsp;</div></li><li><div>                $chunkname = str_replace(&quot;\x00&quot;, '_', substr($chunknamesize, 0, 4));  // note: chunk names of 4 null bytes do appear to be legal (has been observed inside INFO and PRMI chunks, for example), but makes traversing array keys more difficult&nbsp;</div></li><li><div>                $chunksize =  $this-&gt;EitherEndian2Int(substr($chunknamesize, 4, 4));&nbsp;</div></li><li><div>                //if (strlen(trim($chunkname, &quot;\x00&quot;)) &lt; 4) {&nbsp;</div></li><li><div>                if (strlen($chunkname) &lt; 4) {&nbsp;</div></li><li><div>                    $this-&gt;error('Expecting chunk name at offset '.($this-&gt;ftell() - 8).' but found nothing. Aborting RIFF parsing.');&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (($chunksize == 0) && ($chunkname != 'JUNK')) {&nbsp;</div></li><li><div>                    $this-&gt;warning('Chunk ('.$chunkname.') size at offset '.($this-&gt;ftell() - 4).' is zero. Aborting RIFF parsing.');&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (($chunksize % 2) != 0) {&nbsp;</div></li><li><div>                    // all structures are packed on word boundaries&nbsp;</div></li><li><div>                    $chunksize++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                switch ($chunkname) {&nbsp;</div></li><li><div>                    case 'LIST':&nbsp;</div></li><li><div>                        $listname = $this-&gt;fread(4);&nbsp;</div></li><li><div>                        if (preg_match('#^(movi|rec )$#i', $listname)) {&nbsp;</div></li><li><div>                            $RIFFchunk[$listname]['offset'] = $this-&gt;ftell() - 4;&nbsp;</div></li><li><div>                            $RIFFchunk[$listname]['size'] = $chunksize;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if (!$FoundAllChunksWeNeed) {&nbsp;</div></li><li><div>                                $WhereWeWere = $this-&gt;ftell();&nbsp;</div></li><li><div>                                $AudioChunkHeader = $this-&gt;fread(12);&nbsp;</div></li><li><div>                                $AudioChunkStreamNum =                              substr($AudioChunkHeader, 0, 2);&nbsp;</div></li><li><div>                                $AudioChunkStreamType =                              substr($AudioChunkHeader, 2, 2);&nbsp;</div></li><li><div>                                $AudioChunkSize = getid3_lib::LittleEndian2Int(substr($AudioChunkHeader, 4, 4));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                if ($AudioChunkStreamType == 'wb') {&nbsp;</div></li><li><div>                                    $FirstFourBytes = substr($AudioChunkHeader, 8, 4);&nbsp;</div></li><li><div>                                    if (preg_match('/^\xFF[\xE2-\xE7\xF2-\xF7\xFA-\xFF][\x00-\xEB]/s', $FirstFourBytes)) {&nbsp;</div></li><li><div>                                        // MP3&nbsp;</div></li><li><div>                                        if (getid3_mp3::MPEGaudioHeaderBytesValid($FirstFourBytes)) {&nbsp;</div></li><li><div>                                            $getid3_temp = new getID3();&nbsp;</div></li><li><div>                                            $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                                            $getid3_temp-&gt;info['avdataoffset'] = $this-&gt;ftell() - 4;&nbsp;</div></li><li><div>                                            $getid3_temp-&gt;info['avdataend'] = $this-&gt;ftell() + $AudioChunkSize;&nbsp;</div></li><li><div>                                            $getid3_mp3 = new getid3_mp3($getid3_temp, __CLASS__);&nbsp;</div></li><li><div>                                            $getid3_mp3-&gt;getOnlyMPEGaudioInfo($getid3_temp-&gt;info['avdataoffset'], false);&nbsp;</div></li><li><div>                                            if (isset($getid3_temp-&gt;info['mpeg']['audio'])) {&nbsp;</div></li><li><div>                                                $info['mpeg']['audio'] = $getid3_temp-&gt;info['mpeg']['audio'];&nbsp;</div></li><li><div>                                                $info['audio'] = $getid3_temp-&gt;info['audio'];&nbsp;</div></li><li><div>                                                $info['audio']['dataformat'] = 'mp'.$info['mpeg']['audio']['layer'];&nbsp;</div></li><li><div>                                                $info['audio']['sample_rate'] = $info['mpeg']['audio']['sample_rate'];&nbsp;</div></li><li><div>                                                $info['audio']['channels'] = $info['mpeg']['audio']['channels'];&nbsp;</div></li><li><div>                                                $info['audio']['bitrate'] = $info['mpeg']['audio']['bitrate'];&nbsp;</div></li><li><div>                                                $info['audio']['bitrate_mode'] = strtolower($info['mpeg']['audio']['bitrate_mode']);&nbsp;</div></li><li><div>                                                //$info['bitrate'] = $info['audio']['bitrate'];&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                            unset($getid3_temp, $getid3_mp3);&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    } elseif (strpos($FirstFourBytes, getid3_ac3::syncword) === 0) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                        // AC3&nbsp;</div></li><li><div>                                        $getid3_temp = new getID3();&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;info['avdataoffset'] = $this-&gt;ftell() - 4;&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;info['avdataend'] = $this-&gt;ftell() + $AudioChunkSize;&nbsp;</div></li><li><div>                                        $getid3_ac3 = new getid3_ac3($getid3_temp);&nbsp;</div></li><li><div>                                        $getid3_ac3-&gt;Analyze();&nbsp;</div></li><li><div>                                        if (empty($getid3_temp-&gt;info['error'])) {&nbsp;</div></li><li><div>                                            $info['audio'] = $getid3_temp-&gt;info['audio'];&nbsp;</div></li><li><div>                                            $info['ac3'] = $getid3_temp-&gt;info['ac3'];&nbsp;</div></li><li><div>                                            if (!empty($getid3_temp-&gt;info['warning'])) {&nbsp;</div></li><li><div>                                                foreach ($getid3_temp-&gt;info['warning'] as $key =&gt; $value) {&nbsp;</div></li><li><div>                                                    $info['warning'][] = $value;&nbsp;</div></li><li><div>                                                }&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                        unset($getid3_temp, $getid3_ac3);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $FoundAllChunksWeNeed = true;&nbsp;</div></li><li><div>                                $this-&gt;fseek($WhereWeWere);&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $this-&gt;fseek($chunksize - 4, SEEK_CUR);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if (!isset($RIFFchunk[$listname])) {&nbsp;</div></li><li><div>                                $RIFFchunk[$listname] = array();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $LISTchunkParent = $listname;&nbsp;</div></li><li><div>                            $LISTchunkMaxOffset = $this-&gt;ftell() - 4 + $chunksize;&nbsp;</div></li><li><div>                            if ($parsedChunk = $this-&gt;ParseRIFF($this-&gt;ftell(), $LISTchunkMaxOffset)) {&nbsp;</div></li><li><div>                                $RIFFchunk[$listname] = array_merge_recursive($RIFFchunk[$listname], $parsedChunk);&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    default:&nbsp;</div></li><li><div>                        if (preg_match('#^[0-9]{2}(wb|pc|dc|db)$#', $chunkname)) {&nbsp;</div></li><li><div>                            $this-&gt;fseek($chunksize, SEEK_CUR);&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $thisindex = 0;&nbsp;</div></li><li><div>                        if (isset($RIFFchunk[$chunkname]) && is_array($RIFFchunk[$chunkname])) {&nbsp;</div></li><li><div>                            $thisindex = count($RIFFchunk[$chunkname]);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $RIFFchunk[$chunkname][$thisindex]['offset'] = $this-&gt;ftell() - 8;&nbsp;</div></li><li><div>                        $RIFFchunk[$chunkname][$thisindex]['size'] = $chunksize;&nbsp;</div></li><li><div>                        switch ($chunkname) {&nbsp;</div></li><li><div>                            case 'data':&nbsp;</div></li><li><div>                                $info['avdataoffset'] = $this-&gt;ftell();&nbsp;</div></li><li><div>                                $info['avdataend'] = $info['avdataoffset'] + $chunksize;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $testData = $this-&gt;fread(36);&nbsp;</div></li><li><div>                                if ($testData === '') {&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if (preg_match('/^\xFF[\xE2-\xE7\xF2-\xF7\xFA-\xFF][\x00-\xEB]/s', substr($testData, 0, 4))) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    // Probably is MP3 data&nbsp;</div></li><li><div>                                    if (getid3_mp3::MPEGaudioHeaderBytesValid(substr($testData, 0, 4))) {&nbsp;</div></li><li><div>                                        $getid3_temp = new getID3();&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;info['avdataoffset'] = $info['avdataoffset'];&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;info['avdataend'] = $info['avdataend'];&nbsp;</div></li><li><div>                                        $getid3_mp3 = new getid3_mp3($getid3_temp, __CLASS__);&nbsp;</div></li><li><div>                                        $getid3_mp3-&gt;getOnlyMPEGaudioInfo($info['avdataoffset'], false);&nbsp;</div></li><li><div>                                        if (empty($getid3_temp-&gt;info['error'])) {&nbsp;</div></li><li><div>                                            $info['audio'] = $getid3_temp-&gt;info['audio'];&nbsp;</div></li><li><div>                                            $info['mpeg'] = $getid3_temp-&gt;info['mpeg'];&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                        unset($getid3_temp, $getid3_mp3);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                } elseif (($isRegularAC3 = (substr($testData, 0, 2) == getid3_ac3::syncword)) || substr($testData, 8, 2) == strrev(getid3_ac3::syncword)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    // This is probably AC-3 data&nbsp;</div></li><li><div>                                    $getid3_temp = new getID3();&nbsp;</div></li><li><div>                                    if ($isRegularAC3) {&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;info['avdataoffset'] = $info['avdataoffset'];&nbsp;</div></li><li><div>                                        $getid3_temp-&gt;info['avdataend'] = $info['avdataend'];&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    $getid3_ac3 = new getid3_ac3($getid3_temp);&nbsp;</div></li><li><div>                                    if ($isRegularAC3) {&nbsp;</div></li><li><div>                                        $getid3_ac3-&gt;Analyze();&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        // Dolby Digital WAV&nbsp;</div></li><li><div>                                        // AC-3 content, but not encoded in same format as normal AC-3 file&nbsp;</div></li><li><div>                                        // For one thing, byte order is swapped&nbsp;</div></li><li><div>                                        $ac3_data = '';&nbsp;</div></li><li><div>                                        for ($i = 0; $i &lt; 28; $i += 2) {&nbsp;</div></li><li><div>                                            $ac3_data .= substr($testData, 8 + $i + 1, 1);&nbsp;</div></li><li><div>                                            $ac3_data .= substr($testData, 8 + $i + 0, 1);&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                        $getid3_ac3-&gt;AnalyzeString($ac3_data);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    if (empty($getid3_temp-&gt;info['error'])) {&nbsp;</div></li><li><div>                                        $info['audio'] = $getid3_temp-&gt;info['audio'];&nbsp;</div></li><li><div>                                        $info['ac3'] = $getid3_temp-&gt;info['ac3'];&nbsp;</div></li><li><div>                                        if (!empty($getid3_temp-&gt;info['warning'])) {&nbsp;</div></li><li><div>                                            foreach ($getid3_temp-&gt;info['warning'] as $newerror) {&nbsp;</div></li><li><div>                                                $this-&gt;warning('getid3_ac3() says: ['.$newerror.']');&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    unset($getid3_temp, $getid3_ac3);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                } elseif (preg_match('/^('.implode('|', array_map('preg_quote', getid3_dts::$syncwords)).')/', $testData)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    // This is probably DTS data&nbsp;</div></li><li><div>                                    $getid3_temp = new getID3();&nbsp;</div></li><li><div>                                    $getid3_temp-&gt;openfile($this-&gt;getid3-&gt;filename);&nbsp;</div></li><li><div>                                    $getid3_temp-&gt;info['avdataoffset'] = $info['avdataoffset'];&nbsp;</div></li><li><div>                                    $getid3_dts = new getid3_dts($getid3_temp);&nbsp;</div></li><li><div>                                    $getid3_dts-&gt;Analyze();&nbsp;</div></li><li><div>                                    if (empty($getid3_temp-&gt;info['error'])) {&nbsp;</div></li><li><div>                                        $info['audio'] = $getid3_temp-&gt;info['audio'];&nbsp;</div></li><li><div>                                        $info['dts'] = $getid3_temp-&gt;info['dts'];&nbsp;</div></li><li><div>                                        $info['playtime_seconds'] = $getid3_temp-&gt;info['playtime_seconds']; // may not match RIFF calculations since DTS-WAV often used 14/16 bit-word packing&nbsp;</div></li><li><div>                                        if (!empty($getid3_temp-&gt;info['warning'])) {&nbsp;</div></li><li><div>                                            foreach ($getid3_temp-&gt;info['warning'] as $newerror) {&nbsp;</div></li><li><div>                                                $this-&gt;warning('getid3_dts() says: ['.$newerror.']');&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    unset($getid3_temp, $getid3_dts);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                } elseif (substr($testData, 0, 4) == 'wvpk') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    // This is WavPack data&nbsp;</div></li><li><div>                                    $info['wavpack']['offset'] = $info['avdataoffset'];&nbsp;</div></li><li><div>                                    $info['wavpack']['size'] = getid3_lib::LittleEndian2Int(substr($testData, 4, 4));&nbsp;</div></li><li><div>                                    $this-&gt;parseWavPackHeader(substr($testData, 8, 28));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    // This is some other kind of data (quite possibly just PCM)&nbsp;</div></li><li><div>                                    // do nothing special, just skip it&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $nextoffset = $info['avdataend'];&nbsp;</div></li><li><div>                                $this-&gt;fseek($nextoffset);&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            case 'iXML':&nbsp;</div></li><li><div>                            case 'bext':&nbsp;</div></li><li><div>                            case 'cart':&nbsp;</div></li><li><div>                            case 'fmt ':&nbsp;</div></li><li><div>                            case 'strh':&nbsp;</div></li><li><div>                            case 'strf':&nbsp;</div></li><li><div>                            case 'indx':&nbsp;</div></li><li><div>                            case 'MEXT':&nbsp;</div></li><li><div>                            case 'DISP':&nbsp;</div></li><li><div>                                // always read data in&nbsp;</div></li><li><div>                            case 'JUNK':&nbsp;</div></li><li><div>                                // should be: never read data in&nbsp;</div></li><li><div>                                // but some programs write their version strings in a JUNK chunk (e.g. VirtualDub, AVIdemux, etc)&nbsp;</div></li><li><div>                                if ($chunksize &lt; 1048576) {&nbsp;</div></li><li><div>                                    if ($chunksize &gt; 0) {&nbsp;</div></li><li><div>                                        $RIFFchunk[$chunkname][$thisindex]['data'] = $this-&gt;fread($chunksize);&nbsp;</div></li><li><div>                                        if ($chunkname == 'JUNK') {&nbsp;</div></li><li><div>                                            if (preg_match('#^([\\x20-\\x7F]+)#', $RIFFchunk[$chunkname][$thisindex]['data'], $matches)) {&nbsp;</div></li><li><div>                                                // only keep text characters [chr(32)-chr(127)]&nbsp;</div></li><li><div>                                                $info['riff']['comments']['junk'][] = trim($matches[1]);&nbsp;</div></li><li><div>                                            }&nbsp;</div></li><li><div>                                            // but if nothing there, ignore&nbsp;</div></li><li><div>                                            // remove the key in either case&nbsp;</div></li><li><div>                                            unset($RIFFchunk[$chunkname][$thisindex]['data']);&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $this-&gt;warning('Chunk &quot;'.$chunkname.'&quot; at offset '.$this-&gt;ftell().' is unexpectedly larger than 1MB (claims to be '.number_format($chunksize).' bytes), skipping data');&nbsp;</div></li><li><div>                                    $this-&gt;fseek($chunksize, SEEK_CUR);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            //case 'IDVX':&nbsp;</div></li><li><div>                            //    $info['divxtag']['comments'] = self::ParseDIVXTAG($this-&gt;fread($chunksize));&nbsp;</div></li><li><div>                            //    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            default:&nbsp;</div></li><li><div>                                if (!empty($LISTchunkParent) && (($RIFFchunk[$chunkname][$thisindex]['offset'] + $RIFFchunk[$chunkname][$thisindex]['size']) &lt;= $LISTchunkMaxOffset)) {&nbsp;</div></li><li><div>                                    $RIFFchunk[$LISTchunkParent][$chunkname][$thisindex]['offset'] = $RIFFchunk[$chunkname][$thisindex]['offset'];&nbsp;</div></li><li><div>                                    $RIFFchunk[$LISTchunkParent][$chunkname][$thisindex]['size'] = $RIFFchunk[$chunkname][$thisindex]['size'];&nbsp;</div></li><li><div>                                    unset($RIFFchunk[$chunkname][$thisindex]['offset']);&nbsp;</div></li><li><div>                                    unset($RIFFchunk[$chunkname][$thisindex]['size']);&nbsp;</div></li><li><div>                                    if (isset($RIFFchunk[$chunkname][$thisindex]) && empty($RIFFchunk[$chunkname][$thisindex])) {&nbsp;</div></li><li><div>                                        unset($RIFFchunk[$chunkname][$thisindex]);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    if (isset($RIFFchunk[$chunkname]) && empty($RIFFchunk[$chunkname])) {&nbsp;</div></li><li><div>                                        unset($RIFFchunk[$chunkname]);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    $RIFFchunk[$LISTchunkParent][$chunkname][$thisindex]['data'] = $this-&gt;fread($chunksize);&nbsp;</div></li><li><div>                                } elseif ($chunksize &lt; 2048) {&nbsp;</div></li><li><div>                                    // only read data in if smaller than 2kB&nbsp;</div></li><li><div>                                    $RIFFchunk[$chunkname][$thisindex]['data'] = $this-&gt;fread($chunksize);&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $this-&gt;fseek($chunksize, SEEK_CUR);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        } catch (getid3_exception $e) {&nbsp;</div></li><li><div>            if ($e-&gt;getCode() == 10) {&nbsp;</div></li><li><div>                $this-&gt;warning('RIFF parser: '.$e-&gt;getMessage());&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                throw $e;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $RIFFchunk;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function ParseRIFFdata(&$RIFFdata) {&nbsp;</div></li><li><div>        $info = &$this-&gt;getid3-&gt;info;&nbsp;</div></li><li><div>        if ($RIFFdata) {&nbsp;</div></li><li><div>            $tempfile = tempnam(GETID3_TEMP_DIR, 'getID3');&nbsp;</div></li><li><div>            $fp_temp = fopen($tempfile, 'wb');&nbsp;</div></li><li><div>            $RIFFdataLength = strlen($RIFFdata);&nbsp;</div></li><li><div>            $NewLengthString = getid3_lib::LittleEndian2String($RIFFdataLength, 4);&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; 4; $i++) {&nbsp;</div></li><li><div>                $RIFFdata[($i + 4)] = $NewLengthString[$i];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            fwrite($fp_temp, $RIFFdata);&nbsp;</div></li><li><div>            fclose($fp_temp);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $getid3_temp = new getID3();&nbsp;</div></li><li><div>            $getid3_temp-&gt;openfile($tempfile);&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['filesize'] = $RIFFdataLength;&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['filenamepath'] = $info['filenamepath'];&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['tags'] = $info['tags'];&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['warning'] = $info['warning'];&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['error'] = $info['error'];&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['comments'] = $info['comments'];&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['audio'] = (isset($info['audio']) ? $info['audio'] : array());&nbsp;</div></li><li><div>            $getid3_temp-&gt;info['video'] = (isset($info['video']) ? $info['video'] : array());&nbsp;</div></li><li><div>            $getid3_riff = new getid3_riff($getid3_temp);&nbsp;</div></li><li><div>            $getid3_riff-&gt;Analyze();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $info['riff'] = $getid3_temp-&gt;info['riff'];&nbsp;</div></li><li><div>            $info['warning'] = $getid3_temp-&gt;info['warning'];&nbsp;</div></li><li><div>            $info['error'] = $getid3_temp-&gt;info['error'];&nbsp;</div></li><li><div>            $info['tags'] = $getid3_temp-&gt;info['tags'];&nbsp;</div></li><li><div>            $info['comments'] = $getid3_temp-&gt;info['comments'];&nbsp;</div></li><li><div>            unset($getid3_riff, $getid3_temp);&nbsp;</div></li><li><div>            unlink($tempfile);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function parseComments(&$RIFFinfoArray, &$CommentsTargetArray) {&nbsp;</div></li><li><div>        $RIFFinfoKeyLookup = array(&nbsp;</div></li><li><div>            'IARL'=&gt;'archivallocation', &nbsp;</div></li><li><div>            'IART'=&gt;'artist', &nbsp;</div></li><li><div>            'ICDS'=&gt;'costumedesigner', &nbsp;</div></li><li><div>            'ICMS'=&gt;'commissionedby', &nbsp;</div></li><li><div>            'ICMT'=&gt;'comment', &nbsp;</div></li><li><div>            'ICNT'=&gt;'country', &nbsp;</div></li><li><div>            'ICOP'=&gt;'copyright', &nbsp;</div></li><li><div>            'ICRD'=&gt;'creationdate', &nbsp;</div></li><li><div>            'IDIM'=&gt;'dimensions', &nbsp;</div></li><li><div>            'IDIT'=&gt;'digitizationdate', &nbsp;</div></li><li><div>            'IDPI'=&gt;'resolution', &nbsp;</div></li><li><div>            'IDST'=&gt;'distributor', &nbsp;</div></li><li><div>            'IEDT'=&gt;'editor', &nbsp;</div></li><li><div>            'IENG'=&gt;'engineers', &nbsp;</div></li><li><div>            'IFRM'=&gt;'accountofparts', &nbsp;</div></li><li><div>            'IGNR'=&gt;'genre', &nbsp;</div></li><li><div>            'IKEY'=&gt;'keywords', &nbsp;</div></li><li><div>            'ILGT'=&gt;'lightness', &nbsp;</div></li><li><div>            'ILNG'=&gt;'language', &nbsp;</div></li><li><div>            'IMED'=&gt;'orignalmedium', &nbsp;</div></li><li><div>            'IMUS'=&gt;'composer', &nbsp;</div></li><li><div>            'INAM'=&gt;'title', &nbsp;</div></li><li><div>            'IPDS'=&gt;'productiondesigner', &nbsp;</div></li><li><div>            'IPLT'=&gt;'palette', &nbsp;</div></li><li><div>            'IPRD'=&gt;'product', &nbsp;</div></li><li><div>            'IPRO'=&gt;'producer', &nbsp;</div></li><li><div>            'IPRT'=&gt;'part', &nbsp;</div></li><li><div>            'IRTD'=&gt;'rating', &nbsp;</div></li><li><div>            'ISBJ'=&gt;'subject', &nbsp;</div></li><li><div>            'ISFT'=&gt;'software', &nbsp;</div></li><li><div>            'ISGN'=&gt;'secondarygenre', &nbsp;</div></li><li><div>            'ISHP'=&gt;'sharpness', &nbsp;</div></li><li><div>            'ISRC'=&gt;'sourcesupplier', &nbsp;</div></li><li><div>            'ISRF'=&gt;'digitizationsource', &nbsp;</div></li><li><div>            'ISTD'=&gt;'productionstudio', &nbsp;</div></li><li><div>            'ISTR'=&gt;'starring', &nbsp;</div></li><li><div>            'ITCH'=&gt;'encoded_by', &nbsp;</div></li><li><div>            'IWEB'=&gt;'url', &nbsp;</div></li><li><div>            'IWRI'=&gt;'writer', &nbsp;</div></li><li><div>            '____'=&gt;'comment', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        foreach ($RIFFinfoKeyLookup as $key =&gt; $value) {&nbsp;</div></li><li><div>            if (isset($RIFFinfoArray[$key])) {&nbsp;</div></li><li><div>                foreach ($RIFFinfoArray[$key] as $commentid =&gt; $commentdata) {&nbsp;</div></li><li><div>                    if (trim($commentdata['data']) != '') {&nbsp;</div></li><li><div>                        if (isset($CommentsTargetArray[$value])) {&nbsp;</div></li><li><div>                            $CommentsTargetArray[$value][] =     trim($commentdata['data']);&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $CommentsTargetArray[$value] = array(trim($commentdata['data']));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function parseWAVEFORMATex($WaveFormatExData) {&nbsp;</div></li><li><div>        // shortcut&nbsp;</div></li><li><div>        $WaveFormatEx['raw'] = array();&nbsp;</div></li><li><div>        $WaveFormatEx_raw = &$WaveFormatEx['raw'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $WaveFormatEx_raw['wFormatTag'] = substr($WaveFormatExData, 0, 2);&nbsp;</div></li><li><div>        $WaveFormatEx_raw['nChannels'] = substr($WaveFormatExData, 2, 2);&nbsp;</div></li><li><div>        $WaveFormatEx_raw['nSamplesPerSec'] = substr($WaveFormatExData, 4, 4);&nbsp;</div></li><li><div>        $WaveFormatEx_raw['nAvgBytesPerSec'] = substr($WaveFormatExData, 8, 4);&nbsp;</div></li><li><div>        $WaveFormatEx_raw['nBlockAlign'] = substr($WaveFormatExData, 12, 2);&nbsp;</div></li><li><div>        $WaveFormatEx_raw['wBitsPerSample'] = substr($WaveFormatExData, 14, 2);&nbsp;</div></li><li><div>        if (strlen($WaveFormatExData) &gt; 16) {&nbsp;</div></li><li><div>            $WaveFormatEx_raw['cbSize'] = substr($WaveFormatExData, 16, 2);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $WaveFormatEx_raw = array_map('getid3_lib::LittleEndian2Int', $WaveFormatEx_raw);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $WaveFormatEx['codec'] = self::wFormatTagLookup($WaveFormatEx_raw['wFormatTag']);&nbsp;</div></li><li><div>        $WaveFormatEx['channels'] = $WaveFormatEx_raw['nChannels'];&nbsp;</div></li><li><div>        $WaveFormatEx['sample_rate'] = $WaveFormatEx_raw['nSamplesPerSec'];&nbsp;</div></li><li><div>        $WaveFormatEx['bitrate'] = $WaveFormatEx_raw['nAvgBytesPerSec'] * 8;&nbsp;</div></li><li><div>        $WaveFormatEx['bits_per_sample'] = $WaveFormatEx_raw['wBitsPerSample'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $WaveFormatEx;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function parseWavPackHeader($WavPackChunkData) {&nbsp;</div></li><li><div>        // typedef struct {&nbsp;</div></li><li><div>        //     char ckID [4];&nbsp;</div></li><li><div>        //     long ckSize;&nbsp;</div></li><li><div>        //     short version;&nbsp;</div></li><li><div>        //     short bits;                // added for version 2.00&nbsp;</div></li><li><div>        //     short flags, shift;        // added for version 3.00&nbsp;</div></li><li><div>        //     long total_samples, crc, crc2;&nbsp;</div></li><li><div>        //     char extension [4], extra_bc, extras [3];&nbsp;</div></li><li><div>        // } WavpackHeader;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // shortcut&nbsp;</div></li><li><div>        $info = &$this-&gt;getid3-&gt;info;&nbsp;</div></li><li><div>        $info['wavpack'] = array();&nbsp;</div></li><li><div>        $thisfile_wavpack = &$info['wavpack'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $thisfile_wavpack['version'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 0, 2));&nbsp;</div></li><li><div>        if ($thisfile_wavpack['version'] &gt;= 2) {&nbsp;</div></li><li><div>            $thisfile_wavpack['bits'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 2, 2));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($thisfile_wavpack['version'] &gt;= 3) {&nbsp;</div></li><li><div>            $thisfile_wavpack['flags_raw'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 4, 2));&nbsp;</div></li><li><div>            $thisfile_wavpack['shift'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 6, 2));&nbsp;</div></li><li><div>            $thisfile_wavpack['total_samples'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 8, 4));&nbsp;</div></li><li><div>            $thisfile_wavpack['crc1'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 12, 4));&nbsp;</div></li><li><div>            $thisfile_wavpack['crc2'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 16, 4));&nbsp;</div></li><li><div>            $thisfile_wavpack['extension'] =                              substr($WavPackChunkData, 20, 4);&nbsp;</div></li><li><div>            $thisfile_wavpack['extra_bc'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 24, 1));&nbsp;</div></li><li><div>            for ($i = 0; $i &lt;= 2; $i++) {&nbsp;</div></li><li><div>                $thisfile_wavpack['extras'][] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 25 + $i, 1));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // shortcut&nbsp;</div></li><li><div>            $thisfile_wavpack['flags'] = array();&nbsp;</div></li><li><div>            $thisfile_wavpack_flags = &$thisfile_wavpack['flags'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['mono'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000001);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['fast_mode'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000002);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['raw_mode'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000004);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['calc_noise'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000008);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['high_quality'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000010);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['3_byte_samples'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000020);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['over_20_bits'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000040);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['use_wvc'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000080);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['noiseshaping'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000100);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['very_fast_mode'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000200);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['new_high_quality'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000400);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['cancel_extreme'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x000800);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['cross_decorrelation'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x001000);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['new_decorrelation'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x002000);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['joint_stereo'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x004000);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['extra_decorrelation'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x008000);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['override_noiseshape'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x010000);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['override_jointstereo'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x020000);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['copy_source_filetime'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x040000);&nbsp;</div></li><li><div>            $thisfile_wavpack_flags['create_exe'] = (bool) ($thisfile_wavpack['flags_raw'] & 0x080000);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function ParseBITMAPINFOHEADER($BITMAPINFOHEADER, $littleEndian=true) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $parsed['biSize'] = substr($BITMAPINFOHEADER, 0, 4); // number of bytes required by the BITMAPINFOHEADER structure&nbsp;</div></li><li><div>        $parsed['biWidth'] = substr($BITMAPINFOHEADER, 4, 4); // width of the bitmap in pixels&nbsp;</div></li><li><div>        $parsed['biHeight'] = substr($BITMAPINFOHEADER, 8, 4); // height of the bitmap in pixels. If biHeight is positive, the bitmap is a 'bottom-up' DIB and its origin is the lower left corner. If biHeight is negative, the bitmap is a 'top-down' DIB and its origin is the upper left corner&nbsp;</div></li><li><div>        $parsed['biPlanes'] = substr($BITMAPINFOHEADER, 12, 2); // number of color planes on the target device. In most cases this value must be set to 1&nbsp;</div></li><li><div>        $parsed['biBitCount'] = substr($BITMAPINFOHEADER, 14, 2); // Specifies the number of bits per pixels&nbsp;</div></li><li><div>        $parsed['biSizeImage'] = substr($BITMAPINFOHEADER, 20, 4); // size of the bitmap data section of the image (the actual pixel data, excluding BITMAPINFOHEADER and RGBQUAD structures)&nbsp;</div></li><li><div>        $parsed['biXPelsPerMeter'] = substr($BITMAPINFOHEADER, 24, 4); // horizontal resolution, in pixels per metre, of the target device&nbsp;</div></li><li><div>        $parsed['biYPelsPerMeter'] = substr($BITMAPINFOHEADER, 28, 4); // vertical resolution, in pixels per metre, of the target device&nbsp;</div></li><li><div>        $parsed['biClrUsed'] = substr($BITMAPINFOHEADER, 32, 4); // actual number of color indices in the color table used by the bitmap. If this value is zero, the bitmap uses the maximum number of colors corresponding to the value of the biBitCount member for the compression mode specified by biCompression&nbsp;</div></li><li><div>        $parsed['biClrImportant'] = substr($BITMAPINFOHEADER, 36, 4); // number of color indices that are considered important for displaying the bitmap. If this value is zero, all colors are important&nbsp;</div></li><li><div>        $parsed = array_map('getid3_lib::'.($littleEndian ? 'Little' : 'Big').'Endian2Int', $parsed);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $parsed['fourcc'] = substr($BITMAPINFOHEADER, 16, 4);  // compression identifier&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $parsed;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function ParseDIVXTAG($DIVXTAG, $raw=false) {&nbsp;</div></li><li><div>        // structure from &quot;IDivX&quot; source, Form1.frm, by &quot;Greg Frazier of Daemonic Software Group&quot;, email: gfrazier@icestorm.net, web: http://dsg.cjb.net/&nbsp;</div></li><li><div>        // source available at http://files.divx-digest.com/download/c663efe7ef8ad2e90bf4af4d3ea6188a/on0SWN2r/edit/IDivX.zip&nbsp;</div></li><li><div>        // 'Byte Layout:                   '1111111111111111&nbsp;</div></li><li><div>        // '32 for Movie - 1               '1111111111111111&nbsp;</div></li><li><div>        // '28 for Author - 6              '6666666666666666&nbsp;</div></li><li><div>        // '4  for year - 2                '6666666666662222&nbsp;</div></li><li><div>        // '3  for genre - 3               '7777777777777777&nbsp;</div></li><li><div>        // '48 for Comments - 7            '7777777777777777&nbsp;</div></li><li><div>        // '1  for Rating - 4              '7777777777777777&nbsp;</div></li><li><div>        // '5  for Future Additions - 0    '333400000DIVXTAG&nbsp;</div></li><li><div>        // '128 bytes total&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        static $DIVXTAGgenre = array(&nbsp;</div></li><li><div>             0 =&gt; 'Action', &nbsp;</div></li><li><div>             1 =&gt; 'Action/Adventure', &nbsp;</div></li><li><div>             2 =&gt; 'Adventure', &nbsp;</div></li><li><div>             3 =&gt; 'Adult', &nbsp;</div></li><li><div>             4 =&gt; 'Anime', &nbsp;</div></li><li><div>             5 =&gt; 'Cartoon', &nbsp;</div></li><li><div>             6 =&gt; 'Claymation', &nbsp;</div></li><li><div>             7 =&gt; 'Comedy', &nbsp;</div></li><li><div>             8 =&gt; 'Commercial', &nbsp;</div></li><li><div>             9 =&gt; 'Documentary', &nbsp;</div></li><li><div>            10 =&gt; 'Drama', &nbsp;</div></li><li><div>            11 =&gt; 'Home Video', &nbsp;</div></li><li><div>            12 =&gt; 'Horror', &nbsp;</div></li><li><div>            13 =&gt; 'Infomercial', &nbsp;</div></li><li><div>            14 =&gt; 'Interactive', &nbsp;</div></li><li><div>            15 =&gt; 'Mystery', &nbsp;</div></li><li><div>            16 =&gt; 'Music Video', &nbsp;</div></li><li><div>            17 =&gt; 'Other', &nbsp;</div></li><li><div>            18 =&gt; 'Religion', &nbsp;</div></li><li><div>            19 =&gt; 'Sci Fi', &nbsp;</div></li><li><div>            20 =&gt; 'Thriller', &nbsp;</div></li><li><div>            21 =&gt; 'Western', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>        $DIVXTAGrating = array(&nbsp;</div></li><li><div>             0 =&gt; 'Unrated', &nbsp;</div></li><li><div>             1 =&gt; 'G', &nbsp;</div></li><li><div>             2 =&gt; 'PG', &nbsp;</div></li><li><div>             3 =&gt; 'PG-13', &nbsp;</div></li><li><div>             4 =&gt; 'R', &nbsp;</div></li><li><div>             5 =&gt; 'NC-17', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $parsed['title'] =        trim(substr($DIVXTAG, 0, 32));&nbsp;</div></li><li><div>        $parsed['artist'] =        trim(substr($DIVXTAG, 32, 28));&nbsp;</div></li><li><div>        $parsed['year'] = intval(trim(substr($DIVXTAG, 60, 4)));&nbsp;</div></li><li><div>        $parsed['comment'] =        trim(substr($DIVXTAG, 64, 48));&nbsp;</div></li><li><div>        $parsed['genre_id'] = intval(trim(substr($DIVXTAG, 112, 3)));&nbsp;</div></li><li><div>        $parsed['rating_id'] =         ord(substr($DIVXTAG, 115, 1));&nbsp;</div></li><li><div>        //$parsed['padding'] =             substr($DIVXTAG, 116, 5);  // 5-byte null&nbsp;</div></li><li><div>        //$parsed['magic'] =             substr($DIVXTAG, 121, 7);  // &quot;DIVXTAG&quot;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $parsed['genre'] = (isset($DIVXTAGgenre[$parsed['genre_id']])   ? $DIVXTAGgenre[$parsed['genre_id']]   : $parsed['genre_id']);&nbsp;</div></li><li><div>        $parsed['rating'] = (isset($DIVXTAGrating[$parsed['rating_id']]) ? $DIVXTAGrating[$parsed['rating_id']] : $parsed['rating_id']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (!$raw) {&nbsp;</div></li><li><div>            unset($parsed['genre_id'], $parsed['rating_id']);&nbsp;</div></li><li><div>            foreach ($parsed as $key =&gt; $value) {&nbsp;</div></li><li><div>                if (!$value === '') {&nbsp;</div></li><li><div>                    unset($parsed['key']);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($parsed as $tag =&gt; $value) {&nbsp;</div></li><li><div>            $parsed[$tag] = array($value);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $parsed;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function waveSNDMtagLookup($tagshortname) {&nbsp;</div></li><li><div>        $begin = __LINE__;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** This is not a comment!&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>            kwd    keywords&nbsp;</div></li><li><div>            BPM    bpm&nbsp;</div></li><li><div>            trt    tracktitle&nbsp;</div></li><li><div>            des    description&nbsp;</div></li><li><div>            gen    category&nbsp;</div></li><li><div>            fin    featuredinstrument&nbsp;</div></li><li><div>            LID    longid&nbsp;</div></li><li><div>            bex    bwdescription&nbsp;</div></li><li><div>            pub    publisher&nbsp;</div></li><li><div>            cdt    cdtitle&nbsp;</div></li><li><div>            alb    library&nbsp;</div></li><li><div>            com    composer&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return getid3_lib::EmbeddedLookup($tagshortname, $begin, __LINE__, __FILE__, 'riff-sndm');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function wFormatTagLookup($wFormatTag) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $begin = __LINE__;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** This is not a comment!&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>            0x0000    Microsoft Unknown Wave Format&nbsp;</div></li><li><div>            0x0001    Pulse Code Modulation (PCM)&nbsp;</div></li><li><div>            0x0002    Microsoft ADPCM&nbsp;</div></li><li><div>            0x0003    IEEE Float&nbsp;</div></li><li><div>            0x0004    Compaq Computer VSELP&nbsp;</div></li><li><div>            0x0005    IBM CVSD&nbsp;</div></li><li><div>            0x0006    Microsoft A-Law&nbsp;</div></li><li><div>            0x0007    Microsoft mu-Law&nbsp;</div></li><li><div>            0x0008    Microsoft DTS&nbsp;</div></li><li><div>            0x0010    OKI ADPCM&nbsp;</div></li><li><div>            0x0011    Intel DVI/IMA ADPCM&nbsp;</div></li><li><div>            0x0012    Videologic MediaSpace ADPCM&nbsp;</div></li><li><div>            0x0013    Sierra Semiconductor ADPCM&nbsp;</div></li><li><div>            0x0014    Antex Electronics G.723 ADPCM&nbsp;</div></li><li><div>            0x0015    DSP Solutions DigiSTD&nbsp;</div></li><li><div>            0x0016    DSP Solutions DigiFIX&nbsp;</div></li><li><div>            0x0017    Dialogic OKI ADPCM&nbsp;</div></li><li><div>            0x0018    MediaVision ADPCM&nbsp;</div></li><li><div>            0x0019    Hewlett-Packard CU&nbsp;</div></li><li><div>            0x0020    Yamaha ADPCM&nbsp;</div></li><li><div>            0x0021    Speech Compression Sonarc&nbsp;</div></li><li><div>            0x0022    DSP Group TrueSpeech&nbsp;</div></li><li><div>            0x0023    Echo Speech EchoSC1&nbsp;</div></li><li><div>            0x0024    Audiofile AF36&nbsp;</div></li><li><div>            0x0025    Audio Processing Technology APTX&nbsp;</div></li><li><div>            0x0026    AudioFile AF10&nbsp;</div></li><li><div>            0x0027    Prosody 1612&nbsp;</div></li><li><div>            0x0028    LRC&nbsp;</div></li><li><div>            0x0030    Dolby AC2&nbsp;</div></li><li><div>            0x0031    Microsoft GSM 6.10&nbsp;</div></li><li><div>            0x0032    MSNAudio&nbsp;</div></li><li><div>            0x0033    Antex Electronics ADPCME&nbsp;</div></li><li><div>            0x0034    Control Resources VQLPC&nbsp;</div></li><li><div>            0x0035    DSP Solutions DigiREAL&nbsp;</div></li><li><div>            0x0036    DSP Solutions DigiADPCM&nbsp;</div></li><li><div>            0x0037    Control Resources CR10&nbsp;</div></li><li><div>            0x0038    Natural MicroSystems VBXADPCM&nbsp;</div></li><li><div>            0x0039    Crystal Semiconductor IMA ADPCM&nbsp;</div></li><li><div>            0x003A    EchoSC3&nbsp;</div></li><li><div>            0x003B    Rockwell ADPCM&nbsp;</div></li><li><div>            0x003C    Rockwell Digit LK&nbsp;</div></li><li><div>            0x003D    Xebec&nbsp;</div></li><li><div>            0x0040    Antex Electronics G.721 ADPCM&nbsp;</div></li><li><div>            0x0041    G.728 CELP&nbsp;</div></li><li><div>            0x0042    MSG723&nbsp;</div></li><li><div>            0x0050    MPEG Layer-2 or Layer-1&nbsp;</div></li><li><div>            0x0052    RT24&nbsp;</div></li><li><div>            0x0053    PAC&nbsp;</div></li><li><div>            0x0055    MPEG Layer-3&nbsp;</div></li><li><div>            0x0059    Lucent G.723&nbsp;</div></li><li><div>            0x0060    Cirrus&nbsp;</div></li><li><div>            0x0061    ESPCM&nbsp;</div></li><li><div>            0x0062    Voxware&nbsp;</div></li><li><div>            0x0063    Canopus Atrac&nbsp;</div></li><li><div>            0x0064    G.726 ADPCM&nbsp;</div></li><li><div>            0x0065    G.722 ADPCM&nbsp;</div></li><li><div>            0x0066    DSAT&nbsp;</div></li><li><div>            0x0067    DSAT Display&nbsp;</div></li><li><div>            0x0069    Voxware Byte Aligned&nbsp;</div></li><li><div>            0x0070    Voxware AC8&nbsp;</div></li><li><div>            0x0071    Voxware AC10&nbsp;</div></li><li><div>            0x0072    Voxware AC16&nbsp;</div></li><li><div>            0x0073    Voxware AC20&nbsp;</div></li><li><div>            0x0074    Voxware MetaVoice&nbsp;</div></li><li><div>            0x0075    Voxware MetaSound&nbsp;</div></li><li><div>            0x0076    Voxware RT29HW&nbsp;</div></li><li><div>            0x0077    Voxware VR12&nbsp;</div></li><li><div>            0x0078    Voxware VR18&nbsp;</div></li><li><div>            0x0079    Voxware TQ40&nbsp;</div></li><li><div>            0x0080    Softsound&nbsp;</div></li><li><div>            0x0081    Voxware TQ60&nbsp;</div></li><li><div>            0x0082    MSRT24&nbsp;</div></li><li><div>            0x0083    G.729A&nbsp;</div></li><li><div>            0x0084    MVI MV12&nbsp;</div></li><li><div>            0x0085    DF G.726&nbsp;</div></li><li><div>            0x0086    DF GSM610&nbsp;</div></li><li><div>            0x0088    ISIAudio&nbsp;</div></li><li><div>            0x0089    Onlive&nbsp;</div></li><li><div>            0x0091    SBC24&nbsp;</div></li><li><div>            0x0092    Dolby AC3 SPDIF&nbsp;</div></li><li><div>            0x0093    MediaSonic G.723&nbsp;</div></li><li><div>            0x0094    Aculab PLC    Prosody 8kbps&nbsp;</div></li><li><div>            0x0097    ZyXEL ADPCM&nbsp;</div></li><li><div>            0x0098    Philips LPCBB&nbsp;</div></li><li><div>            0x0099    Packed&nbsp;</div></li><li><div>            0x00FF    AAC&nbsp;</div></li><li><div>            0x0100    Rhetorex ADPCM&nbsp;</div></li><li><div>            0x0101    IBM mu-law&nbsp;</div></li><li><div>            0x0102    IBM A-law&nbsp;</div></li><li><div>            0x0103    IBM AVC Adaptive Differential Pulse Code Modulation (ADPCM)&nbsp;</div></li><li><div>            0x0111    Vivo G.723&nbsp;</div></li><li><div>            0x0112    Vivo Siren&nbsp;</div></li><li><div>            0x0123    Digital G.723&nbsp;</div></li><li><div>            0x0125    Sanyo LD ADPCM&nbsp;</div></li><li><div>            0x0130    Sipro Lab Telecom ACELP NET&nbsp;</div></li><li><div>            0x0131    Sipro Lab Telecom ACELP 4800&nbsp;</div></li><li><div>            0x0132    Sipro Lab Telecom ACELP 8V3&nbsp;</div></li><li><div>            0x0133    Sipro Lab Telecom G.729&nbsp;</div></li><li><div>            0x0134    Sipro Lab Telecom G.729A&nbsp;</div></li><li><div>            0x0135    Sipro Lab Telecom Kelvin&nbsp;</div></li><li><div>            0x0140    Windows Media Video V8&nbsp;</div></li><li><div>            0x0150    Qualcomm PureVoice&nbsp;</div></li><li><div>            0x0151    Qualcomm HalfRate&nbsp;</div></li><li><div>            0x0155    Ring Zero Systems TUB GSM&nbsp;</div></li><li><div>            0x0160    Microsoft Audio 1&nbsp;</div></li><li><div>            0x0161    Windows Media Audio V7 / V8 / V9&nbsp;</div></li><li><div>            0x0162    Windows Media Audio Professional V9&nbsp;</div></li><li><div>            0x0163    Windows Media Audio Lossless V9&nbsp;</div></li><li><div>            0x0200    Creative Labs ADPCM&nbsp;</div></li><li><div>            0x0202    Creative Labs Fastspeech8&nbsp;</div></li><li><div>            0x0203    Creative Labs Fastspeech10&nbsp;</div></li><li><div>            0x0210    UHER Informatic GmbH ADPCM&nbsp;</div></li><li><div>            0x0220    Quarterdeck&nbsp;</div></li><li><div>            0x0230    I-link Worldwide VC&nbsp;</div></li><li><div>            0x0240    Aureal RAW Sport&nbsp;</div></li><li><div>            0x0250    Interactive Products HSX&nbsp;</div></li><li><div>            0x0251    Interactive Products RPELP&nbsp;</div></li><li><div>            0x0260    Consistent Software CS2&nbsp;</div></li><li><div>            0x0270    Sony SCX&nbsp;</div></li><li><div>            0x0300    Fujitsu FM Towns Snd&nbsp;</div></li><li><div>            0x0400    BTV Digital&nbsp;</div></li><li><div>            0x0401    Intel Music Coder&nbsp;</div></li><li><div>            0x0450    QDesign Music&nbsp;</div></li><li><div>            0x0680    VME VMPCM&nbsp;</div></li><li><div>            0x0681    AT&T Labs TPC&nbsp;</div></li><li><div>            0x08AE    ClearJump LiteWave&nbsp;</div></li><li><div>            0x1000    Olivetti GSM&nbsp;</div></li><li><div>            0x1001    Olivetti ADPCM&nbsp;</div></li><li><div>            0x1002    Olivetti CELP&nbsp;</div></li><li><div>            0x1003    Olivetti SBC&nbsp;</div></li><li><div>            0x1004    Olivetti OPR&nbsp;</div></li><li><div>            0x1100    Lernout & Hauspie Codec (0x1100)&nbsp;</div></li><li><div>            0x1101    Lernout & Hauspie CELP Codec (0x1101)&nbsp;</div></li><li><div>            0x1102    Lernout & Hauspie SBC Codec (0x1102)&nbsp;</div></li><li><div>            0x1103    Lernout & Hauspie SBC Codec (0x1103)&nbsp;</div></li><li><div>            0x1104    Lernout & Hauspie SBC Codec (0x1104)&nbsp;</div></li><li><div>            0x1400    Norris&nbsp;</div></li><li><div>            0x1401    AT&T ISIAudio&nbsp;</div></li><li><div>            0x1500    Soundspace Music Compression&nbsp;</div></li><li><div>            0x181C    VoxWare RT24 Speech&nbsp;</div></li><li><div>            0x1FC4    NCT Soft ALF2CD (www.nctsoft.com)&nbsp;</div></li><li><div>            0x2000    Dolby AC3&nbsp;</div></li><li><div>            0x2001    Dolby DTS&nbsp;</div></li><li><div>            0x2002    WAVE_FORMAT_14_4&nbsp;</div></li><li><div>            0x2003    WAVE_FORMAT_28_8&nbsp;</div></li><li><div>            0x2004    WAVE_FORMAT_COOK&nbsp;</div></li><li><div>            0x2005    WAVE_FORMAT_DNET&nbsp;</div></li><li><div>            0x674F    Ogg Vorbis 1&nbsp;</div></li><li><div>            0x6750    Ogg Vorbis 2&nbsp;</div></li><li><div>            0x6751    Ogg Vorbis 3&nbsp;</div></li><li><div>            0x676F    Ogg Vorbis 1+&nbsp;</div></li><li><div>            0x6770    Ogg Vorbis 2+&nbsp;</div></li><li><div>            0x6771    Ogg Vorbis 3+&nbsp;</div></li><li><div>            0x7A21    GSM-AMR (CBR, no SID)&nbsp;</div></li><li><div>            0x7A22    GSM-AMR (VBR, including SID)&nbsp;</div></li><li><div>            0xFFFE    WAVE_FORMAT_EXTENSIBLE&nbsp;</div></li><li><div>            0xFFFF    WAVE_FORMAT_DEVELOPMENT&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return getid3_lib::EmbeddedLookup('0x'.str_pad(strtoupper(dechex($wFormatTag)), 4, '0', STR_PAD_LEFT), $begin, __LINE__, __FILE__, 'riff-wFormatTag');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function fourccLookup($fourcc) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $begin = __LINE__;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** This is not a comment!&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>            swot    http://developer.apple.com/qa/snd/snd07.html&nbsp;</div></li><li><div>            ____    No Codec (____)&nbsp;</div></li><li><div>            _BIT    BI_BITFIELDS (Raw RGB)&nbsp;</div></li><li><div>            _JPG    JPEG compressed&nbsp;</div></li><li><div>            _PNG    PNG compressed W3C/ISO/IEC (RFC-2083)&nbsp;</div></li><li><div>            _RAW    Full Frames (Uncompressed)&nbsp;</div></li><li><div>            _RGB    Raw RGB Bitmap&nbsp;</div></li><li><div>            _RL4    RLE 4bpp RGB&nbsp;</div></li><li><div>            _RL8    RLE 8bpp RGB&nbsp;</div></li><li><div>            3IV1    3ivx MPEG-4 v1&nbsp;</div></li><li><div>            3IV2    3ivx MPEG-4 v2&nbsp;</div></li><li><div>            3IVX    3ivx MPEG-4&nbsp;</div></li><li><div>            AASC    Autodesk Animator&nbsp;</div></li><li><div>            ABYR    Kensington ?ABYR?&nbsp;</div></li><li><div>            AEMI    Array Microsystems VideoONE MPEG1-I Capture&nbsp;</div></li><li><div>            AFLC    Autodesk Animator FLC&nbsp;</div></li><li><div>            AFLI    Autodesk Animator FLI&nbsp;</div></li><li><div>            AMPG    Array Microsystems VideoONE MPEG&nbsp;</div></li><li><div>            ANIM    Intel RDX (ANIM)&nbsp;</div></li><li><div>            AP41    AngelPotion Definitive&nbsp;</div></li><li><div>            ASV1    Asus Video v1&nbsp;</div></li><li><div>            ASV2    Asus Video v2&nbsp;</div></li><li><div>            ASVX    Asus Video 2.0 (audio)&nbsp;</div></li><li><div>            AUR2    AuraVision Aura 2 Codec - YUV 4:2:2&nbsp;</div></li><li><div>            AURA    AuraVision Aura 1 Codec - YUV 4:1:1&nbsp;</div></li><li><div>            AVDJ    Independent JPEG Group\'s codec (AVDJ)&nbsp;</div></li><li><div>            AVRN    Independent JPEG Group\'s codec (AVRN)&nbsp;</div></li><li><div>            AYUV    4:4:4 YUV (AYUV)&nbsp;</div></li><li><div>            AZPR    Quicktime Apple Video (AZPR)&nbsp;</div></li><li><div>            BGR     Raw RGB32&nbsp;</div></li><li><div>            BLZ0    Blizzard DivX MPEG-4&nbsp;</div></li><li><div>            BTVC    Conexant Composite Video&nbsp;</div></li><li><div>            BINK    RAD Game Tools Bink Video&nbsp;</div></li><li><div>            BT20    Conexant Prosumer Video&nbsp;</div></li><li><div>            BTCV    Conexant Composite Video Codec&nbsp;</div></li><li><div>            BW10    Data Translation Broadway MPEG Capture&nbsp;</div></li><li><div>            CC12    Intel YUV12&nbsp;</div></li><li><div>            CDVC    Canopus DV&nbsp;</div></li><li><div>            CFCC    Digital Processing Systems DPS Perception&nbsp;</div></li><li><div>            CGDI    Microsoft Office 97 Camcorder Video&nbsp;</div></li><li><div>            CHAM    Winnov Caviara Champagne&nbsp;</div></li><li><div>            CJPG    Creative WebCam JPEG&nbsp;</div></li><li><div>            CLJR    Cirrus Logic YUV 4:1:1&nbsp;</div></li><li><div>            CMYK    Common Data Format in Printing (Colorgraph)&nbsp;</div></li><li><div>            CPLA    Weitek 4:2:0 YUV Planar&nbsp;</div></li><li><div>            CRAM    Microsoft Video 1 (CRAM)&nbsp;</div></li><li><div>            cvid    Radius Cinepak&nbsp;</div></li><li><div>            CVID    Radius Cinepak&nbsp;</div></li><li><div>            CWLT    Microsoft Color WLT DIB&nbsp;</div></li><li><div>            CYUV    Creative Labs YUV&nbsp;</div></li><li><div>            CYUY    ATI YUV&nbsp;</div></li><li><div>            D261    H.261&nbsp;</div></li><li><div>            D263    H.263&nbsp;</div></li><li><div>            DIB     Device Independent Bitmap&nbsp;</div></li><li><div>            DIV1    FFmpeg OpenDivX&nbsp;</div></li><li><div>            DIV2    Microsoft MPEG-4 v1/v2&nbsp;</div></li><li><div>            DIV3    DivX ;-) MPEG-4 v3.x Low-Motion&nbsp;</div></li><li><div>            DIV4    DivX ;-) MPEG-4 v3.x Fast-Motion&nbsp;</div></li><li><div>            DIV5    DivX MPEG-4 v5.x&nbsp;</div></li><li><div>            DIV6    DivX ;-) (MS MPEG-4 v3.x)&nbsp;</div></li><li><div>            DIVX    DivX MPEG-4 v4 (OpenDivX / Project Mayo)&nbsp;</div></li><li><div>            divx    DivX MPEG-4&nbsp;</div></li><li><div>            DMB1    Matrox Rainbow Runner hardware MJPEG&nbsp;</div></li><li><div>            DMB2    Paradigm MJPEG&nbsp;</div></li><li><div>            DSVD    ?DSVD?&nbsp;</div></li><li><div>            DUCK    Duck TrueMotion 1.0&nbsp;</div></li><li><div>            DPS0    DPS/Leitch Reality Motion JPEG&nbsp;</div></li><li><div>            DPSC    DPS/Leitch PAR Motion JPEG&nbsp;</div></li><li><div>            DV25    Matrox DVCPRO codec&nbsp;</div></li><li><div>            DV50    Matrox DVCPRO50 codec&nbsp;</div></li><li><div>            DVC     IEC 61834 and SMPTE 314M (DVC/DV Video)&nbsp;</div></li><li><div>            DVCP    IEC 61834 and SMPTE 314M (DVC/DV Video)&nbsp;</div></li><li><div>            DVHD    IEC Standard DV 1125 lines @ 30fps / 1250 lines @ 25fps&nbsp;</div></li><li><div>            DVMA    Darim Vision DVMPEG (dummy for MPEG compressor) (www.darvision.com)&nbsp;</div></li><li><div>            DVSL    IEC Standard DV compressed in SD (SDL)&nbsp;</div></li><li><div>            DVAN    ?DVAN?&nbsp;</div></li><li><div>            DVE2    InSoft DVE-2 Videoconferencing&nbsp;</div></li><li><div>            dvsd    IEC 61834 and SMPTE 314M DVC/DV Video&nbsp;</div></li><li><div>            DVSD    IEC 61834 and SMPTE 314M DVC/DV Video&nbsp;</div></li><li><div>            DVX1    Lucent DVX1000SP Video Decoder&nbsp;</div></li><li><div>            DVX2    Lucent DVX2000S Video Decoder&nbsp;</div></li><li><div>            DVX3    Lucent DVX3000S Video Decoder&nbsp;</div></li><li><div>            DX50    DivX v5&nbsp;</div></li><li><div>            DXT1    Microsoft DirectX Compressed Texture (DXT1)&nbsp;</div></li><li><div>            DXT2    Microsoft DirectX Compressed Texture (DXT2)&nbsp;</div></li><li><div>            DXT3    Microsoft DirectX Compressed Texture (DXT3)&nbsp;</div></li><li><div>            DXT4    Microsoft DirectX Compressed Texture (DXT4)&nbsp;</div></li><li><div>            DXT5    Microsoft DirectX Compressed Texture (DXT5)&nbsp;</div></li><li><div>            DXTC    Microsoft DirectX Compressed Texture (DXTC)&nbsp;</div></li><li><div>            DXTn    Microsoft DirectX Compressed Texture (DXTn)&nbsp;</div></li><li><div>            EM2V    Etymonix MPEG-2 I-frame (www.etymonix.com)&nbsp;</div></li><li><div>            EKQ0    Elsa ?EKQ0?&nbsp;</div></li><li><div>            ELK0    Elsa ?ELK0?&nbsp;</div></li><li><div>            ESCP    Eidos Escape&nbsp;</div></li><li><div>            ETV1    eTreppid Video ETV1&nbsp;</div></li><li><div>            ETV2    eTreppid Video ETV2&nbsp;</div></li><li><div>            ETVC    eTreppid Video ETVC&nbsp;</div></li><li><div>            FLIC    Autodesk FLI/FLC Animation&nbsp;</div></li><li><div>            FLV1    Sorenson Spark&nbsp;</div></li><li><div>            FLV4    On2 TrueMotion VP6&nbsp;</div></li><li><div>            FRWT    Darim Vision Forward Motion JPEG (www.darvision.com)&nbsp;</div></li><li><div>            FRWU    Darim Vision Forward Uncompressed (www.darvision.com)&nbsp;</div></li><li><div>            FLJP    D-Vision Field Encoded Motion JPEG&nbsp;</div></li><li><div>            FPS1    FRAPS v1&nbsp;</div></li><li><div>            FRWA    SoftLab-Nsk Forward Motion JPEG w/ alpha channel&nbsp;</div></li><li><div>            FRWD    SoftLab-Nsk Forward Motion JPEG&nbsp;</div></li><li><div>            FVF1    Iterated Systems Fractal Video Frame&nbsp;</div></li><li><div>            GLZW    Motion LZW (gabest@freemail.hu)&nbsp;</div></li><li><div>            GPEG    Motion JPEG (gabest@freemail.hu)&nbsp;</div></li><li><div>            GWLT    Microsoft Greyscale WLT DIB&nbsp;</div></li><li><div>            H260    Intel ITU H.260 Videoconferencing&nbsp;</div></li><li><div>            H261    Intel ITU H.261 Videoconferencing&nbsp;</div></li><li><div>            H262    Intel ITU H.262 Videoconferencing&nbsp;</div></li><li><div>            H263    Intel ITU H.263 Videoconferencing&nbsp;</div></li><li><div>            H264    Intel ITU H.264 Videoconferencing&nbsp;</div></li><li><div>            H265    Intel ITU H.265 Videoconferencing&nbsp;</div></li><li><div>            H266    Intel ITU H.266 Videoconferencing&nbsp;</div></li><li><div>            H267    Intel ITU H.267 Videoconferencing&nbsp;</div></li><li><div>            H268    Intel ITU H.268 Videoconferencing&nbsp;</div></li><li><div>            H269    Intel ITU H.269 Videoconferencing&nbsp;</div></li><li><div>            HFYU    Huffman Lossless Codec&nbsp;</div></li><li><div>            HMCR    Rendition Motion Compensation Format (HMCR)&nbsp;</div></li><li><div>            HMRR    Rendition Motion Compensation Format (HMRR)&nbsp;</div></li><li><div>            I263    FFmpeg I263 decoder&nbsp;</div></li><li><div>            IF09    Indeo YVU9 (&quot;YVU9 with additional delta-frame info after the U plane&quot;)&nbsp;</div></li><li><div>            IUYV    Interlaced version of UYVY (www.leadtools.com)&nbsp;</div></li><li><div>            IY41    Interlaced version of Y41P (www.leadtools.com)&nbsp;</div></li><li><div>            IYU1    12 bit format used in mode 2 of the IEEE 1394 Digital Camera 1.04 spec    IEEE standard&nbsp;</div></li><li><div>            IYU2    24 bit format used in mode 2 of the IEEE 1394 Digital Camera 1.04 spec    IEEE standard&nbsp;</div></li><li><div>            IYUV    Planar YUV format (8-bpp Y plane, followed by 8-bpp 22 U and V planes)&nbsp;</div></li><li><div>            i263    Intel ITU H.263 Videoconferencing (i263)&nbsp;</div></li><li><div>            I420    Intel Indeo 4&nbsp;</div></li><li><div>            IAN     Intel Indeo 4 (RDX)&nbsp;</div></li><li><div>            ICLB    InSoft CellB Videoconferencing&nbsp;</div></li><li><div>            IGOR    Power DVD&nbsp;</div></li><li><div>            IJPG    Intergraph JPEG&nbsp;</div></li><li><div>            ILVC    Intel Layered Video&nbsp;</div></li><li><div>            ILVR    ITU-T H.263+&nbsp;</div></li><li><div>            IPDV    I-O Data Device Giga AVI DV Codec&nbsp;</div></li><li><div>            IR21    Intel Indeo 2.1&nbsp;</div></li><li><div>            IRAW    Intel YUV Uncompressed&nbsp;</div></li><li><div>            IV30    Intel Indeo 3.0&nbsp;</div></li><li><div>            IV31    Intel Indeo 3.1&nbsp;</div></li><li><div>            IV32    Ligos Indeo 3.2&nbsp;</div></li><li><div>            IV33    Ligos Indeo 3.3&nbsp;</div></li><li><div>            IV34    Ligos Indeo 3.4&nbsp;</div></li><li><div>            IV35    Ligos Indeo 3.5&nbsp;</div></li><li><div>            IV36    Ligos Indeo 3.6&nbsp;</div></li><li><div>            IV37    Ligos Indeo 3.7&nbsp;</div></li><li><div>            IV38    Ligos Indeo 3.8&nbsp;</div></li><li><div>            IV39    Ligos Indeo 3.9&nbsp;</div></li><li><div>            IV40    Ligos Indeo Interactive 4.0&nbsp;</div></li><li><div>            IV41    Ligos Indeo Interactive 4.1&nbsp;</div></li><li><div>            IV42    Ligos Indeo Interactive 4.2&nbsp;</div></li><li><div>            IV43    Ligos Indeo Interactive 4.3&nbsp;</div></li><li><div>            IV44    Ligos Indeo Interactive 4.4&nbsp;</div></li><li><div>            IV45    Ligos Indeo Interactive 4.5&nbsp;</div></li><li><div>            IV46    Ligos Indeo Interactive 4.6&nbsp;</div></li><li><div>            IV47    Ligos Indeo Interactive 4.7&nbsp;</div></li><li><div>            IV48    Ligos Indeo Interactive 4.8&nbsp;</div></li><li><div>            IV49    Ligos Indeo Interactive 4.9&nbsp;</div></li><li><div>            IV50    Ligos Indeo Interactive 5.0&nbsp;</div></li><li><div>            JBYR    Kensington ?JBYR?&nbsp;</div></li><li><div>            JPEG    Still Image JPEG DIB&nbsp;</div></li><li><div>            JPGL    Pegasus Lossless Motion JPEG&nbsp;</div></li><li><div>            KMVC    Team17 Software Karl Morton\'s Video Codec&nbsp;</div></li><li><div>            LSVM    Vianet Lighting Strike Vmail (Streaming) (www.vianet.com)&nbsp;</div></li><li><div>            LEAD    LEAD Video Codec&nbsp;</div></li><li><div>            Ljpg    LEAD MJPEG Codec&nbsp;</div></li><li><div>            MDVD    Alex MicroDVD Video (hacked MS MPEG-4) (www.tiasoft.de)&nbsp;</div></li><li><div>            MJPA    Morgan Motion JPEG (MJPA) (www.morgan-multimedia.com)&nbsp;</div></li><li><div>            MJPB    Morgan Motion JPEG (MJPB) (www.morgan-multimedia.com)&nbsp;</div></li><li><div>            MMES    Matrox MPEG-2 I-frame&nbsp;</div></li><li><div>            MP2v    Microsoft S-Mpeg 4 version 1 (MP2v)&nbsp;</div></li><li><div>            MP42    Microsoft S-Mpeg 4 version 2 (MP42)&nbsp;</div></li><li><div>            MP43    Microsoft S-Mpeg 4 version 3 (MP43)&nbsp;</div></li><li><div>            MP4S    Microsoft S-Mpeg 4 version 3 (MP4S)&nbsp;</div></li><li><div>            MP4V    FFmpeg MPEG-4&nbsp;</div></li><li><div>            MPG1    FFmpeg MPEG 1/2&nbsp;</div></li><li><div>            MPG2    FFmpeg MPEG 1/2&nbsp;</div></li><li><div>            MPG3    FFmpeg DivX ;-) (MS MPEG-4 v3)&nbsp;</div></li><li><div>            MPG4    Microsoft MPEG-4&nbsp;</div></li><li><div>            MPGI    Sigma Designs MPEG&nbsp;</div></li><li><div>            MPNG    PNG images decoder&nbsp;</div></li><li><div>            MSS1    Microsoft Windows Screen Video&nbsp;</div></li><li><div>            MSZH    LCL (Lossless Codec Library) (www.geocities.co.jp/Playtown-Denei/2837/LRC.htm)&nbsp;</div></li><li><div>            M261    Microsoft H.261&nbsp;</div></li><li><div>            M263    Microsoft H.263&nbsp;</div></li><li><div>            M4S2    Microsoft Fully Compliant MPEG-4 v2 simple profile (M4S2)&nbsp;</div></li><li><div>            m4s2    Microsoft Fully Compliant MPEG-4 v2 simple profile (m4s2)&nbsp;</div></li><li><div>            MC12    ATI Motion Compensation Format (MC12)&nbsp;</div></li><li><div>            MCAM    ATI Motion Compensation Format (MCAM)&nbsp;</div></li><li><div>            MJ2C    Morgan Multimedia Motion JPEG2000&nbsp;</div></li><li><div>            mJPG    IBM Motion JPEG w/ Huffman Tables&nbsp;</div></li><li><div>            MJPG    Microsoft Motion JPEG DIB&nbsp;</div></li><li><div>            MP42    Microsoft MPEG-4 (low-motion)&nbsp;</div></li><li><div>            MP43    Microsoft MPEG-4 (fast-motion)&nbsp;</div></li><li><div>            MP4S    Microsoft MPEG-4 (MP4S)&nbsp;</div></li><li><div>            mp4s    Microsoft MPEG-4 (mp4s)&nbsp;</div></li><li><div>            MPEG    Chromatic Research MPEG-1 Video I-Frame&nbsp;</div></li><li><div>            MPG4    Microsoft MPEG-4 Video High Speed Compressor&nbsp;</div></li><li><div>            MPGI    Sigma Designs MPEG&nbsp;</div></li><li><div>            MRCA    FAST Multimedia Martin Regen Codec&nbsp;</div></li><li><div>            MRLE    Microsoft Run Length Encoding&nbsp;</div></li><li><div>            MSVC    Microsoft Video 1&nbsp;</div></li><li><div>            MTX1    Matrox ?MTX1?&nbsp;</div></li><li><div>            MTX2    Matrox ?MTX2?&nbsp;</div></li><li><div>            MTX3    Matrox ?MTX3?&nbsp;</div></li><li><div>            MTX4    Matrox ?MTX4?&nbsp;</div></li><li><div>            MTX5    Matrox ?MTX5?&nbsp;</div></li><li><div>            MTX6    Matrox ?MTX6?&nbsp;</div></li><li><div>            MTX7    Matrox ?MTX7?&nbsp;</div></li><li><div>            MTX8    Matrox ?MTX8?&nbsp;</div></li><li><div>            MTX9    Matrox ?MTX9?&nbsp;</div></li><li><div>            MV12    Motion Pixels Codec (old)&nbsp;</div></li><li><div>            MWV1    Aware Motion Wavelets&nbsp;</div></li><li><div>            nAVI    SMR Codec (hack of Microsoft MPEG-4) (IRC #shadowrealm)&nbsp;</div></li><li><div>            NT00    NewTek LightWave HDTV YUV w/ Alpha (www.newtek.com)&nbsp;</div></li><li><div>            NUV1    NuppelVideo&nbsp;</div></li><li><div>            NTN1    Nogatech Video Compression 1&nbsp;</div></li><li><div>            NVS0    nVidia GeForce Texture (NVS0)&nbsp;</div></li><li><div>            NVS1    nVidia GeForce Texture (NVS1)&nbsp;</div></li><li><div>            NVS2    nVidia GeForce Texture (NVS2)&nbsp;</div></li><li><div>            NVS3    nVidia GeForce Texture (NVS3)&nbsp;</div></li><li><div>            NVS4    nVidia GeForce Texture (NVS4)&nbsp;</div></li><li><div>            NVS5    nVidia GeForce Texture (NVS5)&nbsp;</div></li><li><div>            NVT0    nVidia GeForce Texture (NVT0)&nbsp;</div></li><li><div>            NVT1    nVidia GeForce Texture (NVT1)&nbsp;</div></li><li><div>            NVT2    nVidia GeForce Texture (NVT2)&nbsp;</div></li><li><div>            NVT3    nVidia GeForce Texture (NVT3)&nbsp;</div></li><li><div>            NVT4    nVidia GeForce Texture (NVT4)&nbsp;</div></li><li><div>            NVT5    nVidia GeForce Texture (NVT5)&nbsp;</div></li><li><div>            PIXL    MiroXL, Pinnacle PCTV&nbsp;</div></li><li><div>            PDVC    I-O Data Device Digital Video Capture DV codec&nbsp;</div></li><li><div>            PGVV    Radius Video Vision&nbsp;</div></li><li><div>            PHMO    IBM Photomotion&nbsp;</div></li><li><div>            PIM1    MPEG Realtime (Pinnacle Cards)&nbsp;</div></li><li><div>            PIM2    Pegasus Imaging ?PIM2?&nbsp;</div></li><li><div>            PIMJ    Pegasus Imaging Lossless JPEG&nbsp;</div></li><li><div>            PVEZ    Horizons Technology PowerEZ&nbsp;</div></li><li><div>            PVMM    PacketVideo Corporation MPEG-4&nbsp;</div></li><li><div>            PVW2    Pegasus Imaging Wavelet Compression&nbsp;</div></li><li><div>            Q1.0    Q-Team\'s QPEG 1.0 (www.q-team.de)&nbsp;</div></li><li><div>            Q1.1    Q-Team\'s QPEG 1.1 (www.q-team.de)&nbsp;</div></li><li><div>            QPEG    Q-Team QPEG 1.0&nbsp;</div></li><li><div>            qpeq    Q-Team QPEG 1.1&nbsp;</div></li><li><div>            RGB     Raw BGR32&nbsp;</div></li><li><div>            RGBA    Raw RGB w/ Alpha&nbsp;</div></li><li><div>            RMP4    REALmagic MPEG-4 (unauthorized XVID copy) (www.sigmadesigns.com)&nbsp;</div></li><li><div>            ROQV    Id RoQ File Video Decoder&nbsp;</div></li><li><div>            RPZA    Quicktime Apple Video (RPZA)&nbsp;</div></li><li><div>            RUD0    Rududu video codec (http://rududu.ifrance.com/rududu/)&nbsp;</div></li><li><div>            RV10    RealVideo 1.0 (aka RealVideo 5.0)&nbsp;</div></li><li><div>            RV13    RealVideo 1.0 (RV13)&nbsp;</div></li><li><div>            RV20    RealVideo G2&nbsp;</div></li><li><div>            RV30    RealVideo 8&nbsp;</div></li><li><div>            RV40    RealVideo 9&nbsp;</div></li><li><div>            RGBT    Raw RGB w/ Transparency&nbsp;</div></li><li><div>            RLE     Microsoft Run Length Encoder&nbsp;</div></li><li><div>            RLE4    Run Length Encoded (4bpp, 16-color)&nbsp;</div></li><li><div>            RLE8    Run Length Encoded (8bpp, 256-color)&nbsp;</div></li><li><div>            RT21    Intel Indeo RealTime Video 2.1&nbsp;</div></li><li><div>            rv20    RealVideo G2&nbsp;</div></li><li><div>            rv30    RealVideo 8&nbsp;</div></li><li><div>            RVX     Intel RDX (RVX )&nbsp;</div></li><li><div>            SMC     Apple Graphics (SMC )&nbsp;</div></li><li><div>            SP54    Logitech Sunplus Sp54 Codec for Mustek GSmart Mini 2&nbsp;</div></li><li><div>            SPIG    Radius Spigot&nbsp;</div></li><li><div>            SVQ3    Sorenson Video 3 (Apple Quicktime 5)&nbsp;</div></li><li><div>            s422    Tekram VideoCap C210 YUV 4:2:2&nbsp;</div></li><li><div>            SDCC    Sun Communication Digital Camera Codec&nbsp;</div></li><li><div>            SFMC    CrystalNet Surface Fitting Method&nbsp;</div></li><li><div>            SMSC    Radius SMSC&nbsp;</div></li><li><div>            SMSD    Radius SMSD&nbsp;</div></li><li><div>            smsv    WorldConnect Wavelet Video&nbsp;</div></li><li><div>            SPIG    Radius Spigot&nbsp;</div></li><li><div>            SPLC    Splash Studios ACM Audio Codec (www.splashstudios.net)&nbsp;</div></li><li><div>            SQZ2    Microsoft VXTreme Video Codec V2&nbsp;</div></li><li><div>            STVA    ST Microelectronics CMOS Imager Data (Bayer)&nbsp;</div></li><li><div>            STVB    ST Microelectronics CMOS Imager Data (Nudged Bayer)&nbsp;</div></li><li><div>            STVC    ST Microelectronics CMOS Imager Data (Bunched)&nbsp;</div></li><li><div>            STVX    ST Microelectronics CMOS Imager Data (Extended CODEC Data Format)&nbsp;</div></li><li><div>            STVY    ST Microelectronics CMOS Imager Data (Extended CODEC Data Format with Correction Data)&nbsp;</div></li><li><div>            SV10    Sorenson Video R1&nbsp;</div></li><li><div>            SVQ1    Sorenson Video&nbsp;</div></li><li><div>            T420    Toshiba YUV 4:2:0&nbsp;</div></li><li><div>            TM2A    Duck TrueMotion Archiver 2.0 (www.duck.com)&nbsp;</div></li><li><div>            TVJP    Pinnacle/Truevision Targa 2000 board (TVJP)&nbsp;</div></li><li><div>            TVMJ    Pinnacle/Truevision Targa 2000 board (TVMJ)&nbsp;</div></li><li><div>            TY0N    Tecomac Low-Bit Rate Codec (www.tecomac.com)&nbsp;</div></li><li><div>            TY2C    Trident Decompression Driver&nbsp;</div></li><li><div>            TLMS    TeraLogic Motion Intraframe Codec (TLMS)&nbsp;</div></li><li><div>            TLST    TeraLogic Motion Intraframe Codec (TLST)&nbsp;</div></li><li><div>            TM20    Duck TrueMotion 2.0&nbsp;</div></li><li><div>            TM2X    Duck TrueMotion 2X&nbsp;</div></li><li><div>            TMIC    TeraLogic Motion Intraframe Codec (TMIC)&nbsp;</div></li><li><div>            TMOT    Horizons Technology TrueMotion S&nbsp;</div></li><li><div>            tmot    Horizons TrueMotion Video Compression&nbsp;</div></li><li><div>            TR20    Duck TrueMotion RealTime 2.0&nbsp;</div></li><li><div>            TSCC    TechSmith Screen Capture Codec&nbsp;</div></li><li><div>            TV10    Tecomac Low-Bit Rate Codec&nbsp;</div></li><li><div>            TY2N    Trident ?TY2N?&nbsp;</div></li><li><div>            U263    UB Video H.263/H.263+/H.263++ Decoder&nbsp;</div></li><li><div>            UMP4    UB Video MPEG 4 (www.ubvideo.com)&nbsp;</div></li><li><div>            UYNV    Nvidia UYVY packed 4:2:2&nbsp;</div></li><li><div>            UYVP    Evans & Sutherland YCbCr 4:2:2 extended precision&nbsp;</div></li><li><div>            UCOD    eMajix.com ClearVideo&nbsp;</div></li><li><div>            ULTI    IBM Ultimotion&nbsp;</div></li><li><div>            UYVY    UYVY packed 4:2:2&nbsp;</div></li><li><div>            V261    Lucent VX2000S&nbsp;</div></li><li><div>            VIFP    VFAPI Reader Codec (www.yks.ne.jp/~hori/)&nbsp;</div></li><li><div>            VIV1    FFmpeg H263+ decoder&nbsp;</div></li><li><div>            VIV2    Vivo H.263&nbsp;</div></li><li><div>            VQC2    Vector-quantised codec 2 (research) http://eprints.ecs.soton.ac.uk/archive/00001310/01/VTC97-js.pdf)&nbsp;</div></li><li><div>            VTLP    Alaris VideoGramPiX&nbsp;</div></li><li><div>            VYU9    ATI YUV (VYU9)&nbsp;</div></li><li><div>            VYUY    ATI YUV (VYUY)&nbsp;</div></li><li><div>            V261    Lucent VX2000S&nbsp;</div></li><li><div>            V422    Vitec Multimedia 24-bit YUV 4:2:2 Format&nbsp;</div></li><li><div>            V655    Vitec Multimedia 16-bit YUV 4:2:2 Format&nbsp;</div></li><li><div>            VCR1    ATI Video Codec 1&nbsp;</div></li><li><div>            VCR2    ATI Video Codec 2&nbsp;</div></li><li><div>            VCR3    ATI VCR 3.0&nbsp;</div></li><li><div>            VCR4    ATI VCR 4.0&nbsp;</div></li><li><div>            VCR5    ATI VCR 5.0&nbsp;</div></li><li><div>            VCR6    ATI VCR 6.0&nbsp;</div></li><li><div>            VCR7    ATI VCR 7.0&nbsp;</div></li><li><div>            VCR8    ATI VCR 8.0&nbsp;</div></li><li><div>            VCR9    ATI VCR 9.0&nbsp;</div></li><li><div>            VDCT    Vitec Multimedia Video Maker Pro DIB&nbsp;</div></li><li><div>            VDOM    VDOnet VDOWave&nbsp;</div></li><li><div>            VDOW    VDOnet VDOLive (H.263)&nbsp;</div></li><li><div>            VDTZ    Darim Vison VideoTizer YUV&nbsp;</div></li><li><div>            VGPX    Alaris VideoGramPiX&nbsp;</div></li><li><div>            VIDS    Vitec Multimedia YUV 4:2:2 CCIR 601 for V422&nbsp;</div></li><li><div>            VIVO    Vivo H.263 v2.00&nbsp;</div></li><li><div>            vivo    Vivo H.263&nbsp;</div></li><li><div>            VIXL    Miro/Pinnacle Video XL&nbsp;</div></li><li><div>            VLV1    VideoLogic/PURE Digital Videologic Capture&nbsp;</div></li><li><div>            VP30    On2 VP3.0&nbsp;</div></li><li><div>            VP31    On2 VP3.1&nbsp;</div></li><li><div>            VP6F    On2 TrueMotion VP6&nbsp;</div></li><li><div>            VX1K    Lucent VX1000S Video Codec&nbsp;</div></li><li><div>            VX2K    Lucent VX2000S Video Codec&nbsp;</div></li><li><div>            VXSP    Lucent VX1000SP Video Codec&nbsp;</div></li><li><div>            WBVC    Winbond W9960&nbsp;</div></li><li><div>            WHAM    Microsoft Video 1 (WHAM)&nbsp;</div></li><li><div>            WINX    Winnov Software Compression&nbsp;</div></li><li><div>            WJPG    AverMedia Winbond JPEG&nbsp;</div></li><li><div>            WMV1    Windows Media Video V7&nbsp;</div></li><li><div>            WMV2    Windows Media Video V8&nbsp;</div></li><li><div>            WMV3    Windows Media Video V9&nbsp;</div></li><li><div>            WNV1    Winnov Hardware Compression&nbsp;</div></li><li><div>            XYZP    Extended PAL format XYZ palette (www.riff.org)&nbsp;</div></li><li><div>            x263    Xirlink H.263&nbsp;</div></li><li><div>            XLV0    NetXL Video Decoder&nbsp;</div></li><li><div>            XMPG    Xing MPEG (I-Frame only)&nbsp;</div></li><li><div>            XVID    XviD MPEG-4 (www.xvid.org)&nbsp;</div></li><li><div>            XXAN    ?XXAN?&nbsp;</div></li><li><div>            YU92    Intel YUV (YU92)&nbsp;</div></li><li><div>            YUNV    Nvidia Uncompressed YUV 4:2:2&nbsp;</div></li><li><div>            YUVP    Extended PAL format YUV palette (www.riff.org)&nbsp;</div></li><li><div>            Y211    YUV 2:1:1 Packed&nbsp;</div></li><li><div>            Y411    YUV 4:1:1 Packed&nbsp;</div></li><li><div>            Y41B    Weitek YUV 4:1:1 Planar&nbsp;</div></li><li><div>            Y41P    Brooktree PC1 YUV 4:1:1 Packed&nbsp;</div></li><li><div>            Y41T    Brooktree PC1 YUV 4:1:1 with transparency&nbsp;</div></li><li><div>            Y42B    Weitek YUV 4:2:2 Planar&nbsp;</div></li><li><div>            Y42T    Brooktree UYUV 4:2:2 with transparency&nbsp;</div></li><li><div>            Y422    ADS Technologies Copy of UYVY used in Pyro WebCam firewire camera&nbsp;</div></li><li><div>            Y800    Simple, single Y plane for monochrome images&nbsp;</div></li><li><div>            Y8      Grayscale video&nbsp;</div></li><li><div>            YC12    Intel YUV 12 codec&nbsp;</div></li><li><div>            YUV8    Winnov Caviar YUV8&nbsp;</div></li><li><div>            YUV9    Intel YUV9&nbsp;</div></li><li><div>            YUY2    Uncompressed YUV 4:2:2&nbsp;</div></li><li><div>            YUYV    Canopus YUV&nbsp;</div></li><li><div>            YV12    YVU12 Planar&nbsp;</div></li><li><div>            YVU9    Intel YVU9 Planar (8-bpp Y plane, followed by 8-bpp 4x4 U and V planes)&nbsp;</div></li><li><div>            YVYU    YVYU 4:2:2 Packed&nbsp;</div></li><li><div>            ZLIB    Lossless Codec Library zlib compression (www.geocities.co.jp/Playtown-Denei/2837/LRC.htm)&nbsp;</div></li><li><div>            ZPEG    Metheus Video Zipper&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return getid3_lib::EmbeddedLookup($fourcc, $begin, __LINE__, __FILE__, 'riff-fourcc');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function EitherEndian2Int($byteword, $signed=false) {&nbsp;</div></li><li><div>        if ($this-&gt;container == 'riff') {&nbsp;</div></li><li><div>            return getid3_lib::LittleEndian2Int($byteword, $signed);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return getid3_lib::BigEndian2Int($byteword, false, $signed);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 4.7</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/4.7.4/classes/getid3_riff/" class="active">4.7.4</a></li><li><a href="http://hookr.io/4.7.3/classes/getid3_riff/" class="">4.7.3</a></li><li><a href="http://hookr.io/4.7.2/classes/getid3_riff/" class="">4.7.2</a></li><li><a href="http://hookr.io/4.7.1/classes/getid3_riff/" class="">4.7.1</a></li><li><a href="http://hookr.io/4.7/classes/getid3_riff/" class="">4.7</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>class</li><li><span></span>getid3_riff</li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>