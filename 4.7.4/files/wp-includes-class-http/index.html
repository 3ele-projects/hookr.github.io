<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="wordpress" data-version="4.7.4" data-type="file" data-id="4633"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp-includes-class-http | file | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, wordpress, 4.7.4" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=c92661388f33a0be17df31157e3c92cc' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/wp-includes-class-http/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-class-http%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-class-http%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-file-wp-includes-class-http","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp-includes-class-http" class="blog single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="http://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp-includes-class-http</span><meta property="position" content="3"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="http://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="http://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="http://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="http://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="" data-id="class" data-count="351"><a href="http://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="http://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/wp-includes/class-http.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * HTTP API: WP_Http class</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage HTTP</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>if ( ! class_exists( 'Requests' ) ) {&nbsp;</div></li><li><div>  require( ABSPATH . WPINC . '/class-requests.php' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  Requests::register_autoloader();&nbsp;</div></li><li><div>  Requests::set_certificate_path( ABSPATH . WPINC . '/certificates/ca-bundle.crt' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Core class used for managing HTTP transports and making HTTP requests.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This class is used to consistently make outgoing HTTP requests easy for developers</span>&nbsp;</div></li><li><div><span class="comment"> * while still being compatible with the many PHP configurations under which</span>&nbsp;</div></li><li><div><span class="comment"> * WordPress runs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Debugging includes several actions, which pass different variables for debugging the HTTP API.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>class WP_Http {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Aliases for HTTP response codes.</span>&nbsp;</div></li><li><div>  const HTTP_CONTINUE = 100;&nbsp;</div></li><li><div>  const SWITCHING_PROTOCOLS = 101;&nbsp;</div></li><li><div>  const PROCESSING = 102;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  const OK = 200;&nbsp;</div></li><li><div>  const CREATED = 201;&nbsp;</div></li><li><div>  const ACCEPTED = 202;&nbsp;</div></li><li><div>  const NON_AUTHORITATIVE_INFORMATION = 203;&nbsp;</div></li><li><div>  const NO_CONTENT = 204;&nbsp;</div></li><li><div>  const RESET_CONTENT = 205;&nbsp;</div></li><li><div>  const PARTIAL_CONTENT = 206;&nbsp;</div></li><li><div>  const MULTI_STATUS = 207;&nbsp;</div></li><li><div>  const IM_USED = 226;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  const MULTIPLE_CHOICES = 300;&nbsp;</div></li><li><div>  const MOVED_PERMANENTLY = 301;&nbsp;</div></li><li><div>  const FOUND = 302;&nbsp;</div></li><li><div>  const SEE_OTHER = 303;&nbsp;</div></li><li><div>  const NOT_MODIFIED = 304;&nbsp;</div></li><li><div>  const USE_PROXY = 305;&nbsp;</div></li><li><div>  const RESERVED = 306;&nbsp;</div></li><li><div>  const TEMPORARY_REDIRECT = 307;&nbsp;</div></li><li><div>  const PERMANENT_REDIRECT = 308;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  const BAD_REQUEST = 400;&nbsp;</div></li><li><div>  const UNAUTHORIZED = 401;&nbsp;</div></li><li><div>  const PAYMENT_REQUIRED = 402;&nbsp;</div></li><li><div>  const FORBIDDEN = 403;&nbsp;</div></li><li><div>  const NOT_FOUND = 404;&nbsp;</div></li><li><div>  const METHOD_NOT_ALLOWED = 405;&nbsp;</div></li><li><div>  const NOT_ACCEPTABLE = 406;&nbsp;</div></li><li><div>  const PROXY_AUTHENTICATION_REQUIRED = 407;&nbsp;</div></li><li><div>  const REQUEST_TIMEOUT = 408;&nbsp;</div></li><li><div>  const CONFLICT = 409;&nbsp;</div></li><li><div>  const GONE = 410;&nbsp;</div></li><li><div>  const LENGTH_REQUIRED = 411;&nbsp;</div></li><li><div>  const PRECONDITION_FAILED = 412;&nbsp;</div></li><li><div>  const REQUEST_ENTITY_TOO_LARGE = 413;&nbsp;</div></li><li><div>  const REQUEST_URI_TOO_LONG = 414;&nbsp;</div></li><li><div>  const UNSUPPORTED_MEDIA_TYPE = 415;&nbsp;</div></li><li><div>  const REQUESTED_RANGE_NOT_SATISFIABLE = 416;&nbsp;</div></li><li><div>  const EXPECTATION_FAILED = 417;&nbsp;</div></li><li><div>  const IM_A_TEAPOT = 418;&nbsp;</div></li><li><div>  const MISDIRECTED_REQUEST = 421;&nbsp;</div></li><li><div>  const UNPROCESSABLE_ENTITY = 422;&nbsp;</div></li><li><div>  const LOCKED = 423;&nbsp;</div></li><li><div>  const FAILED_DEPENDENCY = 424;&nbsp;</div></li><li><div>  const UPGRADE_REQUIRED = 426;&nbsp;</div></li><li><div>  const PRECONDITION_REQUIRED = 428;&nbsp;</div></li><li><div>  const TOO_MANY_REQUESTS = 429;&nbsp;</div></li><li><div>  const REQUEST_HEADER_FIELDS_TOO_LARGE = 431;&nbsp;</div></li><li><div>  const UNAVAILABLE_FOR_LEGAL_REASONS = 451;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  const INTERNAL_SERVER_ERROR = 500;&nbsp;</div></li><li><div>  const NOT_IMPLEMENTED = 501;&nbsp;</div></li><li><div>  const BAD_GATEWAY = 502;&nbsp;</div></li><li><div>  const SERVICE_UNAVAILABLE = 503;&nbsp;</div></li><li><div>  const GATEWAY_TIMEOUT = 504;&nbsp;</div></li><li><div>  const HTTP_VERSION_NOT_SUPPORTED = 505;&nbsp;</div></li><li><div>  const VARIANT_ALSO_NEGOTIATES = 506;&nbsp;</div></li><li><div>  const INSUFFICIENT_STORAGE = 507;&nbsp;</div></li><li><div>  const NOT_EXTENDED = 510;&nbsp;</div></li><li><div>  const NETWORK_AUTHENTICATION_REQUIRED = 511;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Send an HTTP request to a URI.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Please note: The only URI that are supported in the HTTP Transport implementation</span>&nbsp;</div></li><li><div><span class="comment">   * are the HTTP and HTTPS protocols.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string       $url  The request URL.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $args {</span>&nbsp;</div></li><li><div><span class="comment">   *     Optional. Array or string of HTTP request arguments.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string       $method              Request method. Accepts 'GET', 'POST', 'HEAD', or 'PUT'.</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Some transports technically allow others, but should not be</span>&nbsp;</div></li><li><div><span class="comment">   *                                             assumed. Default 'GET'.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int          $timeout             How long the connection should stay open in seconds. Default 5.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int          $redirection         Number of allowed redirects. Not supported by all transports</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Default 5.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string       $httpversion         Version of the HTTP protocol to use. Accepts '1.0' and '1.1'.</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Default '1.0'.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string       $user-agent          User-agent value sent.</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Default WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ).</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool         $reject_unsafe_urls  Whether to pass URLs through wp_http_validate_url().</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Default false.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool         $blocking            Whether the calling code requires the result of the request.</span>&nbsp;</div></li><li><div><span class="comment">   *                                             If set to false, the request will be sent to the remote server, </span>&nbsp;</div></li><li><div><span class="comment">   *                                             and processing returned to the calling code immediately, the caller</span>&nbsp;</div></li><li><div><span class="comment">   *                                             will know if the request succeeded or failed, but will not receive</span>&nbsp;</div></li><li><div><span class="comment">   *                                             any response from the remote server. Default true.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string|array $headers             Array or string of headers to send with the request.</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Default empty array.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type array        $cookies             List of cookies to send with the request. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string|array $body                Body to send with the request. Default null.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool         $compress            Whether to compress the $body when sending the request.</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Default false.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool         $decompress          Whether to decompress a compressed response. If set to false and</span>&nbsp;</div></li><li><div><span class="comment">   *                                             compressed content is returned in the response anyway, it will</span>&nbsp;</div></li><li><div><span class="comment">   *                                             need to be separately decompressed. Default true.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool         $sslverify           Whether to verify SSL for the request. Default true.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string       sslcertificates      Absolute path to an SSL certificate .crt file.</span>&nbsp;</div></li><li><div><span class="comment">   *                                             Default ABSPATH . WPINC . '/certificates/ca-bundle.crt'.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool         $stream              Whether to stream to a file. If set to true and no filename was</span>&nbsp;</div></li><li><div><span class="comment">   *                                             given, it will be droped it in the WP temp dir and its name will</span>&nbsp;</div></li><li><div><span class="comment">   *                                             be set using the basename of the URL. Default false.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type string       $filename            Filename of the file to write to when streaming. $stream must be</span>&nbsp;</div></li><li><div><span class="comment">   *                                             set to true. Default null.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int          $limit_response_size Size in bytes to limit the response to. Default null.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'.</span>&nbsp;</div></li><li><div><span class="comment">   *                        A WP_Error instance upon error.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function request( $url, $args = array() ) {&nbsp;</div></li><li><div>      $defaults = array(&nbsp;</div></li><li><div>          'method' =&gt; 'GET', &nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the timeout value for an HTTP request.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param int $timeout_value Time in seconds until a request times out.</span>&nbsp;</div></li><li><div><span class="comment">           *                           Default 5.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          'timeout' =&gt; apply_filters( 'http_request_timeout', 5 ), &nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the number of redirects allowed during an HTTP request.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param int $redirect_count Number of redirects allowed. Default 5.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          'redirection' =&gt; apply_filters( 'http_request_redirection_count', 5 ), &nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the version of the HTTP protocol used in a request.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $version Version of HTTP used. Accepts '1.0' and '1.1'.</span>&nbsp;</div></li><li><div><span class="comment">           *                        Default '1.0'.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          'httpversion' =&gt; apply_filters( 'http_request_version', '1.0' ), &nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the user agent value sent with an HTTP request.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $user_agent WordPress user agent string.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          'user-agent' =&gt; apply_filters( 'http_headers_useragent', 'WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ) ), &nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters whether to pass URLs through wp_http_validate_url() in an HTTP request.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 3.6.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool $pass_url Whether to pass URLs through wp_http_validate_url().</span>&nbsp;</div></li><li><div><span class="comment">           *                       Default false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          'reject_unsafe_urls' =&gt; apply_filters( 'http_request_reject_unsafe_urls', false ), &nbsp;</div></li><li><div>          'blocking' =&gt; true, &nbsp;</div></li><li><div>          'headers' =&gt; array(), &nbsp;</div></li><li><div>          'cookies' =&gt; array(), &nbsp;</div></li><li><div>          'body' =&gt; null, &nbsp;</div></li><li><div>          'compress' =&gt; false, &nbsp;</div></li><li><div>          'decompress' =&gt; true, &nbsp;</div></li><li><div>          'sslverify' =&gt; true, &nbsp;</div></li><li><div>          'sslcertificates' =&gt; ABSPATH . WPINC . '/certificates/ca-bundle.crt', &nbsp;</div></li><li><div>          'stream' =&gt; false, &nbsp;</div></li><li><div>          'filename' =&gt; null, &nbsp;</div></li><li><div>          'limit_response_size' =&gt; null, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Pre-parse for the HEAD checks.</span>&nbsp;</div></li><li><div>      $args = wp_parse_args( $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// By default, Head requests do not cause redirections.</span>&nbsp;</div></li><li><div>      if ( isset($args['method']) && 'HEAD' == $args['method'] )&nbsp;</div></li><li><div>          $defaults['redirection'] = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the arguments used in an HTTP request.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $r   An array of HTTP request arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $url The request URL.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $r = apply_filters( 'http_request_args', $r, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// The transports decrement this, store a copy of the original value for loop purposes.</span>&nbsp;</div></li><li><div>      if ( ! isset( $r['_redirection'] ) )&nbsp;</div></li><li><div>          $r['_redirection'] = $r['redirection'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters whether to preempt an HTTP request's return value.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * Returning a non-false value from the filter will short-circuit the HTTP request and return</span>&nbsp;</div></li><li><div><span class="comment">       * early with that value. A filter should return either:</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       *  - An array containing 'headers', 'body', 'response', 'cookies', and 'filename' elements</span>&nbsp;</div></li><li><div><span class="comment">       *  - A WP_Error instance</span>&nbsp;</div></li><li><div><span class="comment">       *  - boolean false (to avoid short-circuiting the response)</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * Returning any other value may result in unexpected behaviour.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param false|array|WP_Error $preempt Whether to preempt an HTTP request's return value. Default false.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array               $r        HTTP request arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string              $url      The request URL.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $pre = apply_filters( 'pre_http_request', false, $r, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( false !== $pre )&nbsp;</div></li><li><div>          return $pre;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( function_exists( 'wp_kses_bad_protocol' ) ) {&nbsp;</div></li><li><div>          if ( $r['reject_unsafe_urls'] ) {&nbsp;</div></li><li><div>              $url = wp_http_validate_url( $url );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ( $url ) {&nbsp;</div></li><li><div>              $url = wp_kses_bad_protocol( $url, array( 'http', 'https', 'ssl' ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $arrURL = @parse_url( $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty( $url ) || empty( $arrURL['scheme'] ) ) {&nbsp;</div></li><li><div>          return new WP_Error('http_request_failed', __('A valid URL was not provided.'));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $this-&gt;block_request( $url ) ) {&nbsp;</div></li><li><div>          return new WP_Error( 'http_request_failed', __( 'User has blocked requests through HTTP.' ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If we are streaming to a file but no filename was given drop it in the WP temp dir</span>&nbsp;</div></li><li><div>      <span class="comment">// and pick its name using the basename of the $url</span>&nbsp;</div></li><li><div>      if ( $r['stream'] ) {&nbsp;</div></li><li><div>          if ( empty( $r['filename'] ) ) {&nbsp;</div></li><li><div>              $r['filename'] = get_temp_dir() . basename( $url );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Force some settings if we are streaming to a file and check for existence and perms of destination directory</span>&nbsp;</div></li><li><div>          $r['blocking'] = true;&nbsp;</div></li><li><div>          if ( ! wp_is_writable( dirname( $r['filename'] ) ) ) {&nbsp;</div></li><li><div>              return new WP_Error( 'http_request_failed', __( 'Destination directory for file streaming does not exist or is not writable.' ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_null( $r['headers'] ) ) {&nbsp;</div></li><li><div>          $r['headers'] = array();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// WP allows passing in headers as a string, weirdly.</span>&nbsp;</div></li><li><div>      if ( ! is_array( $r['headers'] ) ) {&nbsp;</div></li><li><div>          $processedHeaders = WP_Http::processHeaders( $r['headers'] );&nbsp;</div></li><li><div>          $r['headers'] = $processedHeaders['headers'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Setup arguments</span>&nbsp;</div></li><li><div>      $headers = $r['headers'];&nbsp;</div></li><li><div>      $data = $r['body'];&nbsp;</div></li><li><div>      $type = $r['method'];&nbsp;</div></li><li><div>      $options = array(&nbsp;</div></li><li><div>          'timeout' =&gt; $r['timeout'], &nbsp;</div></li><li><div>          'useragent' =&gt; $r['user-agent'], &nbsp;</div></li><li><div>          'blocking' =&gt; $r['blocking'], &nbsp;</div></li><li><div>          'hooks' =&gt; new WP_HTTP_Requests_Hooks( $url, $r ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Ensure redirects follow browser behaviour.</span>&nbsp;</div></li><li><div>      $options['hooks']-&gt;register( 'requests.before_redirect', array( get_class(), 'browser_redirect_compatibility' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $r['stream'] ) {&nbsp;</div></li><li><div>          $options['filename'] = $r['filename'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( empty( $r['redirection'] ) ) {&nbsp;</div></li><li><div>          $options['follow_redirects'] = false;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $options['redirects'] = $r['redirection'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Use byte limit, if we can</span>&nbsp;</div></li><li><div>      if ( isset( $r['limit_response_size'] ) ) {&nbsp;</div></li><li><div>          $options['max_bytes'] = $r['limit_response_size'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If we've got cookies, use and convert them to Requests_Cookie.</span>&nbsp;</div></li><li><div>      if ( ! empty( $r['cookies'] ) ) {&nbsp;</div></li><li><div>          $options['cookies'] = WP_Http::normalize_cookies( $r['cookies'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// SSL certificate handling</span>&nbsp;</div></li><li><div>      if ( ! $r['sslverify'] ) {&nbsp;</div></li><li><div>          $options['verify'] = false;&nbsp;</div></li><li><div>          $options['verifyname'] = false;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $options['verify'] = $r['sslcertificates'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// All non-GET/HEAD requests should put the arguments in the form body.</span>&nbsp;</div></li><li><div>      if ( 'HEAD' !== $type && 'GET' !== $type ) {&nbsp;</div></li><li><div>          $options['data_format'] = 'body';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters whether SSL should be verified for non-local requests.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool $ssl_verify Whether to verify the SSL connection. Default true.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $options['verify'] = apply_filters( 'https_ssl_verify', $options['verify'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Check for proxies.</span>&nbsp;</div></li><li><div>      $proxy = new WP_HTTP_Proxy();&nbsp;</div></li><li><div>      if ( $proxy-&gt;is_enabled() && $proxy-&gt;send_through_proxy( $url ) ) {&nbsp;</div></li><li><div>          $options['proxy'] = new Requests_Proxy_HTTP( $proxy-&gt;host() . ':' . $proxy-&gt;port() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $proxy-&gt;use_authentication() ) {&nbsp;</div></li><li><div>              $options['proxy']-&gt;use_authentication = true;&nbsp;</div></li><li><div>              $options['proxy']-&gt;user = $proxy-&gt;username();&nbsp;</div></li><li><div>              $options['proxy']-&gt;pass = $proxy-&gt;password();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Avoid issues where mbstring.func_overload is enabled</span>&nbsp;</div></li><li><div>      mbstring_binary_safe_encoding();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      try {&nbsp;</div></li><li><div>          $requests_response = Requests::request( $url, $headers, $data, $type, $options );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Convert the response into an array</span>&nbsp;</div></li><li><div>          $http_response = new WP_HTTP_Requests_Response( $requests_response, $r['filename'] );&nbsp;</div></li><li><div>          $response = $http_response-&gt;to_array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Add the original object to the array.</span>&nbsp;</div></li><li><div>          $response['http_response'] = $http_response;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      catch ( Requests_Exception $e ) {&nbsp;</div></li><li><div>          $response = new WP_Error( 'http_request_failed', $e-&gt;getMessage() );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      reset_mbstring_encoding();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires after an HTTP API response is received and before the response is returned.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array|WP_Error $response HTTP response or WP_Error object.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string         $context  Context under which the hook is fired.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string         $class    HTTP transport used.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array          $args     HTTP request arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string         $url      The request URL.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'http_api_debug', $response, 'response', 'Requests', $r, $url );&nbsp;</div></li><li><div>      if ( is_wp_error( $response ) ) {&nbsp;</div></li><li><div>          return $response;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $r['blocking'] ) {&nbsp;</div></li><li><div>          return array(&nbsp;</div></li><li><div>              'headers' =&gt; array(), &nbsp;</div></li><li><div>              'body' =&gt; '', &nbsp;</div></li><li><div>              'response' =&gt; array(&nbsp;</div></li><li><div>                  'code' =&gt; false, &nbsp;</div></li><li><div>                  'message' =&gt; false, &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>              'cookies' =&gt; array(), &nbsp;</div></li><li><div>              'http_response' =&gt; null, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the HTTP API response immediately before the response is returned.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $response HTTP response.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $r        HTTP request arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $url      The request URL.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'http_response', $response, $r, $url );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Normalizes cookies for using in Requests.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.6.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $cookies List of cookies to send with the request.</span>&nbsp;</div></li><li><div><span class="comment">   * @return Requests_Cookie_Jar Cookie holder object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function normalize_cookies( $cookies ) {&nbsp;</div></li><li><div>      $cookie_jar = new Requests_Cookie_Jar();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $cookies as $name =&gt; $value ) {&nbsp;</div></li><li><div>          if ( $value instanceof WP_Http_Cookie ) {&nbsp;</div></li><li><div>              $cookie_jar[ $value-&gt;name ] = new Requests_Cookie( $value-&gt;name, $value-&gt;value, $value-&gt;get_attributes() );&nbsp;</div></li><li><div>          } elseif ( is_scalar( $value ) ) {&nbsp;</div></li><li><div>              $cookie_jar[ $name ] = new Requests_Cookie( $name, $value );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $cookie_jar;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Match redirect behaviour to browser handling.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Changes 302 redirects from POST to GET to match browser handling. Per</span>&nbsp;</div></li><li><div><span class="comment">   * RFC 7231, user agents can deviate from the strict reading of the</span>&nbsp;</div></li><li><div><span class="comment">   * specification for compatibility purposes.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.6.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string            $location URL to redirect to.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array             $headers  Headers for the redirect.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array             $options  Redirect request options.</span>&nbsp;</div></li><li><div><span class="comment">   * @param Requests_Response $original Response object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function browser_redirect_compatibility( $location, $headers, $data, &$options, $original ) {&nbsp;</div></li><li><div>      <span class="comment">// Browser compat</span>&nbsp;</div></li><li><div>      if ( $original-&gt;status_code === 302 ) {&nbsp;</div></li><li><div>          $options['type'] = Requests::GET;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Tests which transports are capable of supporting the request.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.2.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $args Request arguments</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url URL to Request</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false Class name for the first transport that claims to support the request. False if no transport claims to support the request.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function _get_first_available_transport( $args, $url = null ) {&nbsp;</div></li><li><div>      $transports = array( 'curl', 'streams' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters which HTTP transports are available and in what order.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $transports Array of HTTP transports to check. Default array contains</span>&nbsp;</div></li><li><div><span class="comment">       *                           'curl', and 'streams', in that order.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $args       HTTP request arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $url        The URL to request.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $request_order = apply_filters( 'http_api_transports', $transports, $args, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Loop over each transport on each HTTP request looking for one which will serve this request's needs.</span>&nbsp;</div></li><li><div>      foreach ( $request_order as $transport ) {&nbsp;</div></li><li><div>          if ( in_array( $transport, $transports ) ) {&nbsp;</div></li><li><div>              $transport = ucfirst( $transport );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $class = 'WP_Http_' . $transport;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Check to see if this transport is a possibility, calls the transport statically.</span>&nbsp;</div></li><li><div>          if ( !call_user_func( array( $class, 'test' ), $args, $url ) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return $class;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Dispatches a HTTP request to a supporting transport.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Tests each transport in order to find a transport which matches the request arguments.</span>&nbsp;</div></li><li><div><span class="comment">   * Also caches the transport instance to be used later.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The order for requests is cURL, and then PHP Streams.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url URL to Request</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $args Request arguments</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  private function _dispatch_request( $url, $args ) {&nbsp;</div></li><li><div>      static $transports = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $class = $this-&gt;_get_first_available_transport( $args, $url );&nbsp;</div></li><li><div>      if ( !$class )&nbsp;</div></li><li><div>          return new WP_Error( 'http_failure', __( 'There are no HTTP transports available which can complete the requested request.' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Transport claims to support request, instantiate it and give it a whirl.</span>&nbsp;</div></li><li><div>      if ( empty( $transports[$class] ) )&nbsp;</div></li><li><div>          $transports[$class] = new $class;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $response = $transports[$class]-&gt;request( $url, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/** This action is documented in wp-includes/class-http.php */</span>&nbsp;</div></li><li><div>      do_action( 'http_api_debug', $response, 'response', $class, $args, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_wp_error( $response ) )&nbsp;</div></li><li><div>          return $response;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the HTTP API response immediately before the response is returned.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $response HTTP response.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $args     HTTP request arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $url      The request URL.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'http_response', $response, $args, $url );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Uses the POST HTTP method.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Used for sending data that is expected to be in the body.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string       $url  The request URL.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $args Optional. Override the defaults.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function post($url, $args = array()) {&nbsp;</div></li><li><div>      $defaults = array('method' =&gt; 'POST');&nbsp;</div></li><li><div>      $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>      return $this-&gt;request($url, $r);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Uses the GET HTTP method.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Used for sending data that is expected to be in the body.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url The request URL.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $args Optional. Override the defaults.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get($url, $args = array()) {&nbsp;</div></li><li><div>      $defaults = array('method' =&gt; 'GET');&nbsp;</div></li><li><div>      $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>      return $this-&gt;request($url, $r);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Uses the HEAD HTTP method.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Used for sending data that is expected to be in the body.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url The request URL.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $args Optional. Override the defaults.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function head($url, $args = array()) {&nbsp;</div></li><li><div>      $defaults = array('method' =&gt; 'HEAD');&nbsp;</div></li><li><div>      $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>      return $this-&gt;request($url, $r);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Parses the responses and splits the parts into headers and body.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $strResponse The full response string</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Array with 'headers' and 'body' keys.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function processResponse($strResponse) {&nbsp;</div></li><li><div>      $res = explode(&quot;\r\n\r\n&quot;, $strResponse, 2);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array('headers' =&gt; $res[0], 'body' =&gt; isset($res[1]) ? $res[1] : '');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Transform header string into an array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If an array is given then it is assumed to be raw header data with numeric keys with the</span>&nbsp;</div></li><li><div><span class="comment">   * headers as the values. No headers must be passed that were already processed.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $headers</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url The URL that was requested</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Processed string headers. If duplicate headers are encountered, </span>&nbsp;</div></li><li><div><span class="comment">   *                     Then a numbered array is returned as the value of that header-key.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function processHeaders( $headers, $url = '' ) {&nbsp;</div></li><li><div>      <span class="comment">// Split headers, one per array element.</span>&nbsp;</div></li><li><div>      if ( is_string($headers) ) {&nbsp;</div></li><li><div>          <span class="comment">// Tolerate line terminator: CRLF = LF (RFC 2616 19.3).</span>&nbsp;</div></li><li><div>          $headers = str_replace(&quot;\r\n&quot;, &quot;\n&quot;, $headers);&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Unfold folded header fields. LWS = [CRLF] 1*( SP | HT ) &lt;US-ASCII SP, space (32)&gt;, </span>&nbsp;</div></li><li><div><span class="comment">           * &lt;US-ASCII HT, horizontal-tab (9)&gt; (RFC 2616 2.2).</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $headers = preg_replace('/\n[ \t]/', ' ', $headers);&nbsp;</div></li><li><div>          <span class="comment">// Create the headers array.</span>&nbsp;</div></li><li><div>          $headers = explode(&quot;\n&quot;, $headers);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $response = array('code' =&gt; 0, 'message' =&gt; '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * If a redirection has taken place, The headers for each page request may have been passed.</span>&nbsp;</div></li><li><div><span class="comment">       * In this case, determine the final HTTP header and parse from there.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      for ( $i = count($headers)-1; $i &gt;= 0; $i-- ) {&nbsp;</div></li><li><div>          if ( !empty($headers[$i]) && false === strpos($headers[$i], ':') ) {&nbsp;</div></li><li><div>              $headers = array_splice($headers, $i);&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $cookies = array();&nbsp;</div></li><li><div>      $newheaders = array();&nbsp;</div></li><li><div>      foreach ( (array) $headers as $tempheader ) {&nbsp;</div></li><li><div>          if ( empty($tempheader) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( false === strpos($tempheader, ':') ) {&nbsp;</div></li><li><div>              $stack = explode(' ', $tempheader, 3);&nbsp;</div></li><li><div>              $stack[] = '';&nbsp;</div></li><li><div>              list( , $response['code'], $response['message']) = $stack;&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          list($key, $value) = explode(':', $tempheader, 2);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $key = strtolower( $key );&nbsp;</div></li><li><div>          $value = trim( $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( isset( $newheaders[ $key ] ) ) {&nbsp;</div></li><li><div>              if ( ! is_array( $newheaders[ $key ] ) )&nbsp;</div></li><li><div>                  $newheaders[$key] = array( $newheaders[ $key ] );&nbsp;</div></li><li><div>              $newheaders[ $key ][] = $value;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $newheaders[ $key ] = $value;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ( 'set-cookie' == $key )&nbsp;</div></li><li><div>              $cookies[] = new WP_Http_Cookie( $value, $url );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Cast the Response Code to an int</span>&nbsp;</div></li><li><div>      $response['code'] = intval( $response['code'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array('response' =&gt; $response, 'headers' =&gt; $newheaders, 'cookies' =&gt; $cookies);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Takes the arguments for a ::request() and checks for the cookie array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If it's found, then it upgrades any basic name =&gt; value pairs to WP_Http_Cookie instances, </span>&nbsp;</div></li><li><div><span class="comment">   * which are each parsed into strings and added to the Cookie: header (within the arguments array).</span>&nbsp;</div></li><li><div><span class="comment">   * Edits the array by reference.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @version 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $r Full array of args passed into ::request()</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function buildCookieHeader( &$r ) {&nbsp;</div></li><li><div>      if ( ! empty($r['cookies']) ) {&nbsp;</div></li><li><div>          <span class="comment">// Upgrade any name =&gt; value cookie pairs to WP_HTTP_Cookie instances.</span>&nbsp;</div></li><li><div>          foreach ( $r['cookies'] as $name =&gt; $value ) {&nbsp;</div></li><li><div>              if ( ! is_object( $value ) )&nbsp;</div></li><li><div>                  $r['cookies'][ $name ] = new WP_Http_Cookie( array( 'name' =&gt; $name, 'value' =&gt; $value ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $cookies_header = '';&nbsp;</div></li><li><div>          foreach ( (array) $r['cookies'] as $cookie ) {&nbsp;</div></li><li><div>              $cookies_header .= $cookie-&gt;getHeaderValue() . '; ';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $cookies_header = substr( $cookies_header, 0, -2 );&nbsp;</div></li><li><div>          $r['headers']['cookie'] = $cookies_header;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Decodes chunk transfer-encoding, based off the HTTP 1.1 specification.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Based off the HTTP http_encoding_dechunk function.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @link https://tools.ietf.org/html/rfc2616#section-19.4.6 Process for chunked decoding.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $body Body content</span>&nbsp;</div></li><li><div><span class="comment">   * @return string Chunked decoded body on success or raw body on failure.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function chunkTransferDecode( $body ) {&nbsp;</div></li><li><div>      <span class="comment">// The body is not chunked encoded or is malformed.</span>&nbsp;</div></li><li><div>      if ( ! preg_match( '/^([0-9a-f]+)[^\r\n]*\r\n/i', trim( $body ) ) )&nbsp;</div></li><li><div>          return $body;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $parsed_body = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// We'll be altering $body, so need a backup in case of error.</span>&nbsp;</div></li><li><div>      $body_original = $body;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      while ( true ) {&nbsp;</div></li><li><div>          $has_chunk = (bool) preg_match( '/^([0-9a-f]+)[^\r\n]*\r\n/i', $body, $match );&nbsp;</div></li><li><div>          if ( ! $has_chunk || empty( $match[1] ) )&nbsp;</div></li><li><div>              return $body_original;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $length = hexdec( $match[1] );&nbsp;</div></li><li><div>          $chunk_length = strlen( $match[0] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Parse out the chunk of data.</span>&nbsp;</div></li><li><div>          $parsed_body .= substr( $body, $chunk_length, $length );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Remove the chunk from the raw data.</span>&nbsp;</div></li><li><div>          $body = substr( $body, $length + $chunk_length );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// End of the document.</span>&nbsp;</div></li><li><div>          if ( '0' === trim( $body ) )&nbsp;</div></li><li><div>              return $parsed_body;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Block requests through the proxy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Those who are behind a proxy and want to prevent access to certain hosts may do so. This will</span>&nbsp;</div></li><li><div><span class="comment">   * prevent plugins from working and core functionality, if you don't include api.wordpress.org.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * You block external URL requests by defining WP_HTTP_BLOCK_EXTERNAL as true in your wp-config.php</span>&nbsp;</div></li><li><div><span class="comment">   * file and this will only allow localhost and your site to make requests. The constant</span>&nbsp;</div></li><li><div><span class="comment">   * WP_ACCESSIBLE_HOSTS will allow additional hosts to go through for requests. The format of the</span>&nbsp;</div></li><li><div><span class="comment">   * WP_ACCESSIBLE_HOSTS constant is a comma separated list of hostnames to allow, wildcard domains</span>&nbsp;</div></li><li><div><span class="comment">   * are supported, eg *.wordpress.org will allow for all subdomains of wordpress.org to be contacted.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">   * @link https://core.trac.wordpress.org/ticket/8927 Allow preventing external requests.</span>&nbsp;</div></li><li><div><span class="comment">   * @link https://core.trac.wordpress.org/ticket/14636 Allow wildcard domains in WP_ACCESSIBLE_HOSTS</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @staticvar array|null $accessible_hosts</span>&nbsp;</div></li><li><div><span class="comment">   * @staticvar array      $wildcard_regex</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $uri URI of url.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool True to block, false to allow.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function block_request($uri) {&nbsp;</div></li><li><div>      <span class="comment">// We don't need to block requests, because nothing is blocked.</span>&nbsp;</div></li><li><div>      if ( ! defined( 'WP_HTTP_BLOCK_EXTERNAL' ) || ! WP_HTTP_BLOCK_EXTERNAL )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $check = parse_url($uri);&nbsp;</div></li><li><div>      if ( ! $check )&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $home = parse_url( get_option('siteurl') );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Don't block requests back to ourselves by default.</span>&nbsp;</div></li><li><div>      if ( 'localhost' == $check['host'] || ( isset( $home['host'] ) && $home['host'] == $check['host'] ) ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters whether to block local requests through the proxy.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool $block Whether to block local requests through proxy.</span>&nbsp;</div></li><li><div><span class="comment">           *                    Default false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          return apply_filters( 'block_local_requests', false );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !defined('WP_ACCESSIBLE_HOSTS') )&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      static $accessible_hosts = null;&nbsp;</div></li><li><div>      static $wildcard_regex = array();&nbsp;</div></li><li><div>      if ( null === $accessible_hosts ) {&nbsp;</div></li><li><div>          $accessible_hosts = preg_split('|, \s*|', WP_ACCESSIBLE_HOSTS);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( false !== strpos(WP_ACCESSIBLE_HOSTS, '*') ) {&nbsp;</div></li><li><div>              $wildcard_regex = array();&nbsp;</div></li><li><div>              foreach ( $accessible_hosts as $host )&nbsp;</div></li><li><div>                  $wildcard_regex[] = str_replace( '\*', '.+', preg_quote( $host, '/' ) );&nbsp;</div></li><li><div>              $wildcard_regex = '/^(' . implode('|', $wildcard_regex) . ')$/i';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($wildcard_regex) )&nbsp;</div></li><li><div>          return !preg_match($wildcard_regex, $check['host']);&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          return !in_array( $check['host'], $accessible_hosts ); <span class="comment">//Inverse logic, If it's in the array, then we can't access it.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Used as a wrapper for PHP's parse_url() function that handles edgecases in &lt; PHP 5.4.7.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @access protected</span>&nbsp;</div></li><li><div><span class="comment">   * @deprecated 4.4.0 Use wp_parse_url()</span>&nbsp;</div></li><li><div><span class="comment">   * @see wp_parse_url()</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url The URL to parse.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool|array False on failure; Array of URL components on success;</span>&nbsp;</div></li><li><div><span class="comment">   *                    See parse_url()'s return values.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  protected static function parse_url( $url ) {&nbsp;</div></li><li><div>      _deprecated_function( __METHOD__, '4.4.0', 'wp_parse_url()' );&nbsp;</div></li><li><div>      return wp_parse_url( $url );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Converts a relative URL to an absolute URL relative to a given URL.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If an Absolute URL is provided, no processing of that URL is done.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $maybe_relative_path The URL which might be relative</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url                 The URL which $maybe_relative_path is relative to</span>&nbsp;</div></li><li><div><span class="comment">   * @return string An Absolute URL, in a failure condition where the URL cannot be parsed, the relative URL will be returned.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function make_absolute_url( $maybe_relative_path, $url ) {&nbsp;</div></li><li><div>      if ( empty( $url ) )&nbsp;</div></li><li><div>          return $maybe_relative_path;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $url_parts = wp_parse_url( $url ) ) {&nbsp;</div></li><li><div>          return $maybe_relative_path;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $relative_url_parts = wp_parse_url( $maybe_relative_path ) ) {&nbsp;</div></li><li><div>          return $maybe_relative_path;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Check for a scheme on the 'relative' url</span>&nbsp;</div></li><li><div>      if ( ! empty( $relative_url_parts['scheme'] ) ) {&nbsp;</div></li><li><div>          return $maybe_relative_path;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $absolute_path = $url_parts['scheme'] . ':<span class="comment">//';</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Schemeless URL's will make it this far, so we check for a host in the relative url and convert it to a protocol-url</span>&nbsp;</div></li><li><div>      if ( isset( $relative_url_parts['host'] ) ) {&nbsp;</div></li><li><div>          $absolute_path .= $relative_url_parts['host'];&nbsp;</div></li><li><div>          if ( isset( $relative_url_parts['port'] ) )&nbsp;</div></li><li><div>              $absolute_path .= ':' . $relative_url_parts['port'];&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $absolute_path .= $url_parts['host'];&nbsp;</div></li><li><div>          if ( isset( $url_parts['port'] ) )&nbsp;</div></li><li><div>              $absolute_path .= ':' . $url_parts['port'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Start off with the Absolute URL path.</span>&nbsp;</div></li><li><div>      $path = ! empty( $url_parts['path'] ) ? $url_parts['path'] : '/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If it's a root-relative path, then great.</span>&nbsp;</div></li><li><div>      if ( ! empty( $relative_url_parts['path'] ) && '/' == $relative_url_parts['path'][0] ) {&nbsp;</div></li><li><div>          $path = $relative_url_parts['path'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Else it's a relative path.</span>&nbsp;</div></li><li><div>      } elseif ( ! empty( $relative_url_parts['path'] ) ) {&nbsp;</div></li><li><div>          <span class="comment">// Strip off any file components from the absolute path.</span>&nbsp;</div></li><li><div>          $path = substr( $path, 0, strrpos( $path, '/' ) + 1 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Build the new path.</span>&nbsp;</div></li><li><div>          $path .= $relative_url_parts['path'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Strip all /path/../ out of the path.</span>&nbsp;</div></li><li><div>          while ( strpos( $path, '../' ) &gt; 1 ) {&nbsp;</div></li><li><div>              $path = preg_replace( '![^/]+/\.\./!', '', $path );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Strip any final leading ../ from the path.</span>&nbsp;</div></li><li><div>          $path = preg_replace( '!^/(\.\./)+!', '', $path );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Add the Query string.</span>&nbsp;</div></li><li><div>      if ( ! empty( $relative_url_parts['query'] ) )&nbsp;</div></li><li><div>          $path .= '?' . $relative_url_parts['query'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $absolute_path . '/' . ltrim( $path, '/' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Handles HTTP Redirects and follows them if appropriate.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url The URL which was requested.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $args The Arguments which were used to make the request.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $response The Response of the HTTP request.</span>&nbsp;</div></li><li><div><span class="comment">   * @return false|object False if no redirect is present, a WP_HTTP or WP_Error result otherwise.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function handle_redirects( $url, $args, $response ) {&nbsp;</div></li><li><div>      <span class="comment">// If no redirects are present, or, redirects were not requested, perform no action.</span>&nbsp;</div></li><li><div>      if ( ! isset( $response['headers']['location'] ) || 0 === $args['_redirection'] )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Only perform redirections on redirection http codes.</span>&nbsp;</div></li><li><div>      if ( $response['response']['code'] &gt; 399 || $response['response']['code'] &lt; 300 )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Don't redirect if we've run out of redirects.</span>&nbsp;</div></li><li><div>      if ( $args['redirection']-- &lt;= 0 )&nbsp;</div></li><li><div>          return new WP_Error( 'http_request_failed', __('Too many redirects.') );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $redirect_location = $response['headers']['location'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If there were multiple Location headers, use the last header specified.</span>&nbsp;</div></li><li><div>      if ( is_array( $redirect_location ) )&nbsp;</div></li><li><div>          $redirect_location = array_pop( $redirect_location );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $redirect_location = WP_Http::make_absolute_url( $redirect_location, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// POST requests should not POST to a redirected location.</span>&nbsp;</div></li><li><div>      if ( 'POST' == $args['method'] ) {&nbsp;</div></li><li><div>          if ( in_array( $response['response']['code'], array( 302, 303 ) ) )&nbsp;</div></li><li><div>              $args['method'] = 'GET';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Include valid cookies in the redirect process.</span>&nbsp;</div></li><li><div>      if ( ! empty( $response['cookies'] ) ) {&nbsp;</div></li><li><div>          foreach ( $response['cookies'] as $cookie ) {&nbsp;</div></li><li><div>              if ( $cookie-&gt;test( $redirect_location ) )&nbsp;</div></li><li><div>                  $args['cookies'][] = $cookie;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return wp_remote_request( $redirect_location, $args );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Determines if a specified string represents an IP address or not.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * This function also detects the type of the IP address, returning either</span>&nbsp;</div></li><li><div><span class="comment">   * '4' or '6' to represent a IPv4 and IPv6 address respectively.</span>&nbsp;</div></li><li><div><span class="comment">   * This does not verify if the IP is a valid IP, only that it appears to be</span>&nbsp;</div></li><li><div><span class="comment">   * an IP address.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @link http://home.deds.nl/~aeron/regex/ for IPv6 regex</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @static</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $maybe_ip A suspected IP address</span>&nbsp;</div></li><li><div><span class="comment">   * @return integer|bool Upon success, '4' or '6' to represent a IPv4 or IPv6 address, false upon failure</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function is_ip_address( $maybe_ip ) {&nbsp;</div></li><li><div>      if ( preg_match( '/^\d{1, 3}\.\d{1, 3}\.\d{1, 3}\.\d{1, 3}$/', $maybe_ip ) )&nbsp;</div></li><li><div>          return 4;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( false !== strpos( $maybe_ip, ':' ) && preg_match( '/^(((?=.*(::))(?!.*\3.+\3))\3?|([\dA-F]{1, 4}(\3|:\b|$)|\2))(?4) {5}((?4) {2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b) {4})$/i', trim( $maybe_ip, ' []' ) ) )&nbsp;</div></li><li><div>          return 6;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>file</li><li><span></span></li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>