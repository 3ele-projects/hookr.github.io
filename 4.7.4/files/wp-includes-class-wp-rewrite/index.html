<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="wordpress" data-version="4.7.4" data-type="file" data-id="4694"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp-includes-class-wp-rewrite | file | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, wordpress, 4.7.4" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.25"}};!function(e,n,t){var a;function i(e){var t=n.createElement("canvas"),a=t.getContext&&t.getContext("2d"),i=String.fromCharCode;return!(!a||!a.fillText)&&(a.textBaseline="top",a.font="600 32px Arial","flag"===e?(a.fillText(i(55356,56806,55356,56826),0,0),3e3<t.toDataURL().length):"diversity"===e?(a.fillText(i(55356,57221),0,0),t=a.getImageData(16,16,1,1).data,a.fillText(i(55356,57221,55356,57343),0,0),(t=a.getImageData(16,16,1,1).data)[0],t[1],t[2],t[3],!0):("simple"===e?a.fillText(i(55357,56835),0,0):a.fillText(i(55356,57135),0,0),0!==a.getImageData(16,16,1,1).data[0]))}function o(e){var t=n.createElement("script");t.src=e,t.type="text/javascript",n.getElementsByTagName("head")[0].appendChild(t)}t.supports={simple:i("simple"),flag:i("flag"),unicode8:i("unicode8"),diversity:i("diversity")},t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.simple&&t.supports.flag&&t.supports.unicode8&&t.supports.diversity||(a=function(){t.readyCallback()},n.addEventListener?(n.addEventListener("DOMContentLoaded",a,!1),e.addEventListener("load",a,!1)):(e.attachEvent("onload",a),n.attachEvent("onreadystatechange",function(){"complete"===n.readyState&&t.readyCallback()})),(a=t.source||{}).concatemoji?o(a.concatemoji):a.wpemoji&&a.twemoji&&(o(a.twemoji),o(a.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=a7a18aaa6823bcb42c31b7c269d7f63b' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.25' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/wp-includes-class-wp-rewrite/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-class-wp-rewrite%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-class-wp-rewrite%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-file-wp-includes-class-wp-rewrite","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp-includes-class-wp-rewrite" class="blog single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="http://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp-includes-class-wp-rewrite</span><meta property="position" content="3"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="http://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="http://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="http://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="http://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="" data-id="class" data-count="351"><a href="http://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="http://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/wp-includes/class-wp-rewrite.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Rewrite API: WP_Rewrite class</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage Rewrite</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Core class used to implement a rewrite component API.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The WordPress Rewrite class writes the rewrite module rules to the .htaccess</span>&nbsp;</div></li><li><div><span class="comment"> * file. It also handles parsing the request to get the correct setup for the</span>&nbsp;</div></li><li><div><span class="comment"> * WordPress Query class.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The Rewrite along with WP class function as a front controller for WordPress.</span>&nbsp;</div></li><li><div><span class="comment"> * You can add rules to trigger your page view and processing using this</span>&nbsp;</div></li><li><div><span class="comment"> * component. The full functionality of a front controller does not exist, </span>&nbsp;</div></li><li><div><span class="comment"> * meaning you can't define how the template files load based on the rewrite</span>&nbsp;</div></li><li><div><span class="comment"> * rules.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>class WP_Rewrite {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Permalink structure for posts.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $permalink_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Whether to add trailing slashes.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.2.0</span>&nbsp;</div></li><li><div><span class="comment">   * @var bool</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $use_trailing_slashes;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Base for the author permalink structure (example.com/$author_base/authorname).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $author_base = 'author';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Permalink structure for author archives.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $author_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Permalink structure for date archives.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $date_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Permalink structure for pages.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $page_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Base of the search permalink structure (example.com/$search_base/query).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $search_base = 'search';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Permalink structure for searches.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $search_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Comments permalink base.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $comments_base = 'comments';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Pagination permalink base.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $pagination_base = 'page';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Comments pagination permalink base.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $comments_pagination_base = 'comment-page';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Feed permalink base.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $feed_base = 'feed';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Comments feed permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $comment_feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Feed request permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The static portion of the post permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If the permalink structure is &quot;/archive/%post_id%&quot; then the front</span>&nbsp;</div></li><li><div><span class="comment">   * is &quot;/archive/&quot;. If the permalink structure is &quot;/%year%/%postname%/&quot;</span>&nbsp;</div></li><li><div><span class="comment">   * then the front is &quot;/&quot;.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::init()</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $front;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The prefix for all permalink structures.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If PATHINFO/index permalinks are in use then the root is the value of</span>&nbsp;</div></li><li><div><span class="comment">   * `WP_Rewrite::$index` with a trailing slash appended. Otherwise the root</span>&nbsp;</div></li><li><div><span class="comment">   * will be empty.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::init()</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::using_index_permalinks()</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $root = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The name of the index file which is the entry point to all requests.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $index = 'index.php';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Variable name to use for regex matches in the rewritten query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $matches = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Rewrite rules to match against the request to find the redirect or query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $rules;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Additional rules added external to the rewrite class.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Those not generated by the class, see add_rewrite_rule().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $extra_rules = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Additional rules that belong at the beginning to match first.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Those not generated by the class, see add_rewrite_rule().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $extra_rules_top = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Rules that don't redirect to WordPress' index.php.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * These rules are written to the mod_rewrite portion of the .htaccess, </span>&nbsp;</div></li><li><div><span class="comment">   * and are added by add_external_rule().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $non_wp_rules = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Extra permalink structures, e.g. categories, added by add_permastruct().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $extra_permastructs = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Endpoints (like /trackback/) added by add_rewrite_endpoint().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $endpoints;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Whether to write every mod_rewrite rule for WordPress into the .htaccess file.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * This is off by default, turning it on might print a lot of rewrite rules</span>&nbsp;</div></li><li><div><span class="comment">   * to the .htaccess file.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var bool</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::mod_rewrite_rules()</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $use_verbose_rules = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Could post permalinks be confused with those of pages?</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If the first rewrite tag in the post permalink structure is one that could</span>&nbsp;</div></li><li><div><span class="comment">   * also match a page name (e.g. %postname% or %author%) then this flag is</span>&nbsp;</div></li><li><div><span class="comment">   * set to true. Prior to WordPress 3.3 this flag indicated that every page</span>&nbsp;</div></li><li><div><span class="comment">   * would have a set of rules added to the top of the rewrite rules array.</span>&nbsp;</div></li><li><div><span class="comment">   * Now it tells WP::parse_request() to check if a URL matching the page</span>&nbsp;</div></li><li><div><span class="comment">   * permastruct is actually a page before accepting it.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   * @var bool</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::init()</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $use_verbose_page_rules = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Rewrite tags that can be used in permalink structures.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * These are translated into the regular expressions stored in</span>&nbsp;</div></li><li><div><span class="comment">   * `WP_Rewrite::$rewritereplace` and are rewritten to the query</span>&nbsp;</div></li><li><div><span class="comment">   * variables listed in WP_Rewrite::$queryreplace.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Additional tags can be added with add_rewrite_tag().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $rewritecode = array(&nbsp;</div></li><li><div>      '%year%', &nbsp;</div></li><li><div>      '%monthnum%', &nbsp;</div></li><li><div>      '%day%', &nbsp;</div></li><li><div>      '%hour%', &nbsp;</div></li><li><div>      '%minute%', &nbsp;</div></li><li><div>      '%second%', &nbsp;</div></li><li><div>      '%postname%', &nbsp;</div></li><li><div>      '%post_id%', &nbsp;</div></li><li><div>      '%author%', &nbsp;</div></li><li><div>      '%pagename%', &nbsp;</div></li><li><div>      '%search%'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Regular expressions to be substituted into rewrite rules in place</span>&nbsp;</div></li><li><div><span class="comment">   * of rewrite tags, see WP_Rewrite::$rewritecode.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $rewritereplace = array(&nbsp;</div></li><li><div>      '([0-9]{4})', &nbsp;</div></li><li><div>      '([0-9]{1, 2})', &nbsp;</div></li><li><div>      '([0-9]{1, 2})', &nbsp;</div></li><li><div>      '([0-9]{1, 2})', &nbsp;</div></li><li><div>      '([0-9]{1, 2})', &nbsp;</div></li><li><div>      '([0-9]{1, 2})', &nbsp;</div></li><li><div>      '([^/]+)', &nbsp;</div></li><li><div>      '([0-9]+)', &nbsp;</div></li><li><div>      '([^/]+)', &nbsp;</div></li><li><div>      '([^/]+?)', &nbsp;</div></li><li><div>      '(.+)'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Query variables that rewrite tags map to, see WP_Rewrite::$rewritecode.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $queryreplace = array(&nbsp;</div></li><li><div>      'year=', &nbsp;</div></li><li><div>      'monthnum=', &nbsp;</div></li><li><div>      'day=', &nbsp;</div></li><li><div>      'hour=', &nbsp;</div></li><li><div>      'minute=', &nbsp;</div></li><li><div>      'second=', &nbsp;</div></li><li><div>      'name=', &nbsp;</div></li><li><div>      'p=', &nbsp;</div></li><li><div>      'author_name=', &nbsp;</div></li><li><div>      'pagename=', &nbsp;</div></li><li><div>      's='&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Supported default feeds.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @var array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public $feeds = array( 'feed', 'rdf', 'rss', 'rss2', 'atom' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Determines whether permalinks are being used.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * This can be either rewrite module or permalink in the HTTP query string.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool True, if permalinks are enabled.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function using_permalinks() {&nbsp;</div></li><li><div>      return ! empty($this-&gt;permalink_structure);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Determines whether permalinks are being used and rewrite module is not enabled.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Means that permalink links are enabled and index.php is in the URL.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool Whether permalink links are enabled and index.php is in the URL.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function using_index_permalinks() {&nbsp;</div></li><li><div>      if ( empty( $this-&gt;permalink_structure ) ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If the index is not in the permalink, we're using mod_rewrite.</span>&nbsp;</div></li><li><div>      return preg_match( '#^<span class="comment">/*' . $this-&gt;index . '#', $this-&gt;permalink_structure );</span>&nbsp;</div></li><li><div><span class="comment">  }</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">  /**</span>&nbsp;</div></li><li><div><span class="comment">   * Determines whether permalinks are being used and rewrite module is enabled.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Using permalinks and index.php is not in the URL.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool Whether permalink links are enabled and index.php is NOT in the URL.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function using_mod_rewrite_permalinks() {&nbsp;</div></li><li><div>      return $this-&gt;using_permalinks() && ! $this-&gt;using_index_permalinks();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Indexes for matches for usage in preg_*() functions.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The format of the string is, with empty matches property value, '$NUM'.</span>&nbsp;</div></li><li><div><span class="comment">   * The 'NUM' will be replaced with the value in the $number parameter. With</span>&nbsp;</div></li><li><div><span class="comment">   * the matches property not empty, the value of the returned string will</span>&nbsp;</div></li><li><div><span class="comment">   * contain that value of the matches property. The format then will be</span>&nbsp;</div></li><li><div><span class="comment">   * '$MATCHES[NUM]', with MATCHES as the value in the property and NUM the</span>&nbsp;</div></li><li><div><span class="comment">   * value of the $number parameter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $number Index number.</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function preg_index($number) {&nbsp;</div></li><li><div>      $match_prefix = '$';&nbsp;</div></li><li><div>      $match_suffix = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty($this-&gt;matches) ) {&nbsp;</div></li><li><div>          $match_prefix = '$' . $this-&gt;matches . '[';&nbsp;</div></li><li><div>          $match_suffix = ']';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return &quot;$match_prefix$number$match_suffix&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves all page and attachments for pages URIs.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The attachments are for those that have pages as parents and will be</span>&nbsp;</div></li><li><div><span class="comment">   * retrieved.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Array of page URIs as first element and attachment URIs as second element.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function page_uri_index() {&nbsp;</div></li><li><div>      global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Get pages in order of hierarchy, i.e. children after parents.</span>&nbsp;</div></li><li><div>      $pages = $wpdb-&gt;get_results(&quot;SELECT ID, post_name, post_parent FROM $wpdb-&gt;posts WHERE post_type = 'page' AND post_status != 'auto-draft'&quot;);&nbsp;</div></li><li><div>      $posts = get_page_hierarchy( $pages );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If we have no pages get out quick.</span>&nbsp;</div></li><li><div>      if ( !$posts )&nbsp;</div></li><li><div>          return array( array(), array() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Now reverse it, because we need parents after children for rewrite rules to work properly.</span>&nbsp;</div></li><li><div>      $posts = array_reverse($posts, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $page_uris = array();&nbsp;</div></li><li><div>      $page_attachment_uris = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $posts as $id =&gt; $post ) {&nbsp;</div></li><li><div>          <span class="comment">// URL =&gt; page name</span>&nbsp;</div></li><li><div>          $uri = get_page_uri($id);&nbsp;</div></li><li><div>          $attachments = $wpdb-&gt;get_results( $wpdb-&gt;prepare( &quot;SELECT ID, post_name, post_parent FROM $wpdb-&gt;posts WHERE post_type = 'attachment' AND post_parent = %d&quot;, $id ));&nbsp;</div></li><li><div>          if ( !empty($attachments) ) {&nbsp;</div></li><li><div>              foreach ( $attachments as $attachment ) {&nbsp;</div></li><li><div>                  $attach_uri = get_page_uri($attachment-&gt;ID);&nbsp;</div></li><li><div>                  $page_attachment_uris[$attach_uri] = $attachment-&gt;ID;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $page_uris[$uri] = $id;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array( $page_uris, $page_attachment_uris );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves all of the rewrite rules for pages.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Page rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function page_rewrite_rules() {&nbsp;</div></li><li><div>      <span class="comment">// The extra .? at the beginning prevents clashes with other regular expressions in the rules array.</span>&nbsp;</div></li><li><div>      $this-&gt;add_rewrite_tag( '%pagename%', '(.?.+?)', 'pagename=' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;generate_rewrite_rules( $this-&gt;get_page_permastruct(), EP_PAGES, true, true, false, false );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves date permalink structure, with year, month, and day.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The permalink structure for the date, if not set already depends on the</span>&nbsp;</div></li><li><div><span class="comment">   * permalink structure. It can be one of three formats. The first is year, </span>&nbsp;</div></li><li><div><span class="comment">   * month, day; the second is day, month, year; and the last format is month, </span>&nbsp;</div></li><li><div><span class="comment">   * day, year. These are matched against the permalink structure for which</span>&nbsp;</div></li><li><div><span class="comment">   * one is used. If none matches, then the default will be used, which is</span>&nbsp;</div></li><li><div><span class="comment">   * year, month, day.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Prevents post ID and date permalinks from overlapping. In the case of</span>&nbsp;</div></li><li><div><span class="comment">   * post_id, the date permalink will be prepended with front permalink with</span>&nbsp;</div></li><li><div><span class="comment">   * 'date/' before the actual permalink to form the complete date permalink</span>&nbsp;</div></li><li><div><span class="comment">   * structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False on no permalink structure. Date permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_date_permastruct() {&nbsp;</div></li><li><div>      if ( isset($this-&gt;date_structure) )&nbsp;</div></li><li><div>          return $this-&gt;date_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>          $this-&gt;date_structure = '';&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// The date permalink must have year, month, and day separated by slashes.</span>&nbsp;</div></li><li><div>      $endians = array('%year%/%monthnum%/%day%', '%day%/%monthnum%/%year%', '%monthnum%/%day%/%year%');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;date_structure = '';&nbsp;</div></li><li><div>      $date_endian = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $endians as $endian ) {&nbsp;</div></li><li><div>          if ( false !== strpos($this-&gt;permalink_structure, $endian) ) {&nbsp;</div></li><li><div>              $date_endian= $endian;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($date_endian) )&nbsp;</div></li><li><div>          $date_endian = '%year%/%monthnum%/%day%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Do not allow the date tags and %post_id% to overlap in the permalink</span>&nbsp;</div></li><li><div><span class="comment">       * structure. If they do, move the date tags to $front/date/.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $front = $this-&gt;front;&nbsp;</div></li><li><div>      preg_match_all('/%.+?%/', $this-&gt;permalink_structure, $tokens);&nbsp;</div></li><li><div>      $tok_index = 1;&nbsp;</div></li><li><div>      foreach ( (array) $tokens[0] as $token) {&nbsp;</div></li><li><div>          if ( '%post_id%' == $token && ($tok_index &lt;= 3) ) {&nbsp;</div></li><li><div>              $front = $front . 'date/';&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $tok_index++;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;date_structure = $front . $date_endian;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;date_structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the year permalink structure without month and day.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Gets the date permalink structure and strips out the month and day</span>&nbsp;</div></li><li><div><span class="comment">   * permalink structures.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return false|string False on failure. Year structure on success.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_year_permastruct() {&nbsp;</div></li><li><div>      $structure = $this-&gt;get_date_permastruct();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($structure) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $structure = str_replace('%monthnum%', '', $structure);&nbsp;</div></li><li><div>      $structure = str_replace('%day%', '', $structure);&nbsp;</div></li><li><div>      $structure = preg_replace('#/+#', '/', $structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the month permalink structure without day and with year.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Gets the date permalink structure and strips out the day permalink</span>&nbsp;</div></li><li><div><span class="comment">   * structures. Keeps the year permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return false|string False on failure. Year/Month structure on success.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_month_permastruct() {&nbsp;</div></li><li><div>      $structure = $this-&gt;get_date_permastruct();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($structure) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $structure = str_replace('%day%', '', $structure);&nbsp;</div></li><li><div>      $structure = preg_replace('#/+#', '/', $structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the day permalink structure with month and year.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Keeps date permalink structure with all year, month, and day.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False on failure. Year/Month/Day structure on success.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_day_permastruct() {&nbsp;</div></li><li><div>      return $this-&gt;get_date_permastruct();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the permalink structure for categories.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If the category_base property has no value, then the category structure</span>&nbsp;</div></li><li><div><span class="comment">   * will have the front property value, followed by 'category', and finally</span>&nbsp;</div></li><li><div><span class="comment">   * '%category%'. If it does, then the root property will be used, along with</span>&nbsp;</div></li><li><div><span class="comment">   * the category_base property value.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False on failure. Category permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_category_permastruct() {&nbsp;</div></li><li><div>      return $this-&gt;get_extra_permastruct('category');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieve the permalink structure for tags.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If the tag_base property has no value, then the tag structure will have</span>&nbsp;</div></li><li><div><span class="comment">   * the front property value, followed by 'tag', and finally '%tag%'. If it</span>&nbsp;</div></li><li><div><span class="comment">   * does, then the root property will be used, along with the tag_base</span>&nbsp;</div></li><li><div><span class="comment">   * property value.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False on failure. Tag permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_tag_permastruct() {&nbsp;</div></li><li><div>      return $this-&gt;get_extra_permastruct('post_tag');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves an extra permalink structure by name.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $name Permalink structure name.</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False if not found. Permalink structure string.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_extra_permastruct($name) {&nbsp;</div></li><li><div>      if ( empty($this-&gt;permalink_structure) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset($this-&gt;extra_permastructs[$name]) )&nbsp;</div></li><li><div>          return $this-&gt;extra_permastructs[$name]['struct'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the author permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The permalink structure is front property, author base, and finally</span>&nbsp;</div></li><li><div><span class="comment">   * '/%author%'. Will set the author_structure property and then return it</span>&nbsp;</div></li><li><div><span class="comment">   * without attempting to set the value again.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False if not found. Permalink structure string.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_author_permastruct() {&nbsp;</div></li><li><div>      if ( isset($this-&gt;author_structure) )&nbsp;</div></li><li><div>          return $this-&gt;author_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>          $this-&gt;author_structure = '';&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;author_structure = $this-&gt;front . $this-&gt;author_base . '/%author%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;author_structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the search permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The permalink structure is root property, search base, and finally</span>&nbsp;</div></li><li><div><span class="comment">   * '/%search%'. Will set the search_structure property and then return it</span>&nbsp;</div></li><li><div><span class="comment">   * without attempting to set the value again.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False if not found. Permalink structure string.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_search_permastruct() {&nbsp;</div></li><li><div>      if ( isset($this-&gt;search_structure) )&nbsp;</div></li><li><div>          return $this-&gt;search_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>          $this-&gt;search_structure = '';&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;search_structure = $this-&gt;root . $this-&gt;search_base . '/%search%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;search_structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the page permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The permalink structure is root property, and '%pagename%'. Will set the</span>&nbsp;</div></li><li><div><span class="comment">   * page_structure property and then return it without attempting to set the</span>&nbsp;</div></li><li><div><span class="comment">   * value again.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False if not found. Permalink structure string.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_page_permastruct() {&nbsp;</div></li><li><div>      if ( isset($this-&gt;page_structure) )&nbsp;</div></li><li><div>          return $this-&gt;page_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (empty($this-&gt;permalink_structure)) {&nbsp;</div></li><li><div>          $this-&gt;page_structure = '';&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;page_structure = $this-&gt;root . '%pagename%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;page_structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the feed permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The permalink structure is root property, feed base, and finally</span>&nbsp;</div></li><li><div><span class="comment">   * '/%feed%'. Will set the feed_structure property and then return it</span>&nbsp;</div></li><li><div><span class="comment">   * without attempting to set the value again.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False if not found. Permalink structure string.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_feed_permastruct() {&nbsp;</div></li><li><div>      if ( isset($this-&gt;feed_structure) )&nbsp;</div></li><li><div>          return $this-&gt;feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($this-&gt;permalink_structure) ) {&nbsp;</div></li><li><div>          $this-&gt;feed_structure = '';&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;feed_structure = $this-&gt;root . $this-&gt;feed_base . '/%feed%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;feed_structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the comment feed permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The permalink structure is root property, comment base property, feed</span>&nbsp;</div></li><li><div><span class="comment">   * base and finally '/%feed%'. Will set the comment_feed_structure property</span>&nbsp;</div></li><li><div><span class="comment">   * and then return it without attempting to set the value again.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|false False if not found. Permalink structure string.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function get_comment_feed_permastruct() {&nbsp;</div></li><li><div>      if ( isset($this-&gt;comment_feed_structure) )&nbsp;</div></li><li><div>          return $this-&gt;comment_feed_structure;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (empty($this-&gt;permalink_structure)) {&nbsp;</div></li><li><div>          $this-&gt;comment_feed_structure = '';&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;comment_feed_structure = $this-&gt;root . $this-&gt;comments_base . '/' . $this-&gt;feed_base . '/%feed%';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;comment_feed_structure;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Adds or updates existing rewrite tags (e.g. %postname%).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If the tag already exists, replace the existing pattern and query for</span>&nbsp;</div></li><li><div><span class="comment">   * that tag, otherwise add the new tag.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::$rewritecode</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::$rewritereplace</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::$queryreplace</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $tag   Name of the rewrite tag to add or update.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $regex Regular expression to substitute the tag for in rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $query String to append to the rewritten query. Must end in '='.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function add_rewrite_tag( $tag, $regex, $query ) {&nbsp;</div></li><li><div>      $position = array_search( $tag, $this-&gt;rewritecode );&nbsp;</div></li><li><div>      if ( false !== $position && null !== $position ) {&nbsp;</div></li><li><div>          $this-&gt;rewritereplace[ $position ] = $regex;&nbsp;</div></li><li><div>          $this-&gt;queryreplace[ $position ] = $query;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $this-&gt;rewritecode[] = $tag;&nbsp;</div></li><li><div>          $this-&gt;rewritereplace[] = $regex;&nbsp;</div></li><li><div>          $this-&gt;queryreplace[] = $query;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Removes an existing rewrite tag.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::$rewritecode</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::$rewritereplace</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::$queryreplace</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $tag Name of the rewrite tag to remove.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function remove_rewrite_tag( $tag ) {&nbsp;</div></li><li><div>      $position = array_search( $tag, $this-&gt;rewritecode );&nbsp;</div></li><li><div>      if ( false !== $position && null !== $position ) {&nbsp;</div></li><li><div>          unset( $this-&gt;rewritecode[ $position ] );&nbsp;</div></li><li><div>          unset( $this-&gt;rewritereplace[ $position ] );&nbsp;</div></li><li><div>          unset( $this-&gt;queryreplace[ $position ] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Generates rewrite rules from a permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The main WP_Rewrite function for building the rewrite rule list. The</span>&nbsp;</div></li><li><div><span class="comment">   * contents of the function is a mix of black magic and regular expressions, </span>&nbsp;</div></li><li><div><span class="comment">   * so best just ignore the contents and move to the parameters.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $permalink_structure The permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $ep_mask             Optional. Endpoint mask defining what endpoints are added to the structure.</span>&nbsp;</div></li><li><div><span class="comment">   *                                    Accepts `EP_NONE`, `EP_PERMALINK`, `EP_ATTACHMENT`, `EP_DATE`, `EP_YEAR`, </span>&nbsp;</div></li><li><div><span class="comment">   *                                    `EP_MONTH`, `EP_DAY`, `EP_ROOT`, `EP_COMMENTS`, `EP_SEARCH`, `EP_CATEGORIES`, </span>&nbsp;</div></li><li><div><span class="comment">   *                                    `EP_TAGS`, `EP_AUTHORS`, `EP_PAGES`, `EP_ALL_ARCHIVES`, and `EP_ALL`.</span>&nbsp;</div></li><li><div><span class="comment">   *                                    Default `EP_NONE`.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $paged               Optional. Whether archive pagination rules should be added for the structure.</span>&nbsp;</div></li><li><div><span class="comment">   *                                    Default true.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $feed                Optional Whether feed rewrite rules should be added for the structure.</span>&nbsp;</div></li><li><div><span class="comment">   *                                    Default true.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $forcomments         Optional. Whether the feed rules should be a query for a comments feed.</span>&nbsp;</div></li><li><div><span class="comment">   *                                    Default false.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $walk_dirs           Optional. Whether the 'directories' making up the structure should be walked</span>&nbsp;</div></li><li><div><span class="comment">   *                                    over and rewrite rules built for each in-turn. Default true.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $endpoints           Optional. Whether endpoints should be applied to the generated rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">   *                                    Default true.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Rewrite rule list.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function generate_rewrite_rules($permalink_structure, $ep_mask = EP_NONE, $paged = true, $feed = true, $forcomments = false, $walk_dirs = true, $endpoints = true) {&nbsp;</div></li><li><div>      <span class="comment">// Build a regex to match the feed section of URLs, something like (feed|atom|rss|rss2)/?</span>&nbsp;</div></li><li><div>      $feedregex2 = '';&nbsp;</div></li><li><div>      foreach ( (array) $this-&gt;feeds as $feed_name)&nbsp;</div></li><li><div>          $feedregex2 .= $feed_name . '|';&nbsp;</div></li><li><div>      $feedregex2 = '(' . trim($feedregex2, '|') . ')/?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * $feedregex is identical but with /feed/ added on as well, so URLs like &lt;permalink&gt;/feed/atom</span>&nbsp;</div></li><li><div><span class="comment">       * and &lt;permalink&gt;/atom are both possible</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $feedregex = $this-&gt;feed_base . '/' . $feedregex2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Build a regex to match the trackback and page/xx parts of URLs.</span>&nbsp;</div></li><li><div>      $trackbackregex = 'trackback/?$';&nbsp;</div></li><li><div>      $pageregex = $this-&gt;pagination_base . '/?([0-9]{1, })/?$';&nbsp;</div></li><li><div>      $commentregex = $this-&gt;comments_pagination_base . '-([0-9]{1, })/?$';&nbsp;</div></li><li><div>      $embedregex = 'embed/?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Build up an array of endpoint regexes to append =&gt; queries to append.</span>&nbsp;</div></li><li><div>      if ( $endpoints ) {&nbsp;</div></li><li><div>          $ep_query_append = array ();&nbsp;</div></li><li><div>          foreach ( (array) $this-&gt;endpoints as $endpoint) {&nbsp;</div></li><li><div>              <span class="comment">// Match everything after the endpoint name, but allow for nothing to appear there.</span>&nbsp;</div></li><li><div>              $epmatch = $endpoint[1] . '(/(.*))?/?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// This will be appended on to the rest of the query for each dir.</span>&nbsp;</div></li><li><div>              $epquery = '&' . $endpoint[2] . '=';&nbsp;</div></li><li><div>              $ep_query_append[$epmatch] = array ( $endpoint[0], $epquery );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Get everything up to the first rewrite tag.</span>&nbsp;</div></li><li><div>      $front = substr($permalink_structure, 0, strpos($permalink_structure, '%'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Build an array of the tags (note that said array ends up being in $tokens[0]).</span>&nbsp;</div></li><li><div>      preg_match_all('/%.+?%/', $permalink_structure, $tokens);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $num_tokens = count($tokens[0]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $index = $this-&gt;index; <span class="comment">//probably 'index.php'</span>&nbsp;</div></li><li><div>      $feedindex = $index;&nbsp;</div></li><li><div>      $trackbackindex = $index;&nbsp;</div></li><li><div>      $embedindex = $index;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Build a list from the rewritecode and queryreplace arrays, that will look something</span>&nbsp;</div></li><li><div><span class="comment">       * like tagname=$matches[i] where i is the current $i.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $queries = array();&nbsp;</div></li><li><div>      for ( $i = 0; $i &lt; $num_tokens; ++$i ) {&nbsp;</div></li><li><div>          if ( 0 &lt; $i )&nbsp;</div></li><li><div>              $queries[$i] = $queries[$i - 1] . '&';&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $queries[$i] = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $query_token = str_replace($this-&gt;rewritecode, $this-&gt;queryreplace, $tokens[0][$i]) . $this-&gt;preg_index($i+1);&nbsp;</div></li><li><div>          $queries[$i] .= $query_token;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Get the structure, minus any cruft (stuff that isn't tags) at the front.</span>&nbsp;</div></li><li><div>      $structure = $permalink_structure;&nbsp;</div></li><li><div>      if ( $front != '/' )&nbsp;</div></li><li><div>          $structure = str_replace($front, '', $structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Create a list of dirs to walk over, making rewrite rules for each level</span>&nbsp;</div></li><li><div><span class="comment">       * so for example, a $structure of /%year%/%monthnum%/%postname% would create</span>&nbsp;</div></li><li><div><span class="comment">       * rewrite rules for /%year%/, /%year%/%monthnum%/ and /%year%/%monthnum%/%postname%</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $structure = trim($structure, '/');&nbsp;</div></li><li><div>      $dirs = $walk_dirs ? explode('/', $structure) : array( $structure );&nbsp;</div></li><li><div>      $num_dirs = count($dirs);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Strip slashes from the front of $front.</span>&nbsp;</div></li><li><div>      $front = preg_replace('|^/+|', '', $front);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// The main workhorse loop.</span>&nbsp;</div></li><li><div>      $post_rewrite = array();&nbsp;</div></li><li><div>      $struct = $front;&nbsp;</div></li><li><div>      for ( $j = 0; $j &lt; $num_dirs; ++$j ) {&nbsp;</div></li><li><div>          <span class="comment">// Get the struct for this dir, and trim slashes off the front.</span>&nbsp;</div></li><li><div>          $struct .= $dirs[$j] . '/'; <span class="comment">// Accumulate. see comment near explode('/', $structure) above.</span>&nbsp;</div></li><li><div>          $struct = ltrim($struct, '/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Replace tags with regexes.</span>&nbsp;</div></li><li><div>          $match = str_replace($this-&gt;rewritecode, $this-&gt;rewritereplace, $struct);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Make a list of tags, and store how many there are in $num_toks.</span>&nbsp;</div></li><li><div>          $num_toks = preg_match_all('/%.+?%/', $struct, $toks);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Get the 'tagname=$matches[i]'.</span>&nbsp;</div></li><li><div>          $query = ( ! empty( $num_toks ) && isset( $queries[$num_toks - 1] ) ) ? $queries[$num_toks - 1] : '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Set up $ep_mask_specific which is used to match more specific URL types.</span>&nbsp;</div></li><li><div>          switch ( $dirs[$j] ) {&nbsp;</div></li><li><div>              case '%year%':&nbsp;</div></li><li><div>                  $ep_mask_specific = EP_YEAR;&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              case '%monthnum%':&nbsp;</div></li><li><div>                  $ep_mask_specific = EP_MONTH;&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              case '%day%':&nbsp;</div></li><li><div>                  $ep_mask_specific = EP_DAY;&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              default:&nbsp;</div></li><li><div>                  $ep_mask_specific = EP_NONE;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Create query for /page/xx.</span>&nbsp;</div></li><li><div>          $pagematch = $match . $pageregex;&nbsp;</div></li><li><div>          $pagequery = $index . '?' . $query . '&paged=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Create query for /comment-page-xx.</span>&nbsp;</div></li><li><div>          $commentmatch = $match . $commentregex;&nbsp;</div></li><li><div>          $commentquery = $index . '?' . $query . '&cpage=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( get_option('page_on_front') ) {&nbsp;</div></li><li><div>              <span class="comment">// Create query for Root /comment-page-xx.</span>&nbsp;</div></li><li><div>              $rootcommentmatch = $match . $commentregex;&nbsp;</div></li><li><div>              $rootcommentquery = $index . '?' . $query . '&page_id=' . get_option('page_on_front') . '&cpage=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Create query for /feed/(feed|atom|rss|rss2|rdf).</span>&nbsp;</div></li><li><div>          $feedmatch = $match . $feedregex;&nbsp;</div></li><li><div>          $feedquery = $feedindex . '?' . $query . '&feed=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Create query for /(feed|atom|rss|rss2|rdf) (see comment near creation of $feedregex).</span>&nbsp;</div></li><li><div>          $feedmatch2 = $match . $feedregex2;&nbsp;</div></li><li><div>          $feedquery2 = $feedindex . '?' . $query . '&feed=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// Create query and regex for embeds.</span></span>&nbsp;</div></li><li><div>          $embedmatch = $match . $embedregex;&nbsp;</div></li><li><div>          $embedquery = $embedindex . '?' . $query . '&embed=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If asked to, turn the feed queries into comment feed ones.</span>&nbsp;</div></li><li><div>          if ( $forcomments ) {&nbsp;</div></li><li><div>              $feedquery .= '&withcomments=1';&nbsp;</div></li><li><div>              $feedquery2 .= '&withcomments=1';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Start creating the array of rewrites for this dir.</span>&nbsp;</div></li><li><div>          $rewrite = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// ...adding on /feed/ regexes =&gt; queries</span>&nbsp;</div></li><li><div>          if ( $feed ) {&nbsp;</div></li><li><div>              $rewrite = array( $feedmatch =&gt; $feedquery, $feedmatch2 =&gt; $feedquery2, $embedmatch =&gt; $embedquery );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">//...and /page/xx ones</span>&nbsp;</div></li><li><div>          if ( $paged ) {&nbsp;</div></li><li><div>              $rewrite = array_merge( $rewrite, array( $pagematch =&gt; $pagequery ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Only on pages with comments add ../comment-page-xx/.</span>&nbsp;</div></li><li><div>          if ( EP_PAGES & $ep_mask || EP_PERMALINK & $ep_mask ) {&nbsp;</div></li><li><div>              $rewrite = array_merge($rewrite, array($commentmatch =&gt; $commentquery));&nbsp;</div></li><li><div>          } elseif ( EP_ROOT & $ep_mask && get_option('page_on_front') ) {&nbsp;</div></li><li><div>              $rewrite = array_merge($rewrite, array($rootcommentmatch =&gt; $rootcommentquery));&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Do endpoints.</span>&nbsp;</div></li><li><div>          if ( $endpoints ) {&nbsp;</div></li><li><div>              foreach ( (array) $ep_query_append as $regex =&gt; $ep) {&nbsp;</div></li><li><div>                  <span class="comment">// Add the endpoints on if the mask fits.</span>&nbsp;</div></li><li><div>                  if ( $ep[0] & $ep_mask || $ep[0] & $ep_mask_specific )&nbsp;</div></li><li><div>                      $rewrite[$match . $regex] = $index . '?' . $query . $ep[1] . $this-&gt;preg_index($num_toks + 2);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If we've got some tags in this dir.</span>&nbsp;</div></li><li><div>          if ( $num_toks ) {&nbsp;</div></li><li><div>              $post = false;&nbsp;</div></li><li><div>              $page = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">               * Check to see if this dir is permalink-level: i.e. the structure specifies an</span>&nbsp;</div></li><li><div><span class="comment">               * individual post. Do this by checking it contains at least one of 1) post name, </span>&nbsp;</div></li><li><div><span class="comment">               * 2) post ID, 3) page name, 4) timestamp (year, month, day, hour, second and</span>&nbsp;</div></li><li><div><span class="comment">               * minute all present). Set these flags now as we need them for the endpoints.</span>&nbsp;</div></li><li><div><span class="comment">               */</span>&nbsp;</div></li><li><div>              if ( strpos($struct, '%postname%') !== false&nbsp;</div></li><li><div>                      || strpos($struct, '%post_id%') !== false&nbsp;</div></li><li><div>                      || strpos($struct, '%pagename%') !== false&nbsp;</div></li><li><div>                      || (strpos($struct, '%year%') !== false && strpos($struct, '%monthnum%') !== false && strpos($struct, '%day%') !== false && strpos($struct, '%hour%') !== false && strpos($struct, '%minute%') !== false && strpos($struct, '%second%') !== false)&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                  $post = true;&nbsp;</div></li><li><div>                  if ( strpos($struct, '%pagename%') !== false )&nbsp;</div></li><li><div>                      $page = true;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( ! $post ) {&nbsp;</div></li><li><div>                  <span class="comment">// For custom post types, we need to add on endpoints as well.</span>&nbsp;</div></li><li><div>                  foreach ( get_post_types( array('_builtin' =&gt; false ) ) as $ptype ) {&nbsp;</div></li><li><div>                      if ( strpos($struct, &quot;%$ptype%&quot;) !== false ) {&nbsp;</div></li><li><div>                          $post = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          <span class="comment">// This is for page style attachment URLs.</span>&nbsp;</div></li><li><div>                          $page = is_post_type_hierarchical( $ptype );&nbsp;</div></li><li><div>                          break;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// If creating rules for a permalink, do all the endpoints like attachments etc.</span>&nbsp;</div></li><li><div>              if ( $post ) {&nbsp;</div></li><li><div>                  <span class="comment">// Create query and regex for trackback.</span>&nbsp;</div></li><li><div>                  $trackbackmatch = $match . $trackbackregex;&nbsp;</div></li><li><div>                  $trackbackquery = $trackbackindex . '?' . $query . '&tb=1';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Create query and regex for embeds.</span></span>&nbsp;</div></li><li><div>                  $embedmatch = $match . $embedregex;&nbsp;</div></li><li><div>                  $embedquery = $embedindex . '?' . $query . '&embed=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Trim slashes from the end of the regex for this dir.</span>&nbsp;</div></li><li><div>                  $match = rtrim($match, '/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Get rid of brackets.</span>&nbsp;</div></li><li><div>                  $submatchbase = str_replace( array('(', ')'), '', $match);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Add a rule for at attachments, which take the form of &lt;permalink&gt;/some-text.</span>&nbsp;</div></li><li><div>                  $sub1 = $submatchbase . '/([^/]+)/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Add trackback regex &lt;permalink&gt;/trackback/...</span>&nbsp;</div></li><li><div>                  $sub1tb = $sub1 . $trackbackregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// And &lt;permalink&gt;/feed/(atom|...)</span>&nbsp;</div></li><li><div>                  $sub1feed = $sub1 . $feedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// And &lt;permalink&gt;/(feed|atom...)</span>&nbsp;</div></li><li><div>                  $sub1feed2 = $sub1 . $feedregex2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// And &lt;permalink&gt;/comment-page-xx</span></span>&nbsp;</div></li><li><div>                  $sub1comment = $sub1 . $commentregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// And &lt;permalink&gt;/embed/...</span></span>&nbsp;</div></li><li><div>                  $sub1embed = $sub1 . $embedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">                   * Add another rule to match attachments in the explicit form:</span>&nbsp;</div></li><li><div><span class="comment">                   * &lt;permalink&gt;/attachment/some-text</span>&nbsp;</div></li><li><div><span class="comment">                   */</span>&nbsp;</div></li><li><div>                  $sub2 = $submatchbase . '/attachment/([^/]+)/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// And add trackbacks &lt;permalink&gt;/attachment/trackback.</span>&nbsp;</div></li><li><div>                  $sub2tb = $sub2 . $trackbackregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Feeds, &lt;permalink&gt;/attachment/feed/(atom|...)</span>&nbsp;</div></li><li><div>                  $sub2feed = $sub2 . $feedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// And feeds again on to this &lt;permalink&gt;/attachment/(feed|atom...)</span>&nbsp;</div></li><li><div>                  $sub2feed2 = $sub2 . $feedregex2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// And &lt;permalink&gt;/comment-page-xx</span></span>&nbsp;</div></li><li><div>                  $sub2comment = $sub2 . $commentregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// And &lt;permalink&gt;/embed/...</span></span>&nbsp;</div></li><li><div>                  $sub2embed = $sub2 . $embedregex;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Create queries for these extra tag-ons we've just dealt with.</span>&nbsp;</div></li><li><div>                  $subquery = $index . '?attachment=' . $this-&gt;preg_index(1);&nbsp;</div></li><li><div>                  $subtbquery = $subquery . '&tb=1';&nbsp;</div></li><li><div>                  $subfeedquery = $subquery . '&feed=' . $this-&gt;preg_index(2);&nbsp;</div></li><li><div>                  $subcommentquery = $subquery . '&cpage=' . $this-&gt;preg_index(2);&nbsp;</div></li><li><div>                  $subembedquery = $subquery . '&embed=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Do endpoints for attachments.</span>&nbsp;</div></li><li><div>                  if ( !empty($endpoints) ) {&nbsp;</div></li><li><div>                      foreach ( (array) $ep_query_append as $regex =&gt; $ep ) {&nbsp;</div></li><li><div>                          if ( $ep[0] & EP_ATTACHMENT ) {&nbsp;</div></li><li><div>                              $rewrite[$sub1 . $regex] = $subquery . $ep[1] . $this-&gt;preg_index(3);&nbsp;</div></li><li><div>                              $rewrite[$sub2 . $regex] = $subquery . $ep[1] . $this-&gt;preg_index(3);&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">                   * Now we've finished with endpoints, finish off the $sub1 and $sub2 matches</span>&nbsp;</div></li><li><div><span class="comment">                   * add a ? as we don't have to match that last slash, and finally a $ so we</span>&nbsp;</div></li><li><div><span class="comment">                   * match to the end of the URL</span>&nbsp;</div></li><li><div><span class="comment">                   */</span>&nbsp;</div></li><li><div>                  $sub1 .= '?$';&nbsp;</div></li><li><div>                  $sub2 .= '?$';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">                   * Post pagination, e.g. &lt;permalink&gt;/2/</span>&nbsp;</div></li><li><div><span class="comment">                   * Previously: '(/[0-9]+)?/?$', which produced '/2' for page.</span>&nbsp;</div></li><li><div><span class="comment">                   * When cast to int, returned 0.</span>&nbsp;</div></li><li><div><span class="comment">                   */</span>&nbsp;</div></li><li><div>                  $match = $match . '(?:/([0-9]+))?/?$';&nbsp;</div></li><li><div>                  $query = $index . '?' . $query . '&page=' . $this-&gt;preg_index($num_toks + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// Not matching a permalink so this is a lot simpler.</span>&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  <span class="comment">// Close the match and finalise the query.</span>&nbsp;</div></li><li><div>                  $match .= '?$';&nbsp;</div></li><li><div>                  $query = $index . '?' . $query;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">               * Create the final array for this dir by joining the $rewrite array (which currently</span>&nbsp;</div></li><li><div><span class="comment">               * only contains rules/queries for trackback, pages etc) to the main regex/query for</span>&nbsp;</div></li><li><div><span class="comment">               * this dir</span>&nbsp;</div></li><li><div><span class="comment">               */</span>&nbsp;</div></li><li><div>              $rewrite = array_merge($rewrite, array($match =&gt; $query));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// If we're matching a permalink, add those extras (attachments etc) on.</span>&nbsp;</div></li><li><div>              if ( $post ) {&nbsp;</div></li><li><div>                  <span class="comment">// Add trackback.</span>&nbsp;</div></li><li><div>                  $rewrite = array_merge(array($trackbackmatch =&gt; $trackbackquery), $rewrite);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Add embed.</span>&nbsp;</div></li><li><div>                  $rewrite = array_merge( array( $embedmatch =&gt; $embedquery ), $rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Add regexes/queries for attachments, attachment trackbacks and so on.</span>&nbsp;</div></li><li><div>                  if ( ! $page ) {&nbsp;</div></li><li><div>                      <span class="comment">// Require &lt;permalink&gt;/attachment/stuff form for pages because of confusion with subpages.</span>&nbsp;</div></li><li><div>                      $rewrite = array_merge( $rewrite, array(&nbsp;</div></li><li><div>                          $sub1 =&gt; $subquery, &nbsp;</div></li><li><div>                          $sub1tb =&gt; $subtbquery, &nbsp;</div></li><li><div>                          $sub1feed =&gt; $subfeedquery, &nbsp;</div></li><li><div>                          $sub1feed2 =&gt; $subfeedquery, &nbsp;</div></li><li><div>                          $sub1comment =&gt; $subcommentquery, &nbsp;</div></li><li><div>                          $sub1embed =&gt; $subembedquery&nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  $rewrite = array_merge( array( $sub2 =&gt; $subquery, $sub2tb =&gt; $subtbquery, $sub2feed =&gt; $subfeedquery, $sub2feed2 =&gt; $subfeedquery, $sub2comment =&gt; $subcommentquery, $sub2embed =&gt; $subembedquery ), $rewrite );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          <span class="comment">// Add the rules for this dir to the accumulating $post_rewrite.</span>&nbsp;</div></li><li><div>          $post_rewrite = array_merge($rewrite, $post_rewrite);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// The finished rules. phew!</span>&nbsp;</div></li><li><div>      return $post_rewrite;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Generates rewrite rules with permalink structure and walking directory only.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Shorten version of WP_Rewrite::generate_rewrite_rules() that allows for shorter</span>&nbsp;</div></li><li><div><span class="comment">   * list of parameters. See the method for longer description of what generating</span>&nbsp;</div></li><li><div><span class="comment">   * rewrite rules does.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see WP_Rewrite::generate_rewrite_rules() See for long description and rest of parameters.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $permalink_structure The permalink structure to generate rules.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $walk_dirs           Optional, default is false. Whether to create list of directories to walk over.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function generate_rewrite_rule($permalink_structure, $walk_dirs = false) {&nbsp;</div></li><li><div>      return $this-&gt;generate_rewrite_rules($permalink_structure, EP_NONE, false, false, false, $walk_dirs);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Constructs rewrite matches and queries from permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Runs the action {@see 'generate_rewrite_rules'} with the parameter that is an</span>&nbsp;</div></li><li><div><span class="comment">   * reference to the current WP_Rewrite instance to further manipulate the</span>&nbsp;</div></li><li><div><span class="comment">   * permalink structures and rewrite rules. Runs the {@see 'rewrite_rules_array'}</span>&nbsp;</div></li><li><div><span class="comment">   * filter on the full rewrite rule array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * There are two ways to manipulate the rewrite rules, one by hooking into</span>&nbsp;</div></li><li><div><span class="comment">   * the {@see 'generate_rewrite_rules'} action and gaining full control of the</span>&nbsp;</div></li><li><div><span class="comment">   * object or just manipulating the rewrite rule array before it is passed</span>&nbsp;</div></li><li><div><span class="comment">   * from the function.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return array An associate array of matches and queries.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function rewrite_rules() {&nbsp;</div></li><li><div>      $rewrite = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($this-&gt;permalink_structure) )&nbsp;</div></li><li><div>          return $rewrite;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// robots.txt -only if installed at the root</span>&nbsp;</div></li><li><div>      $home_path = parse_url( home_url() );&nbsp;</div></li><li><div>      $robots_rewrite = ( empty( $home_path['path'] ) || '/' == $home_path['path'] ) ? array( 'robots\.txt$' =&gt; $this-&gt;index . '?robots=1' ) : array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Old feed and service files.</span>&nbsp;</div></li><li><div>      $deprecated_files = array(&nbsp;</div></li><li><div>          '.*wp-(atom|rdf|rss|rss2|feed|commentsrss2)\.php$' =&gt; $this-&gt;index . '?feed=old', &nbsp;</div></li><li><div>          '.*wp-app\.php(/.*)?$' =&gt; $this-&gt;index . '?error=403', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Registration rules.</span>&nbsp;</div></li><li><div>      $registration_pages = array();&nbsp;</div></li><li><div>      if ( is_multisite() && is_main_site() ) {&nbsp;</div></li><li><div>          $registration_pages['.*wp-signup.php$'] = $this-&gt;index . '?signup=true';&nbsp;</div></li><li><div>          $registration_pages['.*wp-activate.php$'] = $this-&gt;index . '?activate=true';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Deprecated.</span>&nbsp;</div></li><li><div>      $registration_pages['.*wp-register.php$'] = $this-&gt;index . '?register=true';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Post rewrite rules.</span>&nbsp;</div></li><li><div>      $post_rewrite = $this-&gt;generate_rewrite_rules( $this-&gt;permalink_structure, EP_PERMALINK );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters rewrite rules used for &quot;post&quot; archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $post_rewrite The rewrite rules for posts.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $post_rewrite = apply_filters( 'post_rewrite_rules', $post_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Date rewrite rules.</span>&nbsp;</div></li><li><div>      $date_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;get_date_permastruct(), EP_DATE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters rewrite rules used for date archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * Likely date archives would include /yyyy/, /yyyy/mm/, and /yyyy/mm/dd/.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $date_rewrite The rewrite rules for date archives.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $date_rewrite = apply_filters( 'date_rewrite_rules', $date_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Root-level rewrite rules.</span>&nbsp;</div></li><li><div>      $root_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;root . '/', EP_ROOT);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters rewrite rules used for root-level archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * Likely root-level archives would include pagination rules for the homepage</span>&nbsp;</div></li><li><div><span class="comment">       * as well as site-wide post feeds (e.g. /feed/, and /feed/atom/).</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $root_rewrite The root-level rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $root_rewrite = apply_filters( 'root_rewrite_rules', $root_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Comments rewrite rules.</span>&nbsp;</div></li><li><div>      $comments_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;root . $this-&gt;comments_base, EP_COMMENTS, false, true, true, false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters rewrite rules used for comment feed archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * Likely comments feed archives include /comments/feed/, and /comments/feed/atom/.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $comments_rewrite The rewrite rules for the site-wide comments feeds.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $comments_rewrite = apply_filters( 'comments_rewrite_rules', $comments_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Search rewrite rules.</span>&nbsp;</div></li><li><div>      $search_structure = $this-&gt;get_search_permastruct();&nbsp;</div></li><li><div>      $search_rewrite = $this-&gt;generate_rewrite_rules($search_structure, EP_SEARCH);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters rewrite rules used for search archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * Likely search-related archives include /search/search+query/ as well as</span>&nbsp;</div></li><li><div><span class="comment">       * pagination and feed paths for a search.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $search_rewrite The rewrite rules for search queries.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $search_rewrite = apply_filters( 'search_rewrite_rules', $search_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Author rewrite rules.</span>&nbsp;</div></li><li><div>      $author_rewrite = $this-&gt;generate_rewrite_rules($this-&gt;get_author_permastruct(), EP_AUTHORS);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters rewrite rules used for author archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * Likely author archives would include /author/author-name/, as well as</span>&nbsp;</div></li><li><div><span class="comment">       * pagination and feed paths for author archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $author_rewrite The rewrite rules for author archives.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $author_rewrite = apply_filters( 'author_rewrite_rules', $author_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Pages rewrite rules.</span>&nbsp;</div></li><li><div>      $page_rewrite = $this-&gt;page_rewrite_rules();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters rewrite rules used for &quot;page&quot; post type archives.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $page_rewrite The rewrite rules for the &quot;page&quot; post type.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $page_rewrite = apply_filters( 'page_rewrite_rules', $page_rewrite );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Extra permastructs.</span>&nbsp;</div></li><li><div>      foreach ( $this-&gt;extra_permastructs as $permastructname =&gt; $struct ) {&nbsp;</div></li><li><div>          if ( is_array( $struct ) ) {&nbsp;</div></li><li><div>              if ( count( $struct ) == 2 )&nbsp;</div></li><li><div>                  $rules = $this-&gt;generate_rewrite_rules( $struct[0], $struct[1] );&nbsp;</div></li><li><div>              else&nbsp;</div></li><li><div>                  $rules = $this-&gt;generate_rewrite_rules( $struct['struct'], $struct['ep_mask'], $struct['paged'], $struct['feed'], $struct['forcomments'], $struct['walk_dirs'], $struct['endpoints'] );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $rules = $this-&gt;generate_rewrite_rules( $struct );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters rewrite rules used for individual permastructs.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$permastructname`, refers</span>&nbsp;</div></li><li><div><span class="comment">           * to the name of the registered permastruct, e.g. 'post_tag' (tags), </span>&nbsp;</div></li><li><div><span class="comment">           * 'category' (categories), etc.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param array $rules The rewrite rules generated for the current permastruct.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $rules = apply_filters( &quot;{$permastructname}_rewrite_rules&quot;, $rules );&nbsp;</div></li><li><div>          if ( 'post_tag' == $permastructname ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">               * Filters rewrite rules used specifically for Tags.</span>&nbsp;</div></li><li><div><span class="comment">               *</span>&nbsp;</div></li><li><div><span class="comment">               * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">               * @deprecated 3.1.0 Use 'post_tag_rewrite_rules' instead</span>&nbsp;</div></li><li><div><span class="comment">               *</span>&nbsp;</div></li><li><div><span class="comment">               * @param array $rules The rewrite rules generated for tags.</span>&nbsp;</div></li><li><div><span class="comment">               */</span>&nbsp;</div></li><li><div>              $rules = apply_filters( 'tag_rewrite_rules', $rules );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $this-&gt;extra_rules_top = array_merge($this-&gt;extra_rules_top, $rules);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Put them together.</span>&nbsp;</div></li><li><div>      if ( $this-&gt;use_verbose_page_rules )&nbsp;</div></li><li><div>          $this-&gt;rules = array_merge($this-&gt;extra_rules_top, $robots_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite, $author_rewrite, $date_rewrite, $page_rewrite, $post_rewrite, $this-&gt;extra_rules);&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $this-&gt;rules = array_merge($this-&gt;extra_rules_top, $robots_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite, $author_rewrite, $date_rewrite, $post_rewrite, $page_rewrite, $this-&gt;extra_rules);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires after the rewrite rules are generated.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Rewrite $this Current WP_Rewrite instance, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action_ref_array( 'generate_rewrite_rules', array( &$this ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the full set of generated rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $this-&gt;rules The compiled array of rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $this-&gt;rules = apply_filters( 'rewrite_rules_array', $this-&gt;rules );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;rules;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The difference between this method and WP_Rewrite::rewrite_rules() is that</span>&nbsp;</div></li><li><div><span class="comment">   * this method stores the rewrite rules in the 'rewrite_rules' option and retrieves</span>&nbsp;</div></li><li><div><span class="comment">   * it. This prevents having to process all of the permalinks to get the rewrite rules</span>&nbsp;</div></li><li><div><span class="comment">   * in the form of caching.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function wp_rewrite_rules() {&nbsp;</div></li><li><div>      $this-&gt;rules = get_option('rewrite_rules');&nbsp;</div></li><li><div>      if ( empty($this-&gt;rules) ) {&nbsp;</div></li><li><div>          $this-&gt;matches = 'matches';&nbsp;</div></li><li><div>          $this-&gt;rewrite_rules();&nbsp;</div></li><li><div>          if ( ! did_action( 'wp_loaded' ) ) {&nbsp;</div></li><li><div>              add_action( 'wp_loaded', array( $this, 'flush_rules' ) );&nbsp;</div></li><li><div>              return $this-&gt;rules;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          update_option('rewrite_rules', $this-&gt;rules);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;rules;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves mod_rewrite-formatted rewrite rules to write to .htaccess.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Does not actually write to the .htaccess file, but creates the rules for</span>&nbsp;</div></li><li><div><span class="comment">   * the process that will.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will add the non_wp_rules property rules to the .htaccess file before</span>&nbsp;</div></li><li><div><span class="comment">   * the WordPress rewrite rules one.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function mod_rewrite_rules() {&nbsp;</div></li><li><div>      if ( ! $this-&gt;using_permalinks() )&nbsp;</div></li><li><div>          return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $site_root = parse_url( site_url() );&nbsp;</div></li><li><div>      if ( isset( $site_root['path'] ) )&nbsp;</div></li><li><div>          $site_root = trailingslashit($site_root['path']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $home_root = parse_url(home_url());&nbsp;</div></li><li><div>      if ( isset( $home_root['path'] ) )&nbsp;</div></li><li><div>          $home_root = trailingslashit($home_root['path']);&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $home_root = '/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $rules = &quot;&lt;IfModule mod_rewrite.c&gt;\n&quot;;&nbsp;</div></li><li><div>      $rules .= &quot;RewriteEngine On\n&quot;;&nbsp;</div></li><li><div>      $rules .= &quot;RewriteBase $home_root\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Prevent -f checks on index.php.</span>&nbsp;</div></li><li><div>      $rules .= &quot;RewriteRule ^index\.php$ - [L]\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Add in the rules that don't redirect to WP's index.php (and thus shouldn't be handled by WP at all).</span>&nbsp;</div></li><li><div>      foreach ( (array) $this-&gt;non_wp_rules as $match =&gt; $query) {&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// Apache 1.3 does not support the reluctant (non-greedy) modifier.</span></span>&nbsp;</div></li><li><div>          $match = str_replace('.+?', '.+', $match);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . &quot; [QSA, L]\n&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $this-&gt;use_verbose_rules ) {&nbsp;</div></li><li><div>          $this-&gt;matches = '';&nbsp;</div></li><li><div>          $rewrite = $this-&gt;rewrite_rules();&nbsp;</div></li><li><div>          $num_rules = count($rewrite);&nbsp;</div></li><li><div>          $rules .= &quot;RewriteCond %{REQUEST_FILENAME} -f [OR]\n&quot; .&nbsp;</div></li><li><div>              &quot;RewriteCond %{REQUEST_FILENAME} -d\n&quot; .&nbsp;</div></li><li><div>              &quot;RewriteRule ^.*$ - [S=$num_rules]\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          foreach ( (array) $rewrite as $match =&gt; $query) {&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">// Apache 1.3 does not support the reluctant (non-greedy) modifier.</span></span>&nbsp;</div></li><li><div>              $match = str_replace('.+?', '.+', $match);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( strpos($query, $this-&gt;index) !== false )&nbsp;</div></li><li><div>                  $rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . &quot; [QSA, L]\n&quot;;&nbsp;</div></li><li><div>              else&nbsp;</div></li><li><div>                  $rules .= 'RewriteRule ^' . $match . ' ' . $site_root . $query . &quot; [QSA, L]\n&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $rules .= &quot;RewriteCond %{REQUEST_FILENAME} !-f\n&quot; .&nbsp;</div></li><li><div>              &quot;RewriteCond %{REQUEST_FILENAME} !-d\n&quot; .&nbsp;</div></li><li><div>              &quot;RewriteRule . {$home_root}{$this-&gt;index} [L]\n&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $rules .= &quot;&lt;/IfModule&gt;\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the list of rewrite rules formatted for output to an .htaccess file.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $rules = apply_filters( 'mod_rewrite_rules', $rules );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the list of rewrite rules formatted for output to an .htaccess file.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       * @deprecated 1.5.0 Use the mod_rewrite_rules filter instead.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'rewrite_rules', $rules );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves IIS7 URL Rewrite formatted rewrite rules to write to web.config file.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Does not actually write to the web.config file, but creates the rules for</span>&nbsp;</div></li><li><div><span class="comment">   * the process that will.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool $add_parent_tags Optional. Whether to add parent tags to the rewrite rule sets.</span>&nbsp;</div></li><li><div><span class="comment">   *                              Default false.</span>&nbsp;</div></li><li><div><span class="comment">   * @return string IIS7 URL rewrite rule sets.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function iis7_url_rewrite_rules( $add_parent_tags = false ) {&nbsp;</div></li><li><div>      if ( ! $this-&gt;using_permalinks() )&nbsp;</div></li><li><div>          return '';&nbsp;</div></li><li><div>      $rules = '';&nbsp;</div></li><li><div>      if ( $add_parent_tags ) {&nbsp;</div></li><li><div>          $rules .= '&lt;configuration&gt;&nbsp;</div></li><li><div>  &lt;system.webServer&gt;&nbsp;</div></li><li><div>      &lt;rewrite&gt;&nbsp;</div></li><li><div>          &lt;rules&gt;';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $rules .= '&nbsp;</div></li><li><div>          &lt;rule name=&quot;WordPress: ' . esc_attr( home_url() ) . '&quot; patternSyntax=&quot;Wildcard&quot;&gt;&nbsp;</div></li><li><div>              &lt;match url=&quot;*&quot; /&gt;&nbsp;</div></li><li><div>                  &lt;conditions&gt;&nbsp;</div></li><li><div>                      &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot; /&gt;&nbsp;</div></li><li><div>                      &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot; /&gt;&nbsp;</div></li><li><div>                  &lt;/conditions&gt;&nbsp;</div></li><li><div>              &lt;action type=&quot;Rewrite&quot; url=&quot;index.php&quot; /&gt;&nbsp;</div></li><li><div>          &lt;/rule&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $add_parent_tags ) {&nbsp;</div></li><li><div>          $rules .= '&nbsp;</div></li><li><div>          &lt;/rules&gt;&nbsp;</div></li><li><div>      &lt;/rewrite&gt;&nbsp;</div></li><li><div>  &lt;/system.webServer&gt;&nbsp;</div></li><li><div>&lt;/configuration&gt;';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the list of rewrite rules formatted for output to a web.config.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $rules Rewrite rules formatted for IIS web.config.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'iis7_url_rewrite_rules', $rules );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Adds a rewrite rule that transforms a URL structure to a set of query vars.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Any value in the $after parameter that isn't 'bottom' will result in the rule</span>&nbsp;</div></li><li><div><span class="comment">   * being placed at the top of the rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0 Array support was added to the `$query` parameter.</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string       $regex Regular expression to match request against.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $query The corresponding query vars for this rewrite rule.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string       $after Optional. Priority of the new rule. Accepts 'top'</span>&nbsp;</div></li><li><div><span class="comment">   *                            or 'bottom'. Default 'bottom'.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function add_rule( $regex, $query, $after = 'bottom' ) {&nbsp;</div></li><li><div>      if ( is_array( $query ) ) {&nbsp;</div></li><li><div>          $external = false;&nbsp;</div></li><li><div>          $query = add_query_arg( $query, 'index.php' );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $index = false === strpos( $query, '?' ) ? strlen( $query ) : strpos( $query, '?' );&nbsp;</div></li><li><div>          $front = substr( $query, 0, $index );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $external = $front != $this-&gt;index;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// &quot;external&quot; = it doesn't correspond to index.php.</span>&nbsp;</div></li><li><div>      if ( $external ) {&nbsp;</div></li><li><div>          $this-&gt;add_external_rule( $regex, $query );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          if ( 'bottom' == $after ) {&nbsp;</div></li><li><div>              $this-&gt;extra_rules = array_merge( $this-&gt;extra_rules, array( $regex =&gt; $query ) );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $this-&gt;extra_rules_top = array_merge( $this-&gt;extra_rules_top, array( $regex =&gt; $query ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Adds a rewrite rule that doesn't correspond to index.php.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $regex Regular expression to match request against.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $query The corresponding query vars for this rewrite rule.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function add_external_rule( $regex, $query ) {&nbsp;</div></li><li><div>      $this-&gt;non_wp_rules[ $regex ] = $query;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Adds an endpoint, like /trackback/.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.9.0 $query_var parameter added.</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.3.0 Added support for skipping query var registration by passing `false` to `$query_var`.</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see add_rewrite_endpoint() for full documentation.</span>&nbsp;</div></li><li><div><span class="comment">   * @global WP $wp</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string      $name      Name of the endpoint.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int         $places    Endpoint mask describing the places the endpoint should be added.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|bool $query_var Optional. Name of the corresponding query variable. Pass `false` to</span>&nbsp;</div></li><li><div><span class="comment">   *                               skip registering a query_var for this endpoint. Defaults to the</span>&nbsp;</div></li><li><div><span class="comment">   *                               value of `$name`.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function add_endpoint( $name, $places, $query_var = true ) {&nbsp;</div></li><li><div>      global $wp;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// For backward compatibility, if null has explicitly been passed as `$query_var`, assume `true`.</span>&nbsp;</div></li><li><div>      if ( true === $query_var || null === func_get_arg( 2 ) ) {&nbsp;</div></li><li><div>          $query_var = $name;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $this-&gt;endpoints[] = array( $places, $name, $query_var );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $query_var ) {&nbsp;</div></li><li><div>          $wp-&gt;add_query_var( $query_var );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Adds a new permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * A permalink structure (permastruct) is an abstract definition of a set of rewrite rules;</span>&nbsp;</div></li><li><div><span class="comment">   * it is an easy way of expressing a set of regular expressions that rewrite to a set of</span>&nbsp;</div></li><li><div><span class="comment">   * query strings. The new permastruct is added to the WP_Rewrite::$extra_permastructs array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * When the rewrite rules are built by WP_Rewrite::rewrite_rules(), all of these extra</span>&nbsp;</div></li><li><div><span class="comment">   * permastructs are passed to WP_Rewrite::generate_rewrite_rules() which transforms them</span>&nbsp;</div></li><li><div><span class="comment">   * into the regular expressions that many love to hate.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The `$args` parameter gives you control over how WP_Rewrite::generate_rewrite_rules()</span>&nbsp;</div></li><li><div><span class="comment">   * works on the new permastruct.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $name   Name for permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $struct Permalink structure (e.g. category/%category%)</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $args   {</span>&nbsp;</div></li><li><div><span class="comment">   *     Optional. Arguments for building rewrite rules based on the permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *     Default empty array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool $with_front  Whether the structure should be prepended with `WP_Rewrite::$front`.</span>&nbsp;</div></li><li><div><span class="comment">   *                             Default true.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type int  $ep_mask     The endpoint mask defining which endpoints are added to the structure.</span>&nbsp;</div></li><li><div><span class="comment">   *                             Accepts `EP_NONE`, `EP_PERMALINK`, `EP_ATTACHMENT`, `EP_DATE`, `EP_YEAR`, </span>&nbsp;</div></li><li><div><span class="comment">   *                             `EP_MONTH`, `EP_DAY`, `EP_ROOT`, `EP_COMMENTS`, `EP_SEARCH`, `EP_CATEGORIES`, </span>&nbsp;</div></li><li><div><span class="comment">   *                             `EP_TAGS`, `EP_AUTHORS`, `EP_PAGES`, `EP_ALL_ARCHIVES`, and `EP_ALL`.</span>&nbsp;</div></li><li><div><span class="comment">   *                             Default `EP_NONE`.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool $paged       Whether archive pagination rules should be added for the structure.</span>&nbsp;</div></li><li><div><span class="comment">   *                             Default true.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool $feed        Whether feed rewrite rules should be added for the structure. Default true.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool $forcomments Whether the feed rules should be a query for a comments feed. Default false.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool $walk_dirs   Whether the 'directories' making up the structure should be walked over</span>&nbsp;</div></li><li><div><span class="comment">   *                             and rewrite rules built for each in-turn. Default true.</span>&nbsp;</div></li><li><div><span class="comment">   *     @type bool $endpoints   Whether endpoints should be applied to the generated rules. Default true.</span>&nbsp;</div></li><li><div><span class="comment">   * }</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function add_permastruct( $name, $struct, $args = array() ) {&nbsp;</div></li><li><div>      <span class="comment">// Back-compat for the old parameters: $with_front and $ep_mask.</span>&nbsp;</div></li><li><div>      if ( ! is_array( $args ) )&nbsp;</div></li><li><div>          $args = array( 'with_front' =&gt; $args );&nbsp;</div></li><li><div>      if ( func_num_args() == 4 )&nbsp;</div></li><li><div>          $args['ep_mask'] = func_get_arg( 3 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array(&nbsp;</div></li><li><div>          'with_front' =&gt; true, &nbsp;</div></li><li><div>          'ep_mask' =&gt; EP_NONE, &nbsp;</div></li><li><div>          'paged' =&gt; true, &nbsp;</div></li><li><div>          'feed' =&gt; true, &nbsp;</div></li><li><div>          'forcomments' =&gt; false, &nbsp;</div></li><li><div>          'walk_dirs' =&gt; true, &nbsp;</div></li><li><div>          'endpoints' =&gt; true, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      $args = array_intersect_key( $args, $defaults );&nbsp;</div></li><li><div>      $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $args['with_front'] )&nbsp;</div></li><li><div>          $struct = $this-&gt;front . $struct;&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $struct = $this-&gt;root . $struct;&nbsp;</div></li><li><div>      $args['struct'] = $struct;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;extra_permastructs[ $name ] = $args;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Removes a permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $name Name for permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function remove_permastruct( $name ) {&nbsp;</div></li><li><div>      unset( $this-&gt;extra_permastructs[ $name ] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Removes rewrite rules and then recreate rewrite rules.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Calls WP_Rewrite::wp_rewrite_rules() after removing the 'rewrite_rules' option.</span>&nbsp;</div></li><li><div><span class="comment">   * If the function named 'save_mod_rewrite_rules' exists, it will be called.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.1</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @staticvar bool $do_hard_later</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool $hard Whether to update .htaccess (hard flush) or just update rewrite_rules option (soft flush). Default is true (hard).</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function flush_rules( $hard = true ) {&nbsp;</div></li><li><div>      static $do_hard_later = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Prevent this action from running before everyone has registered their rewrites.</span>&nbsp;</div></li><li><div>      if ( ! did_action( 'wp_loaded' ) ) {&nbsp;</div></li><li><div>          add_action( 'wp_loaded', array( $this, 'flush_rules' ) );&nbsp;</div></li><li><div>          $do_hard_later = ( isset( $do_hard_later ) ) ? $do_hard_later || $hard : $hard;&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset( $do_hard_later ) ) {&nbsp;</div></li><li><div>          $hard = $do_hard_later;&nbsp;</div></li><li><div>          unset( $do_hard_later );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      update_option( 'rewrite_rules', '' );&nbsp;</div></li><li><div>      $this-&gt;wp_rewrite_rules();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters whether a &quot;hard&quot; rewrite rule flush should be performed when requested.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * A &quot;hard&quot; flush updates .htaccess (Apache) or web.config (IIS).</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool $hard Whether to flush rewrite rules &quot;hard&quot;. Default true.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( ! $hard || ! apply_filters( 'flush_rewrite_rules_hard', true ) ) {&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( function_exists( 'save_mod_rewrite_rules' ) )&nbsp;</div></li><li><div>          save_mod_rewrite_rules();&nbsp;</div></li><li><div>      if ( function_exists( 'iis7_save_url_rewrite_rules' ) )&nbsp;</div></li><li><div>          iis7_save_url_rewrite_rules();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Sets up the object's properties.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'use_verbose_page_rules' object property will be set to true if the</span>&nbsp;</div></li><li><div><span class="comment">   * permalink structure begins with one of the following: '%postname%', '%category%', </span>&nbsp;</div></li><li><div><span class="comment">   * '%tag%', or '%author%'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function init() {&nbsp;</div></li><li><div>      $this-&gt;extra_rules = $this-&gt;non_wp_rules = $this-&gt;endpoints = array();&nbsp;</div></li><li><div>      $this-&gt;permalink_structure = get_option('permalink_structure');&nbsp;</div></li><li><div>      $this-&gt;front = substr($this-&gt;permalink_structure, 0, strpos($this-&gt;permalink_structure, '%'));&nbsp;</div></li><li><div>      $this-&gt;root = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $this-&gt;using_index_permalinks() )&nbsp;</div></li><li><div>          $this-&gt;root = $this-&gt;index . '/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      unset($this-&gt;author_structure);&nbsp;</div></li><li><div>      unset($this-&gt;date_structure);&nbsp;</div></li><li><div>      unset($this-&gt;page_structure);&nbsp;</div></li><li><div>      unset($this-&gt;search_structure);&nbsp;</div></li><li><div>      unset($this-&gt;feed_structure);&nbsp;</div></li><li><div>      unset($this-&gt;comment_feed_structure);&nbsp;</div></li><li><div>      $this-&gt;use_trailing_slashes = ( '/' == substr($this-&gt;permalink_structure, -1, 1) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Enable generic rules for pages if permalink structure doesn't begin with a wildcard.</span>&nbsp;</div></li><li><div>      if ( preg_match(&quot;/^[^%]*%(?:postname|category|tag|author)%/&quot;, $this-&gt;permalink_structure) )&nbsp;</div></li><li><div>           $this-&gt;use_verbose_page_rules = true;&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $this-&gt;use_verbose_page_rules = false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Sets the main permalink structure for the site.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will update the 'permalink_structure' option, if there is a difference</span>&nbsp;</div></li><li><div><span class="comment">   * between the current permalink structure and the parameter value. Calls</span>&nbsp;</div></li><li><div><span class="comment">   * WP_Rewrite::init() after the option is updated.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Fires the {@see 'permalink_structure_changed'} action once the init call has</span>&nbsp;</div></li><li><div><span class="comment">   * processed passing the old and new values</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $permalink_structure Permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function set_permalink_structure($permalink_structure) {&nbsp;</div></li><li><div>      if ( $permalink_structure != $this-&gt;permalink_structure ) {&nbsp;</div></li><li><div>          $old_permalink_structure = $this-&gt;permalink_structure;&nbsp;</div></li><li><div>          update_option('permalink_structure', $permalink_structure);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $this-&gt;init();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires after the permalink structure is updated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $old_permalink_structure The previous permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $permalink_structure     The new permalink structure.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'permalink_structure_changed', $old_permalink_structure, $permalink_structure );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Sets the category base for the category permalink.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will update the 'category_base' option, if there is a difference between</span>&nbsp;</div></li><li><div><span class="comment">   * the current category base and the parameter value. Calls WP_Rewrite::init()</span>&nbsp;</div></li><li><div><span class="comment">   * after the option is updated.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $category_base Category permalink structure base.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function set_category_base($category_base) {&nbsp;</div></li><li><div>      if ( $category_base != get_option('category_base') ) {&nbsp;</div></li><li><div>          update_option('category_base', $category_base);&nbsp;</div></li><li><div>          $this-&gt;init();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Sets the tag base for the tag permalink.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will update the 'tag_base' option, if there is a difference between the</span>&nbsp;</div></li><li><div><span class="comment">   * current tag base and the parameter value. Calls WP_Rewrite::init() after</span>&nbsp;</div></li><li><div><span class="comment">   * the option is updated.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $tag_base Tag permalink structure base.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function set_tag_base( $tag_base ) {&nbsp;</div></li><li><div>      if ( $tag_base != get_option( 'tag_base') ) {&nbsp;</div></li><li><div>          update_option( 'tag_base', $tag_base );&nbsp;</div></li><li><div>          $this-&gt;init();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Constructor - Calls init(), which runs setup.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access public</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function __construct() {&nbsp;</div></li><li><div>      $this-&gt;init();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>file</li><li><span></span></li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2021 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>