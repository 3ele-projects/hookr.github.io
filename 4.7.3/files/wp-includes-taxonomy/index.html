<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="wordpress" data-version="4.7.3" data-type="file" data-id="4961"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp-includes-taxonomy | file | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, wordpress, 4.7.3" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.10"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=848885247b94243b9f193c7603d91cd7' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.10' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/wp-includes-taxonomy/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-taxonomy%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-taxonomy%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.3-file-wp-includes-taxonomy","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp-includes-taxonomy" class="blog single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.3." href="http://hookr.io/4.7.3/" class="H_VERSION"><span property="name">4.7.3</span></a><meta property="position" content="2"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp-includes-taxonomy</span><meta property="position" content="3"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="6309"><a href="http://hookr.io/4.7.3/all/" title="All">All <span class="count badge">6309</span></a></li><li class="" data-id="new" data-count="1"><a href="http://hookr.io/4.7.3/new/" title="New">New <span class="count badge">1</span></a></li><li class="" data-id="hooks" data-count="2532"><a href="http://hookr.io/4.7.3/hooks/" title="Hooks">Hooks <span class="count badge">2532</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.3/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1668"><a href="http://hookr.io/4.7.3/filters/" title="Filters">Filters <span class="count badge">1668</span></a></li><li class="" data-id="class" data-count="351"><a href="http://hookr.io/4.7.3/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.3/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2852"><a href="http://hookr.io/4.7.3/functions/" title="Functions">Functions <span class="count badge">2852</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.3/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/wp-includes/taxonomy.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Core Taxonomy API</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">// Taxonomy Registration</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Creates the initial taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function fires twice: in wp-settings.php before plugins are loaded (for</span>&nbsp;</div></li><li><div><span class="comment"> * backward compatibility reasons), and again on the {@see 'init'} action. We must</span>&nbsp;</div></li><li><div><span class="comment"> * avoid registering rewrite rules before the {@see 'init'} action.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Rewrite $wp_rewrite The WordPress rewrite class.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function create_initial_taxonomies() {&nbsp;</div></li><li><div>  global $wp_rewrite;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! did_action( 'init' ) ) {&nbsp;</div></li><li><div>      $rewrite = array( 'category' =&gt; false, 'post_tag' =&gt; false, 'post_format' =&gt; false );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the post formats rewrite base.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $context Context of the rewrite base. Default 'type'.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $post_format_base = apply_filters( 'post_format_rewrite_base', 'type' );&nbsp;</div></li><li><div>      $rewrite = array(&nbsp;</div></li><li><div>          'category' =&gt; array(&nbsp;</div></li><li><div>              'hierarchical' =&gt; true, &nbsp;</div></li><li><div>              'slug' =&gt; get_option('category_base') ? get_option('category_base') : 'category', &nbsp;</div></li><li><div>              'with_front' =&gt; ! get_option('category_base') || $wp_rewrite-&gt;using_index_permalinks(), &nbsp;</div></li><li><div>              'ep_mask' =&gt; EP_CATEGORIES, &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>          'post_tag' =&gt; array(&nbsp;</div></li><li><div>              'hierarchical' =&gt; false, &nbsp;</div></li><li><div>              'slug' =&gt; get_option('tag_base') ? get_option('tag_base') : 'tag', &nbsp;</div></li><li><div>              'with_front' =&gt; ! get_option('tag_base') || $wp_rewrite-&gt;using_index_permalinks(), &nbsp;</div></li><li><div>              'ep_mask' =&gt; EP_TAGS, &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>          'post_format' =&gt; $post_format_base ? array( 'slug' =&gt; $post_format_base ) : false, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_taxonomy( 'category', 'post', array(&nbsp;</div></li><li><div>      'hierarchical' =&gt; true, &nbsp;</div></li><li><div>      'query_var' =&gt; 'category_name', &nbsp;</div></li><li><div>      'rewrite' =&gt; $rewrite['category'], &nbsp;</div></li><li><div>      'public' =&gt; true, &nbsp;</div></li><li><div>      'show_ui' =&gt; true, &nbsp;</div></li><li><div>      'show_admin_column' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, &nbsp;</div></li><li><div>      'capabilities' =&gt; array(&nbsp;</div></li><li><div>          'manage_terms' =&gt; 'manage_categories', &nbsp;</div></li><li><div>          'edit_terms' =&gt; 'edit_categories', &nbsp;</div></li><li><div>          'delete_terms' =&gt; 'delete_categories', &nbsp;</div></li><li><div>          'assign_terms' =&gt; 'assign_categories', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'show_in_rest' =&gt; true, &nbsp;</div></li><li><div>      'rest_base' =&gt; 'categories', &nbsp;</div></li><li><div>      'rest_controller_class' =&gt; 'WP_REST_Terms_Controller', &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_taxonomy( 'post_tag', 'post', array(&nbsp;</div></li><li><div>       'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; 'tag', &nbsp;</div></li><li><div>      'rewrite' =&gt; $rewrite['post_tag'], &nbsp;</div></li><li><div>      'public' =&gt; true, &nbsp;</div></li><li><div>      'show_ui' =&gt; true, &nbsp;</div></li><li><div>      'show_admin_column' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, &nbsp;</div></li><li><div>      'capabilities' =&gt; array(&nbsp;</div></li><li><div>          'manage_terms' =&gt; 'manage_post_tags', &nbsp;</div></li><li><div>          'edit_terms' =&gt; 'edit_post_tags', &nbsp;</div></li><li><div>          'delete_terms' =&gt; 'delete_post_tags', &nbsp;</div></li><li><div>          'assign_terms' =&gt; 'assign_post_tags', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'show_in_rest' =&gt; true, &nbsp;</div></li><li><div>      'rest_base' =&gt; 'tags', &nbsp;</div></li><li><div>      'rest_controller_class' =&gt; 'WP_REST_Terms_Controller', &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_taxonomy( 'nav_menu', 'nav_menu_item', array(&nbsp;</div></li><li><div>      'public' =&gt; false, &nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; __( 'Navigation Menus' ), &nbsp;</div></li><li><div>          'singular_name' =&gt; __( 'Navigation Menu' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'show_ui' =&gt; false, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, &nbsp;</div></li><li><div>      'show_in_nav_menus' =&gt; false, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_taxonomy( 'link_category', 'link', array(&nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; __( 'Link Categories' ), &nbsp;</div></li><li><div>          'singular_name' =&gt; __( 'Link Category' ), &nbsp;</div></li><li><div>          'search_items' =&gt; __( 'Search Link Categories' ), &nbsp;</div></li><li><div>          'popular_items' =&gt; null, &nbsp;</div></li><li><div>          'all_items' =&gt; __( 'All Link Categories' ), &nbsp;</div></li><li><div>          'edit_item' =&gt; __( 'Edit Link Category' ), &nbsp;</div></li><li><div>          'update_item' =&gt; __( 'Update Link Category' ), &nbsp;</div></li><li><div>          'add_new_item' =&gt; __( 'Add New Link Category' ), &nbsp;</div></li><li><div>          'new_item_name' =&gt; __( 'New Link Category Name' ), &nbsp;</div></li><li><div>          'separate_items_with_commas' =&gt; null, &nbsp;</div></li><li><div>          'add_or_remove_items' =&gt; null, &nbsp;</div></li><li><div>          'choose_from_most_used' =&gt; null, &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'capabilities' =&gt; array(&nbsp;</div></li><li><div>          'manage_terms' =&gt; 'manage_links', &nbsp;</div></li><li><div>          'edit_terms' =&gt; 'manage_links', &nbsp;</div></li><li><div>          'delete_terms' =&gt; 'manage_links', &nbsp;</div></li><li><div>          'assign_terms' =&gt; 'manage_links', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'public' =&gt; false, &nbsp;</div></li><li><div>      'show_ui' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_taxonomy( 'post_format', 'post', array(&nbsp;</div></li><li><div>      'public' =&gt; true, &nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; _x( 'Format', 'post format' ), &nbsp;</div></li><li><div>          'singular_name' =&gt; _x( 'Format', 'post format' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'query_var' =&gt; true, &nbsp;</div></li><li><div>      'rewrite' =&gt; $rewrite['post_format'], &nbsp;</div></li><li><div>      'show_ui' =&gt; false, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, &nbsp;</div></li><li><div>      'show_in_nav_menus' =&gt; current_theme_supports( 'post-formats' ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves a list of registered taxonomy names or objects.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies The registered taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $args     Optional. An array of `key =&gt; value` arguments to match against the taxonomy objects.</span>&nbsp;</div></li><li><div><span class="comment"> *                         Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $output   Optional. The type of output to return in the array. Accepts either taxonomy 'names'</span>&nbsp;</div></li><li><div><span class="comment"> *                         or 'objects'. Default 'names'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $operator Optional. The logical operation to perform. Accepts 'and' or 'or'. 'or' means only</span>&nbsp;</div></li><li><div><span class="comment"> *                         one element from the array needs to match; 'and' means all elements must match.</span>&nbsp;</div></li><li><div><span class="comment"> *                         Default 'and'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array A list of taxonomy names or objects.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_taxonomies( $args = array(), $output = 'names', $operator = 'and' ) {&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $field = ('names' == $output) ? 'name' : false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_filter_object_list($wp_taxonomies, $args, $operator, $field);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Return the names or objects of the taxonomies which are registered for the requested object or object type, such as</span>&nbsp;</div></li><li><div><span class="comment"> * a post object or post type name.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Example:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     $taxonomies = get_object_taxonomies( 'post' );</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This results in:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     Array( 'category', 'post_tag' )</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies The registered taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string|WP_Post $object Name of the type of taxonomy object, or an object (row from posts)</span>&nbsp;</div></li><li><div><span class="comment"> * @param string               $output Optional. The type of output to return in the array. Accepts either</span>&nbsp;</div></li><li><div><span class="comment"> *                                     taxonomy 'names' or 'objects'. Default 'names'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array The names of all taxonomy of $object_type.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_object_taxonomies( $object, $output = 'names' ) {&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_object($object) ) {&nbsp;</div></li><li><div>      if ( $object-&gt;post_type == 'attachment' )&nbsp;</div></li><li><div>          return get_attachment_taxonomies( $object, $output );&nbsp;</div></li><li><div>      $object = $object-&gt;post_type;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object = (array) $object;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomies = array();&nbsp;</div></li><li><div>  foreach ( (array) $wp_taxonomies as $tax_name =&gt; $tax_obj ) {&nbsp;</div></li><li><div>      if ( array_intersect($object, (array) $tax_obj-&gt;object_type) ) {&nbsp;</div></li><li><div>          if ( 'names' == $output )&nbsp;</div></li><li><div>              $taxonomies[] = $tax_name;&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $taxonomies[ $tax_name ] = $tax_obj;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $taxonomies;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves the taxonomy object of $taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The get_taxonomy function will first check that the parameter string given</span>&nbsp;</div></li><li><div><span class="comment"> * is a taxonomy object and if it is, it will return it.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies The registered taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Name of taxonomy object to return.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Taxonomy|false The Taxonomy Object or false if $taxonomy doesn't exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_taxonomy( $taxonomy ) {&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! taxonomy_exists( $taxonomy ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $wp_taxonomies[$taxonomy];&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Checks that the taxonomy name exists.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Formerly is_taxonomy(), introduced in 2.3.0.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies The registered taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Name of taxonomy object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether the taxonomy exists.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function taxonomy_exists( $taxonomy ) {&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return isset( $wp_taxonomies[$taxonomy] );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Whether the taxonomy object is hierarchical.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Checks to make sure that the taxonomy is an object first. Then Gets the</span>&nbsp;</div></li><li><div><span class="comment"> * object, and finally returns the hierarchical value in the object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A false return value might also mean that the taxonomy does not exist.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Name of taxonomy object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether the taxonomy is hierarchical.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_taxonomy_hierarchical($taxonomy) {&nbsp;</div></li><li><div>  if ( ! taxonomy_exists($taxonomy) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy = get_taxonomy($taxonomy);&nbsp;</div></li><li><div>  return $taxonomy-&gt;hierarchical;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Creates or modifies a taxonomy object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Note: Do not use before the {@see 'init'} hook.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A simple function for creating or modifying a taxonomy object based on the</span>&nbsp;</div></li><li><div><span class="comment"> * parameters given. The function will accept an array (third optional</span>&nbsp;</div></li><li><div><span class="comment"> * parameter), along with strings for the taxonomy name and another string for</span>&nbsp;</div></li><li><div><span class="comment"> * the object type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0 Introduced `show_in_quick_edit` argument.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 The `show_ui` argument is now enforced on the term editing screen.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 The `public` argument now controls whether the taxonomy can be queried on the front end.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0 Introduced `publicly_queryable` argument.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Introduced `show_in_rest`, 'rest_base' and 'rest_controller_class'</span>&nbsp;</div></li><li><div><span class="comment"> *              arguments to register the Taxonomy in REST API.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies Registered taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $taxonomy    Taxonomy key, must not exceed 32 characters.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $object_type Object type or array of object types with which the taxonomy should be associated.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args        {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Array or query string of arguments for registering a taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array         $labels                An array of labels for this taxonomy. By default, Tag labels are</span>&nbsp;</div></li><li><div><span class="comment"> *                                                used for non-hierarchical taxonomies, and Category labels are used</span>&nbsp;</div></li><li><div><span class="comment"> *                                                for hierarchical taxonomies. See accepted values in</span>&nbsp;</div></li><li><div><span class="comment"> *                                                get_taxonomy_labels(). Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string        $description           A short descriptive summary of what the taxonomy is for. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $public                Whether a taxonomy is intended for use publicly either via</span>&nbsp;</div></li><li><div><span class="comment"> *                                                the admin interface or by front-end users. The default settings</span>&nbsp;</div></li><li><div><span class="comment"> *                                                of `$publicly_queryable`, `$show_ui`, and `$show_in_nav_menus`</span>&nbsp;</div></li><li><div><span class="comment"> *                                                are inherited from `$public`.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $publicly_queryable    Whether the taxonomy is publicly queryable.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                If not set, the default is inherited from `$public`</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $hierarchical          Whether the taxonomy is hierarchical. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $show_ui               Whether to generate and allow a UI for managing terms in this taxonomy in</span>&nbsp;</div></li><li><div><span class="comment"> *                                                the admin. If not set, the default is inherited from `$public`</span>&nbsp;</div></li><li><div><span class="comment"> *                                                (default true).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $show_in_menu          Whether to show the taxonomy in the admin menu. If true, the taxonomy is</span>&nbsp;</div></li><li><div><span class="comment"> *                                                shown as a submenu of the object type menu. If false, no menu is shown.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                `$show_ui` must be true. If not set, default is inherited from `$show_ui`</span>&nbsp;</div></li><li><div><span class="comment"> *                                                (default true).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $show_in_nav_menus     Makes this taxonomy available for selection in navigation menus. If not</span>&nbsp;</div></li><li><div><span class="comment"> *                                                set, the default is inherited from `$public` (default true).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $show_in_rest          Whether to include the taxonomy in the REST API.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string        $rest_base             To change the base url of REST API route. Default is $taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string        $rest_controller_class REST API Controller class name. Default is 'WP_REST_Terms_Controller'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $show_tagcloud         Whether to list the taxonomy in the Tag Cloud Widget controls. If not set, </span>&nbsp;</div></li><li><div><span class="comment"> *                                                the default is inherited from `$show_ui` (default true).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $show_in_quick_edit    Whether to show the taxonomy in the quick/bulk edit panel. It not set, </span>&nbsp;</div></li><li><div><span class="comment"> *                                                the default is inherited from `$show_ui` (default true).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $show_admin_column     Whether to display a column for the taxonomy on its post type listing</span>&nbsp;</div></li><li><div><span class="comment"> *                                                screens. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool|callable $meta_box_cb           Provide a callback function for the meta box display. If not set, </span>&nbsp;</div></li><li><div><span class="comment"> *                                                post_categories_meta_box() is used for hierarchical taxonomies, and</span>&nbsp;</div></li><li><div><span class="comment"> *                                                post_tags_meta_box() is used for non-hierarchical. If false, no meta</span>&nbsp;</div></li><li><div><span class="comment"> *                                                box is shown.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array         $capabilities {</span>&nbsp;</div></li><li><div><span class="comment"> *         Array of capabilities for this taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *         @type string $manage_terms Default 'manage_categories'.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type string $edit_terms   Default 'manage_categories'.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type string $delete_terms Default 'manage_categories'.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type string $assign_terms Default 'edit_posts'.</span>&nbsp;</div></li><li><div><span class="comment"> *     }</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool|array    $rewrite {</span>&nbsp;</div></li><li><div><span class="comment"> *         Triggers the handling of rewrites for this taxonomy. Default true, using $taxonomy as slug. To prevent</span>&nbsp;</div></li><li><div><span class="comment"> *         rewrite, set to false. To specify rewrite rules, an array can be passed with any of these keys:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *         @type string $slug         Customize the permastruct slug. Default `$taxonomy` key.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type bool   $with_front   Should the permastruct be prepended with WP_Rewrite::$front. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type bool   $hierarchical Either hierarchical rewrite tag or not. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type int    $ep_mask      Assign an endpoint mask. Default `EP_NONE`.</span>&nbsp;</div></li><li><div><span class="comment"> *     }</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string        $query_var             Sets the query var key for this taxonomy. Default `$taxonomy` key. If</span>&nbsp;</div></li><li><div><span class="comment"> *                                                false, a taxonomy cannot be loaded at `?{query_var}={term_slug}`. If a</span>&nbsp;</div></li><li><div><span class="comment"> *                                                string, the query `?{query_var}={term_slug}` will be valid.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type callable      $update_count_callback Works much like a hook, in that it will be called when the count is</span>&nbsp;</div></li><li><div><span class="comment"> *                                                updated. Default _update_post_term_count() for taxonomies attached</span>&nbsp;</div></li><li><div><span class="comment"> *                                                to post types, which confirms that the objects are published before</span>&nbsp;</div></li><li><div><span class="comment"> *                                                counting them. Default _update_generic_term_count() for taxonomies</span>&nbsp;</div></li><li><div><span class="comment"> *                                                attached to other object types, such as users.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool          $_builtin              This taxonomy is a &quot;built-in&quot; taxonomy. INTERNAL USE ONLY!</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Error|void WP_Error, if errors.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function register_taxonomy( $taxonomy, $object_type, $args = array() ) {&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_array( $wp_taxonomies ) )&nbsp;</div></li><li><div>      $wp_taxonomies = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args = wp_parse_args( $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $taxonomy ) || strlen( $taxonomy ) &gt; 32 ) {&nbsp;</div></li><li><div>      _doing_it_wrong( __FUNCTION__, __( 'Taxonomy names must be between 1 and 32 characters in length.' ), '4.2.0' );&nbsp;</div></li><li><div>      return new WP_Error( 'taxonomy_length_invalid', __( 'Taxonomy names must be between 1 and 32 characters in length.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy_object = new WP_Taxonomy( $taxonomy, $object_type, $args );&nbsp;</div></li><li><div>  $taxonomy_object-&gt;add_rewrite_rules();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wp_taxonomies[ $taxonomy ] = $taxonomy_object;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy_object-&gt;add_hooks();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a taxonomy is registered.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string       $taxonomy    Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $object_type Object type or array of object types.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array        $args        Array of taxonomy registration arguments.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'registered_taxonomy', $taxonomy, $object_type, (array) $taxonomy_object );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Unregisters a taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Can not be used to unregister built-in taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP    $wp            Current WordPress environment instance.</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies List of taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|WP_Error True on success, WP_Error on failure or if the taxonomy doesn't exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function unregister_taxonomy( $taxonomy ) {&nbsp;</div></li><li><div>  if ( ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy_object = get_taxonomy( $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Do not allow unregistering internal taxonomies.</span>&nbsp;</div></li><li><div>  if ( $taxonomy_object-&gt;_builtin ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Unregistering a built-in taxonomy is not allowed' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy_object-&gt;remove_rewrite_rules();&nbsp;</div></li><li><div>  $taxonomy_object-&gt;remove_hooks();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Remove the taxonomy.</span>&nbsp;</div></li><li><div>  unset( $wp_taxonomies[ $taxonomy ] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a taxonomy is unregistered.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'unregistered_taxonomy', $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Builds an object with all taxonomy labels out of a taxonomy object</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Accepted keys of the label array in the taxonomy object:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * - name - general name for the taxonomy, usually plural. The same as and overridden by $tax-&gt;label. Default is Tags/Categories</span>&nbsp;</div></li><li><div><span class="comment"> * - singular_name - name for one object of this taxonomy. Default is Tag/Category</span>&nbsp;</div></li><li><div><span class="comment"> * - search_items - Default is Search Tags/Search Categories</span>&nbsp;</div></li><li><div><span class="comment"> * - popular_items - This string isn't used on hierarchical taxonomies. Default is Popular Tags</span>&nbsp;</div></li><li><div><span class="comment"> * - all_items - Default is All Tags/All Categories</span>&nbsp;</div></li><li><div><span class="comment"> * - parent_item - This string isn't used on non-hierarchical taxonomies. In hierarchical ones the default is Parent Category</span>&nbsp;</div></li><li><div><span class="comment"> * - parent_item_colon - The same as `parent_item`, but with colon `:` in the end</span>&nbsp;</div></li><li><div><span class="comment"> * - edit_item - Default is Edit Tag/Edit Category</span>&nbsp;</div></li><li><div><span class="comment"> * - view_item - Default is View Tag/View Category</span>&nbsp;</div></li><li><div><span class="comment"> * - update_item - Default is Update Tag/Update Category</span>&nbsp;</div></li><li><div><span class="comment"> * - add_new_item - Default is Add New Tag/Add New Category</span>&nbsp;</div></li><li><div><span class="comment"> * - new_item_name - Default is New Tag Name/New Category Name</span>&nbsp;</div></li><li><div><span class="comment"> * - separate_items_with_commas - This string isn't used on hierarchical taxonomies. Default is &quot;Separate tags with commas&quot;, used in the meta box.</span>&nbsp;</div></li><li><div><span class="comment"> * - add_or_remove_items - This string isn't used on hierarchical taxonomies. Default is &quot;Add or remove tags&quot;, used in the meta box when JavaScript is disabled.</span>&nbsp;</div></li><li><div><span class="comment"> * - choose_from_most_used - This string isn't used on hierarchical taxonomies. Default is &quot;Choose from the most used tags&quot;, used in the meta box.</span>&nbsp;</div></li><li><div><span class="comment"> * - not_found - Default is &quot;No tags found&quot;/&quot;No categories found&quot;, used in the meta box and taxonomy list table.</span>&nbsp;</div></li><li><div><span class="comment"> * - no_terms - Default is &quot;No tags&quot;/&quot;No categories&quot;, used in the posts and media list tables.</span>&nbsp;</div></li><li><div><span class="comment"> * - items_list_navigation - String for the table pagination hidden heading.</span>&nbsp;</div></li><li><div><span class="comment"> * - items_list - String for the table hidden heading.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Above, the first default value is for non-hierarchical taxonomies (like tags) and the second one is for hierarchical taxonomies (like categories).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @todo Better documentation for the labels array.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0 Added the `no_terms` label.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Added the `items_list_navigation` and `items_list` labels.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Taxonomy $tax Taxonomy object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object object with all the labels as member variables.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_taxonomy_labels( $tax ) {&nbsp;</div></li><li><div>  $tax-&gt;labels = (array) $tax-&gt;labels;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $tax-&gt;helps ) && empty( $tax-&gt;labels['separate_items_with_commas'] ) )&nbsp;</div></li><li><div>      $tax-&gt;labels['separate_items_with_commas'] = $tax-&gt;helps;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $tax-&gt;no_tagcloud ) && empty( $tax-&gt;labels['not_found'] ) )&nbsp;</div></li><li><div>      $tax-&gt;labels['not_found'] = $tax-&gt;no_tagcloud;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $nohier_vs_hier_defaults = array(&nbsp;</div></li><li><div>      'name' =&gt; array( _x( 'Tags', 'taxonomy general name' ), _x( 'Categories', 'taxonomy general name' ) ), &nbsp;</div></li><li><div>      'singular_name' =&gt; array( _x( 'Tag', 'taxonomy singular name' ), _x( 'Category', 'taxonomy singular name' ) ), &nbsp;</div></li><li><div>      'search_items' =&gt; array( __( 'Search Tags' ), __( 'Search Categories' ) ), &nbsp;</div></li><li><div>      'popular_items' =&gt; array( __( 'Popular Tags' ), null ), &nbsp;</div></li><li><div>      'all_items' =&gt; array( __( 'All Tags' ), __( 'All Categories' ) ), &nbsp;</div></li><li><div>      'parent_item' =&gt; array( null, __( 'Parent Category' ) ), &nbsp;</div></li><li><div>      'parent_item_colon' =&gt; array( null, __( 'Parent Category:' ) ), &nbsp;</div></li><li><div>      'edit_item' =&gt; array( __( 'Edit Tag' ), __( 'Edit Category' ) ), &nbsp;</div></li><li><div>      'view_item' =&gt; array( __( 'View Tag' ), __( 'View Category' ) ), &nbsp;</div></li><li><div>      'update_item' =&gt; array( __( 'Update Tag' ), __( 'Update Category' ) ), &nbsp;</div></li><li><div>      'add_new_item' =&gt; array( __( 'Add New Tag' ), __( 'Add New Category' ) ), &nbsp;</div></li><li><div>      'new_item_name' =&gt; array( __( 'New Tag Name' ), __( 'New Category Name' ) ), &nbsp;</div></li><li><div>      'separate_items_with_commas' =&gt; array( __( 'Separate tags with commas' ), null ), &nbsp;</div></li><li><div>      'add_or_remove_items' =&gt; array( __( 'Add or remove tags' ), null ), &nbsp;</div></li><li><div>      'choose_from_most_used' =&gt; array( __( 'Choose from the most used tags' ), null ), &nbsp;</div></li><li><div>      'not_found' =&gt; array( __( 'No tags found.' ), __( 'No categories found.' ) ), &nbsp;</div></li><li><div>      'no_terms' =&gt; array( __( 'No tags' ), __( 'No categories' ) ), &nbsp;</div></li><li><div>      'items_list_navigation' =&gt; array( __( 'Tags list navigation' ), __( 'Categories list navigation' ) ), &nbsp;</div></li><li><div>      'items_list' =&gt; array( __( 'Tags list' ), __( 'Categories list' ) ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  $nohier_vs_hier_defaults['menu_name'] = $nohier_vs_hier_defaults['name'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $labels = _get_custom_object_labels( $tax, $nohier_vs_hier_defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy = $tax-&gt;name;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $default_labels = clone $labels;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the labels of a specific taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$taxonomy`, refers to the taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see get_taxonomy_labels() for the full list of taxonomy labels.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $labels Object with labels for the taxonomy as member variables.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $labels = apply_filters( &quot;taxonomy_labels_{$taxonomy}&quot;, $labels );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Ensure that the filtered labels contain all required default values.</span>&nbsp;</div></li><li><div>  $labels = (object) array_merge( (array) $default_labels, (array) $labels );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $labels;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add an already registered taxonomy to an object type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies The registered taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy    Name of taxonomy object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $object_type Name of the object type.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True if successful, false if not.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function register_taxonomy_for_object_type( $taxonomy, $object_type) {&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset($wp_taxonomies[$taxonomy]) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! get_post_type_object($object_type) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! in_array( $object_type, $wp_taxonomies[$taxonomy]-&gt;object_type ) )&nbsp;</div></li><li><div>      $wp_taxonomies[$taxonomy]-&gt;object_type[] = $object_type;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Filter out empties.</span>&nbsp;</div></li><li><div>  $wp_taxonomies[ $taxonomy ]-&gt;object_type = array_filter( $wp_taxonomies[ $taxonomy ]-&gt;object_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove an already registered taxonomy from an object type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_taxonomies The registered taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy    Name of taxonomy object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $object_type Name of the object type.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True if successful, false if not.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function unregister_taxonomy_for_object_type( $taxonomy, $object_type ) {&nbsp;</div></li><li><div>  global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! isset( $wp_taxonomies[ $taxonomy ] ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! get_post_type_object( $object_type ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $key = array_search( $object_type, $wp_taxonomies[ $taxonomy ]-&gt;object_type, true );&nbsp;</div></li><li><div>  if ( false === $key )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  unset( $wp_taxonomies[ $taxonomy ]-&gt;object_type[ $key ] );&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Term API&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve object_ids of valid taxonomy and term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The strings of $taxonomies must exist before this function will continue. On</span>&nbsp;</div></li><li><div><span class="comment"> * failure of finding a valid taxonomy, it will return an WP_Error class, kind</span>&nbsp;</div></li><li><div><span class="comment"> * of like Exceptions in PHP 5, except you can't catch them. Even so, you can</span>&nbsp;</div></li><li><div><span class="comment"> * still test for the WP_Error class and get the error message.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The $terms aren't checked the same as $taxonomies, but still need to exist</span>&nbsp;</div></li><li><div><span class="comment"> * for $object_ids to be returned.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * It is possible to change the order that object_ids is returned by either</span>&nbsp;</div></li><li><div><span class="comment"> * using PHP sort family functions or using the database by using $args with</span>&nbsp;</div></li><li><div><span class="comment"> * either ASC or DESC array. The value should be in the key named 'order'.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|array    $term_ids   Term id or array of term ids of terms that will be used.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $taxonomies String of taxonomy name or Array of string values of taxonomy names.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args       Change the order of the object_ids, either ASC or DESC.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Error|array If the taxonomy does not exist, then WP_Error will be returned. On success.</span>&nbsp;</div></li><li><div><span class="comment"> *    the array can be empty meaning that there are no $object_ids found or it will return the $object_ids found.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_objects_in_term( $term_ids, $taxonomies, $args = array() ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_array( $term_ids ) ) {&nbsp;</div></li><li><div>      $term_ids = array( $term_ids );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( ! is_array( $taxonomies ) ) {&nbsp;</div></li><li><div>      $taxonomies = array( $taxonomies );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  foreach ( (array) $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>      if ( ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>          return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array( 'order' =&gt; 'ASC' );&nbsp;</div></li><li><div>  $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $order = ( 'desc' == strtolower( $args['order'] ) ) ? 'DESC' : 'ASC';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_ids = array_map('intval', $term_ids );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomies = &quot;'&quot; . implode( &quot;', '&quot;, array_map( 'esc_sql', $taxonomies ) ) . &quot;'&quot;;&nbsp;</div></li><li><div>  $term_ids = &quot;'&quot; . implode( &quot;', '&quot;, $term_ids ) . &quot;'&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_ids = $wpdb-&gt;get_col(&quot;SELECT tr.object_id FROM $wpdb-&gt;term_relationships AS tr INNER JOIN $wpdb-&gt;term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tt.term_id IN ($term_ids) ORDER BY tr.object_id $order&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $object_ids ) {&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $object_ids;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Given a taxonomy query, generates SQL to be appended to a main query.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see WP_Tax_Query</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $tax_query         A compact tax query</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $primary_table</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $primary_id_column</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_tax_sql( $tax_query, $primary_table, $primary_id_column ) {&nbsp;</div></li><li><div>  $tax_query_obj = new WP_Tax_Query( $tax_query );&nbsp;</div></li><li><div>  return $tax_query_obj-&gt;get_sql( $primary_table, $primary_id_column );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get all Term data from database by Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The usage of the get_term function is to apply filters to a term object. It</span>&nbsp;</div></li><li><div><span class="comment"> * is possible to get a term object from the database before applying the</span>&nbsp;</div></li><li><div><span class="comment"> * filters.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * $term ID must be part of $taxonomy, to get from the database. Failure, might</span>&nbsp;</div></li><li><div><span class="comment"> * be able to be captured by the hooks. Failure would be the same value as $wpdb</span>&nbsp;</div></li><li><div><span class="comment"> * returns for the get_row method.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * There are two hooks, one is specifically for each term, named 'get_term', and</span>&nbsp;</div></li><li><div><span class="comment"> * the second is for the taxonomy name, 'term_$taxonomy'. Both hooks gets the</span>&nbsp;</div></li><li><div><span class="comment"> * term object, and the taxonomy name as parameters. Both hooks are expected to</span>&nbsp;</div></li><li><div><span class="comment"> * return a Term object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * {@see 'get_term'} hook - Takes two parameters the term Object and the taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * Must return term object. Used in get_term() as a catch-all filter for every</span>&nbsp;</div></li><li><div><span class="comment"> * $term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * {@see 'get_$taxonomy'} hook - Takes two parameters the term Object and the taxonomy</span>&nbsp;</div></li><li><div><span class="comment"> * name. Must return term object. $taxonomy will be the taxonomy name, so for</span>&nbsp;</div></li><li><div><span class="comment"> * example, if 'category', it would be 'get_category' as the filter name. Useful</span>&nbsp;</div></li><li><div><span class="comment"> * for custom taxonomies or plugging into default taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @todo Better formatting for DocBlock</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Converted to return a WP_Term object if `$output` is `OBJECT`.</span>&nbsp;</div></li><li><div><span class="comment"> *              The `$taxonomy` parameter was made optional.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Term|object $term If integer, term data will be fetched from the database, or from the cache if</span>&nbsp;</div></li><li><div><span class="comment"> *                                 available. If stdClass object (as in the results of a database query), will apply</span>&nbsp;</div></li><li><div><span class="comment"> *                                 filters and return a `WP_Term` object corresponding to the `$term` data. If `WP_Term`, </span>&nbsp;</div></li><li><div><span class="comment"> *                                 will return `$term`.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $taxonomy Optional. Taxonomy name that $term is part of.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $output   Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                             a WP_Term object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $filter   Optional, default is raw or no WordPress defined filter will applied.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Term|WP_Error|null Object of the type specified by `$output` on success. When `$output` is 'OBJECT', </span>&nbsp;</div></li><li><div><span class="comment"> *                                     a WP_Term instance is returned. If taxonomy does not exist, a WP_Error is</span>&nbsp;</div></li><li><div><span class="comment"> *                                     returned. Returns null for miscellaneous failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_term( $term, $taxonomy = '', $output = OBJECT, $filter = 'raw' ) {&nbsp;</div></li><li><div>  if ( empty( $term ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_term', __( 'Empty Term' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $taxonomy && ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $term instanceof WP_Term ) {&nbsp;</div></li><li><div>      $_term = $term;&nbsp;</div></li><li><div>  } elseif ( is_object( $term ) ) {&nbsp;</div></li><li><div>      if ( empty( $term-&gt;filter ) || 'raw' === $term-&gt;filter ) {&nbsp;</div></li><li><div>          $_term = sanitize_term( $term, $taxonomy, 'raw' );&nbsp;</div></li><li><div>          $_term = new WP_Term( $_term );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $_term = WP_Term::get_instance( $term-&gt;term_id );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $_term = WP_Term::get_instance( $term, $taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error( $_term ) ) {&nbsp;</div></li><li><div>      return $_term;&nbsp;</div></li><li><div>  } elseif ( ! $_term ) {&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters a term.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0 `$_term` can now also be a WP_Term object.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|WP_Term $_term    Term object or ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string      $taxonomy The taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $_term = apply_filters( 'get_term', $_term, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters a taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the filter name, `$taxonomy`, refers</span>&nbsp;</div></li><li><div><span class="comment">   * to the taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0 `$_term` can now also be a WP_Term object.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|WP_Term $_term    Term object or ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string      $taxonomy The taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $_term = apply_filters( &quot;get_{$taxonomy}&quot;, $_term, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Bail if a filter callback has changed the type of the `$_term` object.</span>&nbsp;</div></li><li><div>  if ( ! ( $_term instanceof WP_Term ) ) {&nbsp;</div></li><li><div>      return $_term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Sanitize term, according to the specified filter.</span>&nbsp;</div></li><li><div>  $_term-&gt;filter( $filter );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $output == ARRAY_A ) {&nbsp;</div></li><li><div>      return $_term-&gt;to_array();&nbsp;</div></li><li><div>  } elseif ( $output == ARRAY_N ) {&nbsp;</div></li><li><div>      return array_values( $_term-&gt;to_array() );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $_term;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get all Term data from database by Term field and data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Warning: $value is not escaped for 'name' $field. You must do it yourself, if</span>&nbsp;</div></li><li><div><span class="comment"> * required.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The default $field is 'id', therefore it is possible to also use null for</span>&nbsp;</div></li><li><div><span class="comment"> * field, but not recommended that you do so.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If $value does not exist, the return value will be false. If $taxonomy exists</span>&nbsp;</div></li><li><div><span class="comment"> * and $field and $value combinations exist, the Term will be returned.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function will always return the first term that matches the `$field`-</span>&nbsp;</div></li><li><div><span class="comment"> * `$value`-`$taxonomy` combination specified in the parameters. If your query</span>&nbsp;</div></li><li><div><span class="comment"> * is likely to match more than one term (as is likely to be the case when</span>&nbsp;</div></li><li><div><span class="comment"> * `$field` is 'name', for example), consider using get_terms() instead; that</span>&nbsp;</div></li><li><div><span class="comment"> * way, you will get all matching terms, and can provide your own logic for</span>&nbsp;</div></li><li><div><span class="comment"> * deciding which one was intended.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @todo Better formatting for DocBlock.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 `$taxonomy` is optional if `$field` is 'term_taxonomy_id'. Converted to return</span>&nbsp;</div></li><li><div><span class="comment"> *              a WP_Term object if `$output` is `OBJECT`.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $field    Either 'slug', 'name', 'id' (term_id), or 'term_taxonomy_id'</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|int $value    Search for this term value</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $taxonomy Taxonomy name. Optional, if `$field` is 'term_taxonomy_id'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $output   Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                             a WP_Term object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $filter   Optional, default is raw or no WordPress defined filter will applied.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Term|array|false WP_Term instance (or array) on success. Will return false if `$taxonomy` does not exist</span>&nbsp;</div></li><li><div><span class="comment"> *                             or `$term` was not found.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_term_by( $field, $value, $taxonomy = '', $output = OBJECT, $filter = 'raw' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// 'term_taxonomy_id' lookups don't require taxonomy checks.</span>&nbsp;</div></li><li><div>  if ( 'term_taxonomy_id' !== $field && ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tax_clause = $wpdb-&gt;prepare( &quot;AND tt.taxonomy = %s&quot;, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'slug' == $field ) {&nbsp;</div></li><li><div>      $_field = 't.slug';&nbsp;</div></li><li><div>      $value = sanitize_title($value);&nbsp;</div></li><li><div>      if ( empty($value) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>  } elseif ( 'name' == $field ) {&nbsp;</div></li><li><div>      <span class="comment">// Assume already escaped</span>&nbsp;</div></li><li><div>      $value = wp_unslash($value);&nbsp;</div></li><li><div>      $_field = 't.name';&nbsp;</div></li><li><div>  } elseif ( 'term_taxonomy_id' == $field ) {&nbsp;</div></li><li><div>      $value = (int) $value;&nbsp;</div></li><li><div>      $_field = 'tt.term_taxonomy_id';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// No `taxonomy` clause when searching by 'term_taxonomy_id'.</span>&nbsp;</div></li><li><div>      $tax_clause = '';&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $term = get_term( (int) $value, $taxonomy, $output, $filter );&nbsp;</div></li><li><div>      if ( is_wp_error( $term ) || is_null( $term ) ) {&nbsp;</div></li><li><div>          $term = false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;SELECT t.*, tt.* FROM $wpdb-&gt;terms AS t INNER JOIN $wpdb-&gt;term_taxonomy AS tt ON t.term_id = tt.term_id WHERE $_field = %s&quot;, $value ) . &quot; $tax_clause LIMIT 1&quot; );&nbsp;</div></li><li><div>  if ( ! $term )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// In the case of 'term_taxonomy_id', override the provided `$taxonomy` with whatever we find in the db.</span>&nbsp;</div></li><li><div>  if ( 'term_taxonomy_id' === $field ) {&nbsp;</div></li><li><div>      $taxonomy = $term-&gt;taxonomy;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_add( $term-&gt;term_id, $term, 'terms' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return get_term( $term, $taxonomy, $output, $filter );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Merge all term children into a single array of their IDs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This recursive function will merge all of the children of $term into the same</span>&nbsp;</div></li><li><div><span class="comment"> * array of term IDs. Only useful for taxonomies which are hierarchical.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Will return an empty array if $term does not exist in $taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $term_id  ID of Term to get children.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Taxonomy Name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error List of Term IDs. WP_Error returned if `$taxonomy` does not exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_term_children( $term_id, $taxonomy ) {&nbsp;</div></li><li><div>  if ( ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_id = intval( $term_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $terms = _get_term_hierarchy($taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! isset($terms[$term_id]) )&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $children = $terms[$term_id];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $terms[$term_id] as $child ) {&nbsp;</div></li><li><div>      if ( $term_id == $child ) {&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset($terms[$child]) )&nbsp;</div></li><li><div>          $children = array_merge($children, get_term_children($child, $taxonomy));&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $children;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get sanitized Term field.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function is for contextual reasons and for simplicity of usage.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 The `$taxonomy` parameter was made optional. `$term` can also now accept a WP_Term object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see sanitize_term_field()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string      $field    Term field to fetch.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Term $term     Term ID or object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string      $taxonomy Optional. Taxonomy Name. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string      $context  Optional, default is display. Look at sanitize_term_field() for available options.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|int|null|WP_Error Will return an empty string if $term is not an object or if $field is not set in $term.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_term_field( $field, $term, $taxonomy = '', $context = 'display' ) {&nbsp;</div></li><li><div>  $term = get_term( $term, $taxonomy );&nbsp;</div></li><li><div>  if ( is_wp_error($term) )&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_object($term) )&nbsp;</div></li><li><div>      return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset($term-&gt;$field) )&nbsp;</div></li><li><div>      return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return sanitize_term_field( $field, $term-&gt;$field, $term-&gt;term_id, $term-&gt;taxonomy, $context );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sanitizes Term for editing.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Return value is sanitize_term() and usage is for sanitizing the term for</span>&nbsp;</div></li><li><div><span class="comment"> * editing. Function is for contextual and simplicity.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|object $id       Term ID or object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $taxonomy Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|int|null|WP_Error Will return empty string if $term is not an object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_term_to_edit( $id, $taxonomy ) {&nbsp;</div></li><li><div>  $term = get_term( $id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error($term) )&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_object($term) )&nbsp;</div></li><li><div>      return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return sanitize_term($term, $taxonomy, 'edit');&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the terms in a given taxonomy or list of taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * You can fully inject any customizations to the query before it is sent, as</span>&nbsp;</div></li><li><div><span class="comment"> * well as control the output with a filter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The {@see 'get_terms'} filter will be called when the cache has the term and will</span>&nbsp;</div></li><li><div><span class="comment"> * pass the found term along with the array of $taxonomies and array of $args.</span>&nbsp;</div></li><li><div><span class="comment"> * This filter is also called before the array of terms is passed and will pass</span>&nbsp;</div></li><li><div><span class="comment"> * the array of terms, along with the $taxonomies and $args.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The {@see 'list_terms_exclusions'} filter passes the compiled exclusions along with</span>&nbsp;</div></li><li><div><span class="comment"> * the $args.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The {@see 'get_terms_orderby'} filter passes the `ORDER BY` clause for the query</span>&nbsp;</div></li><li><div><span class="comment"> * along with the $args array.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Prior to 4.5.0, the first parameter of `get_terms()` was a taxonomy or list of taxonomies:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     $terms = get_terms( 'post_tag', array(</span>&nbsp;</div></li><li><div><span class="comment"> *         'hide_empty' =&gt; false, </span>&nbsp;</div></li><li><div><span class="comment"> * ) );</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Since 4.5.0, taxonomies should be passed via the 'taxonomy' argument in the `$args` array:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     $terms = get_terms( array(</span>&nbsp;</div></li><li><div><span class="comment"> *         'taxonomy' =&gt; 'post_tag', </span>&nbsp;</div></li><li><div><span class="comment"> *         'hide_empty' =&gt; false, </span>&nbsp;</div></li><li><div><span class="comment"> * ) );</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0 Introduced 'name' and 'childless' parameters.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Introduced the ability to pass 'term_id' as an alias of 'id' for the `orderby` parameter.</span>&nbsp;</div></li><li><div><span class="comment"> *              Introduced the 'meta_query' and 'update_term_meta_cache' parameters. Converted to return</span>&nbsp;</div></li><li><div><span class="comment"> *              a list of WP_Term objects.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0 Changed the function signature so that the `$args` array can be provided as the first parameter.</span>&nbsp;</div></li><li><div><span class="comment"> *              Introduced 'meta_key' and 'meta_value' parameters. Introduced the ability to order results by metadata.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @internal The `$deprecated` parameter is parsed for backward compatibility only.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb  $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_filter</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Array or string of arguments to get terms.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|array $taxonomy               Taxonomy name, or array of taxonomies, to which results should</span>&nbsp;</div></li><li><div><span class="comment"> *                                                be limited.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $orderby                Field(s) to order terms by. Accepts term fields ('name', 'slug', </span>&nbsp;</div></li><li><div><span class="comment"> *                                                'term_group', 'term_id', 'id', 'description'), 'count' for term</span>&nbsp;</div></li><li><div><span class="comment"> *                                                taxonomy count, 'include' to match the 'order' of the $include param, </span>&nbsp;</div></li><li><div><span class="comment"> *                                                'meta_value', 'meta_value_num', the value of `$meta_key`, the array</span>&nbsp;</div></li><li><div><span class="comment"> *                                                keys of `$meta_query`, or 'none' to omit the ORDER BY clause.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Defaults to 'name'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $order                  Whether to order terms in ascending or descending order.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Accepts 'ASC' (ascending) or 'DESC' (descending).</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Default 'ASC'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool|int     $hide_empty             Whether to hide terms not assigned to any posts. Accepts</span>&nbsp;</div></li><li><div><span class="comment"> *                                                1|true or 0|false. Default 1|true.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array|string $include                Array or comma/space-separated string of term ids to include.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array|string $exclude                Array or comma/space-separated string of term ids to exclude.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                If $include is non-empty, $exclude is ignored.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array|string $exclude_tree           Array or comma/space-separated string of term ids to exclude</span>&nbsp;</div></li><li><div><span class="comment"> *                                                along with all of their descendant terms. If $include is</span>&nbsp;</div></li><li><div><span class="comment"> *                                                non-empty, $exclude_tree is ignored. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int|string   $number                 Maximum number of terms to return. Accepts ''|0 (all) or any</span>&nbsp;</div></li><li><div><span class="comment"> *                                                positive number. Default ''|0 (all).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int          $offset                 The number by which to offset the terms query. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $fields                 Term fields to query for. Accepts 'all' (returns an array of complete</span>&nbsp;</div></li><li><div><span class="comment"> *                                                term objects), 'ids' (returns an array of ids), 'id=&gt;parent' (returns</span>&nbsp;</div></li><li><div><span class="comment"> *                                                an associative array with ids as keys, parent term IDs as values), </span>&nbsp;</div></li><li><div><span class="comment"> *                                                'names' (returns an array of term names), 'count' (returns the number</span>&nbsp;</div></li><li><div><span class="comment"> *                                                of matching terms), 'id=&gt;name' (returns an associative array with ids</span>&nbsp;</div></li><li><div><span class="comment"> *                                                as keys, term names as values), or 'id=&gt;slug' (returns an associative</span>&nbsp;</div></li><li><div><span class="comment"> *                                                array with ids as keys, term slugs as values). Default 'all'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|array $name                   Optional. Name or array of names to return term(s) for. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|array $slug                   Optional. Slug or array of slugs to return term(s) for. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool         $hierarchical           Whether to include terms that have non-empty descendants (even</span>&nbsp;</div></li><li><div><span class="comment"> *                                                if $hide_empty is set to true). Default true.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $search                 Search criteria to match terms. Will be SQL-formatted with</span>&nbsp;</div></li><li><div><span class="comment"> *                                                wildcards before and after. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $name__like             Retrieve terms with criteria by which a term is LIKE $name__like.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $description__like      Retrieve terms where the description is LIKE $description__like.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool         $pad_counts             Whether to pad the quantity of a term's children in the quantity</span>&nbsp;</div></li><li><div><span class="comment"> *                                                of each term's &quot;count&quot; object variable. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $get                    Whether to return terms regardless of ancestry or whether the terms</span>&nbsp;</div></li><li><div><span class="comment"> *                                                are empty. Accepts 'all' or empty (disabled). Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int          $child_of               Term ID to retrieve child terms of. If multiple taxonomies</span>&nbsp;</div></li><li><div><span class="comment"> *                                                are passed, $child_of is ignored. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int|string   $parent                 Parent term ID to retrieve direct-child terms of. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool         $childless              True to limit results to terms that have no children. This parameter</span>&nbsp;</div></li><li><div><span class="comment"> *                                                has no effect on non-hierarchical taxonomies. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $cache_domain           Unique cache key to be produced when this query is stored in an</span>&nbsp;</div></li><li><div><span class="comment"> *                                                object cache. Default is 'core'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool         $update_term_meta_cache Whether to prime meta caches for matched terms. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array        $meta_query             Meta query clauses to limit retrieved terms by.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                See `WP_Meta_Query`. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $meta_key               Limit terms to those matching a specific metadata key. Can be used in</span>&nbsp;</div></li><li><div><span class="comment"> *                                                conjunction with `$meta_value`.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $meta_value             Limit terms to those matching a specific metadata value. Usually used</span>&nbsp;</div></li><li><div><span class="comment"> *                                                in conjunction with `$meta_key`.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $deprecated Argument array, when using the legacy function parameter format. If present, this</span>&nbsp;</div></li><li><div><span class="comment"> *                          parameter will be interpreted as `$args`, and the first function parameter will</span>&nbsp;</div></li><li><div><span class="comment"> *                          be parsed as a taxonomy or array of taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|int|WP_Error List of WP_Term instances and their children. Will return WP_Error, if any of $taxonomies</span>&nbsp;</div></li><li><div><span class="comment"> *                            do not exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_terms( $args = array(), $deprecated = '' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_query = new WP_Term_Query();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Legacy argument format ($taxonomy, $args) takes precedence.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * We detect legacy argument format by checking if</span>&nbsp;</div></li><li><div><span class="comment">   * (a) a second non-empty parameter is passed, or</span>&nbsp;</div></li><li><div><span class="comment">   * (b) the first parameter shares no keys with the default array (ie, it's a list of taxonomies)</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $_args = wp_parse_args( $args );&nbsp;</div></li><li><div>  $key_intersect = array_intersect_key( $term_query-&gt;query_var_defaults, (array) $_args );&nbsp;</div></li><li><div>  $do_legacy_args = $deprecated || empty( $key_intersect );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $do_legacy_args ) {&nbsp;</div></li><li><div>      $taxonomies = (array) $args;&nbsp;</div></li><li><div>      $args = wp_parse_args( $deprecated );&nbsp;</div></li><li><div>      $args['taxonomy'] = $taxonomies;&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $args = wp_parse_args( $args );&nbsp;</div></li><li><div>      if ( isset( $args['taxonomy'] ) && null !== $args['taxonomy'] ) {&nbsp;</div></li><li><div>          $args['taxonomy'] = (array) $args['taxonomy'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $args['taxonomy'] ) ) {&nbsp;</div></li><li><div>      foreach ( $args['taxonomy'] as $taxonomy ) {&nbsp;</div></li><li><div>          if ( ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>              return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $terms = $term_query-&gt;query( $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Count queries are not filtered, for legacy reasons.</span>&nbsp;</div></li><li><div>  if ( ! is_array( $terms ) ) {&nbsp;</div></li><li><div>      return $terms;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the found terms.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.6.0 Added the `$term_query` parameter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array         $terms      Array of found terms.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array         $taxonomies An array of taxonomies.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array         $args       An array of get_terms() arguments.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Term_Query $term_query The WP_Term_Query object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_terms', $terms, $term_query-&gt;query_vars['taxonomy'], $term_query-&gt;query_vars, $term_query );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds metadata to a term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id    Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key   Metadata name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $meta_value Metadata value.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $unique     Optional. Whether to bail if an entry with the same key is found for the term.</span>&nbsp;</div></li><li><div><span class="comment"> *                           Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|WP_Error|bool Meta ID on success. WP_Error when term_id is ambiguous between taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *                           False on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_term_meta( $term_id, $meta_key, $meta_value, $unique = false ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// Bail if term meta table is not installed.</span></span></span></span></span>&nbsp;</div></li><li><div>  if ( get_option( 'db_version' ) &lt; 34370 ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_term_is_shared( $term_id ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'ambiguous_term_id', __( 'Term meta cannot be added to terms that are shared between taxonomies.'), $term_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $added = add_metadata( 'term', $term_id, $meta_key, $meta_value, $unique );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment">// Bust term query cache.</span></span></span>&nbsp;</div></li><li><div>  if ( $added ) {&nbsp;</div></li><li><div>      wp_cache_set( 'last_changed', microtime(), 'terms' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $added;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Removes metadata matching criteria from a term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id    Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key   Metadata name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $meta_value Optional. Metadata value. If provided, rows will only be removed that match the value.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function delete_term_meta( $term_id, $meta_key, $meta_value = '' ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// Bail if term meta table is not installed.</span></span></span></span></span>&nbsp;</div></li><li><div>  if ( get_option( 'db_version' ) &lt; 34370 ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $deleted = delete_metadata( 'term', $term_id, $meta_key, $meta_value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment">// Bust term query cache.</span></span></span>&nbsp;</div></li><li><div>  if ( $deleted ) {&nbsp;</div></li><li><div>      wp_cache_set( 'last_changed', microtime(), 'terms' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $deleted;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves metadata for a term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $key     Optional. The meta key to retrieve. If no key is provided, fetches all metadata for the term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $single  Whether to return a single value. If false, an array of all values matching the</span>&nbsp;</div></li><li><div><span class="comment"> *                        `$term_id`/`$key` pair will be returned. Default: false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed If `$single` is false, an array of metadata values. If `$single` is true, a single metadata value.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_term_meta( $term_id, $key = '', $single = false ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// Bail if term meta table is not installed.</span></span></span></span></span>&nbsp;</div></li><li><div>  if ( get_option( 'db_version' ) &lt; 34370 ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return get_metadata( 'term', $term_id, $key, $single );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates term metadata.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Use the `$prev_value` parameter to differentiate between meta fields with the same key and term ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the meta field for the term does not exist, it will be added.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id    Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key   Metadata key.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $meta_value Metadata value.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $prev_value Optional. Previous value to check before removing.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|WP_Error|bool Meta ID if the key didn't previously exist. True on successful update.</span>&nbsp;</div></li><li><div><span class="comment"> *                           WP_Error when term_id is ambiguous between taxonomies. False on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_term_meta( $term_id, $meta_key, $meta_value, $prev_value = '' ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// Bail if term meta table is not installed.</span></span></span></span></span>&nbsp;</div></li><li><div>  if ( get_option( 'db_version' ) &lt; 34370 ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_term_is_shared( $term_id ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'ambiguous_term_id', __( 'Term meta cannot be added to terms that are shared between taxonomies.'), $term_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $updated = update_metadata( 'term', $term_id, $meta_key, $meta_value, $prev_value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment">// Bust term query cache.</span></span></span>&nbsp;</div></li><li><div>  if ( $updated ) {&nbsp;</div></li><li><div>      wp_cache_set( 'last_changed', microtime(), 'terms' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $updated;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates metadata cache for list of term IDs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Performs SQL query to retrieve all metadata for the terms matching `$term_ids` and stores them in the cache.</span>&nbsp;</div></li><li><div><span class="comment"> * Subsequent calls to `get_term_meta()` will not need to query the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $term_ids List of term IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false Returns false if there is nothing to update. Returns an array of metadata on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_termmeta_cache( $term_ids ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// Bail if term meta table is not installed.</span></span></span></span></span>&nbsp;</div></li><li><div>  if ( get_option( 'db_version' ) &lt; 34370 ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return update_meta_cache( 'term', $term_ids );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check if Term exists.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Formerly is_term(), introduced in 2.3.0.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|string $term     The term to check. Accepts term ID, slug, or name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $taxonomy The taxonomy name to use</span>&nbsp;</div></li><li><div><span class="comment"> * @param int        $parent   Optional. ID of parent term under which to confine the exists search.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed Returns null if the term does not exist. Returns the term ID</span>&nbsp;</div></li><li><div><span class="comment"> *               if no taxonomy is specified and the term ID exists. Returns</span>&nbsp;</div></li><li><div><span class="comment"> *               an array of the term ID and the term taxonomy ID the taxonomy</span>&nbsp;</div></li><li><div><span class="comment"> *               is specified and the pairing exists.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function term_exists( $term, $taxonomy = '', $parent = null ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $select = &quot;SELECT term_id FROM $wpdb-&gt;terms as t WHERE &quot;;&nbsp;</div></li><li><div>  $tax_select = &quot;SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb-&gt;terms AS t INNER JOIN $wpdb-&gt;term_taxonomy as tt ON tt.term_id = t.term_id WHERE &quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_int($term) ) {&nbsp;</div></li><li><div>      if ( 0 == $term )&nbsp;</div></li><li><div>          return 0;&nbsp;</div></li><li><div>      $where = 't.term_id = %d';&nbsp;</div></li><li><div>      if ( !empty($taxonomy) )&nbsp;</div></li><li><div>          return $wpdb-&gt;get_row( $wpdb-&gt;prepare( $tax_select . $where . &quot; AND tt.taxonomy = %s&quot;, $term, $taxonomy ), ARRAY_A );&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          return $wpdb-&gt;get_var( $wpdb-&gt;prepare( $select . $where, $term ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term = trim( wp_unslash( $term ) );&nbsp;</div></li><li><div>  $slug = sanitize_title( $term );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $where = 't.slug = %s';&nbsp;</div></li><li><div>  $else_where = 't.name = %s';&nbsp;</div></li><li><div>  $where_fields = array($slug);&nbsp;</div></li><li><div>  $else_where_fields = array($term);&nbsp;</div></li><li><div>  $orderby = 'ORDER BY t.term_id ASC';&nbsp;</div></li><li><div>  $limit = 'LIMIT 1';&nbsp;</div></li><li><div>  if ( !empty($taxonomy) ) {&nbsp;</div></li><li><div>      if ( is_numeric( $parent ) ) {&nbsp;</div></li><li><div>          $parent = (int) $parent;&nbsp;</div></li><li><div>          $where_fields[] = $parent;&nbsp;</div></li><li><div>          $else_where_fields[] = $parent;&nbsp;</div></li><li><div>          $where .= ' AND tt.parent = %d';&nbsp;</div></li><li><div>          $else_where .= ' AND tt.parent = %d';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $where_fields[] = $taxonomy;&nbsp;</div></li><li><div>      $else_where_fields[] = $taxonomy;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $result = $wpdb-&gt;get_row( $wpdb-&gt;prepare(&quot;SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb-&gt;terms AS t INNER JOIN $wpdb-&gt;term_taxonomy as tt ON tt.term_id = t.term_id WHERE $where AND tt.taxonomy = %s $orderby $limit&quot;, $where_fields), ARRAY_A) )&nbsp;</div></li><li><div>          return $result;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $wpdb-&gt;get_row( $wpdb-&gt;prepare(&quot;SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb-&gt;terms AS t INNER JOIN $wpdb-&gt;term_taxonomy as tt ON tt.term_id = t.term_id WHERE $else_where AND tt.taxonomy = %s $orderby $limit&quot;, $else_where_fields), ARRAY_A);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $result = $wpdb-&gt;get_var( $wpdb-&gt;prepare(&quot;SELECT term_id FROM $wpdb-&gt;terms as t WHERE $where $orderby $limit&quot;, $where_fields) ) )&nbsp;</div></li><li><div>      return $result;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $wpdb-&gt;get_var( $wpdb-&gt;prepare(&quot;SELECT term_id FROM $wpdb-&gt;terms as t WHERE $else_where $orderby $limit&quot;, $else_where_fields) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check if a term is an ancestor of another term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * You can use either an id or the term object for both parameters.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|object $term1    ID or object to check if this is the parent term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|object $term2    The child term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string     $taxonomy Taxonomy name that $term1 and `$term2` belong to.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether `$term2` is a child of `$term1`.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function term_is_ancestor_of( $term1, $term2, $taxonomy ) {&nbsp;</div></li><li><div>  if ( ! isset( $term1-&gt;term_id ) )&nbsp;</div></li><li><div>      $term1 = get_term( $term1, $taxonomy );&nbsp;</div></li><li><div>  if ( ! isset( $term2-&gt;parent ) )&nbsp;</div></li><li><div>      $term2 = get_term( $term2, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $term1-&gt;term_id ) || empty( $term2-&gt;parent ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  if ( $term2-&gt;parent == $term1-&gt;term_id )&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return term_is_ancestor_of( $term1, get_term( $term2-&gt;parent, $taxonomy ), $taxonomy );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sanitize Term all fields.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Relies on sanitize_term_field() to sanitize the term. The difference is that</span>&nbsp;</div></li><li><div><span class="comment"> * this function will sanitize &lt;strong&gt;all&lt;/strong&gt; fields. The context is based</span>&nbsp;</div></li><li><div><span class="comment"> * on sanitize_term_field().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The $term is expected to be either an array or an object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|object $term     The term to check.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $taxonomy The taxonomy name to use.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $context  Optional. Context in which to sanitize the term. Accepts 'edit', 'db', </span>&nbsp;</div></li><li><div><span class="comment"> *                               'display', 'attribute', or 'js'. Default 'display'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|object Term with all fields sanitized.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function sanitize_term($term, $taxonomy, $context = 'display') {&nbsp;</div></li><li><div>  $fields = array( 'term_id', 'name', 'description', 'slug', 'count', 'parent', 'term_group', 'term_taxonomy_id', 'object_id' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $do_object = is_object( $term );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_id = $do_object ? $term-&gt;term_id : (isset($term['term_id']) ? $term['term_id'] : 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $fields as $field ) {&nbsp;</div></li><li><div>      if ( $do_object ) {&nbsp;</div></li><li><div>          if ( isset($term-&gt;$field) )&nbsp;</div></li><li><div>              $term-&gt;$field = sanitize_term_field($field, $term-&gt;$field, $term_id, $taxonomy, $context);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          if ( isset($term[$field]) )&nbsp;</div></li><li><div>              $term[$field] = sanitize_term_field($field, $term[$field], $term_id, $taxonomy, $context);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $do_object )&nbsp;</div></li><li><div>      $term-&gt;filter = $context;&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $term['filter'] = $context;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $term;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Cleanse the field value in the term based on the context.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Passing a term field value through the function should be assumed to have</span>&nbsp;</div></li><li><div><span class="comment"> * cleansed the value for whatever context the term field is going to be used.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If no context or an unsupported context is given, then default filters will</span>&nbsp;</div></li><li><div><span class="comment"> * be applied.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * There are enough filters for each context to support a custom filtering</span>&nbsp;</div></li><li><div><span class="comment"> * without creating your own filter function. Simply create a function that</span>&nbsp;</div></li><li><div><span class="comment"> * hooks into the filter you need.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $field    Term field to sanitize.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $value    Search for this term value.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Taxonomy Name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $context  Context in which to sanitize the term field. Accepts 'edit', 'db', 'display', </span>&nbsp;</div></li><li><div><span class="comment"> *                         'attribute', or 'js'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed Sanitized field.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function sanitize_term_field($field, $value, $term_id, $taxonomy, $context) {&nbsp;</div></li><li><div>  $int_fields = array( 'parent', 'term_id', 'count', 'term_group', 'term_taxonomy_id', 'object_id' );&nbsp;</div></li><li><div>  if ( in_array( $field, $int_fields ) ) {&nbsp;</div></li><li><div>      $value = (int) $value;&nbsp;</div></li><li><div>      if ( $value &lt; 0 )&nbsp;</div></li><li><div>          $value = 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'raw' == $context )&nbsp;</div></li><li><div>      return $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'edit' == $context ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters a term field to edit before it is sanitized.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portion of the filter name, `$field`, refers to the term field.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed $value     Value of the term field.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int   $term_id   Term ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;edit_term_{$field}&quot;, $value, $term_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the taxonomy field to edit before it is sanitized.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portions of the filter name, `$taxonomy` and `$field`, refer</span>&nbsp;</div></li><li><div><span class="comment">       * to the taxonomy slug and taxonomy field, respectively.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed $value   Value of the taxonomy field to edit.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int   $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;edit_{$taxonomy}_{$field}&quot;, $value, $term_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'description' == $field )&nbsp;</div></li><li><div>          $value = esc_html($value); <span class="comment">// textarea_escaped</span>&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $value = esc_attr($value);&nbsp;</div></li><li><div>  } elseif ( 'db' == $context ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters a term field value before it is sanitized.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portion of the filter name, `$field`, refers to the term field.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed  $value    Value of the term field.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;pre_term_{$field}&quot;, $value, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters a taxonomy field before it is sanitized.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portions of the filter name, `$taxonomy` and `$field`, refer</span>&nbsp;</div></li><li><div><span class="comment">       * to the taxonomy slug and field name, respectively.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed $value Value of the taxonomy field.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;pre_{$taxonomy}_{$field}&quot;, $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Back compat filters</span>&nbsp;</div></li><li><div>      if ( 'slug' == $field ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the category nicename before it is sanitized.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * Use the {@see 'pre_$taxonomy_$field'} hook instead.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.3</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $value The category nicename.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $value = apply_filters( 'pre_category_nicename', $value );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  } elseif ( 'rss' == $context ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the term field for use in RSS.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portion of the filter name, `$field`, refers to the term field.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed  $value    Value of the term field.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;term_{$field}_rss&quot;, $value, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the taxonomy field for use in RSS.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portions of the hook name, `$taxonomy`, and `$field`, refer</span>&nbsp;</div></li><li><div><span class="comment">       * to the taxonomy slug and field name, respectively.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed $value Value of the taxonomy field.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;{$taxonomy}_{$field}_rss&quot;, $value );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment">// Use display filters by default.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the term field sanitized for display.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portion of the filter name, `$field`, refers to the term field name.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed  $value    Value of the term field.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $context  Context to retrieve the term field value.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;term_{$field}&quot;, $value, $term_id, $taxonomy, $context );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the taxonomy field sanitized for display.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The dynamic portions of the filter name, `$taxonomy`, and `$field`, refer</span>&nbsp;</div></li><li><div><span class="comment">       * to the taxonomy slug and taxonomy field, respectively.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param mixed  $value   Value of the taxonomy field.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $context Context to retrieve the taxonomy field value.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $value = apply_filters( &quot;{$taxonomy}_{$field}&quot;, $value, $term_id, $context );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attribute' == $context ) {&nbsp;</div></li><li><div>      $value = esc_attr($value);&nbsp;</div></li><li><div>  } elseif ( 'js' == $context ) {&nbsp;</div></li><li><div>      $value = esc_js($value);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $value;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Count how many terms are in Taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Default $args is 'hide_empty' which can be 'hide_empty=true' or array('hide_empty' =&gt; true).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $taxonomy Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args     Optional. Array of arguments that get passed to get_terms().</span>&nbsp;</div></li><li><div><span class="comment"> *                               Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|int|WP_Error Number of terms in that taxonomy or WP_Error if the taxonomy does not exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_count_terms( $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>  $defaults = array('hide_empty' =&gt; false);&nbsp;</div></li><li><div>  $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// backward compatibility</span>&nbsp;</div></li><li><div>  if ( isset($args['ignore_empty']) ) {&nbsp;</div></li><li><div>      $args['hide_empty'] = $args['ignore_empty'];&nbsp;</div></li><li><div>      unset($args['ignore_empty']);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args['fields'] = 'count';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return get_terms($taxonomy, $args);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Will unlink the object from the taxonomy or taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Will remove all relationships between the object and any terms in</span>&nbsp;</div></li><li><div><span class="comment"> * a particular taxonomy or taxonomies. Does not remove the term or</span>&nbsp;</div></li><li><div><span class="comment"> * taxonomy itself.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int          $object_id  The term Object Id that refers to the term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $taxonomies List of Taxonomy Names or single Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_delete_object_term_relationships( $object_id, $taxonomies ) {&nbsp;</div></li><li><div>  $object_id = (int) $object_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($taxonomies) )&nbsp;</div></li><li><div>      $taxonomies = array($taxonomies);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>      $term_ids = wp_get_object_terms( $object_id, $taxonomy, array( 'fields' =&gt; 'ids' ) );&nbsp;</div></li><li><div>      $term_ids = array_map( 'intval', $term_ids );&nbsp;</div></li><li><div>      wp_remove_object_terms( $object_id, $term_ids, $taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Removes a term from the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the term is a parent of other terms, then the children will be updated to</span>&nbsp;</div></li><li><div><span class="comment"> * that term's parent.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Metadata associated with the term will be deleted.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int          $term     Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $taxonomy Taxonomy Name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Array of arguments to override the default term ID. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int  $default       The term ID to make the default term. This will only override</span>&nbsp;</div></li><li><div><span class="comment"> *                               the terms found if there is only one term found. Any other and</span>&nbsp;</div></li><li><div><span class="comment"> *                               the found terms are used.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool $force_default Optional. Whether to force the supplied term as default to be</span>&nbsp;</div></li><li><div><span class="comment"> *                               assigned even if the object was not going to be term-less.</span>&nbsp;</div></li><li><div><span class="comment"> *                               Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|int|WP_Error True on success, false if term does not exist. Zero on attempted</span>&nbsp;</div></li><li><div><span class="comment"> *                           deletion of default Category. WP_Error if the taxonomy does not exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_delete_term( $term, $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term = (int) $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $ids = term_exists($term, $taxonomy) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  if ( is_wp_error( $ids ) )&nbsp;</div></li><li><div>      return $ids;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tt_id = $ids['term_taxonomy_id'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'category' == $taxonomy ) {&nbsp;</div></li><li><div>      $defaults['default'] = get_option( 'default_category' );&nbsp;</div></li><li><div>      if ( $defaults['default'] == $term )&nbsp;</div></li><li><div>          return 0; <span class="comment">// Don't delete the default category</span>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $args['default'] ) ) {&nbsp;</div></li><li><div>      $default = (int) $args['default'];&nbsp;</div></li><li><div>      if ( ! term_exists( $default, $taxonomy ) ) {&nbsp;</div></li><li><div>          unset( $default );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $args['force_default'] ) ) {&nbsp;</div></li><li><div>      $force_default = $args['force_default'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires when deleting a term, before any modifications are made to posts or terms.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term     Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'pre_delete_term', $term, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Update children to point to new parent</span>&nbsp;</div></li><li><div>  if ( is_taxonomy_hierarchical($taxonomy) ) {&nbsp;</div></li><li><div>      $term_obj = get_term($term, $taxonomy);&nbsp;</div></li><li><div>      if ( is_wp_error( $term_obj ) )&nbsp;</div></li><li><div>          return $term_obj;&nbsp;</div></li><li><div>      $parent = $term_obj-&gt;parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $edit_ids = $wpdb-&gt;get_results( &quot;SELECT term_id, term_taxonomy_id FROM $wpdb-&gt;term_taxonomy WHERE `parent` = &quot; . (int)$term_obj-&gt;term_id );&nbsp;</div></li><li><div>      $edit_tt_ids = wp_list_pluck( $edit_ids, 'term_taxonomy_id' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately before a term to delete's children are reassigned a parent.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $edit_tt_ids An array of term taxonomy IDs for the given term.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'edit_term_taxonomies', $edit_tt_ids );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $wpdb-&gt;update( $wpdb-&gt;term_taxonomy, compact( 'parent' ), array( 'parent' =&gt; $term_obj-&gt;term_id) + compact( 'taxonomy' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Clean the cache for all child terms.</span>&nbsp;</div></li><li><div>      $edit_term_ids = wp_list_pluck( $edit_ids, 'term_id' );&nbsp;</div></li><li><div>      clean_term_cache( $edit_term_ids, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a term to delete's children are reassigned a parent.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $edit_tt_ids An array of term taxonomy IDs for the given term.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'edited_term_taxonomies', $edit_tt_ids );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Get the term before deleting it or its term relationships so we can pass to actions below.</span>&nbsp;</div></li><li><div>  $deleted_term = get_term( $term, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_ids = (array) $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT object_id FROM $wpdb-&gt;term_relationships WHERE term_taxonomy_id = %d&quot;, $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $object_ids as $object_id ) {&nbsp;</div></li><li><div>      $terms = wp_get_object_terms( $object_id, $taxonomy, array( 'fields' =&gt; 'ids', 'orderby' =&gt; 'none' ) );&nbsp;</div></li><li><div>      if ( 1 == count($terms) && isset($default) ) {&nbsp;</div></li><li><div>          $terms = array($default);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $terms = array_diff($terms, array($term));&nbsp;</div></li><li><div>          if (isset($default) && isset($force_default) && $force_default)&nbsp;</div></li><li><div>              $terms = array_merge($terms, array($default));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $terms = array_map('intval', $terms);&nbsp;</div></li><li><div>      wp_set_object_terms( $object_id, $terms, $taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Clean the relationship caches for all object types using this term.</span>&nbsp;</div></li><li><div>  $tax_object = get_taxonomy( $taxonomy );&nbsp;</div></li><li><div>  foreach ( $tax_object-&gt;object_type as $object_type )&nbsp;</div></li><li><div>      clean_object_term_cache( $object_ids, $object_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_meta_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT meta_id FROM $wpdb-&gt;termmeta WHERE term_id = %d &quot;, $term ) );&nbsp;</div></li><li><div>  foreach ( $term_meta_ids as $mid ) {&nbsp;</div></li><li><div>      delete_metadata_by_mid( 'term', $mid );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a term taxonomy ID is deleted.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $tt_id Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'delete_term_taxonomy', $tt_id );&nbsp;</div></li><li><div>  $wpdb-&gt;delete( $wpdb-&gt;term_taxonomy, array( 'term_taxonomy_id' =&gt; $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a term taxonomy ID is deleted.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $tt_id Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'deleted_term_taxonomy', $tt_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Delete the term if no taxonomies use it.</span>&nbsp;</div></li><li><div>  if ( !$wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(*) FROM $wpdb-&gt;term_taxonomy WHERE term_id = %d&quot;, $term) ) )&nbsp;</div></li><li><div>      $wpdb-&gt;delete( $wpdb-&gt;terms, array( 'term_id' =&gt; $term ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_term_cache($term, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a term is deleted from the database and the cache is cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0 Introduced the `$object_ids` argument.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $term         Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $tt_id        Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string  $taxonomy     Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param mixed   $deleted_term Copy of the already-deleted term, in the form specified</span>&nbsp;</div></li><li><div><span class="comment">   *                              by the parent function. WP_Error otherwise.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array   $object_ids   List of term object IDs.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'delete_term', $term, $tt_id, $taxonomy, $deleted_term, $object_ids );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a term in a specific taxonomy is deleted.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$taxonomy`, refers to the specific</span>&nbsp;</div></li><li><div><span class="comment">   * taxonomy the term belonged to.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0 Introduced the `$object_ids` argument.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $term         Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $tt_id        Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param mixed   $deleted_term Copy of the already-deleted term, in the form specified</span>&nbsp;</div></li><li><div><span class="comment">   *                              by the parent function. WP_Error otherwise.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array   $object_ids   List of term object IDs.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;delete_{$taxonomy}&quot;, $term, $tt_id, $deleted_term, $object_ids );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Deletes one existing category.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $cat_ID</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|int|WP_Error Returns true if completes delete action; false if term doesn't exist;</span>&nbsp;</div></li><li><div><span class="comment"> *     Zero on attempted deletion of default Category; WP_Error object is also a possibility.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_delete_category( $cat_ID ) {&nbsp;</div></li><li><div>  return wp_delete_term( $cat_ID, 'category' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves the terms associated with the given object(s), in the supplied taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0 Added support for 'taxonomy', 'parent', and 'term_taxonomy_id' values of `$orderby`.</span>&nbsp;</div></li><li><div><span class="comment"> *              Introduced `$parent` argument.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Introduced `$meta_query` and `$update_term_meta_cache` arguments. When `$fields` is 'all' or</span>&nbsp;</div></li><li><div><span class="comment"> *              'all_with_object_id', an array of `WP_Term` objects will be returned.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Refactored to use WP_Term_Query, and to support any WP_Term_Query arguments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|array    $object_ids The ID(s) of the object(s) to retrieve.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $taxonomies The taxonomies to retrieve terms from.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args       See WP_Term_Query::__construct() for supported arguments.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error The requested term data or empty array if no terms found.</span>&nbsp;</div></li><li><div><span class="comment"> *                        WP_Error if any of the $taxonomies don't exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_object_terms($object_ids, $taxonomies, $args = array()) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $object_ids ) || empty( $taxonomies ) )&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($taxonomies) )&nbsp;</div></li><li><div>      $taxonomies = array($taxonomies);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>      if ( ! taxonomy_exists($taxonomy) )&nbsp;</div></li><li><div>          return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($object_ids) )&nbsp;</div></li><li><div>      $object_ids = array($object_ids);&nbsp;</div></li><li><div>  $object_ids = array_map('intval', $object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args = wp_parse_args( $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args['taxonomy'] = $taxonomies;&nbsp;</div></li><li><div>  $args['object_ids'] = $object_ids;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $terms = get_terms( $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the terms for a given object or objects.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $terms      An array of terms for the given object or objects.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $object_ids Array of object IDs for which `$terms` were retrieved.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $taxonomies Array of taxonomies from which `$terms` were retrieved.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $args       An array of arguments for retrieving terms for the given</span>&nbsp;</div></li><li><div><span class="comment">   *                          object(s). See wp_get_object_terms() for details.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $terms = apply_filters( 'get_object_terms', $terms, $object_ids, $taxonomies, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_ids = implode( ', ', $object_ids );&nbsp;</div></li><li><div>  $taxonomies = implode( ', ', $taxonomies );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the terms for a given object or objects.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The `$taxonomies` parameter passed to this filter is formatted as a SQL fragment. The</span>&nbsp;</div></li><li><div><span class="comment">   * {@see 'get_object_terms'} filter is recommended as an alternative.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array     $terms      An array of terms for the given object or objects.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|array $object_ids Object ID or array of IDs.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string    $taxonomies SQL-formatted (comma-separated and quoted) list of taxonomy names.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array     $args       An array of arguments for retrieving terms for the given object(s).</span>&nbsp;</div></li><li><div><span class="comment">   *                              See wp_get_object_terms() for details.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_get_object_terms', $terms, $object_ids, $taxonomies, $args );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add a new term to the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A non-existent term is inserted in the following sequence:</span>&nbsp;</div></li><li><div><span class="comment"> * 1. The term is added to the term table, then related to the taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> * 2. If everything is correct, several actions are fired.</span>&nbsp;</div></li><li><div><span class="comment"> * 3. The 'term_id_filter' is evaluated.</span>&nbsp;</div></li><li><div><span class="comment"> * 4. The term cache is cleaned.</span>&nbsp;</div></li><li><div><span class="comment"> * 5. Several more actions are fired.</span>&nbsp;</div></li><li><div><span class="comment"> * 6. An array is returned containing the term_id and term_taxonomy_id.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the 'slug' argument is not empty, then it is checked to see if the term</span>&nbsp;</div></li><li><div><span class="comment"> * is invalid. If it is not a valid, existing term, it is added and the term_id</span>&nbsp;</div></li><li><div><span class="comment"> * is given.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the taxonomy is hierarchical, and the 'parent' argument is not empty, </span>&nbsp;</div></li><li><div><span class="comment"> * the term is inserted and the term_id will be given.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Error handling:</span>&nbsp;</div></li><li><div><span class="comment"> * If $taxonomy does not exist or $term is empty, </span>&nbsp;</div></li><li><div><span class="comment"> * a WP_Error object will be returned.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the term already exists on the same hierarchical level, </span>&nbsp;</div></li><li><div><span class="comment"> * or the term slug and name are not unique, a WP_Error object will be returned.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $term     The term to add or update.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $taxonomy The taxonomy to which to add the term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Array or string of arguments for inserting a term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $alias_of    Slug of the term to make this term an alias of.</span>&nbsp;</div></li><li><div><span class="comment"> *                               Default empty string. Accepts a term slug.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $description The term description. Default empty string.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $parent      The id of the parent term. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $slug        The term slug to use. Default empty string.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error An array containing the `term_id` and `term_taxonomy_id`, </span>&nbsp;</div></li><li><div><span class="comment"> *                        WP_Error otherwise.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_insert_term( $term, $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! taxonomy_exists($taxonomy) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters a term before it is sanitized and inserted into the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $term     The term to add or update.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $term = apply_filters( 'pre_insert_term', $term, $taxonomy );&nbsp;</div></li><li><div>  if ( is_wp_error( $term ) ) {&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( is_int( $term ) && 0 == $term ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_term_id', __( 'Invalid term ID.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( '' == trim( $term ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'empty_term_name', __( 'A name is required for this term.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $defaults = array( 'alias_of' =&gt; '', 'description' =&gt; '', 'parent' =&gt; 0, 'slug' =&gt; '');&nbsp;</div></li><li><div>  $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $args['parent'] &gt; 0 && ! term_exists( (int) $args['parent'] ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'missing_parent', __( 'Parent term does not exist.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args['name'] = $term;&nbsp;</div></li><li><div>  $args['taxonomy'] = $taxonomy;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Coerce null description to strings, to avoid database errors.</span>&nbsp;</div></li><li><div>  $args['description'] = (string) $args['description'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args = sanitize_term($args, $taxonomy, 'db');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// expected_slashed ($name)</span></span>&nbsp;</div></li><li><div>  $name = wp_unslash( $args['name'] );&nbsp;</div></li><li><div>  $description = wp_unslash( $args['description'] );&nbsp;</div></li><li><div>  $parent = (int) $args['parent'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $slug_provided = ! empty( $args['slug'] );&nbsp;</div></li><li><div>  if ( ! $slug_provided ) {&nbsp;</div></li><li><div>      $slug = sanitize_title( $name );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $slug = $args['slug'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_group = 0;&nbsp;</div></li><li><div>  if ( $args['alias_of'] ) {&nbsp;</div></li><li><div>      $alias = get_term_by( 'slug', $args['alias_of'], $taxonomy );&nbsp;</div></li><li><div>      if ( ! empty( $alias-&gt;term_group ) ) {&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// The alias we want is already in a group, so let's use that one.</span></span>&nbsp;</div></li><li><div>          $term_group = $alias-&gt;term_group;&nbsp;</div></li><li><div>      } elseif ( ! empty( $alias-&gt;term_id ) ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * The alias is not in a group, so we create a new one</span>&nbsp;</div></li><li><div><span class="comment">           * and add the alias to it.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $term_group = $wpdb-&gt;get_var(&quot;SELECT MAX(term_group) FROM $wpdb-&gt;terms&quot;) + 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          wp_update_term( $alias-&gt;term_id, $taxonomy, array(&nbsp;</div></li><li><div>              'term_group' =&gt; $term_group, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Prevent the creation of terms with duplicate names at the same level of a taxonomy hierarchy, </span>&nbsp;</div></li><li><div><span class="comment">   * unless a unique slug has been explicitly provided.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $name_matches = get_terms( $taxonomy, array(&nbsp;</div></li><li><div>      'name' =&gt; $name, &nbsp;</div></li><li><div>      'hide_empty' =&gt; false, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The `name` match in `get_terms()` doesn't differentiate accented characters, </span>&nbsp;</div></li><li><div><span class="comment">   * so we do a stricter comparison here.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $name_match = null;&nbsp;</div></li><li><div>  if ( $name_matches ) {&nbsp;</div></li><li><div>      foreach ( $name_matches as $_match ) {&nbsp;</div></li><li><div>          if ( strtolower( $name ) === strtolower( $_match-&gt;name ) ) {&nbsp;</div></li><li><div>              $name_match = $_match;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $name_match ) {&nbsp;</div></li><li><div>      $slug_match = get_term_by( 'slug', $slug, $taxonomy );&nbsp;</div></li><li><div>      if ( ! $slug_provided || $name_match-&gt;slug === $slug || $slug_match ) {&nbsp;</div></li><li><div>          if ( is_taxonomy_hierarchical( $taxonomy ) ) {&nbsp;</div></li><li><div>              $siblings = get_terms( $taxonomy, array( 'get' =&gt; 'all', 'parent' =&gt; $parent ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $existing_term = null;&nbsp;</div></li><li><div>              if ( $name_match-&gt;slug === $slug && in_array( $name, wp_list_pluck( $siblings, 'name' ) ) ) {&nbsp;</div></li><li><div>                  $existing_term = $name_match;&nbsp;</div></li><li><div>              } elseif ( $slug_match && in_array( $slug, wp_list_pluck( $siblings, 'slug' ) ) ) {&nbsp;</div></li><li><div>                  $existing_term = $slug_match;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( $existing_term ) {&nbsp;</div></li><li><div>                  return new WP_Error( 'term_exists', __( 'A term with the name provided already exists with this parent.' ), $existing_term-&gt;term_id );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              return new WP_Error( 'term_exists', __( 'A term with the name provided already exists in this taxonomy.' ), $name_match-&gt;term_id );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $slug = wp_unique_term_slug( $slug, (object) $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $data = compact( 'name', 'slug', 'term_group' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters term data before it is inserted into the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $data     Term data to be inserted.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $args     Arguments passed to wp_insert_term().</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $data = apply_filters( 'wp_insert_term_data', $data, $taxonomy, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( false === $wpdb-&gt;insert( $wpdb-&gt;terms, $data ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'db_insert_error', __( 'Could not insert term into the database' ), $wpdb-&gt;last_error );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_id = (int) $wpdb-&gt;insert_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Seems unreachable, However, Is used in the case that a term name is provided, which sanitizes to an empty string.</span>&nbsp;</div></li><li><div>  if ( empty($slug) ) {&nbsp;</div></li><li><div>      $slug = sanitize_title($slug, $term_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/taxonomy.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>      do_action( 'edit_terms', $term_id, $taxonomy );&nbsp;</div></li><li><div>      $wpdb-&gt;update( $wpdb-&gt;terms, compact( 'slug' ), compact( 'term_id' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/taxonomy.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>      do_action( 'edited_terms', $term_id, $taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tt_id = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT tt.term_taxonomy_id FROM $wpdb-&gt;term_taxonomy AS tt INNER JOIN $wpdb-&gt;terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d&quot;, $taxonomy, $term_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !empty($tt_id) ) {&nbsp;</div></li><li><div>      return array('term_id' =&gt; $term_id, 'term_taxonomy_id' =&gt; $tt_id);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $wpdb-&gt;insert( $wpdb-&gt;term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent') + array( 'count' =&gt; 0 ) );&nbsp;</div></li><li><div>  $tt_id = (int) $wpdb-&gt;insert_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Sanity check: if we just created a term with the same parent + taxonomy + slug but a higher term_id than</span>&nbsp;</div></li><li><div><span class="comment">   * an existing term, then we have unwittingly created a duplicate term. Delete the dupe, and use the term_id</span>&nbsp;</div></li><li><div><span class="comment">   * and term_taxonomy_id of the older term instead. Then return out of the function so that the &quot;create&quot; hooks</span>&nbsp;</div></li><li><div><span class="comment">   * are not fired.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $duplicate_term = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;SELECT t.term_id, tt.term_taxonomy_id FROM $wpdb-&gt;terms t INNER JOIN $wpdb-&gt;term_taxonomy tt ON ( tt.term_id = t.term_id ) WHERE t.slug = %s AND tt.parent = %d AND tt.taxonomy = %s AND t.term_id &lt; %d AND tt.term_taxonomy_id != %d&quot;, $slug, $parent, $taxonomy, $term_id, $tt_id ) );&nbsp;</div></li><li><div>  if ( $duplicate_term ) {&nbsp;</div></li><li><div>      $wpdb-&gt;delete( $wpdb-&gt;terms, array( 'term_id' =&gt; $term_id ) );&nbsp;</div></li><li><div>      $wpdb-&gt;delete( $wpdb-&gt;term_taxonomy, array( 'term_taxonomy_id' =&gt; $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_id = (int) $duplicate_term-&gt;term_id;&nbsp;</div></li><li><div>      $tt_id = (int) $duplicate_term-&gt;term_taxonomy_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      clean_term_cache( $term_id, $taxonomy );&nbsp;</div></li><li><div>      return array( 'term_id' =&gt; $term_id, 'term_taxonomy_id' =&gt; $tt_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a new term is created, before the term cache is cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $tt_id    Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;create_term&quot;, $term_id, $tt_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a new term is created for a specific taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$taxonomy`, refers</span>&nbsp;</div></li><li><div><span class="comment">   * to the slug of the taxonomy the term was created for.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $tt_id   Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;create_{$taxonomy}&quot;, $term_id, $tt_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the term ID after a new term is created.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $tt_id   Taxonomy term ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $term_id = apply_filters( 'term_id_filter', $term_id, $tt_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_term_cache($term_id, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a new term is created, and after the term cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $tt_id    Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'created_term', $term_id, $tt_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a new term in a specific taxonomy is created, and after the term</span>&nbsp;</div></li><li><div><span class="comment">   * cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$taxonomy`, refers to the taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $tt_id   Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;created_{$taxonomy}&quot;, $term_id, $tt_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return array('term_id' =&gt; $term_id, 'term_taxonomy_id' =&gt; $tt_id);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Create Term and Taxonomy Relationships.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Relates an object (post, link etc) to a term and taxonomy type. Creates the</span>&nbsp;</div></li><li><div><span class="comment"> * term and taxonomy relationship if it doesn't already exist. Creates a term if</span>&nbsp;</div></li><li><div><span class="comment"> * it doesn't exist (using the slug).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A relationship means that the term is grouped in or belongs to the taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> * A term has no meaning until it is given context by defining which taxonomy it</span>&nbsp;</div></li><li><div><span class="comment"> * exists under.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb The WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int              $object_id The object to relate to.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|int|string $terms     A single term slug, single term id, or array of either term slugs or ids.</span>&nbsp;</div></li><li><div><span class="comment"> *                                    Will replace all existing related terms in this taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string           $taxonomy  The context in which to relate the term to the object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool             $append    Optional. If false will delete difference of terms. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error Term taxonomy IDs of the affected terms.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_set_object_terms( $object_id, $terms, $taxonomy, $append = false ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_id = (int) $object_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($terms) )&nbsp;</div></li><li><div>      $terms = array($terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $append )&nbsp;</div></li><li><div>      $old_tt_ids =  wp_get_object_terms($object_id, $taxonomy, array('fields' =&gt; 'tt_ids', 'orderby' =&gt; 'none'));&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $old_tt_ids = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tt_ids = array();&nbsp;</div></li><li><div>  $term_ids = array();&nbsp;</div></li><li><div>  $new_tt_ids = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $terms as $term) {&nbsp;</div></li><li><div>      if ( !strlen(trim($term)) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !$term_info = term_exists($term, $taxonomy) ) {&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// Skip if a non-existent term ID is passed.</span></span>&nbsp;</div></li><li><div>          if ( is_int($term) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          $term_info = wp_insert_term($term, $taxonomy);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( is_wp_error($term_info) )&nbsp;</div></li><li><div>          return $term_info;&nbsp;</div></li><li><div>      $term_ids[] = $term_info['term_id'];&nbsp;</div></li><li><div>      $tt_id = $term_info['term_taxonomy_id'];&nbsp;</div></li><li><div>      $tt_ids[] = $tt_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT term_taxonomy_id FROM $wpdb-&gt;term_relationships WHERE object_id = %d AND term_taxonomy_id = %d&quot;, $object_id, $tt_id ) ) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately before an object-term relationship is added.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.7.0 Added the `$taxonomy` parameter.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $object_id Object ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $tt_id     Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy  Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'add_term_relationship', $object_id, $tt_id, $taxonomy );&nbsp;</div></li><li><div>      $wpdb-&gt;insert( $wpdb-&gt;term_relationships, array( 'object_id' =&gt; $object_id, 'term_taxonomy_id' =&gt; $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after an object-term relationship is added.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.7.0 Added the `$taxonomy` parameter.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $object_id Object ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $tt_id     Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy  Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'added_term_relationship', $object_id, $tt_id, $taxonomy );&nbsp;</div></li><li><div>      $new_tt_ids[] = $tt_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $new_tt_ids )&nbsp;</div></li><li><div>      wp_update_term_count( $new_tt_ids, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $append ) {&nbsp;</div></li><li><div>      $delete_tt_ids = array_diff( $old_tt_ids, $tt_ids );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $delete_tt_ids ) {&nbsp;</div></li><li><div>          $in_delete_tt_ids = &quot;'&quot; . implode( &quot;', '&quot;, $delete_tt_ids ) . &quot;'&quot;;&nbsp;</div></li><li><div>          $delete_term_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT tt.term_id FROM $wpdb-&gt;term_taxonomy AS tt WHERE tt.taxonomy = %s AND tt.term_taxonomy_id IN ($in_delete_tt_ids)&quot;, $taxonomy ) );&nbsp;</div></li><li><div>          $delete_term_ids = array_map( 'intval', $delete_term_ids );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $remove = wp_remove_object_terms( $object_id, $delete_term_ids, $taxonomy );&nbsp;</div></li><li><div>          if ( is_wp_error( $remove ) ) {&nbsp;</div></li><li><div>              return $remove;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $t = get_taxonomy($taxonomy);&nbsp;</div></li><li><div>  if ( ! $append && isset($t-&gt;sort) && $t-&gt;sort ) {&nbsp;</div></li><li><div>      $values = array();&nbsp;</div></li><li><div>      $term_order = 0;&nbsp;</div></li><li><div>      $final_tt_ids = wp_get_object_terms($object_id, $taxonomy, array('fields' =&gt; 'tt_ids'));&nbsp;</div></li><li><div>      foreach ( $tt_ids as $tt_id )&nbsp;</div></li><li><div>          if ( in_array($tt_id, $final_tt_ids) )&nbsp;</div></li><li><div>              $values[] = $wpdb-&gt;prepare( &quot;(%d, %d, %d)&quot;, $object_id, $tt_id, ++$term_order);&nbsp;</div></li><li><div>      if ( $values )&nbsp;</div></li><li><div>          if ( false === $wpdb-&gt;query( &quot;INSERT INTO $wpdb-&gt;term_relationships (object_id, term_taxonomy_id, term_order) VALUES &quot; . join( ', ', $values ) . &quot; ON DUPLICATE KEY UPDATE term_order = VALUES(term_order)&quot; ) )&nbsp;</div></li><li><div>              return new WP_Error( 'db_insert_error', __( 'Could not insert term relationship into the database' ), $wpdb-&gt;last_error );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_delete( $object_id, $taxonomy . '_relationships' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after an object's terms have been set.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $object_id  Object ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $terms      An array of object terms.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $tt_ids     An array of term taxonomy IDs.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy   Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $append     Whether to append new terms to the old terms.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $old_tt_ids Old array of term taxonomy IDs.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'set_object_terms', $object_id, $terms, $tt_ids, $taxonomy, $append, $old_tt_ids );&nbsp;</div></li><li><div>  return $tt_ids;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add term(s) associated with a given object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.6.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int              $object_id The ID of the object to which the terms will be added.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|int|string $terms     The slug(s) or ID(s) of the term(s) to add.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string     $taxonomy  Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error Term taxonomy IDs of the affected terms.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_add_object_terms( $object_id, $terms, $taxonomy ) {&nbsp;</div></li><li><div>  return wp_set_object_terms( $object_id, $terms, $taxonomy, true );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove term(s) associated with a given object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.6.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int              $object_id The ID of the object from which the terms will be removed.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|int|string $terms     The slug(s) or ID(s) of the term(s) to remove.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string     $taxonomy  Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|WP_Error True on success, false or WP_Error on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_remove_object_terms( $object_id, $terms, $taxonomy ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_id = (int) $object_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_array( $terms ) ) {&nbsp;</div></li><li><div>      $terms = array( $terms );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tt_ids = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>      if ( ! strlen( trim( $term ) ) ) {&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $term_info = term_exists( $term, $taxonomy ) ) {&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// Skip if a non-existent term ID is passed.</span></span>&nbsp;</div></li><li><div>          if ( is_int( $term ) ) {&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_wp_error( $term_info ) ) {&nbsp;</div></li><li><div>          return $term_info;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $tt_ids[] = $term_info['term_taxonomy_id'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $tt_ids ) {&nbsp;</div></li><li><div>      $in_tt_ids = &quot;'&quot; . implode( &quot;', '&quot;, $tt_ids ) . &quot;'&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately before an object-term relationship is deleted.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.7.0 Added the `$taxonomy` parameter.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int   $object_id Object ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $tt_ids    An array of term taxonomy IDs.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy  Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'delete_term_relationships', $object_id, $tt_ids, $taxonomy );&nbsp;</div></li><li><div>      $deleted = $wpdb-&gt;query( $wpdb-&gt;prepare( &quot;DELETE FROM $wpdb-&gt;term_relationships WHERE object_id = %d AND term_taxonomy_id IN ($in_tt_ids)&quot;, $object_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_cache_delete( $object_id, $taxonomy . '_relationships' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after an object-term relationship is deleted.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.7.0 Added the `$taxonomy` parameter.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $object_id Object ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $tt_ids    An array of term taxonomy IDs.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy  Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'deleted_term_relationships', $object_id, $tt_ids, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_update_term_count( $tt_ids, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return (bool) $deleted;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Will make slug unique, if it isn't already.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The `$slug` has to be unique global to every taxonomy, meaning that one</span>&nbsp;</div></li><li><div><span class="comment"> * taxonomy term can't have a matching slug with another taxonomy term. Each</span>&nbsp;</div></li><li><div><span class="comment"> * slug has to be globally unique for every taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The way this works is that if the taxonomy that the term belongs to is</span>&nbsp;</div></li><li><div><span class="comment"> * hierarchical and has a parent, it will append that parent to the $slug.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If that still doesn't return an unique slug, then it try to append a number</span>&nbsp;</div></li><li><div><span class="comment"> * until it finds a number that is truly unique.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The only purpose for `$term` is for appending a parent, if one exists.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $slug The string that will be tried for a unique slug.</span>&nbsp;</div></li><li><div><span class="comment"> * @param object $term The term object that the `$slug` will belong to.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string Will return a true unique slug.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_unique_term_slug( $slug, $term ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $needs_suffix = true;&nbsp;</div></li><li><div>  $original_slug = $slug;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// As of 4.1, duplicate slugs are allowed as long as they're in different taxonomies.</span>&nbsp;</div></li><li><div>  if ( ! term_exists( $slug ) || get_option( 'db_version' ) &gt;= 30133 && ! get_term_by( 'slug', $slug, $term-&gt;taxonomy ) ) {&nbsp;</div></li><li><div>      $needs_suffix = false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * If the taxonomy supports hierarchy and the term has a parent, make the slug unique</span>&nbsp;</div></li><li><div><span class="comment">   * by incorporating parent slugs.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $parent_suffix = '';&nbsp;</div></li><li><div>  if ( $needs_suffix && is_taxonomy_hierarchical( $term-&gt;taxonomy ) && ! empty( $term-&gt;parent ) ) {&nbsp;</div></li><li><div>      $the_parent = $term-&gt;parent;&nbsp;</div></li><li><div>      while ( ! empty($the_parent) ) {&nbsp;</div></li><li><div>          $parent_term = get_term($the_parent, $term-&gt;taxonomy);&nbsp;</div></li><li><div>          if ( is_wp_error($parent_term) || empty($parent_term) )&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          $parent_suffix .= '-' . $parent_term-&gt;slug;&nbsp;</div></li><li><div>          if ( ! term_exists( $slug . $parent_suffix ) ) {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( empty($parent_term-&gt;parent) )&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          $the_parent = $parent_term-&gt;parent;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If we didn't get a unique slug, try appending a number to make it unique.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters whether the proposed unique term slug is bad.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool   $needs_suffix Whether the slug needs to be made unique with a suffix.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $slug         The slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $term         Term object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( apply_filters( 'wp_unique_term_slug_is_bad_slug', $needs_suffix, $slug, $term ) ) {&nbsp;</div></li><li><div>      if ( $parent_suffix ) {&nbsp;</div></li><li><div>          $slug .= $parent_suffix;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          if ( ! empty( $term-&gt;term_id ) )&nbsp;</div></li><li><div>              $query = $wpdb-&gt;prepare( &quot;SELECT slug FROM $wpdb-&gt;terms WHERE slug = %s AND term_id != %d&quot;, $slug, $term-&gt;term_id );&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $query = $wpdb-&gt;prepare( &quot;SELECT slug FROM $wpdb-&gt;terms WHERE slug = %s&quot;, $slug );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $wpdb-&gt;get_var( $query ) ) {&nbsp;</div></li><li><div>              $num = 2;&nbsp;</div></li><li><div>              do {&nbsp;</div></li><li><div>                  $alt_slug = $slug . &quot;-$num&quot;;&nbsp;</div></li><li><div>                  $num++;&nbsp;</div></li><li><div>                  $slug_check = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT slug FROM $wpdb-&gt;terms WHERE slug = %s&quot;, $alt_slug ) );&nbsp;</div></li><li><div>              } while ( $slug_check );&nbsp;</div></li><li><div>              $slug = $alt_slug;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the unique term slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $slug          Unique term slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $term          Term object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $original_slug Slug originally passed to the function for testing.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_unique_term_slug', $slug, $term, $original_slug );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update term based on arguments provided.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The $args will indiscriminately override all values with the same field name.</span>&nbsp;</div></li><li><div><span class="comment"> * Care must be taken to not override important information need to update or</span>&nbsp;</div></li><li><div><span class="comment"> * update will fail (or perhaps create a new term, neither would be acceptable).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Defaults will set 'alias_of', 'description', 'parent', and 'slug' if not</span>&nbsp;</div></li><li><div><span class="comment"> * defined in $args already.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * 'alias_of' will create a term group, if it doesn't already exist, and update</span>&nbsp;</div></li><li><div><span class="comment"> * it for the $term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the 'slug' argument in $args is missing, then the 'name' in $args will be</span>&nbsp;</div></li><li><div><span class="comment"> * used. It should also be noted that if you set 'slug' and it isn't unique then</span>&nbsp;</div></li><li><div><span class="comment"> * a WP_Error will be passed back. If you don't pass any slug, then a unique one</span>&nbsp;</div></li><li><div><span class="comment"> * will be created for you.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * For what can be overrode in `$args`, check the term scheme can contain and stay</span>&nbsp;</div></li><li><div><span class="comment"> * away from the term keys.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int          $term_id  The ID of the term</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $taxonomy The context in which to relate the term to the object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args     Optional. Array of get_terms() arguments. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error Returns Term ID and Taxonomy Term ID</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_term( $term_id, $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! taxonomy_exists( $taxonomy ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_taxonomy', __( 'Invalid taxonomy.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_id = (int) $term_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// First, get all of the original args</span>&nbsp;</div></li><li><div>  $term = get_term( $term_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error( $term ) ) {&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $term ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_term', __( 'Empty Term' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term = (array) $term-&gt;data;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Escape data pulled from DB.</span>&nbsp;</div></li><li><div>  $term = wp_slash( $term );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Merge old and new args with new args overwriting old ones.</span>&nbsp;</div></li><li><div>  $args = array_merge($term, $args);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array( 'alias_of' =&gt; '', 'description' =&gt; '', 'parent' =&gt; 0, 'slug' =&gt; '');&nbsp;</div></li><li><div>  $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>  $args = sanitize_term($args, $taxonomy, 'db');&nbsp;</div></li><li><div>  $parsed_args = $args;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// expected_slashed ($name)</span></span>&nbsp;</div></li><li><div>  $name = wp_unslash( $args['name'] );&nbsp;</div></li><li><div>  $description = wp_unslash( $args['description'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $parsed_args['name'] = $name;&nbsp;</div></li><li><div>  $parsed_args['description'] = $description;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( '' == trim( $name ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'empty_term_name', __( 'A name is required for this term.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $parsed_args['parent'] &gt; 0 && ! term_exists( (int) $parsed_args['parent'] ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'missing_parent', __( 'Parent term does not exist.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $empty_slug = false;&nbsp;</div></li><li><div>  if ( empty( $args['slug'] ) ) {&nbsp;</div></li><li><div>      $empty_slug = true;&nbsp;</div></li><li><div>      $slug = sanitize_title($name);&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $slug = $args['slug'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $parsed_args['slug'] = $slug;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_group = isset( $parsed_args['term_group'] ) ? $parsed_args['term_group'] : 0;&nbsp;</div></li><li><div>  if ( $args['alias_of'] ) {&nbsp;</div></li><li><div>      $alias = get_term_by( 'slug', $args['alias_of'], $taxonomy );&nbsp;</div></li><li><div>      if ( ! empty( $alias-&gt;term_group ) ) {&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// The alias we want is already in a group, so let's use that one.</span></span>&nbsp;</div></li><li><div>          $term_group = $alias-&gt;term_group;&nbsp;</div></li><li><div>      } elseif ( ! empty( $alias-&gt;term_id ) ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * The alias is not in a group, so we create a new one</span>&nbsp;</div></li><li><div><span class="comment">           * and add the alias to it.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $term_group = $wpdb-&gt;get_var(&quot;SELECT MAX(term_group) FROM $wpdb-&gt;terms&quot;) + 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          wp_update_term( $alias-&gt;term_id, $taxonomy, array(&nbsp;</div></li><li><div>              'term_group' =&gt; $term_group, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $parsed_args['term_group'] = $term_group;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the term parent.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Hook to this filter to see if it will cause a hierarchy loop.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $parent      ID of the parent term.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id     Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy    Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $parsed_args An array of potentially altered update arguments for the given term.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $args        An array of update arguments for the given term.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $parent = apply_filters( 'wp_update_term_parent', $args['parent'], $term_id, $taxonomy, $parsed_args, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Check for duplicate slug</span>&nbsp;</div></li><li><div>  $duplicate = get_term_by( 'slug', $slug, $taxonomy );&nbsp;</div></li><li><div>  if ( $duplicate && $duplicate-&gt;term_id != $term_id ) {&nbsp;</div></li><li><div>      <span class="comment">// If an empty slug was passed or the parent changed, reset the slug to something unique.</span>&nbsp;</div></li><li><div>      <span class="comment">// Otherwise, bail.</span>&nbsp;</div></li><li><div>      if ( $empty_slug || ( $parent != $term['parent']) ) {&nbsp;</div></li><li><div>          $slug = wp_unique_term_slug($slug, (object) $args);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment">/** translators: 1: Taxonomy term slug */</span>&nbsp;</div></li><li><div>          return new WP_Error('duplicate_term_slug', sprintf(__('The slug &#8220;%s&#8221; is already in use by another term'), $slug));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tt_id = (int) $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT tt.term_taxonomy_id FROM $wpdb-&gt;term_taxonomy AS tt INNER JOIN $wpdb-&gt;terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d&quot;, $taxonomy, $term_id) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Check whether this is a shared term that needs splitting.</span>&nbsp;</div></li><li><div>  $_term_id = _split_shared_term( $term_id, $tt_id );&nbsp;</div></li><li><div>  if ( ! is_wp_error( $_term_id ) ) {&nbsp;</div></li><li><div>      $term_id = $_term_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before the given terms are edited.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'edit_terms', $term_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $data = compact( 'name', 'slug', 'term_group' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters term data before it is updated in the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $data     Term data to be updated.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $args     Arguments passed to wp_update_term().</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $data = apply_filters( 'wp_update_term_data', $data, $term_id, $taxonomy, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wpdb-&gt;update( $wpdb-&gt;terms, $data, compact( 'term_id' ) );&nbsp;</div></li><li><div>  if ( empty($slug) ) {&nbsp;</div></li><li><div>      $slug = sanitize_title($name, $term_id);&nbsp;</div></li><li><div>      $wpdb-&gt;update( $wpdb-&gt;terms, compact( 'slug' ), compact( 'term_id' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after the given terms are edited.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id  Term ID</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'edited_terms', $term_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediate before a term-taxonomy relationship is updated.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $tt_id    Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'edit_term_taxonomy', $tt_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wpdb-&gt;update( $wpdb-&gt;term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent' ), array( 'term_taxonomy_id' =&gt; $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a term-taxonomy relationship is updated.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $tt_id    Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'edited_term_taxonomy', $tt_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a term has been updated, but before the term cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $tt_id    Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;edit_term&quot;, $term_id, $tt_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a term in a specific taxonomy has been updated, but before the term</span>&nbsp;</div></li><li><div><span class="comment">   * cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$taxonomy`, refers to the taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $tt_id   Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;edit_{$taxonomy}&quot;, $term_id, $tt_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">/** This filter is documented in wp-includes/taxonomy.php */</span></span>&nbsp;</div></li><li><div>  $term_id = apply_filters( 'term_id_filter', $term_id, $tt_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_term_cache($term_id, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a term has been updated, and the term cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $tt_id    Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;edited_term&quot;, $term_id, $tt_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a term for a specific taxonomy has been updated, and the term</span>&nbsp;</div></li><li><div><span class="comment">   * cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$taxonomy`, refers to the taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $tt_id   Term taxonomy ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;edited_{$taxonomy}&quot;, $term_id, $tt_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return array('term_id' =&gt; $term_id, 'term_taxonomy_id' =&gt; $tt_id);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Enable or disable term counting.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @staticvar bool $_defer</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $defer Optional. Enable if true, disable if false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether term counting is enabled or disabled.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_defer_term_counting($defer=null) {&nbsp;</div></li><li><div>  static $_defer = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_bool($defer) ) {&nbsp;</div></li><li><div>      $_defer = $defer;&nbsp;</div></li><li><div>      <span class="comment">// flush any deferred counts</span>&nbsp;</div></li><li><div>      if ( !$defer )&nbsp;</div></li><li><div>          wp_update_term_count( null, null, true );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $_defer;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates the amount of terms in taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If there is a taxonomy callback applied, then it will be called for updating</span>&nbsp;</div></li><li><div><span class="comment"> * the count.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The default action is to count what the amount of terms have the relationship</span>&nbsp;</div></li><li><div><span class="comment"> * of term ID. Once that is done, then update the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @staticvar array $_deferred</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|array $terms       The term_taxonomy_id of the terms.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string    $taxonomy    The context of the term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool      $do_deferred Whether to flush the deferred term counts too. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool If no terms will return false, and if successful will return true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_term_count( $terms, $taxonomy, $do_deferred = false ) {&nbsp;</div></li><li><div>  static $_deferred = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $do_deferred ) {&nbsp;</div></li><li><div>      foreach ( (array) array_keys($_deferred) as $tax ) {&nbsp;</div></li><li><div>          wp_update_term_count_now( $_deferred[$tax], $tax );&nbsp;</div></li><li><div>          unset( $_deferred[$tax] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($terms) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($terms) )&nbsp;</div></li><li><div>      $terms = array($terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( wp_defer_term_counting() ) {&nbsp;</div></li><li><div>      if ( !isset($_deferred[$taxonomy]) )&nbsp;</div></li><li><div>          $_deferred[$taxonomy] = array();&nbsp;</div></li><li><div>      $_deferred[$taxonomy] = array_unique( array_merge($_deferred[$taxonomy], $terms) );&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_update_term_count_now( $terms, $taxonomy );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Perform term count update immediately.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $terms    The term_taxonomy_id of terms to update.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy The context of the term.</span>&nbsp;</div></li><li><div><span class="comment"> * @return true Always true when complete.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_term_count_now( $terms, $taxonomy ) {&nbsp;</div></li><li><div>  $terms = array_map('intval', $terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy = get_taxonomy($taxonomy);&nbsp;</div></li><li><div>  if ( !empty($taxonomy-&gt;update_count_callback) ) {&nbsp;</div></li><li><div>      call_user_func($taxonomy-&gt;update_count_callback, $terms, $taxonomy);&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $object_types = (array) $taxonomy-&gt;object_type;&nbsp;</div></li><li><div>      foreach ( $object_types as &$object_type ) {&nbsp;</div></li><li><div>          if ( 0 === strpos( $object_type, 'attachment:' ) )&nbsp;</div></li><li><div>              list( $object_type ) = explode( ':', $object_type );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $object_types == array_filter( $object_types, 'post_type_exists' ) ) {&nbsp;</div></li><li><div>          <span class="comment">// Only post types are attached to this taxonomy</span>&nbsp;</div></li><li><div>          _update_post_term_count( $terms, $taxonomy );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment">// Default count updater</span>&nbsp;</div></li><li><div>          _update_generic_term_count( $terms, $taxonomy );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_term_cache($terms, '', false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Cache&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Removes the taxonomy relationship to terms from the cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Will remove the entire taxonomy relationship containing term `$object_id`. The</span>&nbsp;</div></li><li><div><span class="comment"> * term IDs have to exist within the taxonomy `$object_type` for the deletion to</span>&nbsp;</div></li><li><div><span class="comment"> * take place.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global bool $_wp_suspend_cache_invalidation</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see get_object_taxonomies() for more on $object_type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|array    $object_ids  Single or list of term object ID(s).</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $object_type The taxonomy object type.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function clean_object_term_cache($object_ids, $object_type) {&nbsp;</div></li><li><div>  global $_wp_suspend_cache_invalidation;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $_wp_suspend_cache_invalidation ) ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($object_ids) )&nbsp;</div></li><li><div>      $object_ids = array($object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomies = get_object_taxonomies( $object_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $object_ids as $id ) {&nbsp;</div></li><li><div>      foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          wp_cache_delete($id, &quot;{$taxonomy}_relationships&quot;);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after the object term cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $object_ids An array of object IDs.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $objet_type Object type.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'clean_object_term_cache', $object_ids, $object_type );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Will remove all of the term ids from the cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> * @global bool $_wp_suspend_cache_invalidation</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|array $ids            Single or list of Term IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string    $taxonomy       Optional. Can be empty and will assume `tt_ids`, else will use for context.</span>&nbsp;</div></li><li><div><span class="comment"> *                                  Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool      $clean_taxonomy Optional. Whether to clean taxonomy wide caches (true), or just individual</span>&nbsp;</div></li><li><div><span class="comment"> *                                  term object caches (false). Default true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function clean_term_cache($ids, $taxonomy = '', $clean_taxonomy = true) {&nbsp;</div></li><li><div>  global $wpdb, $_wp_suspend_cache_invalidation;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $_wp_suspend_cache_invalidation ) ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($ids) )&nbsp;</div></li><li><div>      $ids = array($ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomies = array();&nbsp;</div></li><li><div>  <span class="comment">// If no taxonomy, assume tt_ids.</span>&nbsp;</div></li><li><div>  if ( empty($taxonomy) ) {&nbsp;</div></li><li><div>      $tt_ids = array_map('intval', $ids);&nbsp;</div></li><li><div>      $tt_ids = implode(', ', $tt_ids);&nbsp;</div></li><li><div>      $terms = $wpdb-&gt;get_results(&quot;SELECT term_id, taxonomy FROM $wpdb-&gt;term_taxonomy WHERE term_taxonomy_id IN ($tt_ids)&quot;);&nbsp;</div></li><li><div>      $ids = array();&nbsp;</div></li><li><div>      foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>          $taxonomies[] = $term-&gt;taxonomy;&nbsp;</div></li><li><div>          $ids[] = $term-&gt;term_id;&nbsp;</div></li><li><div>          wp_cache_delete( $term-&gt;term_id, 'terms' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $taxonomies = array_unique($taxonomies);&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $taxonomies = array($taxonomy);&nbsp;</div></li><li><div>      foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          foreach ( $ids as $id ) {&nbsp;</div></li><li><div>              wp_cache_delete( $id, 'terms' );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>      if ( $clean_taxonomy ) {&nbsp;</div></li><li><div>          wp_cache_delete('all_ids', $taxonomy);&nbsp;</div></li><li><div>          wp_cache_delete('get', $taxonomy);&nbsp;</div></li><li><div>          delete_option(&quot;{$taxonomy}_children&quot;);&nbsp;</div></li><li><div>          <span class="comment">// Regenerate {$taxonomy}_children</span>&nbsp;</div></li><li><div>          _get_term_hierarchy($taxonomy);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires once after each taxonomy's term cache has been cleaned.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.5.0 Added the `$clean_taxonomy` parameter.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array  $ids            An array of term IDs.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $taxonomy       Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool   $clean_taxonomy Whether or not to clean taxonomy-wide caches</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'clean_term_cache', $ids, $taxonomy, $clean_taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_set( 'last_changed', microtime(), 'terms' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves the taxonomy relationship to the term object id.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Upstream functions (like get_the_terms() and is_object_in_term()) are</span>&nbsp;</div></li><li><div><span class="comment"> * responsible for populating the object-term relationship cache. The current</span>&nbsp;</div></li><li><div><span class="comment"> * function only fetches relationship data that is already in the cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Returns a WP_Error object if get_term() returns an error for</span>&nbsp;</div></li><li><div><span class="comment"> *              any of the matched terms.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $id       Term object ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|array|WP_Error Array of `WP_Term` objects, if cached.</span>&nbsp;</div></li><li><div><span class="comment"> *                             False if cache is empty for `$taxonomy` and `$id`.</span>&nbsp;</div></li><li><div><span class="comment"> *                             WP_Error if get_term() returns an error object for any term.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_object_term_cache( $id, $taxonomy ) {&nbsp;</div></li><li><div>  $_term_ids = wp_cache_get( $id, &quot;{$taxonomy}_relationships&quot; );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// We leave the priming of relationship caches to upstream functions.</span>&nbsp;</div></li><li><div>  if ( false === $_term_ids ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Backward compatibility for if a plugin is putting objects into the cache, rather than IDs.</span>&nbsp;</div></li><li><div>  $term_ids = array();&nbsp;</div></li><li><div>  foreach ( $_term_ids as $term_id ) {&nbsp;</div></li><li><div>      if ( is_numeric( $term_id ) ) {&nbsp;</div></li><li><div>          $term_ids[] = intval( $term_id );&nbsp;</div></li><li><div>      } elseif ( isset( $term_id-&gt;term_id ) ) {&nbsp;</div></li><li><div>          $term_ids[] = intval( $term_id-&gt;term_id );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Fill the term objects.</span>&nbsp;</div></li><li><div>  _prime_term_caches( $term_ids );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $terms = array();&nbsp;</div></li><li><div>  foreach ( $term_ids as $term_id ) {&nbsp;</div></li><li><div>      $term = get_term( $term_id, $taxonomy );&nbsp;</div></li><li><div>      if ( is_wp_error( $term ) ) {&nbsp;</div></li><li><div>          return $term;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms[] = $term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $terms;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates the cache for the given term object ID(s).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Note: Due to performance concerns, great care should be taken to only update</span>&nbsp;</div></li><li><div><span class="comment"> * term caches when necessary. Processing time can increase exponentially depending</span>&nbsp;</div></li><li><div><span class="comment"> * on both the number of passed term IDs and the number of taxonomies those terms</span>&nbsp;</div></li><li><div><span class="comment"> * belong to.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Caches will only be updated for terms not already cached.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $object_ids  Comma-separated list or array of term object IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $object_type The taxonomy object type.</span>&nbsp;</div></li><li><div><span class="comment"> * @return void|false False if all of the terms in `$object_ids` are already cached.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_object_term_cache($object_ids, $object_type) {&nbsp;</div></li><li><div>  if ( empty($object_ids) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($object_ids) )&nbsp;</div></li><li><div>      $object_ids = explode(', ', $object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_ids = array_map('intval', $object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomies = get_object_taxonomies($object_type);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $ids = array();&nbsp;</div></li><li><div>  foreach ( (array) $object_ids as $id ) {&nbsp;</div></li><li><div>      foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          if ( false === wp_cache_get($id, &quot;{$taxonomy}_relationships&quot;) ) {&nbsp;</div></li><li><div>              $ids[] = $id;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $ids ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $terms = wp_get_object_terms( $ids, $taxonomies, array(&nbsp;</div></li><li><div>      'fields' =&gt; 'all_with_object_id', &nbsp;</div></li><li><div>      'orderby' =&gt; 'name', &nbsp;</div></li><li><div>      'update_term_meta_cache' =&gt; false, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_terms = array();&nbsp;</div></li><li><div>  foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>      $object_terms[ $term-&gt;object_id ][ $term-&gt;taxonomy ][] = $term-&gt;term_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $ids as $id ) {&nbsp;</div></li><li><div>      foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          if ( ! isset($object_terms[$id][$taxonomy]) ) {&nbsp;</div></li><li><div>              if ( !isset($object_terms[$id]) )&nbsp;</div></li><li><div>                  $object_terms[$id] = array();&nbsp;</div></li><li><div>              $object_terms[$id][$taxonomy] = array();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $object_terms as $id =&gt; $value ) {&nbsp;</div></li><li><div>      foreach ( $value as $taxonomy =&gt; $terms ) {&nbsp;</div></li><li><div>          wp_cache_add( $id, $terms, &quot;{$taxonomy}_relationships&quot; );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates Terms to Taxonomy in cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $terms    List of term objects to change.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Optional. Update Term to this taxonomy in cache. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_term_cache( $terms, $taxonomy = '' ) {&nbsp;</div></li><li><div>  foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>      <span class="comment">// Create a copy in case the array was passed by reference.</span>&nbsp;</div></li><li><div>      $_term = clone $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Object ID should not be cached.</span>&nbsp;</div></li><li><div>      unset( $_term-&gt;object_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_cache_add( $term-&gt;term_id, $_term, 'terms' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Private&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves children of taxonomy as Term IDs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @ignore</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Empty if $taxonomy isn't hierarchical or returns children as Term IDs.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _get_term_hierarchy( $taxonomy ) {&nbsp;</div></li><li><div>  if ( !is_taxonomy_hierarchical($taxonomy) )&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>  $children = get_option(&quot;{$taxonomy}_children&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array($children) )&nbsp;</div></li><li><div>      return $children;&nbsp;</div></li><li><div>  $children = array();&nbsp;</div></li><li><div>  $terms = get_terms($taxonomy, array('get' =&gt; 'all', 'orderby' =&gt; 'id', 'fields' =&gt; 'id=&gt;parent'));&nbsp;</div></li><li><div>  foreach ( $terms as $term_id =&gt; $parent ) {&nbsp;</div></li><li><div>      if ( $parent &gt; 0 )&nbsp;</div></li><li><div>          $children[$parent][] = $term_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  update_option(&quot;{$taxonomy}_children&quot;, $children);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $children;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get the subset of $terms that are descendants of $term_id.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If `$terms` is an array of objects, then _get_term_children() returns an array of objects.</span>&nbsp;</div></li><li><div><span class="comment"> * If `$terms` is an array of IDs, then _get_term_children() returns an array of IDs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id   The ancestor term: all returned terms should be descendants of `$term_id`.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $terms     The set of terms - either an array of term objects or term IDs - from which those that</span>&nbsp;</div></li><li><div><span class="comment"> *                          are descendants of $term_id will be chosen.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy  The taxonomy which determines the hierarchy of the terms.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $ancestors Optional. Term ancestors that have already been identified. Passed by reference, to keep</span>&nbsp;</div></li><li><div><span class="comment"> *                          track of found terms when recursing the hierarchy. The array of located ancestors is used</span>&nbsp;</div></li><li><div><span class="comment"> *                          to prevent infinite recursion loops. For performance, `term_ids` are used as array keys, </span>&nbsp;</div></li><li><div><span class="comment"> *                          with 1 as value. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error The subset of $terms that are descendants of $term_id.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _get_term_children( $term_id, $terms, $taxonomy, &$ancestors = array() ) {&nbsp;</div></li><li><div>  $empty_array = array();&nbsp;</div></li><li><div>  if ( empty($terms) )&nbsp;</div></li><li><div>      return $empty_array;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_list = array();&nbsp;</div></li><li><div>  $has_children = _get_term_hierarchy($taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if  ( ( 0 != $term_id ) && ! isset($has_children[$term_id]) )&nbsp;</div></li><li><div>      return $empty_array;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Include the term itself in the ancestors array, so we can properly detect when a loop has occurred.</span>&nbsp;</div></li><li><div>  if ( empty( $ancestors ) ) {&nbsp;</div></li><li><div>      $ancestors[ $term_id ] = 1;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>      $use_id = false;&nbsp;</div></li><li><div>      if ( !is_object($term) ) {&nbsp;</div></li><li><div>          $term = get_term($term, $taxonomy);&nbsp;</div></li><li><div>          if ( is_wp_error( $term ) )&nbsp;</div></li><li><div>              return $term;&nbsp;</div></li><li><div>          $use_id = true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Don't recurse if we've already identified the term as a child - this indicates a loop.</span>&nbsp;</div></li><li><div>      if ( isset( $ancestors[ $term-&gt;term_id ] ) ) {&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $term-&gt;parent == $term_id ) {&nbsp;</div></li><li><div>          if ( $use_id )&nbsp;</div></li><li><div>              $term_list[] = $term-&gt;term_id;&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $term_list[] = $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( !isset($has_children[$term-&gt;term_id]) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $ancestors[ $term-&gt;term_id ] = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $children = _get_term_children( $term-&gt;term_id, $terms, $taxonomy, $ancestors) )&nbsp;</div></li><li><div>              $term_list = array_merge($term_list, $children);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $term_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add count of children to parent count.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Recalculates term counts by including items from child terms. Assumes all</span>&nbsp;</div></li><li><div><span class="comment"> * relevant children are already in the $terms argument.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $terms    List of term objects, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Term context.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _pad_term_counts( &$terms, $taxonomy ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// This function only works for hierarchical taxonomies like post categories.</span>&nbsp;</div></li><li><div>  if ( !is_taxonomy_hierarchical( $taxonomy ) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_hier = _get_term_hierarchy($taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($term_hier) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_items = array();&nbsp;</div></li><li><div>  $terms_by_id = array();&nbsp;</div></li><li><div>  $term_ids = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $terms as $key =&gt; $term ) {&nbsp;</div></li><li><div>      $terms_by_id[$term-&gt;term_id] = & $terms[$key];&nbsp;</div></li><li><div>      $term_ids[$term-&gt;term_taxonomy_id] = $term-&gt;term_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Get the object and term ids and stick them in a lookup table.</span>&nbsp;</div></li><li><div>  $tax_obj = get_taxonomy($taxonomy);&nbsp;</div></li><li><div>  $object_types = esc_sql($tax_obj-&gt;object_type);&nbsp;</div></li><li><div>  $results = $wpdb-&gt;get_results(&quot;SELECT object_id, term_taxonomy_id FROM $wpdb-&gt;term_relationships INNER JOIN $wpdb-&gt;posts ON object_id = ID WHERE term_taxonomy_id IN (&quot; . implode(', ', array_keys($term_ids)) . &quot;) AND post_type IN ('&quot; . implode(&quot;', '&quot;, $object_types) . &quot;') AND post_status = 'publish'&quot;);&nbsp;</div></li><li><div>  foreach ( $results as $row ) {&nbsp;</div></li><li><div>      $id = $term_ids[$row-&gt;term_taxonomy_id];&nbsp;</div></li><li><div>      $term_items[$id][$row-&gt;object_id] = isset($term_items[$id][$row-&gt;object_id]) ? ++$term_items[$id][$row-&gt;object_id] : 1;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Touch every ancestor's lookup row for each post in each term.</span>&nbsp;</div></li><li><div>  foreach ( $term_ids as $term_id ) {&nbsp;</div></li><li><div>      $child = $term_id;&nbsp;</div></li><li><div>      $ancestors = array();&nbsp;</div></li><li><div>      while ( !empty( $terms_by_id[$child] ) && $parent = $terms_by_id[$child]-&gt;parent ) {&nbsp;</div></li><li><div>          $ancestors[] = $child;&nbsp;</div></li><li><div>          if ( !empty( $term_items[$term_id] ) )&nbsp;</div></li><li><div>              foreach ( $term_items[$term_id] as $item_id =&gt; $touches ) {&nbsp;</div></li><li><div>                  $term_items[$parent][$item_id] = isset($term_items[$parent][$item_id]) ? ++$term_items[$parent][$item_id]: 1;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          $child = $parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( in_array( $parent, $ancestors ) ) {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Transfer the touched cells.</span>&nbsp;</div></li><li><div>  foreach ( (array) $term_items as $id =&gt; $items )&nbsp;</div></li><li><div>      if ( isset($terms_by_id[$id]) )&nbsp;</div></li><li><div>          $terms_by_id[$id]-&gt;count = count($items);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds any terms from the given IDs to the cache that do not already exist in cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.6.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $term_ids          Array of term IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $update_meta_cache Optional. Whether to update the meta cache. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _prime_term_caches( $term_ids, $update_meta_cache = true ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $non_cached_ids = _get_non_cached_ids( $term_ids, 'terms' );&nbsp;</div></li><li><div>  if ( ! empty( $non_cached_ids ) ) {&nbsp;</div></li><li><div>      $fresh_terms = $wpdb-&gt;get_results( sprintf( &quot;SELECT t.*, tt.* FROM $wpdb-&gt;terms AS t INNER JOIN $wpdb-&gt;term_taxonomy AS tt ON t.term_id = tt.term_id WHERE t.term_id IN (%s)&quot;, join( &quot;, &quot;, array_map( 'intval', $non_cached_ids ) ) ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      update_term_cache( $fresh_terms, $update_meta_cache );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $update_meta_cache ) {&nbsp;</div></li><li><div>          update_termmeta_cache( $non_cached_ids );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Default callbacks&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Will update term count based on object types of the current taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Private function for the default callback for post_tag and category</span>&nbsp;</div></li><li><div><span class="comment"> * taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $terms    List of Term taxonomy IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @param object $taxonomy Current taxonomy object of terms.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _update_post_term_count( $terms, $taxonomy ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_types = (array) $taxonomy-&gt;object_type;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $object_types as &$object_type )&nbsp;</div></li><li><div>      list( $object_type ) = explode( ':', $object_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_types = array_unique( $object_types );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( false !== ( $check_attachments = array_search( 'attachment', $object_types ) ) ) {&nbsp;</div></li><li><div>      unset( $object_types[ $check_attachments ] );&nbsp;</div></li><li><div>      $check_attachments = true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $object_types )&nbsp;</div></li><li><div>      $object_types = esc_sql( array_filter( $object_types, 'post_type_exists' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>      $count = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Attachments can be 'inherit' status, we need to base count off the parent's status if so.</span>&nbsp;</div></li><li><div>      if ( $check_attachments )&nbsp;</div></li><li><div>          $count += (int) $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(*) FROM $wpdb-&gt;term_relationships, $wpdb-&gt;posts p1 WHERE p1.ID = $wpdb-&gt;term_relationships.object_id AND ( post_status = 'publish' OR ( post_status = 'inherit' AND post_parent &gt; 0 AND ( SELECT post_status FROM $wpdb-&gt;posts WHERE ID = p1.post_parent ) = 'publish' ) ) AND post_type = 'attachment' AND term_taxonomy_id = %d&quot;, $term ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $object_types )&nbsp;</div></li><li><div>          $count += (int) $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(*) FROM $wpdb-&gt;term_relationships, $wpdb-&gt;posts WHERE $wpdb-&gt;posts.ID = $wpdb-&gt;term_relationships.object_id AND post_status = 'publish' AND post_type IN ('&quot; . implode(&quot;', '&quot;, $object_types ) . &quot;') AND term_taxonomy_id = %d&quot;, $term ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/taxonomy.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>      do_action( 'edit_term_taxonomy', $term, $taxonomy-&gt;name );&nbsp;</div></li><li><div>      $wpdb-&gt;update( $wpdb-&gt;term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' =&gt; $term ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/taxonomy.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>      do_action( 'edited_term_taxonomy', $term, $taxonomy-&gt;name );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Will update term count based on number of objects.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Default callback for the 'link_category' taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $terms    List of term taxonomy IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @param object $taxonomy Current taxonomy object of terms.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _update_generic_term_count( $terms, $taxonomy ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>      $count = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(*) FROM $wpdb-&gt;term_relationships WHERE term_taxonomy_id = %d&quot;, $term ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/taxonomy.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>      do_action( 'edit_term_taxonomy', $term, $taxonomy-&gt;name );&nbsp;</div></li><li><div>      $wpdb-&gt;update( $wpdb-&gt;term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' =&gt; $term ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/taxonomy.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>      do_action( 'edited_term_taxonomy', $term, $taxonomy-&gt;name );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Create a new term for a term_taxonomy item that currently shares its term</span>&nbsp;</div></li><li><div><span class="comment"> * with another term_taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @ignore</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0 Introduced `$record` parameter. Also, `$term_id` and</span>&nbsp;</div></li><li><div><span class="comment"> *              `$term_taxonomy_id` can now accept objects.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|object $term_id          ID of the shared term, or the shared term object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|object $term_taxonomy_id ID of the term_taxonomy item to receive a new term, or the term_taxonomy object</span>&nbsp;</div></li><li><div><span class="comment"> *                                     (corresponding to a row from the term_taxonomy table).</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool       $record           Whether to record data about the split term in the options table. The recording</span>&nbsp;</div></li><li><div><span class="comment"> *                                     process has the potential to be resource-intensive, so during batch operations</span>&nbsp;</div></li><li><div><span class="comment"> *                                     it can be beneficial to skip inline recording and do it just once, after the</span>&nbsp;</div></li><li><div><span class="comment"> *                                     batch is processed. Only set this to `false` if you know what you are doing.</span>&nbsp;</div></li><li><div><span class="comment"> *                                     Default: true.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|WP_Error When the current term does not need to be split (or cannot be split on the current</span>&nbsp;</div></li><li><div><span class="comment"> *                      database schema), `$term_id` is returned. When the term is successfully split, the</span>&nbsp;</div></li><li><div><span class="comment"> *                      new term_id is returned. A WP_Error is returned for miscellaneous errors.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _split_shared_term( $term_id, $term_taxonomy_id, $record = true ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_object( $term_id ) ) {&nbsp;</div></li><li><div>      $shared_term = $term_id;&nbsp;</div></li><li><div>      $term_id = intval( $shared_term-&gt;term_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_object( $term_taxonomy_id ) ) {&nbsp;</div></li><li><div>      $term_taxonomy = $term_taxonomy_id;&nbsp;</div></li><li><div>      $term_taxonomy_id = intval( $term_taxonomy-&gt;term_taxonomy_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If there are no shared term_taxonomy rows, there's nothing to do here.</span>&nbsp;</div></li><li><div>  $shared_tt_count = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(*) FROM $wpdb-&gt;term_taxonomy tt WHERE tt.term_id = %d AND tt.term_taxonomy_id != %d&quot;, $term_id, $term_taxonomy_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $shared_tt_count ) {&nbsp;</div></li><li><div>      return $term_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Verify that the term_taxonomy_id passed to the function is actually associated with the term_id.</span>&nbsp;</div></li><li><div><span class="comment">   * If there's a mismatch, it may mean that the term is already split. Return the actual term_id from the db.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $check_term_id = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT term_id FROM $wpdb-&gt;term_taxonomy WHERE term_taxonomy_id = %d&quot;, $term_taxonomy_id ) );&nbsp;</div></li><li><div>  if ( $check_term_id != $term_id ) {&nbsp;</div></li><li><div>      return $check_term_id;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Pull up data about the currently shared slug, which we'll use to populate the new one.</span>&nbsp;</div></li><li><div>  if ( empty( $shared_term ) ) {&nbsp;</div></li><li><div>      $shared_term = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;SELECT t.* FROM $wpdb-&gt;terms t WHERE t.term_id = %d&quot;, $term_id ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $new_term_data = array(&nbsp;</div></li><li><div>      'name' =&gt; $shared_term-&gt;name, &nbsp;</div></li><li><div>      'slug' =&gt; $shared_term-&gt;slug, &nbsp;</div></li><li><div>      'term_group' =&gt; $shared_term-&gt;term_group, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( false === $wpdb-&gt;insert( $wpdb-&gt;terms, $new_term_data ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'db_insert_error', __( 'Could not split shared term.' ), $wpdb-&gt;last_error );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $new_term_id = (int) $wpdb-&gt;insert_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Update the existing term_taxonomy to point to the newly created term.</span>&nbsp;</div></li><li><div>  $wpdb-&gt;update( $wpdb-&gt;term_taxonomy, &nbsp;</div></li><li><div>      array( 'term_id' =&gt; $new_term_id ), &nbsp;</div></li><li><div>      array( 'term_taxonomy_id' =&gt; $term_taxonomy_id )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Reassign child terms to the new parent.</span>&nbsp;</div></li><li><div>  if ( empty( $term_taxonomy ) ) {&nbsp;</div></li><li><div>      $term_taxonomy = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;SELECT * FROM $wpdb-&gt;term_taxonomy WHERE term_taxonomy_id = %d&quot;, $term_taxonomy_id ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $children_tt_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT term_taxonomy_id FROM $wpdb-&gt;term_taxonomy WHERE parent = %d AND taxonomy = %s&quot;, $term_id, $term_taxonomy-&gt;taxonomy ) );&nbsp;</div></li><li><div>  if ( ! empty( $children_tt_ids ) ) {&nbsp;</div></li><li><div>      foreach ( $children_tt_ids as $child_tt_id ) {&nbsp;</div></li><li><div>          $wpdb-&gt;update( $wpdb-&gt;term_taxonomy, &nbsp;</div></li><li><div>              array( 'parent' =&gt; $new_term_id ), &nbsp;</div></li><li><div>              array( 'term_taxonomy_id' =&gt; $child_tt_id )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>          clean_term_cache( $term_id, $term_taxonomy-&gt;taxonomy );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment">// If the term has no children, we must force its taxonomy cache to be rebuilt separately.</span>&nbsp;</div></li><li><div>      clean_term_cache( $new_term_id, $term_taxonomy-&gt;taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Clean the cache for term taxonomies formerly shared with the current term.</span>&nbsp;</div></li><li><div>  $shared_term_taxonomies = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;SELECT taxonomy FROM $wpdb-&gt;term_taxonomy WHERE term_id = %d&quot;, $term_id ) );&nbsp;</div></li><li><div>  if ( $shared_term_taxonomies ) {&nbsp;</div></li><li><div>      foreach ( $shared_term_taxonomies as $shared_term_taxonomy ) {&nbsp;</div></li><li><div>          clean_term_cache( $term_id, $shared_term_taxonomy );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Keep a record of term_ids that have been split, keyed by old term_id. See wp_get_split_term().</span>&nbsp;</div></li><li><div>  if ( $record ) {&nbsp;</div></li><li><div>      $split_term_data = get_option( '_split_terms', array() );&nbsp;</div></li><li><div>      if ( ! isset( $split_term_data[ $term_id ] ) ) {&nbsp;</div></li><li><div>          $split_term_data[ $term_id ] = array();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $split_term_data[ $term_id ][ $term_taxonomy-&gt;taxonomy ] = $new_term_id;&nbsp;</div></li><li><div>      update_option( '_split_terms', $split_term_data );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If we've just split the final shared term, set the &quot;finished&quot; flag.</span>&nbsp;</div></li><li><div>  $shared_terms_exist = $wpdb-&gt;get_results(&nbsp;</div></li><li><div>      &quot;SELECT tt.term_id, t.*, count(*) as term_tt_count FROM {$wpdb-&gt;term_taxonomy} tt&nbsp;</div></li><li><div>       LEFT JOIN {$wpdb-&gt;terms} t ON t.term_id = tt.term_id&nbsp;</div></li><li><div>       GROUP BY t.term_id&nbsp;</div></li><li><div>       HAVING term_tt_count &gt; 1&nbsp;</div></li><li><div>       LIMIT 1&quot;&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  if ( ! $shared_terms_exist ) {&nbsp;</div></li><li><div>      update_option( 'finished_splitting_shared_terms', true );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a previously shared taxonomy term is split into two separate terms.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_id          ID of the formerly shared term.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $new_term_id      ID of the new term created for the $term_taxonomy_id.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $term_taxonomy_id ID for the term_taxonomy row affected by the split.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy         Taxonomy for the split term.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'split_shared_term', $term_id, $new_term_id, $term_taxonomy_id, $term_taxonomy-&gt;taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $new_term_id;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Splits a batch of shared taxonomy terms.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _wp_batch_split_terms() {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $lock_name = 'term_split.lock';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Try to lock.</span>&nbsp;</div></li><li><div>  $lock_result = $wpdb-&gt;query( $wpdb-&gt;prepare( &quot;INSERT IGNORE INTO `$wpdb-&gt;options` ( `option_name`, `option_value`, `autoload` ) VALUES (%s, %s, 'no') <span class="comment">/* LOCK */</span>&quot;, $lock_name, time() ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $lock_result ) {&nbsp;</div></li><li><div>      $lock_result = get_option( $lock_name );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Bail if we were unable to create a lock, or if the existing lock is still valid.</span>&nbsp;</div></li><li><div>      if ( ! $lock_result || ( $lock_result &gt; ( time() - HOUR_IN_SECONDS ) ) ) {&nbsp;</div></li><li><div>          wp_schedule_single_event( time() + ( 5 * MINUTE_IN_SECONDS ), 'wp_split_shared_term_batch' );&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Update the lock, as by this point we've definitely got a lock, just need to fire the actions.</span>&nbsp;</div></li><li><div>  update_option( $lock_name, time() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Get a list of shared terms (those with more than one associated row in term_taxonomy).</span>&nbsp;</div></li><li><div>  $shared_terms = $wpdb-&gt;get_results(&nbsp;</div></li><li><div>      &quot;SELECT tt.term_id, t.*, count(*) as term_tt_count FROM {$wpdb-&gt;term_taxonomy} tt&nbsp;</div></li><li><div>       LEFT JOIN {$wpdb-&gt;terms} t ON t.term_id = tt.term_id&nbsp;</div></li><li><div>       GROUP BY t.term_id&nbsp;</div></li><li><div>       HAVING term_tt_count &gt; 1&nbsp;</div></li><li><div>       LIMIT 10&quot;&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// No more terms, we're done here.</span>&nbsp;</div></li><li><div>  if ( ! $shared_terms ) {&nbsp;</div></li><li><div>      update_option( 'finished_splitting_shared_terms', true );&nbsp;</div></li><li><div>      delete_option( $lock_name );&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Shared terms found? We'll need to run this script again.</span>&nbsp;</div></li><li><div>  wp_schedule_single_event( time() + ( 2 * MINUTE_IN_SECONDS ), 'wp_split_shared_term_batch' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Rekey shared term array for faster lookups.</span>&nbsp;</div></li><li><div>  $_shared_terms = array();&nbsp;</div></li><li><div>  foreach ( $shared_terms as $shared_term ) {&nbsp;</div></li><li><div>      $term_id = intval( $shared_term-&gt;term_id );&nbsp;</div></li><li><div>      $_shared_terms[ $term_id ] = $shared_term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $shared_terms = $_shared_terms;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Get term taxonomy data for all shared terms.</span>&nbsp;</div></li><li><div>  $shared_term_ids = implode( ', ', array_keys( $shared_terms ) );&nbsp;</div></li><li><div>  $shared_tts = $wpdb-&gt;get_results( &quot;SELECT * FROM {$wpdb-&gt;term_taxonomy} WHERE `term_id` IN ({$shared_term_ids})&quot; );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Split term data recording is slow, so we do it just once, outside the loop.</span>&nbsp;</div></li><li><div>  $split_term_data = get_option( '_split_terms', array() );&nbsp;</div></li><li><div>  $skipped_first_term = $taxonomies = array();&nbsp;</div></li><li><div>  foreach ( $shared_tts as $shared_tt ) {&nbsp;</div></li><li><div>      $term_id = intval( $shared_tt-&gt;term_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Don't split the first tt belonging to a given term_id.</span>&nbsp;</div></li><li><div>      if ( ! isset( $skipped_first_term[ $term_id ] ) ) {&nbsp;</div></li><li><div>          $skipped_first_term[ $term_id ] = 1;&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $split_term_data[ $term_id ] ) ) {&nbsp;</div></li><li><div>          $split_term_data[ $term_id ] = array();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Keep track of taxonomies whose hierarchies need flushing.</span>&nbsp;</div></li><li><div>      if ( ! isset( $taxonomies[ $shared_tt-&gt;taxonomy ] ) ) {&nbsp;</div></li><li><div>          $taxonomies[ $shared_tt-&gt;taxonomy ] = 1;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Split the term.</span>&nbsp;</div></li><li><div>      $split_term_data[ $term_id ][ $shared_tt-&gt;taxonomy ] = _split_shared_term( $shared_terms[ $term_id ], $shared_tt, false );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Rebuild the cached hierarchy for each affected taxonomy.</span>&nbsp;</div></li><li><div>  foreach ( array_keys( $taxonomies ) as $tax ) {&nbsp;</div></li><li><div>      delete_option( &quot;{$tax}_children&quot; );&nbsp;</div></li><li><div>      _get_term_hierarchy( $tax );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  update_option( '_split_terms', $split_term_data );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  delete_option( $lock_name );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * In order to avoid the _wp_batch_split_terms() job being accidentally removed, </span>&nbsp;</div></li><li><div><span class="comment"> * check that it's still scheduled while we haven't finished splitting terms.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @ignore</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _wp_check_for_scheduled_split_terms() {&nbsp;</div></li><li><div>  if ( ! get_option( 'finished_splitting_shared_terms' ) && ! wp_next_scheduled( 'wp_split_shared_term_batch' ) ) {&nbsp;</div></li><li><div>      wp_schedule_single_event( time() + MINUTE_IN_SECONDS, 'wp_split_shared_term_batch' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check default categories when a term gets split to see if any of them need to be updated.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @ignore</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id          ID of the formerly shared term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $new_term_id      ID of the new term created for the $term_taxonomy_id.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_taxonomy_id ID for the term_taxonomy row affected by the split.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy         Taxonomy for the split term.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _wp_check_split_default_terms( $term_id, $new_term_id, $term_taxonomy_id, $taxonomy ) {&nbsp;</div></li><li><div>  if ( 'category' != $taxonomy ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( array( 'default_category', 'default_link_category', 'default_email_category' ) as $option ) {&nbsp;</div></li><li><div>      if ( $term_id == get_option( $option, -1 ) ) {&nbsp;</div></li><li><div>          update_option( $option, $new_term_id );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check menu items when a term gets split to see if any of them need to be updated.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @ignore</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id          ID of the formerly shared term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $new_term_id      ID of the new term created for the $term_taxonomy_id.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_taxonomy_id ID for the term_taxonomy row affected by the split.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy         Taxonomy for the split term.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _wp_check_split_terms_in_menus( $term_id, $new_term_id, $term_taxonomy_id, $taxonomy ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>  $post_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare(&nbsp;</div></li><li><div>      &quot;SELECT m1.post_id&nbsp;</div></li><li><div>      FROM {$wpdb-&gt;postmeta} AS m1&nbsp;</div></li><li><div>          INNER JOIN {$wpdb-&gt;postmeta} AS m2 ON ( m2.post_id = m1.post_id )&nbsp;</div></li><li><div>          INNER JOIN {$wpdb-&gt;postmeta} AS m3 ON ( m3.post_id = m1.post_id )&nbsp;</div></li><li><div>      WHERE ( m1.meta_key = '_menu_item_type' AND m1.meta_value = 'taxonomy' )&nbsp;</div></li><li><div>          AND ( m2.meta_key = '_menu_item_object' AND m2.meta_value = '%s' )&nbsp;</div></li><li><div>          AND ( m3.meta_key = '_menu_item_object_id' AND m3.meta_value = %d )&quot;, &nbsp;</div></li><li><div>      $taxonomy, &nbsp;</div></li><li><div>      $term_id&nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $post_ids ) {&nbsp;</div></li><li><div>      foreach ( $post_ids as $post_id ) {&nbsp;</div></li><li><div>          update_post_meta( $post_id, '_menu_item_object_id', $new_term_id, $term_id );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * If the term being split is a nav_menu, change associations.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @ignore</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id          ID of the formerly shared term.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $new_term_id      ID of the new term created for the $term_taxonomy_id.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_taxonomy_id ID for the term_taxonomy row affected by the split.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy         Taxonomy for the split term.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _wp_check_split_nav_menu_terms( $term_id, $new_term_id, $term_taxonomy_id, $taxonomy ) {&nbsp;</div></li><li><div>  if ( 'nav_menu' !== $taxonomy ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Update menu locations.</span>&nbsp;</div></li><li><div>  $locations = get_nav_menu_locations();&nbsp;</div></li><li><div>  foreach ( $locations as $location =&gt; $menu_id ) {&nbsp;</div></li><li><div>      if ( $term_id == $menu_id ) {&nbsp;</div></li><li><div>          $locations[ $location ] = $new_term_id;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  set_theme_mod( 'nav_menu_locations', $locations );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get data about terms that previously shared a single term_id, but have since been split.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $old_term_id Term ID. This is the old, pre-split term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Array of new term IDs, keyed by taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_split_terms( $old_term_id ) {&nbsp;</div></li><li><div>  $split_terms = get_option( '_split_terms', array() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $terms = array();&nbsp;</div></li><li><div>  if ( isset( $split_terms[ $old_term_id ] ) ) {&nbsp;</div></li><li><div>      $terms = $split_terms[ $old_term_id ];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $terms;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get the new term ID corresponding to a previously split term.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $old_term_id Term ID. This is the old, pre-split term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy    Taxonomy that the term belongs to.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false If a previously split term is found corresponding to the old term_id and taxonomy, </span>&nbsp;</div></li><li><div><span class="comment"> *                   the new term_id will be returned. If no previously split term is found matching</span>&nbsp;</div></li><li><div><span class="comment"> *                   the parameters, returns false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_split_term( $old_term_id, $taxonomy ) {&nbsp;</div></li><li><div>  $split_terms = wp_get_split_terms( $old_term_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $term_id = false;&nbsp;</div></li><li><div>  if ( isset( $split_terms[ $taxonomy ] ) ) {&nbsp;</div></li><li><div>      $term_id = (int) $split_terms[ $taxonomy ];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $term_id;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Determine whether a term is shared between multiple taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Shared taxonomy terms began to be split in 4.3, but failed cron tasks or other delays in upgrade routines may cause</span>&nbsp;</div></li><li><div><span class="comment"> * shared terms to remain.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $term_id</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_term_is_shared( $term_id ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( get_option( 'finished_splitting_shared_terms' ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tt_count = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT(*) FROM $wpdb-&gt;term_taxonomy WHERE term_id = %d&quot;, $term_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $tt_count &gt; 1;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Generate a permalink for a taxonomy term archive.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Rewrite $wp_rewrite</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param object|int|string $term     The term object, ID, or slug whose link will be retrieved.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string            $taxonomy Optional. Taxonomy. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|WP_Error HTML link to taxonomy term archive on success, WP_Error if term does not exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_term_link( $term, $taxonomy = '' ) {&nbsp;</div></li><li><div>  global $wp_rewrite;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_object($term) ) {&nbsp;</div></li><li><div>      if ( is_int( $term ) ) {&nbsp;</div></li><li><div>          $term = get_term( $term, $taxonomy );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $term = get_term_by( 'slug', $term, $taxonomy );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_object($term) )&nbsp;</div></li><li><div>      $term = new WP_Error('invalid_term', __('Empty Term'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error( $term ) )&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomy = $term-&gt;taxonomy;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $termlink = $wp_rewrite-&gt;get_extra_permastruct($taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $slug = $term-&gt;slug;&nbsp;</div></li><li><div>  $t = get_taxonomy($taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($termlink) ) {&nbsp;</div></li><li><div>      if ( 'category' == $taxonomy )&nbsp;</div></li><li><div>          $termlink = '?cat=' . $term-&gt;term_id;&nbsp;</div></li><li><div>      elseif ( $t-&gt;query_var )&nbsp;</div></li><li><div>          $termlink = &quot;?$t-&gt;query_var=$slug&quot;;&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $termlink = &quot;?taxonomy=$taxonomy&term=$slug&quot;;&nbsp;</div></li><li><div>      $termlink = home_url($termlink);&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      if ( $t-&gt;rewrite['hierarchical'] ) {&nbsp;</div></li><li><div>          $hierarchical_slugs = array();&nbsp;</div></li><li><div>          $ancestors = get_ancestors( $term-&gt;term_id, $taxonomy, 'taxonomy' );&nbsp;</div></li><li><div>          foreach ( (array)$ancestors as $ancestor ) {&nbsp;</div></li><li><div>              $ancestor_term = get_term($ancestor, $taxonomy);&nbsp;</div></li><li><div>              $hierarchical_slugs[] = $ancestor_term-&gt;slug;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $hierarchical_slugs = array_reverse($hierarchical_slugs);&nbsp;</div></li><li><div>          $hierarchical_slugs[] = $slug;&nbsp;</div></li><li><div>          $termlink = str_replace(&quot;%$taxonomy%&quot;, implode('/', $hierarchical_slugs), $termlink);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $termlink = str_replace(&quot;%$taxonomy%&quot;, $slug, $termlink);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $termlink = home_url( user_trailingslashit($termlink, 'category') );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  <span class="comment">// Back Compat filters.</span>&nbsp;</div></li><li><div>  if ( 'post_tag' == $taxonomy ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the tag link.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">       * @deprecated 2.5.0 Use 'term_link' instead.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $termlink Tag link URL.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $termlink = apply_filters( 'tag_link', $termlink, $term-&gt;term_id );&nbsp;</div></li><li><div>  } elseif ( 'category' == $taxonomy ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the category link.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       * @deprecated 2.5.0 Use 'term_link' instead.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $termlink Category link URL.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $termlink = apply_filters( 'category_link', $termlink, $term-&gt;term_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the term link.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $termlink Term link URL.</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $term     Term object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'term_link', $termlink, $term, $taxonomy );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Display the taxonomies of a post with available options.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function can be used within the loop to display the taxonomies for a</span>&nbsp;</div></li><li><div><span class="comment"> * post without specifying the Post ID. You can also use it outside the Loop to</span>&nbsp;</div></li><li><div><span class="comment"> * display the taxonomies for a specific post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Arguments about which post to use and how to format the output. Shares all of the arguments</span>&nbsp;</div></li><li><div><span class="comment"> *     supported by get_the_taxonomies(), in addition to the following.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type  int|WP_Post $post   Post ID or object to get taxonomies of. Default current post.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type  string      $before Displays before the taxonomies. Default empty string.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type  string      $sep    Separates each taxonomy. Default is a space.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type  string      $after  Displays after the taxonomies. Default empty string.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function the_taxonomies( $args = array() ) {&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'post' =&gt; 0, &nbsp;</div></li><li><div>      'before' =&gt; '', &nbsp;</div></li><li><div>      'sep' =&gt; ' ', &nbsp;</div></li><li><div>      'after' =&gt; '', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  echo $r['before'] . join( $r['sep'], get_the_taxonomies( $r['post'], $r ) ) . $r['after'];&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve all taxonomies associated with a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function can be used within the loop. It will also return an array of</span>&nbsp;</div></li><li><div><span class="comment"> * the taxonomies with links to the taxonomy and name.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Optional. Post ID or WP_Post object. Default is global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Arguments about how to format the list of taxonomies. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $template      Template for displaying a taxonomy label and list of terms.</span>&nbsp;</div></li><li><div><span class="comment"> *                                 Default is &quot;Label: Terms.&quot;</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $term_template Template for displaying a single term in the list. Default is the term name</span>&nbsp;</div></li><li><div><span class="comment"> *                                 linked to its archive.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of taxonomies.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_the_taxonomies( $post = 0, $args = array() ) {&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $args = wp_parse_args( $args, array(&nbsp;</div></li><li><div>      <span class="comment">/** translators: %s: taxonomy label, %l: list of terms formatted as per $term_template */</span>&nbsp;</div></li><li><div>      'template' =&gt; __( '%s: %l.' ), &nbsp;</div></li><li><div>      'term_template' =&gt; '&lt;a href=&quot;%1$s&quot;&gt;%2$s&lt;/a&gt;', &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $taxonomies = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $post ) {&nbsp;</div></li><li><div>      return $taxonomies;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( get_object_taxonomies( $post ) as $taxonomy ) {&nbsp;</div></li><li><div>      $t = (array) get_taxonomy( $taxonomy );&nbsp;</div></li><li><div>      if ( empty( $t['label'] ) ) {&nbsp;</div></li><li><div>          $t['label'] = $taxonomy;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( empty( $t['args'] ) ) {&nbsp;</div></li><li><div>          $t['args'] = array();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( empty( $t['template'] ) ) {&nbsp;</div></li><li><div>          $t['template'] = $args['template'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( empty( $t['term_template'] ) ) {&nbsp;</div></li><li><div>          $t['term_template'] = $args['term_template'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = get_object_term_cache( $post-&gt;ID, $taxonomy );&nbsp;</div></li><li><div>      if ( false === $terms ) {&nbsp;</div></li><li><div>          $terms = wp_get_object_terms( $post-&gt;ID, $taxonomy, $t['args'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $links = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $terms as $term ) {&nbsp;</div></li><li><div>          $links[] = wp_sprintf( $t['term_template'], esc_attr( get_term_link( $term ) ), $term-&gt;name );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( $links ) {&nbsp;</div></li><li><div>          $taxonomies[$taxonomy] = wp_sprintf( $t['template'], $t['label'], $links, $terms );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $taxonomies;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve all taxonomies of a post with just the names.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Optional. Post ID or WP_Post object. Default is global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_taxonomies( $post = 0 ) {&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return get_object_taxonomies($post);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Determine if the given object is associated with any of the given terms.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The given terms are checked against the object's terms' term_ids, names and slugs.</span>&nbsp;</div></li><li><div><span class="comment"> * Terms given as integers will only be checked against the object's terms' term_ids.</span>&nbsp;</div></li><li><div><span class="comment"> * If no terms are given, determines if object is associated with any terms in the given taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int              $object_id ID of the object (post ID, link ID, ...).</span>&nbsp;</div></li><li><div><span class="comment"> * @param string           $taxonomy  Single taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|string|array $terms     Optional. Term term_id, name, slug or array of said. Default null.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|WP_Error WP_Error on input error.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_object_in_term( $object_id, $taxonomy, $terms = null ) {&nbsp;</div></li><li><div>  if ( !$object_id = (int) $object_id )&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_object', __( 'Invalid object ID' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $object_terms = get_object_term_cache( $object_id, $taxonomy );&nbsp;</div></li><li><div>  if ( false === $object_terms ) {&nbsp;</div></li><li><div>      $object_terms = wp_get_object_terms( $object_id, $taxonomy, array( 'update_term_meta_cache' =&gt; false ) );&nbsp;</div></li><li><div>      if ( is_wp_error( $object_terms ) ) {&nbsp;</div></li><li><div>          return $object_terms;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_cache_set( $object_id, wp_list_pluck( $object_terms, 'term_id' ), &quot;{$taxonomy}_relationships&quot; );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error( $object_terms ) )&nbsp;</div></li><li><div>      return $object_terms;&nbsp;</div></li><li><div>  if ( empty( $object_terms ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  if ( empty( $terms ) )&nbsp;</div></li><li><div>      return ( !empty( $object_terms ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $terms = (array) $terms;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $ints = array_filter( $terms, 'is_int' ) )&nbsp;</div></li><li><div>      $strs = array_diff( $terms, $ints );&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $strs =& $terms;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $object_terms as $object_term ) {&nbsp;</div></li><li><div>      <span class="comment">// If term is an int, check against term_ids only.</span>&nbsp;</div></li><li><div>      if ( $ints && in_array( $object_term-&gt;term_id, $ints ) ) {&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $strs ) {&nbsp;</div></li><li><div>          <span class="comment">// Only check numeric strings against term_id, to avoid false matches due to type juggling.</span>&nbsp;</div></li><li><div>          $numeric_strs = array_map( 'intval', array_filter( $strs, 'is_numeric' ) );&nbsp;</div></li><li><div>          if ( in_array( $object_term-&gt;term_id, $numeric_strs, true ) ) {&nbsp;</div></li><li><div>              return true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( in_array( $object_term-&gt;name, $strs ) ) return true;&nbsp;</div></li><li><div>          if ( in_array( $object_term-&gt;slug, $strs ) ) return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Determine if the given object type is associated with the given taxonomy.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $object_type Object type string.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy    Single taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True if object is associated with the taxonomy, otherwise false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_object_in_taxonomy( $object_type, $taxonomy ) {&nbsp;</div></li><li><div>  $taxonomies = get_object_taxonomies( $object_type );&nbsp;</div></li><li><div>  if ( empty( $taxonomies ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return in_array( $taxonomy, $taxonomies );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get an array of ancestor IDs for a given object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.1.0 Introduced the `$resource_type` argument.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $object_id     Optional. The ID of the object. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $object_type   Optional. The type of object for which we'll be retrieving</span>&nbsp;</div></li><li><div><span class="comment"> *                              ancestors. Accepts a post type or a taxonomy name. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $resource_type Optional. Type of resource $object_type is. Accepts 'post_type'</span>&nbsp;</div></li><li><div><span class="comment"> *                              or 'taxonomy'. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array An array of ancestors from lowest to highest in the hierarchy.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_ancestors( $object_id = 0, $object_type = '', $resource_type = '' ) {&nbsp;</div></li><li><div>  $object_id = (int) $object_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $ancestors = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $object_id ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">/** This filter is documented in wp-includes/taxonomy.php */</span></span>&nbsp;</div></li><li><div>      return apply_filters( 'get_ancestors', $ancestors, $object_id, $object_type, $resource_type );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $resource_type ) {&nbsp;</div></li><li><div>      if ( is_taxonomy_hierarchical( $object_type ) ) {&nbsp;</div></li><li><div>          $resource_type = 'taxonomy';&nbsp;</div></li><li><div>      } elseif ( post_type_exists( $object_type ) ) {&nbsp;</div></li><li><div>          $resource_type = 'post_type';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'taxonomy' === $resource_type ) {&nbsp;</div></li><li><div>      $term = get_term($object_id, $object_type);&nbsp;</div></li><li><div>      while ( ! is_wp_error($term) && ! empty( $term-&gt;parent ) && ! in_array( $term-&gt;parent, $ancestors ) ) {&nbsp;</div></li><li><div>          $ancestors[] = (int) $term-&gt;parent;&nbsp;</div></li><li><div>          $term = get_term($term-&gt;parent, $object_type);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } elseif ( 'post_type' === $resource_type ) {&nbsp;</div></li><li><div>      $ancestors = get_post_ancestors($object_id);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters a given object's ancestors.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.1 Introduced the `$resource_type` parameter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $ancestors     An array of object ancestors.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $object_id     Object ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $object_type   Type of object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $resource_type Type of resource $object_type is.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_ancestors', $ancestors, $object_id, $object_type, $resource_type );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Returns the term's parent's term_ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id  Term ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false False on error.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_term_taxonomy_parent_id( $term_id, $taxonomy ) {&nbsp;</div></li><li><div>  $term = get_term( $term_id, $taxonomy );&nbsp;</div></li><li><div>  if ( ! $term || is_wp_error( $term ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return (int) $term-&gt;parent;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Checks the given subset of the term hierarchy for hierarchy loops.</span>&nbsp;</div></li><li><div><span class="comment"> * Prevents loops from forming and breaks those that it finds.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Attached to the {@see 'wp_update_term_parent'} filter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $parent   `term_id` of the parent for the term we're checking.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $term_id  The term we're checking.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy The taxonomy of the term we're checking.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return int The new parent for the term.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_check_term_hierarchy_for_loops( $parent, $term_id, $taxonomy ) {&nbsp;</div></li><li><div>  <span class="comment">// Nothing fancy here - bail</span>&nbsp;</div></li><li><div>  if ( !$parent )&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Can't be its own parent.</span>&nbsp;</div></li><li><div>  if ( $parent == $term_id )&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Now look for larger loops.</span>&nbsp;</div></li><li><div>  if ( !$loop = wp_find_hierarchy_loop( 'wp_get_term_taxonomy_parent_id', $term_id, $parent, array( $taxonomy ) ) )&nbsp;</div></li><li><div>      return $parent; <span class="comment">// No loop</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Setting $parent to the given value causes a loop.</span>&nbsp;</div></li><li><div>  if ( isset( $loop[$term_id] ) )&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// There's a loop, but it doesn't contain $term_id. Break the loop.</span>&nbsp;</div></li><li><div>  foreach ( array_keys( $loop ) as $loop_member )&nbsp;</div></li><li><div>      wp_update_term( $loop_member, $taxonomy, array( 'parent' =&gt; 0 ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $parent;&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>file</li><li><span></span></li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2017 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer> <script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>