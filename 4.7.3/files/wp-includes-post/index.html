<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="wordpress" data-version="4.7.3" data-type="file" data-id="4827"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp-includes-post | file | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, wordpress, 4.7.3" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.25"}};!function(e,n,t){var a;function i(e){var t=n.createElement("canvas"),a=t.getContext&&t.getContext("2d"),i=String.fromCharCode;return!(!a||!a.fillText)&&(a.textBaseline="top",a.font="600 32px Arial","flag"===e?(a.fillText(i(55356,56806,55356,56826),0,0),3e3<t.toDataURL().length):"diversity"===e?(a.fillText(i(55356,57221),0,0),t=a.getImageData(16,16,1,1).data,a.fillText(i(55356,57221,55356,57343),0,0),(t=a.getImageData(16,16,1,1).data)[0],t[1],t[2],t[3],!0):("simple"===e?a.fillText(i(55357,56835),0,0):a.fillText(i(55356,57135),0,0),0!==a.getImageData(16,16,1,1).data[0]))}function o(e){var t=n.createElement("script");t.src=e,t.type="text/javascript",n.getElementsByTagName("head")[0].appendChild(t)}t.supports={simple:i("simple"),flag:i("flag"),unicode8:i("unicode8"),diversity:i("diversity")},t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.simple&&t.supports.flag&&t.supports.unicode8&&t.supports.diversity||(a=function(){t.readyCallback()},n.addEventListener?(n.addEventListener("DOMContentLoaded",a,!1),e.addEventListener("load",a,!1)):(e.attachEvent("onload",a),n.attachEvent("onreadystatechange",function(){"complete"===n.readyState&&t.readyCallback()})),(a=t.source||{}).concatemoji?o(a.concatemoji):a.wpemoji&&a.twemoji&&(o(a.twemoji),o(a.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=0758b5b9b75c96fcca5e273376491da1' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.25' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/wp-includes-post/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-post%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-includes-post%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.3-file-wp-includes-post","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp-includes-post" class="blog single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.3." href="http://hookr.io/4.7.3/" class="H_VERSION"><span property="name">4.7.3</span></a><meta property="position" content="2"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp-includes-post</span><meta property="position" content="3"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="6309"><a href="http://hookr.io/4.7.3/all/" title="All">All <span class="count badge">6309</span></a></li><li class="" data-id="new" data-count="1"><a href="http://hookr.io/4.7.3/new/" title="New">New <span class="count badge">1</span></a></li><li class="" data-id="hooks" data-count="2532"><a href="http://hookr.io/4.7.3/hooks/" title="Hooks">Hooks <span class="count badge">2532</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.3/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1668"><a href="http://hookr.io/4.7.3/filters/" title="Filters">Filters <span class="count badge">1668</span></a></li><li class="" data-id="class" data-count="351"><a href="http://hookr.io/4.7.3/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.3/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2852"><a href="http://hookr.io/4.7.3/functions/" title="Functions">Functions <span class="count badge">2852</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.3/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/wp-includes/post.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Core Post API</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage Post</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">// Post Type Registration</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Creates the initial post types when 'init' action is fired.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * See {@see 'init'}.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function create_initial_post_types() {&nbsp;</div></li><li><div>  register_post_type( 'post', array(&nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name_admin_bar' =&gt; _x( 'Post', 'add new from admin bar' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'public' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      '_edit_link' =&gt; 'post.php?post=%d', <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'capability_type' =&gt; 'post', &nbsp;</div></li><li><div>      'map_meta_cap' =&gt; true, &nbsp;</div></li><li><div>      'menu_position' =&gt; 5, &nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'delete_with_user' =&gt; true, &nbsp;</div></li><li><div>      'supports' =&gt; array( 'title', 'editor', 'author', 'thumbnail', 'excerpt', 'trackbacks', 'custom-fields', 'comments', 'revisions', 'post-formats' ), &nbsp;</div></li><li><div>      'show_in_rest' =&gt; true, &nbsp;</div></li><li><div>      'rest_base' =&gt; 'posts', &nbsp;</div></li><li><div>      'rest_controller_class' =&gt; 'WP_REST_Posts_Controller', &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_type( 'page', array(&nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name_admin_bar' =&gt; _x( 'Page', 'add new from admin bar' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'public' =&gt; true, &nbsp;</div></li><li><div>      'publicly_queryable' =&gt; false, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      '_edit_link' =&gt; 'post.php?post=%d', <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'capability_type' =&gt; 'page', &nbsp;</div></li><li><div>      'map_meta_cap' =&gt; true, &nbsp;</div></li><li><div>      'menu_position' =&gt; 20, &nbsp;</div></li><li><div>      'hierarchical' =&gt; true, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'delete_with_user' =&gt; true, &nbsp;</div></li><li><div>      'supports' =&gt; array( 'title', 'editor', 'author', 'thumbnail', 'page-attributes', 'custom-fields', 'comments', 'revisions' ), &nbsp;</div></li><li><div>      'show_in_rest' =&gt; true, &nbsp;</div></li><li><div>      'rest_base' =&gt; 'pages', &nbsp;</div></li><li><div>      'rest_controller_class' =&gt; 'WP_REST_Posts_Controller', &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_type( 'attachment', array(&nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; _x('Media', 'post type general name'), &nbsp;</div></li><li><div>          'name_admin_bar' =&gt; _x( 'Media', 'add new from admin bar' ), &nbsp;</div></li><li><div>          'add_new' =&gt; _x( 'Add New', 'add new media' ), &nbsp;</div></li><li><div>           'edit_item' =&gt; __( 'Edit Media' ), &nbsp;</div></li><li><div>           'view_item' =&gt; __( 'View Attachment Page' ), &nbsp;</div></li><li><div>          'attributes' =&gt; __( 'Attachment Attributes' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'public' =&gt; true, &nbsp;</div></li><li><div>      'show_ui' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      '_edit_link' =&gt; 'post.php?post=%d', <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'capability_type' =&gt; 'post', &nbsp;</div></li><li><div>      'capabilities' =&gt; array(&nbsp;</div></li><li><div>          'create_posts' =&gt; 'upload_files', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'map_meta_cap' =&gt; true, &nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'show_in_nav_menus' =&gt; false, &nbsp;</div></li><li><div>      'delete_with_user' =&gt; true, &nbsp;</div></li><li><div>      'supports' =&gt; array( 'title', 'author', 'comments' ), &nbsp;</div></li><li><div>      'show_in_rest' =&gt; true, &nbsp;</div></li><li><div>      'rest_base' =&gt; 'media', &nbsp;</div></li><li><div>      'rest_controller_class' =&gt; 'WP_REST_Attachments_Controller', &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>  add_post_type_support( 'attachment:audio', 'thumbnail' );&nbsp;</div></li><li><div>  add_post_type_support( 'attachment:video', 'thumbnail' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_type( 'revision', array(&nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; __( 'Revisions' ), &nbsp;</div></li><li><div>          'singular_name' =&gt; __( 'Revision' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'public' =&gt; false, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      '_edit_link' =&gt; 'revision.php?revision=%d', <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'capability_type' =&gt; 'post', &nbsp;</div></li><li><div>      'map_meta_cap' =&gt; true, &nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'can_export' =&gt; false, &nbsp;</div></li><li><div>      'delete_with_user' =&gt; true, &nbsp;</div></li><li><div>      'supports' =&gt; array( 'author' ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_type( 'nav_menu_item', array(&nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; __( 'Navigation Menu Items' ), &nbsp;</div></li><li><div>          'singular_name' =&gt; __( 'Navigation Menu Item' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'public' =&gt; false, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'delete_with_user' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_type( 'custom_css', array(&nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; __( 'Custom CSS' ), &nbsp;</div></li><li><div>          'singular_name' =&gt; __( 'Custom CSS' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'public' =&gt; false, &nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'delete_with_user' =&gt; false, &nbsp;</div></li><li><div>      'can_export' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'supports' =&gt; array( 'title', 'revisions' ), &nbsp;</div></li><li><div>      'capabilities' =&gt; array(&nbsp;</div></li><li><div>          'delete_posts' =&gt; 'edit_theme_options', &nbsp;</div></li><li><div>          'delete_post' =&gt; 'edit_theme_options', &nbsp;</div></li><li><div>          'delete_published_posts' =&gt; 'edit_theme_options', &nbsp;</div></li><li><div>          'delete_private_posts' =&gt; 'edit_theme_options', &nbsp;</div></li><li><div>          'delete_others_posts' =&gt; 'edit_theme_options', &nbsp;</div></li><li><div>          'edit_post' =&gt; 'edit_css', &nbsp;</div></li><li><div>          'edit_posts' =&gt; 'edit_css', &nbsp;</div></li><li><div>          'edit_others_posts' =&gt; 'edit_css', &nbsp;</div></li><li><div>          'edit_published_posts' =&gt; 'edit_css', &nbsp;</div></li><li><div>          'read_post' =&gt; 'read', &nbsp;</div></li><li><div>          'read_private_posts' =&gt; 'read', &nbsp;</div></li><li><div>          'publish_posts' =&gt; 'edit_theme_options', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_type( 'customize_changeset', array(&nbsp;</div></li><li><div>      'labels' =&gt; array(&nbsp;</div></li><li><div>          'name' =&gt; _x( 'Changesets', 'post type general name' ), &nbsp;</div></li><li><div>          'singular_name' =&gt; _x( 'Changeset', 'post type singular name' ), &nbsp;</div></li><li><div>          'menu_name' =&gt; _x( 'Changesets', 'admin menu' ), &nbsp;</div></li><li><div>          'name_admin_bar' =&gt; _x( 'Changeset', 'add new on admin bar' ), &nbsp;</div></li><li><div>          'add_new' =&gt; _x( 'Add New', 'Customize Changeset' ), &nbsp;</div></li><li><div>          'add_new_item' =&gt; __( 'Add New Changeset' ), &nbsp;</div></li><li><div>          'new_item' =&gt; __( 'New Changeset' ), &nbsp;</div></li><li><div>          'edit_item' =&gt; __( 'Edit Changeset' ), &nbsp;</div></li><li><div>          'view_item' =&gt; __( 'View Changeset' ), &nbsp;</div></li><li><div>          'all_items' =&gt; __( 'All Changesets' ), &nbsp;</div></li><li><div>          'search_items' =&gt; __( 'Search Changesets' ), &nbsp;</div></li><li><div>          'not_found' =&gt; __( 'No changesets found.' ), &nbsp;</div></li><li><div>          'not_found_in_trash' =&gt; __( 'No changesets found in Trash.' ), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>      'public' =&gt; false, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. don't use this when registering your own post type. */</span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'map_meta_cap' =&gt; true, &nbsp;</div></li><li><div>      'hierarchical' =&gt; false, &nbsp;</div></li><li><div>      'rewrite' =&gt; false, &nbsp;</div></li><li><div>      'query_var' =&gt; false, &nbsp;</div></li><li><div>      'can_export' =&gt; false, &nbsp;</div></li><li><div>      'delete_with_user' =&gt; false, &nbsp;</div></li><li><div>      'supports' =&gt; array( 'title', 'author' ), &nbsp;</div></li><li><div>      'capability_type' =&gt; 'customize_changeset', &nbsp;</div></li><li><div>      'capabilities' =&gt; array(&nbsp;</div></li><li><div>          'create_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'delete_others_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'delete_post' =&gt; 'customize', &nbsp;</div></li><li><div>          'delete_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'delete_private_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'delete_published_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'edit_others_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'edit_post' =&gt; 'customize', &nbsp;</div></li><li><div>          'edit_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'edit_private_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'edit_published_posts' =&gt; 'do_not_allow', &nbsp;</div></li><li><div>          'publish_posts' =&gt; 'customize', &nbsp;</div></li><li><div>          'read' =&gt; 'read', &nbsp;</div></li><li><div>          'read_post' =&gt; 'customize', &nbsp;</div></li><li><div>          'read_private_posts' =&gt; 'customize', &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'publish', array(&nbsp;</div></li><li><div>      'label' =&gt; _x( 'Published', 'post status' ), &nbsp;</div></li><li><div>      'public' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'label_count' =&gt; _n_noop( 'Published &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Published &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;' ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'future', array(&nbsp;</div></li><li><div>      'label' =&gt; _x( 'Scheduled', 'post status' ), &nbsp;</div></li><li><div>      'protected' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'label_count' =&gt; _n_noop('Scheduled &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Scheduled &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;' ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'draft', array(&nbsp;</div></li><li><div>      'label' =&gt; _x( 'Draft', 'post status' ), &nbsp;</div></li><li><div>      'protected' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'label_count' =&gt; _n_noop( 'Draft &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Drafts &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;' ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'pending', array(&nbsp;</div></li><li><div>      'label' =&gt; _x( 'Pending', 'post status' ), &nbsp;</div></li><li><div>      'protected' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'label_count' =&gt; _n_noop( 'Pending &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Pending &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;' ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'private', array(&nbsp;</div></li><li><div>      'label' =&gt; _x( 'Private', 'post status' ), &nbsp;</div></li><li><div>      'private' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'label_count' =&gt; _n_noop( 'Private &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Private &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;' ), &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'trash', array(&nbsp;</div></li><li><div>      'label' =&gt; _x( 'Trash', 'post status' ), &nbsp;</div></li><li><div>      'internal' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'label_count' =&gt; _n_noop( 'Trash &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Trash &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;' ), &nbsp;</div></li><li><div>      'show_in_admin_status_list' =&gt; true, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'auto-draft', array(&nbsp;</div></li><li><div>      'label' =&gt; 'auto-draft', &nbsp;</div></li><li><div>      'internal' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  register_post_status( 'inherit', array(&nbsp;</div></li><li><div>      'label' =&gt; 'inherit', &nbsp;</div></li><li><div>      'internal' =&gt; true, &nbsp;</div></li><li><div>      '_builtin' =&gt; true, <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** internal use only. */</span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      'exclude_from_search' =&gt; false, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve attached file path based on attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * By default the path will go through the 'get_attached_file' filter, but</span>&nbsp;</div></li><li><div><span class="comment"> * passing a true to the $unfiltered argument of get_attached_file() will</span>&nbsp;</div></li><li><div><span class="comment"> * return the file path unfiltered.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function works by getting the single post meta name, named</span>&nbsp;</div></li><li><div><span class="comment"> * '_wp_attached_file' and returning it. This is a convenience function to</span>&nbsp;</div></li><li><div><span class="comment"> * prevent looking up the meta name and provide a mechanism for sending the</span>&nbsp;</div></li><li><div><span class="comment"> * attached filename through a filter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int  $attachment_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $unfiltered    Optional. Whether to apply filters. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false The file path to where the attached file should be, false otherwise.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_attached_file( $attachment_id, $unfiltered = false ) {&nbsp;</div></li><li><div>  $file = get_post_meta( $attachment_id, '_wp_attached_file', true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If the file is relative, prepend upload dir.</span>&nbsp;</div></li><li><div>  if ( $file && 0 !== strpos( $file, '/' ) && ! preg_match( '|^.:\\\|', $file ) && ( ( $uploads = wp_get_upload_dir() ) && false === $uploads['error'] ) ) {&nbsp;</div></li><li><div>      $file = $uploads['basedir'] . &quot;/$file&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $unfiltered ) {&nbsp;</div></li><li><div>      return $file;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the attached file based on the given ID.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $file          Path to attached file.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $attachment_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_attached_file', $file, $attachment_id );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update attachment file path based on attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Used to update the file path of the attachment, which uses post meta name</span>&nbsp;</div></li><li><div><span class="comment"> * '_wp_attached_file' to store the path of the attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $attachment_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $file          File path for the attachment.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_attached_file( $attachment_id, $file ) {&nbsp;</div></li><li><div>  if ( !get_post( $attachment_id ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the path to the attached file to update.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $file          Path to the attached file to update.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $attachment_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $file = apply_filters( 'update_attached_file', $file, $attachment_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $file = _wp_relative_upload_path( $file ) )&nbsp;</div></li><li><div>      return update_post_meta( $attachment_id, '_wp_attached_file', $file );&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      return delete_post_meta( $attachment_id, '_wp_attached_file' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Return relative path to an uploaded file.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The path is relative to the current upload dir.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $path Full path to the file.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string Relative path on success, unchanged path on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _wp_relative_upload_path( $path ) {&nbsp;</div></li><li><div>  $new_path = $path;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $uploads = wp_get_upload_dir();&nbsp;</div></li><li><div>  if ( 0 === strpos( $new_path, $uploads['basedir'] ) ) {&nbsp;</div></li><li><div>          $new_path = str_replace( $uploads['basedir'], '', $new_path );&nbsp;</div></li><li><div>          $new_path = ltrim( $new_path, '/' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the relative path to an uploaded file.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $new_path Relative path to the file.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $path     Full path to the file.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( '_wp_relative_upload_path', $new_path, $path );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve all children of the post parent ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Normally, without any enhancements, the children would apply to pages. In the</span>&nbsp;</div></li><li><div><span class="comment"> * context of the inner workings of WordPress, pages, posts, and attachments</span>&nbsp;</div></li><li><div><span class="comment"> * share the same table, so therefore the functionality could apply to any one</span>&nbsp;</div></li><li><div><span class="comment"> * of them. It is then noted that while this function does not work on posts, it</span>&nbsp;</div></li><li><div><span class="comment"> * does not mean that it won't work on posts. It is recommended that you know</span>&nbsp;</div></li><li><div><span class="comment"> * what context you wish to retrieve the children of.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Attachments may also be made the child of a post, so if that is an accurate</span>&nbsp;</div></li><li><div><span class="comment"> * statement (which needs to be verified), it would then be possible to get</span>&nbsp;</div></li><li><div><span class="comment"> * all of the attachments for a post. Attachments have since changed since</span>&nbsp;</div></li><li><div><span class="comment"> * version 2.5, so this is most likely inaccurate, but serves generally as an</span>&nbsp;</div></li><li><div><span class="comment"> * example of what is possible.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The arguments listed as defaults are for this function and also of the</span>&nbsp;</div></li><li><div><span class="comment"> * get_posts() function. The arguments are combined with the get_children defaults</span>&nbsp;</div></li><li><div><span class="comment"> * and are then passed to the get_posts() function, which accepts additional arguments.</span>&nbsp;</div></li><li><div><span class="comment"> * You can replace the defaults in this function, listed below and the additional</span>&nbsp;</div></li><li><div><span class="comment"> * arguments listed in the get_posts() function.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The 'post_parent' is the most important argument and important attention</span>&nbsp;</div></li><li><div><span class="comment"> * needs to be paid to the $args parameter. If you pass either an object or an</span>&nbsp;</div></li><li><div><span class="comment"> * integer (number), then just the 'post_parent' is grabbed and everything else</span>&nbsp;</div></li><li><div><span class="comment"> * is lost. If you don't specify any arguments, then it is assumed that you are</span>&nbsp;</div></li><li><div><span class="comment"> * in The Loop and the post parent will be grabbed for from the current post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The 'post_parent' argument is the ID to get the children. The 'numberposts'</span>&nbsp;</div></li><li><div><span class="comment"> * is the amount of posts to retrieve that has a default of '-1', which is</span>&nbsp;</div></li><li><div><span class="comment"> * used to get all of the posts. Giving a number higher than 0 will only</span>&nbsp;</div></li><li><div><span class="comment"> * retrieve that amount of posts.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The 'post_type' and 'post_status' arguments can be used to choose what</span>&nbsp;</div></li><li><div><span class="comment"> * criteria of posts to retrieve. The 'post_type' can be anything, but WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * post types are 'post', 'pages', and 'attachments'. The 'post_status'</span>&nbsp;</div></li><li><div><span class="comment"> * argument will accept any post status within the write administration panels.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see get_posts()</span>&nbsp;</div></li><li><div><span class="comment"> * @todo Check validity of description.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Post $post</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $args   Optional. User defined arguments for replacing the defaults. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $output Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                       a WP_Post object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Array of children, where the type of each element is determined by $output parameter.</span>&nbsp;</div></li><li><div><span class="comment"> *               Empty array on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_children( $args = '', $output = OBJECT ) {&nbsp;</div></li><li><div>  $kids = array();&nbsp;</div></li><li><div>  if ( empty( $args ) ) {&nbsp;</div></li><li><div>      if ( isset( $GLOBALS['post'] ) ) {&nbsp;</div></li><li><div>          $args = array('post_parent' =&gt; (int) $GLOBALS['post']-&gt;post_parent );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return $kids;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } elseif ( is_object( $args ) ) {&nbsp;</div></li><li><div>      $args = array('post_parent' =&gt; (int) $args-&gt;post_parent );&nbsp;</div></li><li><div>  } elseif ( is_numeric( $args ) ) {&nbsp;</div></li><li><div>      $args = array('post_parent' =&gt; (int) $args);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'numberposts' =&gt; -1, 'post_type' =&gt; 'any', &nbsp;</div></li><li><div>      'post_status' =&gt; 'any', 'post_parent' =&gt; 0, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $children = get_posts( $r );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $children )&nbsp;</div></li><li><div>      return $kids;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $r['fields'] ) )&nbsp;</div></li><li><div>      return $children;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  update_post_cache($children);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $children as $key =&gt; $child )&nbsp;</div></li><li><div>      $kids[$child-&gt;ID] = $children[$key];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $output == OBJECT ) {&nbsp;</div></li><li><div>      return $kids;&nbsp;</div></li><li><div>  } elseif ( $output == ARRAY_A ) {&nbsp;</div></li><li><div>      $weeuns = array();&nbsp;</div></li><li><div>      foreach ( (array) $kids as $kid ) {&nbsp;</div></li><li><div>          $weeuns[$kid-&gt;ID] = get_object_vars($kids[$kid-&gt;ID]);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $weeuns;&nbsp;</div></li><li><div>  } elseif ( $output == ARRAY_N ) {&nbsp;</div></li><li><div>      $babes = array();&nbsp;</div></li><li><div>      foreach ( (array) $kids as $kid ) {&nbsp;</div></li><li><div>          $babes[$kid-&gt;ID] = array_values(get_object_vars($kids[$kid-&gt;ID]));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $babes;&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      return $kids;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get extended entry info (&lt;!--more--&gt;).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * There should not be any space after the second dash and before the word</span>&nbsp;</div></li><li><div><span class="comment"> * 'more'. There can be text or space(s) after the word 'more', but won't be</span>&nbsp;</div></li><li><div><span class="comment"> * referenced.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The returned array has 'main', 'extended', and 'more_text' keys. Main has the text before</span>&nbsp;</div></li><li><div><span class="comment"> * the `&lt;!--more--&gt;`. The 'extended' key has the content after the</span>&nbsp;</div></li><li><div><span class="comment"> * `&lt;!--more--&gt;` comment. The 'more_text' key has the custom &quot;Read More&quot; text.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post Post content.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Post before ('main'), after ('extended'), and custom read more ('more_text').</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_extended( $post ) {&nbsp;</div></li><li><div>  <span class="comment">//Match the new style more links.</span>&nbsp;</div></li><li><div>  if ( preg_match('/&lt;!--more(.*?)?--&gt;/', $post, $matches) ) {&nbsp;</div></li><li><div>      list($main, $extended) = explode($matches[0], $post, 2);&nbsp;</div></li><li><div>      $more_text = $matches[1];&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $main = $post;&nbsp;</div></li><li><div>      $extended = '';&nbsp;</div></li><li><div>      $more_text = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">//  leading and trailing whitespace.</span>&nbsp;</div></li><li><div>  $main = preg_replace('/^[\s]*(.*)[\s]*$/', '\\1', $main);&nbsp;</div></li><li><div>  $extended = preg_replace('/^[\s]*(.*)[\s]*$/', '\\1', $extended);&nbsp;</div></li><li><div>  $more_text = preg_replace('/^[\s]*(.*)[\s]*$/', '\\1', $more_text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return array( 'main' =&gt; $main, 'extended' =&gt; $extended, 'more_text' =&gt; $more_text );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves post data given a post ID or post object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * See sanitize_post() for optional $filter values. Also, the parameter</span>&nbsp;</div></li><li><div><span class="comment"> * `$post`, must be given as a variable, since it is passed by reference.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.1</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Post $post</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post|null $post   Optional. Post ID or post object. Defaults to global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string           $output Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                                 a WP_Post object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string           $filter Optional. Type of filter to apply. Accepts 'raw', 'edit', 'db', </span>&nbsp;</div></li><li><div><span class="comment"> *                                 or 'display'. Default 'raw'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Post|array|null Type corresponding to $output on success or null on failure.</span>&nbsp;</div></li><li><div><span class="comment"> *                            When $output is OBJECT, a `WP_Post` instance is returned.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post( $post = null, $output = OBJECT, $filter = 'raw' ) {&nbsp;</div></li><li><div>  if ( empty( $post ) && isset( $GLOBALS['post'] ) )&nbsp;</div></li><li><div>      $post = $GLOBALS['post'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $post instanceof WP_Post ) {&nbsp;</div></li><li><div>      $_post = $post;&nbsp;</div></li><li><div>  } elseif ( is_object( $post ) ) {&nbsp;</div></li><li><div>      if ( empty( $post-&gt;filter ) ) {&nbsp;</div></li><li><div>          $_post = sanitize_post( $post, 'raw' );&nbsp;</div></li><li><div>          $_post = new WP_Post( $_post );&nbsp;</div></li><li><div>      } elseif ( 'raw' == $post-&gt;filter ) {&nbsp;</div></li><li><div>          $_post = new WP_Post( $post );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $_post = WP_Post::get_instance( $post-&gt;ID );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $_post = WP_Post::get_instance( $post );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $_post )&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $_post = $_post-&gt;filter( $filter );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $output == ARRAY_A )&nbsp;</div></li><li><div>      return $_post-&gt;to_array();&nbsp;</div></li><li><div>  elseif ( $output == ARRAY_N )&nbsp;</div></li><li><div>      return array_values( $_post-&gt;to_array() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $_post;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve ancestors of a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Post ID or post object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Ancestor IDs or empty array if none are found.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_ancestors( $post ) {&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $post || empty( $post-&gt;post_parent ) || $post-&gt;post_parent == $post-&gt;ID )&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $ancestors = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $id = $ancestors[] = $post-&gt;post_parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  while ( $ancestor = get_post( $id ) ) {&nbsp;</div></li><li><div>      <span class="comment">// Loop detection: If the ancestor has been seen before, break.</span>&nbsp;</div></li><li><div>      if ( empty( $ancestor-&gt;post_parent ) || ( $ancestor-&gt;post_parent == $post-&gt;ID ) || in_array( $ancestor-&gt;post_parent, $ancestors ) )&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $id = $ancestors[] = $ancestor-&gt;post_parent;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $ancestors;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve data from a post field based on Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Examples of the post field will be, 'post_type', 'post_status', 'post_content', </span>&nbsp;</div></li><li><div><span class="comment"> * etc and based off of the post object property or key names.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The context values are based off of the taxonomy filter functions and</span>&nbsp;</div></li><li><div><span class="comment"> * supported values are found within those functions.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0 The `$post` parameter was made optional.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see sanitize_post_field()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string      $field   Post field name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post    Optional. Post ID or post object. Defaults to current post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string      $context Optional. How to filter the field. Accepts 'raw', 'edit', 'db', </span>&nbsp;</div></li><li><div><span class="comment"> *                             or 'display'. Default 'display'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string The value of the post field on success, empty string on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_field( $field, $post = null, $context = 'display' ) {&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$post )&nbsp;</div></li><li><div>      return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset($post-&gt;$field) )&nbsp;</div></li><li><div>      return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return sanitize_post_field($field, $post-&gt;$field, $post-&gt;ID, $context);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the mime type of an attachment based on the ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function can be used with any post type, but it makes more sense with</span>&nbsp;</div></li><li><div><span class="comment"> * attachments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $ID Optional. Post ID or post object. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false The mime type on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_mime_type( $ID = '' ) {&nbsp;</div></li><li><div>  $post = get_post($ID);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_object($post) )&nbsp;</div></li><li><div>      return $post-&gt;post_mime_type;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the post status based on the Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the post ID is of an attachment, then the parent post status will be given</span>&nbsp;</div></li><li><div><span class="comment"> * instead.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $ID Optional. Post ID or post object. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false Post status on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_status( $ID = '' ) {&nbsp;</div></li><li><div>  $post = get_post($ID);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_object($post) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' == $post-&gt;post_type ) {&nbsp;</div></li><li><div>      if ( 'private' == $post-&gt;post_status )&nbsp;</div></li><li><div>          return 'private';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Unattached attachments are assumed to be published.</span>&nbsp;</div></li><li><div>      if ( ( 'inherit' == $post-&gt;post_status ) && ( 0 == $post-&gt;post_parent) )&nbsp;</div></li><li><div>          return 'publish';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Inherit status from the parent.</span>&nbsp;</div></li><li><div>      if ( $post-&gt;post_parent && ( $post-&gt;ID != $post-&gt;post_parent ) ) {&nbsp;</div></li><li><div>          $parent_post_status = get_post_status( $post-&gt;post_parent );&nbsp;</div></li><li><div>          if ( 'trash' == $parent_post_status ) {&nbsp;</div></li><li><div>              return get_post_meta( $post-&gt;post_parent, '_wp_trash_meta_status', true );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              return $parent_post_status;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the post status.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string  $post_status The post status.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post        The post object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_post_status', $post-&gt;post_status, $post );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve all of the WordPress supported post statuses.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Posts have a limited set of valid status values, this provides the</span>&nbsp;</div></li><li><div><span class="comment"> * post_status values and descriptions.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of post statuses.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_statuses() {&nbsp;</div></li><li><div>  $status = array(&nbsp;</div></li><li><div>      'draft' =&gt; __( 'Draft' ), &nbsp;</div></li><li><div>      'pending' =&gt; __( 'Pending Review' ), &nbsp;</div></li><li><div>      'private' =&gt; __( 'Private' ), &nbsp;</div></li><li><div>      'publish' =&gt; __( 'Published' )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $status;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve all of the WordPress support page statuses.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Pages have a limited set of valid status values, this provides the</span>&nbsp;</div></li><li><div><span class="comment"> * post_status values and descriptions.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of page statuses.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page_statuses() {&nbsp;</div></li><li><div>  $status = array(&nbsp;</div></li><li><div>      'draft' =&gt; __( 'Draft' ), &nbsp;</div></li><li><div>      'private' =&gt; __( 'Private' ), &nbsp;</div></li><li><div>      'publish' =&gt; __( 'Published' )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $status;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Register a post status. Do not use before init.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A simple function for creating or modifying a post status based on the</span>&nbsp;</div></li><li><div><span class="comment"> * parameters given. The function will accept an array (second optional</span>&nbsp;</div></li><li><div><span class="comment"> * parameter), along with a string for the post status name.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Arguments prefixed with an _underscore shouldn't be used by plugins and themes.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_post_statuses Inserts new post status object into the list</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_status Name of the post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Array or string of post status arguments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool|string $label                     A descriptive name for the post status marked</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  for translation. Defaults to value of $post_status.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool|array  $label_count               Descriptive text to use for nooped plurals.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  Default array of $label, twice</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $exclude_from_search       Whether to exclude posts with this post status</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  from search results. Default is value of $internal.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $_builtin                  Whether the status is built-in. Core-use only.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $public                    Whether posts of this status should be shown</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  in the front end of the site. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $internal                  Whether the status is for internal use only.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $protected                 Whether posts with this status should be protected.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $private                   Whether posts with this status should be private.</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $publicly_queryable        Whether posts with this status should be publicly-</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  queryable. Default is value of $public.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $show_in_admin_all_list    Whether to include posts in the edit listing for</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  their post type. Default is value of $internal.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $show_in_admin_status_list Show in the list of statuses with post counts at</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  the top of the edit listings, </span>&nbsp;</div></li><li><div><span class="comment"> *                                                  e.g. All (12) | Published (9) | My Custom Status (2)</span>&nbsp;</div></li><li><div><span class="comment"> *                                                  Default is value of $internal.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return object</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function register_post_status( $post_status, $args = array() ) {&nbsp;</div></li><li><div>  global $wp_post_statuses;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if (!is_array($wp_post_statuses))&nbsp;</div></li><li><div>      $wp_post_statuses = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Args prefixed with an underscore are reserved for internal use.</span>&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'label' =&gt; false, &nbsp;</div></li><li><div>      'label_count' =&gt; false, &nbsp;</div></li><li><div>      'exclude_from_search' =&gt; null, &nbsp;</div></li><li><div>      '_builtin' =&gt; false, &nbsp;</div></li><li><div>      'public' =&gt; null, &nbsp;</div></li><li><div>      'internal' =&gt; null, &nbsp;</div></li><li><div>      'protected' =&gt; null, &nbsp;</div></li><li><div>      'private' =&gt; null, &nbsp;</div></li><li><div>      'publicly_queryable' =&gt; null, &nbsp;</div></li><li><div>      'show_in_admin_status_list' =&gt; null, &nbsp;</div></li><li><div>      'show_in_admin_all_list' =&gt; null, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>  $args = (object) $args;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_status = sanitize_key($post_status);&nbsp;</div></li><li><div>  $args-&gt;name = $post_status;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Set various defaults.</span>&nbsp;</div></li><li><div>  if ( null === $args-&gt;public && null === $args-&gt;internal && null === $args-&gt;protected && null === $args-&gt;private )&nbsp;</div></li><li><div>      $args-&gt;internal = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;public )&nbsp;</div></li><li><div>      $args-&gt;public = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;private )&nbsp;</div></li><li><div>      $args-&gt;private = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;protected )&nbsp;</div></li><li><div>      $args-&gt;protected = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;internal )&nbsp;</div></li><li><div>      $args-&gt;internal = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;publicly_queryable )&nbsp;</div></li><li><div>      $args-&gt;publicly_queryable = $args-&gt;public;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;exclude_from_search )&nbsp;</div></li><li><div>      $args-&gt;exclude_from_search = $args-&gt;internal;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;show_in_admin_all_list )&nbsp;</div></li><li><div>      $args-&gt;show_in_admin_all_list = !$args-&gt;internal;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $args-&gt;show_in_admin_status_list )&nbsp;</div></li><li><div>      $args-&gt;show_in_admin_status_list = !$args-&gt;internal;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( false === $args-&gt;label )&nbsp;</div></li><li><div>      $args-&gt;label = $post_status;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( false === $args-&gt;label_count )&nbsp;</div></li><li><div>      $args-&gt;label_count = array( $args-&gt;label, $args-&gt;label );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wp_post_statuses[$post_status] = $args;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $args;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve a post status object by name.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_post_statuses List of post statuses.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see register_post_status()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_status The name of a registered post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object|null A post status object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_status_object( $post_status ) {&nbsp;</div></li><li><div>  global $wp_post_statuses;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($wp_post_statuses[$post_status]) )&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $wp_post_statuses[$post_status];&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get a list of post statuses.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_post_statuses List of post statuses.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see register_post_status()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args     Optional. Array or string of post status arguments to compare against</span>&nbsp;</div></li><li><div><span class="comment"> *                               properties of the global `$wp_post_statuses objects`. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $output   Optional. The type of output to return, either 'names' or 'objects'. Default 'names'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $operator Optional. The logical operation to perform. 'or' means only one element</span>&nbsp;</div></li><li><div><span class="comment"> *                               from the array needs to match; 'and' means all elements must match.</span>&nbsp;</div></li><li><div><span class="comment"> *                               Default 'and'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array A list of post status names or objects.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_stati( $args = array(), $output = 'names', $operator = 'and' ) {&nbsp;</div></li><li><div>  global $wp_post_statuses;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $field = ('names' == $output) ? 'name' : false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_filter_object_list($wp_post_statuses, $args, $operator, $field);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Whether the post type is hierarchical.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A false return value might also mean that the post type does not exist.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see get_post_type_object()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Post type name</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether post type is hierarchical.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_post_type_hierarchical( $post_type ) {&nbsp;</div></li><li><div>  if ( ! post_type_exists( $post_type ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type = get_post_type_object( $post_type );&nbsp;</div></li><li><div>  return $post_type-&gt;hierarchical;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check if a post type is registered.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see get_post_type_object()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Post type name.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether post type is registered.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function post_type_exists( $post_type ) {&nbsp;</div></li><li><div>  return (bool) get_post_type_object( $post_type );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves the post type of the current post or of a given post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post|null $post Optional. Post ID or post object. Default is global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false          Post type on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_type( $post = null ) {&nbsp;</div></li><li><div>  if ( $post = get_post( $post ) )&nbsp;</div></li><li><div>      return $post-&gt;post_type;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves a post type object by name.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.6.0 Object returned is now an instance of WP_Post_Type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_post_types List of post types.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see register_post_type()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type The name of a registered post type.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Post_Type|null WP_Post_Type object if it exists, null otherwise.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_type_object( $post_type ) {&nbsp;</div></li><li><div>  global $wp_post_types;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_scalar( $post_type ) || empty( $wp_post_types[ $post_type ] ) ) {&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $wp_post_types[ $post_type ];&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get a list of all registered post type objects.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_post_types List of post types.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see register_post_type() for accepted arguments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args     Optional. An array of key =&gt; value arguments to match against</span>&nbsp;</div></li><li><div><span class="comment"> *                               the post type objects. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $output   Optional. The type of output to return. Accepts post type 'names'</span>&nbsp;</div></li><li><div><span class="comment"> *                               or 'objects'. Default 'names'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $operator Optional. The logical operation to perform. 'or' means only one</span>&nbsp;</div></li><li><div><span class="comment"> *                               element from the array needs to match; 'and' means all elements</span>&nbsp;</div></li><li><div><span class="comment"> *                               must match; 'not' means no elements may match. Default 'and'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array A list of post type names or objects.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_types( $args = array(), $output = 'names', $operator = 'and' ) {&nbsp;</div></li><li><div>  global $wp_post_types;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $field = ('names' == $output) ? 'name' : false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_filter_object_list($wp_post_types, $args, $operator, $field);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Registers a post type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Note: Post type registrations should not be hooked before the</span>&nbsp;</div></li><li><div><span class="comment"> * {@see 'init'} action. Also, any taxonomy connections should be</span>&nbsp;</div></li><li><div><span class="comment"> * registered via the `$taxonomies` argument to ensure consistency</span>&nbsp;</div></li><li><div><span class="comment"> * when hooks such as {@see 'parse_query'} or {@see 'pre_get_posts'}</span>&nbsp;</div></li><li><div><span class="comment"> * are used.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Post types can support any number of built-in core features such</span>&nbsp;</div></li><li><div><span class="comment"> * as meta boxes, custom fields, post thumbnails, post statuses, </span>&nbsp;</div></li><li><div><span class="comment"> * comments, and more. See the `$supports` argument for a complete</span>&nbsp;</div></li><li><div><span class="comment"> * list of supported features.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0 The `show_ui` argument is now enforced on the new post screen.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 The `show_ui` argument is now enforced on the post type listing</span>&nbsp;</div></li><li><div><span class="comment"> *              screen and post editing screen.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.6.0 Post type object returned is now an instance of WP_Post_Type.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Introduced `show_in_rest`, 'rest_base' and 'rest_controller_class'</span>&nbsp;</div></li><li><div><span class="comment"> *              arguments to register the post type in REST API.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_post_types List of post types.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Post type key. Must not exceed 20 characters and may</span>&nbsp;</div></li><li><div><span class="comment"> *                          only contain lowercase alphanumeric characters, dashes, </span>&nbsp;</div></li><li><div><span class="comment"> *                          and underscores. See sanitize_key().</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Array or string of arguments for registering a post type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string      $label                 Name of the post type shown in the menu. Usually plural.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Default is value of $labels['name'].</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array       $labels                An array of labels for this post type. If not set, post</span>&nbsp;</div></li><li><div><span class="comment"> *                                              labels are inherited for non-hierarchical types and page</span>&nbsp;</div></li><li><div><span class="comment"> *                                              labels for hierarchical ones. See get_post_type_labels() for a full</span>&nbsp;</div></li><li><div><span class="comment"> *                                              list of supported labels.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string      $description           A short descriptive summary of what the post type is.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $public                Whether a post type is intended for use publicly either via</span>&nbsp;</div></li><li><div><span class="comment"> *                                              the admin interface or by front-end users. While the default</span>&nbsp;</div></li><li><div><span class="comment"> *                                              settings of $exclude_from_search, $publicly_queryable, $show_ui, </span>&nbsp;</div></li><li><div><span class="comment"> *                                              and $show_in_nav_menus are inherited from public, each does not</span>&nbsp;</div></li><li><div><span class="comment"> *                                              rely on this relationship and controls a very specific intention.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $hierarchical          Whether the post type is hierarchical (e.g. page). Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $exclude_from_search   Whether to exclude posts with this post type from front end search</span>&nbsp;</div></li><li><div><span class="comment"> *                                              results. Default is the opposite value of $public.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $publicly_queryable    Whether queries can be performed on the front end for the post type</span>&nbsp;</div></li><li><div><span class="comment"> *                                              as part of parse_request(). Endpoints would include:</span>&nbsp;</div></li><li><div><span class="comment"> *                                              * ?post_type={post_type_key}</span>&nbsp;</div></li><li><div><span class="comment"> *                                              * ?{post_type_key}={single_post_slug}</span>&nbsp;</div></li><li><div><span class="comment"> *                                              * ?{post_type_query_var}={single_post_slug}</span>&nbsp;</div></li><li><div><span class="comment"> *                                              If not set, the default is inherited from $public.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $show_ui               Whether to generate and allow a UI for managing this post type in the</span>&nbsp;</div></li><li><div><span class="comment"> *                                              admin. Default is value of $public.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $show_in_menu          Where to show the post type in the admin menu. To work, $show_ui</span>&nbsp;</div></li><li><div><span class="comment"> *                                              must be true. If true, the post type is shown in its own top level</span>&nbsp;</div></li><li><div><span class="comment"> *                                              menu. If false, no menu is shown. If a string of an existing top</span>&nbsp;</div></li><li><div><span class="comment"> *                                              level menu (eg. 'tools.php' or 'edit.php?post_type=page'), the post</span>&nbsp;</div></li><li><div><span class="comment"> *                                              type will be placed as a sub-menu of that.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Default is value of $show_ui.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $show_in_nav_menus     Makes this post type available for selection in navigation menus.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Default is value $public.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $show_in_admin_bar     Makes this post type available via the admin bar. Default is value</span>&nbsp;</div></li><li><div><span class="comment"> *                                              of $show_in_menu.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $show_in_rest          Whether to add the post type route in the REST API 'wp/v2' namespace.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string      $rest_base             To change the base url of REST API route. Default is $post_type.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string      $rest_controller_class REST API Controller class name. Default is 'WP_REST_Posts_Controller'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int         $menu_position         The position in the menu order the post type should appear. To work, </span>&nbsp;</div></li><li><div><span class="comment"> *                                              $show_in_menu must be true. Default null (at the bottom).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string      $menu_icon             The url to the icon to be used for this menu. Pass a base64-encoded</span>&nbsp;</div></li><li><div><span class="comment"> *                                              SVG using a data URI, which will be colored to match the color scheme</span>&nbsp;</div></li><li><div><span class="comment"> *                                              -- this should begin with 'data:image/svg+xml;base64, '. Pass the name</span>&nbsp;</div></li><li><div><span class="comment"> *                                              of a Dashicons helper class to use a font icon, e.g.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              'dashicons-chart-pie'. Pass 'none' to leave div.wp-menu-image empty</span>&nbsp;</div></li><li><div><span class="comment"> *                                              so an icon can be added via CSS. Defaults to use the posts icon.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string      $capability_type       The string to use to build the read, edit, and delete capabilities.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              May be passed as an array to allow for alternative plurals when using</span>&nbsp;</div></li><li><div><span class="comment"> *                                              this argument as a base to construct the capabilities, e.g.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              array('story', 'stories'). Default 'post'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array       $capabilities          Array of capabilities for this post type. $capability_type is used</span>&nbsp;</div></li><li><div><span class="comment"> *                                              as a base to construct capabilities by default.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              See get_post_type_capabilities().</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $map_meta_cap          Whether to use the internal default meta capability handling.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array       $supports              Core feature(s) the post type supports. Serves as an alias for calling</span>&nbsp;</div></li><li><div><span class="comment"> *                                              add_post_type_support() directly. Core features include 'title', </span>&nbsp;</div></li><li><div><span class="comment"> *                                              'editor', 'comments', 'revisions', 'trackbacks', 'author', 'excerpt', </span>&nbsp;</div></li><li><div><span class="comment"> *                                              'page-attributes', 'thumbnail', 'custom-fields', and 'post-formats'.</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Additionally, the 'revisions' feature dictates whether the post type</span>&nbsp;</div></li><li><div><span class="comment"> *                                              will store revisions, and the 'comments' feature dictates whether the</span>&nbsp;</div></li><li><div><span class="comment"> *                                              comments count will show on the edit screen. Defaults is an array</span>&nbsp;</div></li><li><div><span class="comment"> *                                              containing 'title' and 'editor'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type callable    $register_meta_box_cb  Provide a callback function that sets up the meta boxes for the</span>&nbsp;</div></li><li><div><span class="comment"> *                                              edit form. Do remove_meta_box() and add_meta_box() calls in the</span>&nbsp;</div></li><li><div><span class="comment"> *                                              callback. Default null.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array       $taxonomies            An array of taxonomy identifiers that will be registered for the</span>&nbsp;</div></li><li><div><span class="comment"> *                                              post type. Taxonomies can be registered later with register_taxonomy()</span>&nbsp;</div></li><li><div><span class="comment"> *                                              or register_taxonomy_for_object_type().</span>&nbsp;</div></li><li><div><span class="comment"> *                                              Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool|string $has_archive           Whether there should be post type archives, or if a string, the</span>&nbsp;</div></li><li><div><span class="comment"> *                                              archive slug to use. Will generate the proper rewrite rules if</span>&nbsp;</div></li><li><div><span class="comment"> *                                              $rewrite is enabled. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool|array  $rewrite              {</span>&nbsp;</div></li><li><div><span class="comment"> *         Triggers the handling of rewrites for this post type. To prevent rewrite, set to false.</span>&nbsp;</div></li><li><div><span class="comment"> *         Defaults to true, using $post_type as slug. To specify rewrite rules, an array can be</span>&nbsp;</div></li><li><div><span class="comment"> *         passed with any of these keys:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *         @type string $slug       Customize the permastruct slug. Defaults to $post_type key.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type bool   $with_front Whether the permastruct should be prepended with WP_Rewrite::$front.</span>&nbsp;</div></li><li><div><span class="comment"> *                                  Default true.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type bool   $feeds      Whether the feed permastruct should be built for this post type.</span>&nbsp;</div></li><li><div><span class="comment"> *                                  Default is value of $has_archive.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type bool   $pages      Whether the permastruct should provide for pagination. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> *         @type const  $ep_mask    Endpoint mask to assign. If not specified and permalink_epmask is set, </span>&nbsp;</div></li><li><div><span class="comment"> *                                  inherits from $permalink_epmask. If not specified and permalink_epmask</span>&nbsp;</div></li><li><div><span class="comment"> *                                  is not set, defaults to EP_PERMALINK.</span>&nbsp;</div></li><li><div><span class="comment"> *     }</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|bool $query_var             Sets the query_var key for this post type. Defaults to $post_type</span>&nbsp;</div></li><li><div><span class="comment"> *                                              key. If false, a post type cannot be loaded at</span>&nbsp;</div></li><li><div><span class="comment"> *                                              ?{query_var}={post_slug}. If specified as a string, the query</span>&nbsp;</div></li><li><div><span class="comment"> *                                              ?{query_var_string}={post_slug} will be valid.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $can_export            Whether to allow this post type to be exported. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $delete_with_user      Whether to delete posts of this type when deleting a user. If true, </span>&nbsp;</div></li><li><div><span class="comment"> *                                              posts of this type belonging to the user will be moved to trash</span>&nbsp;</div></li><li><div><span class="comment"> *                                              when then user is deleted. If false, posts of this type belonging</span>&nbsp;</div></li><li><div><span class="comment"> *                                              to the user will *not* be trashed or deleted. If not set (the default), </span>&nbsp;</div></li><li><div><span class="comment"> *                                              posts are trashed if post_type_supports('author'). Otherwise posts</span>&nbsp;</div></li><li><div><span class="comment"> *                                              are not trashed or deleted. Default null.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool        $_builtin              FOR INTERNAL USE ONLY! True if this post type is a native or</span>&nbsp;</div></li><li><div><span class="comment"> *                                              &quot;built-in&quot; post_type. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string      $_edit_link            FOR INTERNAL USE ONLY! URL segment to use for edit link of</span>&nbsp;</div></li><li><div><span class="comment"> *                                              this post type. Default 'post.php?post=%d'.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Post_Type|WP_Error The registered post type object, or an error object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function register_post_type( $post_type, $args = array() ) {&nbsp;</div></li><li><div>  global $wp_post_types;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_array( $wp_post_types ) ) {&nbsp;</div></li><li><div>      $wp_post_types = array();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Sanitize post type name</span>&nbsp;</div></li><li><div>  $post_type = sanitize_key( $post_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $post_type ) || strlen( $post_type ) &gt; 20 ) {&nbsp;</div></li><li><div>      _doing_it_wrong( __FUNCTION__, __( 'Post type names must be between 1 and 20 characters in length.' ), '4.2.0' );&nbsp;</div></li><li><div>      return new WP_Error( 'post_type_length_invalid', __( 'Post type names must be between 1 and 20 characters in length.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type_object = new WP_Post_Type( $post_type, $args );&nbsp;</div></li><li><div>  $post_type_object-&gt;add_supports();&nbsp;</div></li><li><div>  $post_type_object-&gt;add_rewrite_rules();&nbsp;</div></li><li><div>  $post_type_object-&gt;register_meta_boxes();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wp_post_types[ $post_type ] = $post_type_object;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type_object-&gt;add_hooks();&nbsp;</div></li><li><div>  $post_type_object-&gt;register_taxonomies();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a post type is registered.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.6.0 Converted the `$post_type` parameter to accept a WP_Post_Type object.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string       $post_type        Post type.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post_Type $post_type_object Arguments used to register the post type.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'registered_post_type', $post_type, $post_type_object );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post_type_object;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Unregisters a post type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Can not be used to unregister built-in post types.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $wp_post_types List of post types.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Post type to unregister.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|WP_Error True on success, WP_Error on failure or if the post type doesn't exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function unregister_post_type( $post_type ) {&nbsp;</div></li><li><div>  global $wp_post_types;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! post_type_exists( $post_type ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_post_type', __( 'Invalid post type.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type_object = get_post_type_object( $post_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Do not allow unregistering internal post types.</span>&nbsp;</div></li><li><div>  if ( $post_type_object-&gt;_builtin ) {&nbsp;</div></li><li><div>      return new WP_Error( 'invalid_post_type', __( 'Unregistering a built-in post type is not allowed' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type_object-&gt;remove_supports();&nbsp;</div></li><li><div>  $post_type_object-&gt;remove_rewrite_rules();&nbsp;</div></li><li><div>  $post_type_object-&gt;unregister_meta_boxes();&nbsp;</div></li><li><div>  $post_type_object-&gt;remove_hooks();&nbsp;</div></li><li><div>  $post_type_object-&gt;unregister_taxonomies();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  unset( $wp_post_types[ $post_type ] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a post type was unregistered.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $post_type Post type key.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'unregistered_post_type', $post_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Build an object with all post type capabilities out of a post type object</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Post type capabilities use the 'capability_type' argument as a base, if the</span>&nbsp;</div></li><li><div><span class="comment"> * capability is not set in the 'capabilities' argument array or if the</span>&nbsp;</div></li><li><div><span class="comment"> * 'capabilities' argument is not supplied.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The capability_type argument can optionally be registered as an array, with</span>&nbsp;</div></li><li><div><span class="comment"> * the first value being singular and the second plural, e.g. array('story, 'stories')</span>&nbsp;</div></li><li><div><span class="comment"> * Otherwise, an 's' will be added to the value for the plural form. After</span>&nbsp;</div></li><li><div><span class="comment"> * registration, capability_type will always be a string of the singular value.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * By default, seven keys are accepted as part of the capabilities array:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * - edit_post, read_post, and delete_post are meta capabilities, which are then</span>&nbsp;</div></li><li><div><span class="comment"> *   generally mapped to corresponding primitive capabilities depending on the</span>&nbsp;</div></li><li><div><span class="comment"> *   context, which would be the post being edited/read/deleted and the user or</span>&nbsp;</div></li><li><div><span class="comment"> *   role being checked. Thus these capabilities would generally not be granted</span>&nbsp;</div></li><li><div><span class="comment"> *   directly to users or roles.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * - edit_posts - Controls whether objects of this post type can be edited.</span>&nbsp;</div></li><li><div><span class="comment"> * - edit_others_posts - Controls whether objects of this type owned by other users</span>&nbsp;</div></li><li><div><span class="comment"> *   can be edited. If the post type does not support an author, then this will</span>&nbsp;</div></li><li><div><span class="comment"> *   behave like edit_posts.</span>&nbsp;</div></li><li><div><span class="comment"> * - publish_posts - Controls publishing objects of this post type.</span>&nbsp;</div></li><li><div><span class="comment"> * - read_private_posts - Controls whether private objects can be read.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * These four primitive capabilities are checked in core in various locations.</span>&nbsp;</div></li><li><div><span class="comment"> * There are also seven other primitive capabilities which are not referenced</span>&nbsp;</div></li><li><div><span class="comment"> * directly in core, except in map_meta_cap(), which takes the three aforementioned</span>&nbsp;</div></li><li><div><span class="comment"> * meta capabilities and translates them into one or more primitive capabilities</span>&nbsp;</div></li><li><div><span class="comment"> * that must then be checked against the user or role, depending on the context.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * - read - Controls whether objects of this post type can be read.</span>&nbsp;</div></li><li><div><span class="comment"> * - delete_posts - Controls whether objects of this post type can be deleted.</span>&nbsp;</div></li><li><div><span class="comment"> * - delete_private_posts - Controls whether private objects can be deleted.</span>&nbsp;</div></li><li><div><span class="comment"> * - delete_published_posts - Controls whether published objects can be deleted.</span>&nbsp;</div></li><li><div><span class="comment"> * - delete_others_posts - Controls whether objects owned by other users can be</span>&nbsp;</div></li><li><div><span class="comment"> *   can be deleted. If the post type does not support an author, then this will</span>&nbsp;</div></li><li><div><span class="comment"> *   behave like delete_posts.</span>&nbsp;</div></li><li><div><span class="comment"> * - edit_private_posts - Controls whether private objects can be edited.</span>&nbsp;</div></li><li><div><span class="comment"> * - edit_published_posts - Controls whether published objects can be edited.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * These additional capabilities are only used in map_meta_cap(). Thus, they are</span>&nbsp;</div></li><li><div><span class="comment"> * only assigned by default if the post type is registered with the 'map_meta_cap'</span>&nbsp;</div></li><li><div><span class="comment"> * argument set to true (default is false).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see register_post_type()</span>&nbsp;</div></li><li><div><span class="comment"> * @see map_meta_cap()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param object $args Post type registration arguments.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object object with all the capabilities as member variables.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_type_capabilities( $args ) {&nbsp;</div></li><li><div>  if ( ! is_array( $args-&gt;capability_type ) )&nbsp;</div></li><li><div>      $args-&gt;capability_type = array( $args-&gt;capability_type, $args-&gt;capability_type . 's' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Singular base for meta capabilities, plural base for primitive capabilities.</span>&nbsp;</div></li><li><div>  list( $singular_base, $plural_base ) = $args-&gt;capability_type;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $default_capabilities = array(&nbsp;</div></li><li><div>      <span class="comment">// Meta capabilities</span>&nbsp;</div></li><li><div>      'edit_post' =&gt; 'edit_'         . $singular_base, &nbsp;</div></li><li><div>      'read_post' =&gt; 'read_'         . $singular_base, &nbsp;</div></li><li><div>      'delete_post' =&gt; 'delete_'       . $singular_base, &nbsp;</div></li><li><div>      <span class="comment">// Primitive capabilities used outside of map_meta_cap():</span>&nbsp;</div></li><li><div>      'edit_posts' =&gt; 'edit_'         . $plural_base, &nbsp;</div></li><li><div>      'edit_others_posts' =&gt; 'edit_others_'  . $plural_base, &nbsp;</div></li><li><div>      'publish_posts' =&gt; 'publish_'      . $plural_base, &nbsp;</div></li><li><div>      'read_private_posts' =&gt; 'read_private_' . $plural_base, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Primitive capabilities used within map_meta_cap():</span>&nbsp;</div></li><li><div>  if ( $args-&gt;map_meta_cap ) {&nbsp;</div></li><li><div>      $default_capabilities_for_mapping = array(&nbsp;</div></li><li><div>          'read' =&gt; 'read', &nbsp;</div></li><li><div>          'delete_posts' =&gt; 'delete_'           . $plural_base, &nbsp;</div></li><li><div>          'delete_private_posts' =&gt; 'delete_private_'   . $plural_base, &nbsp;</div></li><li><div>          'delete_published_posts' =&gt; 'delete_published_' . $plural_base, &nbsp;</div></li><li><div>          'delete_others_posts' =&gt; 'delete_others_'    . $plural_base, &nbsp;</div></li><li><div>          'edit_private_posts' =&gt; 'edit_private_'     . $plural_base, &nbsp;</div></li><li><div>          'edit_published_posts' =&gt; 'edit_published_'   . $plural_base, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      $default_capabilities = array_merge( $default_capabilities, $default_capabilities_for_mapping );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $capabilities = array_merge( $default_capabilities, $args-&gt;capabilities );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Post creation capability simply maps to edit_posts by default:</span>&nbsp;</div></li><li><div>  if ( ! isset( $capabilities['create_posts'] ) )&nbsp;</div></li><li><div>      $capabilities['create_posts'] = $capabilities['edit_posts'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Remember meta capabilities for future reference.</span>&nbsp;</div></li><li><div>  if ( $args-&gt;map_meta_cap )&nbsp;</div></li><li><div>      _post_type_meta_capabilities( $capabilities );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return (object) $capabilities;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Store or return a list of post type meta caps for map_meta_cap().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $post_type_meta_caps Used to store meta capabilities.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $capabilities Post type meta capabilities.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _post_type_meta_capabilities( $capabilities = null ) {&nbsp;</div></li><li><div>  global $post_type_meta_caps;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $capabilities as $core =&gt; $custom ) {&nbsp;</div></li><li><div>      if ( in_array( $core, array( 'read_post', 'delete_post', 'edit_post' ) ) ) {&nbsp;</div></li><li><div>          $post_type_meta_caps[ $custom ] = $core;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Builds an object with all post type labels out of a post type object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Accepted keys of the label array in the post type object:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * - `name` - General name for the post type, usually plural. The same and overridden</span>&nbsp;</div></li><li><div><span class="comment"> *          by `$post_type_object-&gt;label`. Default is 'Posts' / 'Pages'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `singular_name` - Name for one object of this post type. Default is 'Post' / 'Page'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `add_new` - Default is 'Add New' for both hierarchical and non-hierarchical types.</span>&nbsp;</div></li><li><div><span class="comment"> *             When internationalizing this string, please use a {@link https://codex.wordpress.org/I18n_for_WordPress_Developers#Disambiguation_by_context gettext context}</span>&nbsp;</div></li><li><div><span class="comment"> *             matching your post type. Example: `_x( 'Add New', 'product', 'textdomain' );`.</span>&nbsp;</div></li><li><div><span class="comment"> * - `add_new_item` - Label for adding a new singular item. Default is 'Add New Post' / 'Add New Page'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `edit_item` - Label for editing a singular item. Default is 'Edit Post' / 'Edit Page'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `new_item` - Label for the new item page title. Default is 'New Post' / 'New Page'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `view_item` - Label for viewing a singular item. Default is 'View Post' / 'View Page'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `view_items` - Label for viewing post type archives. Default is 'View Posts' / 'View Pages'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `search_items` - Label for searching plural items. Default is 'Search Posts' / 'Search Pages'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `not_found` - Label used when no items are found. Default is 'No posts found' / 'No pages found'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `not_found_in_trash` - Label used when no items are in the trash. Default is 'No posts found in Trash' /</span>&nbsp;</div></li><li><div><span class="comment"> *                        'No pages found in Trash'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `parent_item_colon` - Label used to prefix parents of hierarchical items. Not used on non-hierarchical</span>&nbsp;</div></li><li><div><span class="comment"> *                       post types. Default is 'Parent Page:'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `all_items` - Label to signify all items in a submenu link. Default is 'All Posts' / 'All Pages'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `archives` - Label for archives in nav menus. Default is 'Post Archives' / 'Page Archives'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `attributes` - Label for the attributes meta box. Default is 'Post Attributes' / 'Page Attributes'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `insert_into_item` - Label for the media frame button. Default is 'Insert into post' / 'Insert into page'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `uploaded_to_this_item` - Label for the media frame filter. Default is 'Uploaded to this post' /</span>&nbsp;</div></li><li><div><span class="comment"> *                           'Uploaded to this page'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `featured_image` - Label for the Featured Image meta box title. Default is 'Featured Image'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `set_featured_image` - Label for setting the featured image. Default is 'Set featured image'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `remove_featured_image` - Label for removing the featured image. Default is 'Remove featured image'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `use_featured_image` - Label in the media frame for using a featured image. Default is 'Use as featured image'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `menu_name` - Label for the menu name. Default is the same as `name`.</span>&nbsp;</div></li><li><div><span class="comment"> * - `filter_items_list` - Label for the table views hidden heading. Default is 'Filter posts list' /</span>&nbsp;</div></li><li><div><span class="comment"> *                       'Filter pages list'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `items_list_navigation` - Label for the table pagination hidden heading. Default is 'Posts list navigation' /</span>&nbsp;</div></li><li><div><span class="comment"> *                           'Pages list navigation'.</span>&nbsp;</div></li><li><div><span class="comment"> * - `items_list` - Label for the table hidden heading. Default is 'Posts list' / 'Pages list'.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Above, the first default value is for non-hierarchical post types (like posts)</span>&nbsp;</div></li><li><div><span class="comment"> * and the second one is for hierarchical post types (like pages).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Note: To set labels used in post type admin notices, see the {@see 'post_updated_messages'} filter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0 Added the `featured_image`, `set_featured_image`, `remove_featured_image`, </span>&nbsp;</div></li><li><div><span class="comment"> *              and `use_featured_image` labels.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Added the `insert_into_item`, `uploaded_to_this_item`, `filter_items_list`, </span>&nbsp;</div></li><li><div><span class="comment"> *              `items_list_navigation`, and `items_list` labels.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.6.0 Converted the `$post_type` parameter to accept a WP_Post_Type object.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Added the `view_items` and `attributes` labels.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param object|WP_Post_Type $post_type_object Post type object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object Object with all the labels as member variables.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_type_labels( $post_type_object ) {&nbsp;</div></li><li><div>  $nohier_vs_hier_defaults = array(&nbsp;</div></li><li><div>      'name' =&gt; array( _x('Posts', 'post type general name'), _x('Pages', 'post type general name') ), &nbsp;</div></li><li><div>      'singular_name' =&gt; array( _x('Post', 'post type singular name'), _x('Page', 'post type singular name') ), &nbsp;</div></li><li><div>      'add_new' =&gt; array( _x('Add New', 'post'), _x('Add New', 'page') ), &nbsp;</div></li><li><div>      'add_new_item' =&gt; array( __('Add New Post'), __('Add New Page') ), &nbsp;</div></li><li><div>      'edit_item' =&gt; array( __('Edit Post'), __('Edit Page') ), &nbsp;</div></li><li><div>      'new_item' =&gt; array( __('New Post'), __('New Page') ), &nbsp;</div></li><li><div>      'view_item' =&gt; array( __('View Post'), __('View Page') ), &nbsp;</div></li><li><div>      'view_items' =&gt; array( __('View Posts'), __('View Pages') ), &nbsp;</div></li><li><div>      'search_items' =&gt; array( __('Search Posts'), __('Search Pages') ), &nbsp;</div></li><li><div>      'not_found' =&gt; array( __('No posts found.'), __('No pages found.') ), &nbsp;</div></li><li><div>      'not_found_in_trash' =&gt; array( __('No posts found in Trash.'), __('No pages found in Trash.') ), &nbsp;</div></li><li><div>      'parent_item_colon' =&gt; array( null, __('Parent Page:') ), &nbsp;</div></li><li><div>      'all_items' =&gt; array( __( 'All Posts' ), __( 'All Pages' ) ), &nbsp;</div></li><li><div>      'archives' =&gt; array( __( 'Post Archives' ), __( 'Page Archives' ) ), &nbsp;</div></li><li><div>      'attributes' =&gt; array( __( 'Post Attributes' ), __( 'Page Attributes' ) ), &nbsp;</div></li><li><div>      'insert_into_item' =&gt; array( __( 'Insert into post' ), __( 'Insert into page' ) ), &nbsp;</div></li><li><div>      'uploaded_to_this_item' =&gt; array( __( 'Uploaded to this post' ), __( 'Uploaded to this page' ) ), &nbsp;</div></li><li><div>      'featured_image' =&gt; array( __( 'Featured Image' ), __( 'Featured Image' ) ), &nbsp;</div></li><li><div>      'set_featured_image' =&gt; array( __( 'Set featured image' ), __( 'Set featured image' ) ), &nbsp;</div></li><li><div>      'remove_featured_image' =&gt; array( __( 'Remove featured image' ), __( 'Remove featured image' ) ), &nbsp;</div></li><li><div>      'use_featured_image' =&gt; array( __( 'Use as featured image' ), __( 'Use as featured image' ) ), &nbsp;</div></li><li><div>      'filter_items_list' =&gt; array( __( 'Filter posts list' ), __( 'Filter pages list' ) ), &nbsp;</div></li><li><div>      'items_list_navigation' =&gt; array( __( 'Posts list navigation' ), __( 'Pages list navigation' ) ), &nbsp;</div></li><li><div>      'items_list' =&gt; array( __( 'Posts list' ), __( 'Pages list' ) ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  $nohier_vs_hier_defaults['menu_name'] = $nohier_vs_hier_defaults['name'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $labels = _get_custom_object_labels( $post_type_object, $nohier_vs_hier_defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type = $post_type_object-&gt;name;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $default_labels = clone $labels;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the labels of a specific post type.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$post_type`, refers to</span>&nbsp;</div></li><li><div><span class="comment">   * the post type slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see get_post_type_labels() for the full list of labels.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $labels Object with labels for the post type as member variables.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $labels = apply_filters( &quot;post_type_labels_{$post_type}&quot;, $labels );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Ensure that the filtered labels contain all required default values.</span>&nbsp;</div></li><li><div>  $labels = (object) array_merge( (array) $default_labels, (array) $labels );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $labels;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Build an object with custom-something object (post type, taxonomy) labels</span>&nbsp;</div></li><li><div><span class="comment"> * out of a custom-something object</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param object $object                  A custom-something object.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $nohier_vs_hier_defaults Hierarchical vs non-hierarchical default labels.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object Object containing labels for the given custom-something object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _get_custom_object_labels( $object, $nohier_vs_hier_defaults ) {&nbsp;</div></li><li><div>  $object-&gt;labels = (array) $object-&gt;labels;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $object-&gt;label ) && empty( $object-&gt;labels['name'] ) )&nbsp;</div></li><li><div>      $object-&gt;labels['name'] = $object-&gt;label;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset( $object-&gt;labels['singular_name'] ) && isset( $object-&gt;labels['name'] ) )&nbsp;</div></li><li><div>      $object-&gt;labels['singular_name'] = $object-&gt;labels['name'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! isset( $object-&gt;labels['name_admin_bar'] ) )&nbsp;</div></li><li><div>      $object-&gt;labels['name_admin_bar'] = isset( $object-&gt;labels['singular_name'] ) ? $object-&gt;labels['singular_name'] : $object-&gt;name;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset( $object-&gt;labels['menu_name'] ) && isset( $object-&gt;labels['name'] ) )&nbsp;</div></li><li><div>      $object-&gt;labels['menu_name'] = $object-&gt;labels['name'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset( $object-&gt;labels['all_items'] ) && isset( $object-&gt;labels['menu_name'] ) )&nbsp;</div></li><li><div>      $object-&gt;labels['all_items'] = $object-&gt;labels['menu_name'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset( $object-&gt;labels['archives'] ) && isset( $object-&gt;labels['all_items'] ) ) {&nbsp;</div></li><li><div>      $object-&gt;labels['archives'] = $object-&gt;labels['all_items'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array();&nbsp;</div></li><li><div>  foreach ( $nohier_vs_hier_defaults as $key =&gt; $value ) {&nbsp;</div></li><li><div>      $defaults[$key] = $object-&gt;hierarchical ? $value[1] : $value[0];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $labels = array_merge( $defaults, $object-&gt;labels );&nbsp;</div></li><li><div>  $object-&gt;labels = (object) $object-&gt;labels;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return (object) $labels;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenus for post types.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _add_post_type_submenus() {&nbsp;</div></li><li><div>  foreach ( get_post_types( array( 'show_ui' =&gt; true ) ) as $ptype ) {&nbsp;</div></li><li><div>      $ptype_obj = get_post_type_object( $ptype );&nbsp;</div></li><li><div>      <span class="comment">// Sub-menus only.</span>&nbsp;</div></li><li><div>      if ( ! $ptype_obj-&gt;show_in_menu || $ptype_obj-&gt;show_in_menu === true )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      add_submenu_page( $ptype_obj-&gt;show_in_menu, $ptype_obj-&gt;labels-&gt;name, $ptype_obj-&gt;labels-&gt;all_items, $ptype_obj-&gt;cap-&gt;edit_posts, &quot;edit.php?post_type=$ptype&quot; );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Register support of certain features for a post type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * All core features are directly associated with a functional area of the edit</span>&nbsp;</div></li><li><div><span class="comment"> * screen, such as the editor or a meta box. Features include: 'title', 'editor', </span>&nbsp;</div></li><li><div><span class="comment"> * 'comments', 'revisions', 'trackbacks', 'author', 'excerpt', 'page-attributes', </span>&nbsp;</div></li><li><div><span class="comment"> * 'thumbnail', 'custom-fields', and 'post-formats'.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Additionally, the 'revisions' feature dictates whether the post type will</span>&nbsp;</div></li><li><div><span class="comment"> * store revisions, and the 'comments' feature dictates whether the comments</span>&nbsp;</div></li><li><div><span class="comment"> * count will show on the edit screen.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_post_type_features</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $post_type The post type for which to add the feature.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $feature   The feature being added, accepts an array of</span>&nbsp;</div></li><li><div><span class="comment"> *                                feature strings or a single string.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_post_type_support( $post_type, $feature ) {&nbsp;</div></li><li><div>  global $_wp_post_type_features;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $features = (array) $feature;&nbsp;</div></li><li><div>  foreach ($features as $feature) {&nbsp;</div></li><li><div>      if ( func_num_args() == 2 )&nbsp;</div></li><li><div>          $_wp_post_type_features[$post_type][$feature] = true;&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $_wp_post_type_features[$post_type][$feature] = array_slice( func_get_args(), 2 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove support for a feature from a post type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_post_type_features</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type The post type for which to remove the feature.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $feature   The feature being removed.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function remove_post_type_support( $post_type, $feature ) {&nbsp;</div></li><li><div>  global $_wp_post_type_features;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  unset( $_wp_post_type_features[ $post_type ][ $feature ] );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get all the post type features</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_post_type_features</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type The post type.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Post type supports list.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_all_post_type_supports( $post_type ) {&nbsp;</div></li><li><div>  global $_wp_post_type_features;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $_wp_post_type_features[$post_type] ) )&nbsp;</div></li><li><div>      return $_wp_post_type_features[$post_type];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return array();&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check a post type's support for a given feature.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_post_type_features</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type The post type being checked.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $feature   The feature being checked.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether the post type supports the given feature.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function post_type_supports( $post_type, $feature ) {&nbsp;</div></li><li><div>  global $_wp_post_type_features;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return ( isset( $_wp_post_type_features[$post_type][$feature] ) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves a list of post type names that support a specific feature.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_post_type_features Post type features</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $feature  Single feature or an array of features the post types should support.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $operator Optional. The logical operation to perform. 'or' means</span>&nbsp;</div></li><li><div><span class="comment"> *                               only one element from the array needs to match; 'and'</span>&nbsp;</div></li><li><div><span class="comment"> *                               means all elements must match; 'not' means no elements may</span>&nbsp;</div></li><li><div><span class="comment"> *                               match. Default 'and'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array A list of post type names.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_types_by_support( $feature, $operator = 'and' ) {&nbsp;</div></li><li><div>  global $_wp_post_type_features;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $features = array_fill_keys( (array) $feature, true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return array_keys( wp_filter_object_list( $_wp_post_type_features, $features, $operator ) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update the post type for the post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The page or post cache will be cleaned for the post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id   Optional. Post ID to change post type. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Optional. Post type. Accepts 'post' or 'page' to</span>&nbsp;</div></li><li><div><span class="comment"> *                          name a few. Default 'post'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false Amount of rows changed. Should be 1 for success and 0 for failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function set_post_type( $post_id = 0, $post_type = 'post' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type = sanitize_post_field('post_type', $post_type, $post_id, 'db');&nbsp;</div></li><li><div>  $return = $wpdb-&gt;update( $wpdb-&gt;posts, array('post_type' =&gt; $post_type), array('ID' =&gt; $post_id) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_post_cache( $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $return;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Determines whether a post type is considered &quot;viewable&quot;.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * For built-in post types such as posts and pages, the 'public' value will be evaluated.</span>&nbsp;</div></li><li><div><span class="comment"> * For all others, the 'publicly_queryable' value will be used.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0 Added the ability to pass a post type name in addition to object.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.6.0 Converted the `$post_type` parameter to accept a WP_Post_Type object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|WP_Post_Type $post_type Post type name or object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether the post type should be considered viewable.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_post_type_viewable( $post_type ) {&nbsp;</div></li><li><div>  if ( is_scalar( $post_type ) ) {&nbsp;</div></li><li><div>      $post_type = get_post_type_object( $post_type );&nbsp;</div></li><li><div>      if ( ! $post_type ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post_type-&gt;publicly_queryable || ( $post_type-&gt;_builtin && $post_type-&gt;public );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve list of latest posts or posts matching criteria.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The defaults are as follows:</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see WP_Query::parse_query()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Arguments to retrieve posts. See WP_Query::parse_query() for all</span>&nbsp;</div></li><li><div><span class="comment"> *     available arguments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int        $numberposts      Total number of posts to retrieve. Is an alias of $posts_per_page</span>&nbsp;</div></li><li><div><span class="comment"> *                                        in WP_Query. Accepts -1 for all. Default 5.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int|string $category         Category ID or comma-separated list of IDs (this or any children).</span>&nbsp;</div></li><li><div><span class="comment"> *                                        Is an alias of $cat in WP_Query. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array      $include          An array of post IDs to retrieve, sticky posts will be included.</span>&nbsp;</div></li><li><div><span class="comment"> *                                        Is an alias of $post__in in WP_Query. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array      $exclude          An array of post IDs not to retrieve. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool       $suppress_filters Whether to suppress filters. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of posts.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_posts( $args = null ) {&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'numberposts' =&gt; 5, &nbsp;</div></li><li><div>      'category' =&gt; 0, 'orderby' =&gt; 'date', &nbsp;</div></li><li><div>      'order' =&gt; 'DESC', 'include' =&gt; array(), &nbsp;</div></li><li><div>      'exclude' =&gt; array(), 'meta_key' =&gt; '', &nbsp;</div></li><li><div>      'meta_value' =&gt;'', 'post_type' =&gt; 'post', &nbsp;</div></li><li><div>      'suppress_filters' =&gt; true&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>  if ( empty( $r['post_status'] ) )&nbsp;</div></li><li><div>      $r['post_status'] = ( 'attachment' == $r['post_type'] ) ? 'inherit' : 'publish';&nbsp;</div></li><li><div>  if ( ! empty($r['numberposts']) && empty($r['posts_per_page']) )&nbsp;</div></li><li><div>      $r['posts_per_page'] = $r['numberposts'];&nbsp;</div></li><li><div>  if ( ! empty($r['category']) )&nbsp;</div></li><li><div>      $r['cat'] = $r['category'];&nbsp;</div></li><li><div>  if ( ! empty($r['include']) ) {&nbsp;</div></li><li><div>      $incposts = wp_parse_id_list( $r['include'] );&nbsp;</div></li><li><div>      $r['posts_per_page'] = count($incposts);  <span class="comment">// only the number of posts included</span>&nbsp;</div></li><li><div>      $r['post__in'] = $incposts;&nbsp;</div></li><li><div>  } elseif ( ! empty($r['exclude']) )&nbsp;</div></li><li><div>      $r['post__not_in'] = wp_parse_id_list( $r['exclude'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $r['ignore_sticky_posts'] = true;&nbsp;</div></li><li><div>  $r['no_found_rows'] = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $get_posts = new WP_Query;&nbsp;</div></li><li><div>  return $get_posts-&gt;query($r);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Post meta functions&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add meta data field to a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Post meta data is called &quot;Custom Fields&quot; on the Administration Screen.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id    Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key   Metadata name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $meta_value Metadata value. Must be serializable if non-scalar.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $unique     Optional. Whether the same key should not be added.</span>&nbsp;</div></li><li><div><span class="comment"> *                           Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false Meta ID on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_post_meta( $post_id, $meta_key, $meta_value, $unique = false ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment">// Make sure meta is added to the post, not a revision.</span></span></span>&nbsp;</div></li><li><div>  if ( $the_post = wp_is_post_revision($post_id) )&nbsp;</div></li><li><div>      $post_id = $the_post;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return add_metadata('post', $post_id, $meta_key, $meta_value, $unique);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove metadata matching criteria from a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * You can match based on the key, or key and value. Removing based on key and</span>&nbsp;</div></li><li><div><span class="comment"> * value, will keep from removing duplicate metadata with the same key. It also</span>&nbsp;</div></li><li><div><span class="comment"> * allows removing all metadata matching key, if needed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id    Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key   Metadata name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $meta_value Optional. Metadata value. Must be serializable if</span>&nbsp;</div></li><li><div><span class="comment"> *                           non-scalar. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function delete_post_meta( $post_id, $meta_key, $meta_value = '' ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment">// Make sure meta is added to the post, not a revision.</span></span></span>&nbsp;</div></li><li><div>  if ( $the_post = wp_is_post_revision($post_id) )&nbsp;</div></li><li><div>      $post_id = $the_post;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return delete_metadata('post', $post_id, $meta_key, $meta_value);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve post meta field for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $key     Optional. The meta key to retrieve. By default, returns</span>&nbsp;</div></li><li><div><span class="comment"> *                        data for all keys. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $single  Optional. Whether to return a single value. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed Will be an array if $single is false. Will be value of meta data</span>&nbsp;</div></li><li><div><span class="comment"> *               field if $single is true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_meta( $post_id, $key = '', $single = false ) {&nbsp;</div></li><li><div>  return get_metadata('post', $post_id, $key, $single);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update post meta field based on post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Use the $prev_value parameter to differentiate between meta fields with the</span>&nbsp;</div></li><li><div><span class="comment"> * same key and post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the meta field for the post does not exist, it will be added.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id    Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $meta_key   Metadata key.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $meta_value Metadata value. Must be serializable if non-scalar.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $prev_value Optional. Previous value to check before removing.</span>&nbsp;</div></li><li><div><span class="comment"> *                           Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|bool Meta ID if the key didn't exist, true on successful update, </span>&nbsp;</div></li><li><div><span class="comment"> *                  false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_post_meta( $post_id, $meta_key, $meta_value, $prev_value = '' ) {&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment">// Make sure meta is added to the post, not a revision.</span></span></span>&nbsp;</div></li><li><div>  if ( $the_post = wp_is_post_revision($post_id) )&nbsp;</div></li><li><div>      $post_id = $the_post;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return update_metadata('post', $post_id, $meta_key, $meta_value, $prev_value);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Delete everything from post meta matching meta key.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_meta_key Key to search for when deleting.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether the post meta key was deleted from the database.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function delete_post_meta_by_key( $post_meta_key ) {&nbsp;</div></li><li><div>  return delete_metadata( 'post', null, $post_meta_key, '', true );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve post meta fields, based on post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The post meta fields are retrieved from the cache where possible, </span>&nbsp;</div></li><li><div><span class="comment"> * so the function is optimized to be called more than once.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Post ID. Default is ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Post meta for the given post.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_custom( $post_id = 0 ) {&nbsp;</div></li><li><div>  $post_id = absint( $post_id );&nbsp;</div></li><li><div>  if ( ! $post_id )&nbsp;</div></li><li><div>      $post_id = get_the_ID();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return get_post_meta( $post_id );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve meta field names for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If there are no meta fields, then nothing (null) will be returned.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Post ID. Default is ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|void Array of the keys, if retrieved.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_custom_keys( $post_id = 0 ) {&nbsp;</div></li><li><div>  $custom = get_post_custom( $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($custom) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $keys = array_keys($custom) )&nbsp;</div></li><li><div>      return $keys;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve values for a custom post field.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The parameters must not be considered optional. All of the post meta fields</span>&nbsp;</div></li><li><div><span class="comment"> * will be retrieved and only the meta field key values returned.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $key     Optional. Meta field key. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id Optional. Post ID. Default is ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|null Meta field values.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_custom_values( $key = '', $post_id = 0 ) {&nbsp;</div></li><li><div>  if ( !$key )&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $custom = get_post_custom($post_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return isset($custom[$key]) ? $custom[$key] : null;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check if post is sticky.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Sticky posts should remain at the top of The Loop. If the post ID is not</span>&nbsp;</div></li><li><div><span class="comment"> * given, then The Loop ID for the current post will be used.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Post ID. Default is ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether post is sticky.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_sticky( $post_id = 0 ) {&nbsp;</div></li><li><div>  $post_id = absint( $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $post_id )&nbsp;</div></li><li><div>      $post_id = get_the_ID();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $stickies = get_option( 'sticky_posts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_array( $stickies ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( in_array( $post_id, $stickies ) )&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sanitize every post field.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the context is 'raw', then the post object or array will get minimal</span>&nbsp;</div></li><li><div><span class="comment"> * sanitization of the integer fields.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see sanitize_post_field()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param object|WP_Post|array $post    The Post Object or Array</span>&nbsp;</div></li><li><div><span class="comment"> * @param string               $context Optional. How to sanitize post fields.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Accepts 'raw', 'edit', 'db', or 'display'.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default 'display'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object|WP_Post|array The now sanitized Post Object or Array (will be the</span>&nbsp;</div></li><li><div><span class="comment"> *                              same type as $post).</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function sanitize_post( $post, $context = 'display' ) {&nbsp;</div></li><li><div>  if ( is_object($post) ) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// Check if post already filtered for this context.</span></span>&nbsp;</div></li><li><div>      if ( isset($post-&gt;filter) && $context == $post-&gt;filter )&nbsp;</div></li><li><div>          return $post;&nbsp;</div></li><li><div>      if ( !isset($post-&gt;ID) )&nbsp;</div></li><li><div>          $post-&gt;ID = 0;&nbsp;</div></li><li><div>      foreach ( array_keys(get_object_vars($post)) as $field )&nbsp;</div></li><li><div>          $post-&gt;$field = sanitize_post_field($field, $post-&gt;$field, $post-&gt;ID, $context);&nbsp;</div></li><li><div>      $post-&gt;filter = $context;&nbsp;</div></li><li><div>  } elseif ( is_array( $post ) ) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// Check if post already filtered for this context.</span></span>&nbsp;</div></li><li><div>      if ( isset($post['filter']) && $context == $post['filter'] )&nbsp;</div></li><li><div>          return $post;&nbsp;</div></li><li><div>      if ( !isset($post['ID']) )&nbsp;</div></li><li><div>          $post['ID'] = 0;&nbsp;</div></li><li><div>      foreach ( array_keys($post) as $field )&nbsp;</div></li><li><div>          $post[$field] = sanitize_post_field($field, $post[$field], $post['ID'], $context);&nbsp;</div></li><li><div>      $post['filter'] = $context;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $post;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sanitize post field based on context.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Possible context values are:  'raw', 'edit', 'db', 'display', 'attribute' and</span>&nbsp;</div></li><li><div><span class="comment"> * 'js'. The 'display' context is used by default. 'attribute' and 'js' contexts</span>&nbsp;</div></li><li><div><span class="comment"> * are treated like 'display' when calling filters.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 Like `sanitize_post()`, `$context` defaults to 'display'.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $field   The Post Object field name.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $value   The Post Object value.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $context Optional. How to sanitize post fields. Looks for 'raw', 'edit', </span>&nbsp;</div></li><li><div><span class="comment"> *                        'db', 'display', 'attribute' and 'js'. Default 'display'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed Sanitized value.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function sanitize_post_field( $field, $value, $post_id, $context = 'display' ) {&nbsp;</div></li><li><div>  $int_fields = array('ID', 'post_parent', 'menu_order');&nbsp;</div></li><li><div>  if ( in_array($field, $int_fields) )&nbsp;</div></li><li><div>      $value = (int) $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Fields which contain arrays of integers.</span>&nbsp;</div></li><li><div>  $array_int_fields = array( 'ancestors' );&nbsp;</div></li><li><div>  if ( in_array($field, $array_int_fields) ) {&nbsp;</div></li><li><div>      $value = array_map( 'absint', $value);&nbsp;</div></li><li><div>      return $value;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'raw' == $context )&nbsp;</div></li><li><div>      return $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $prefixed = false;&nbsp;</div></li><li><div>  if ( false !== strpos($field, 'post_') ) {&nbsp;</div></li><li><div>      $prefixed = true;&nbsp;</div></li><li><div>      $field_no_prefix = str_replace('post_', '', $field);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'edit' == $context ) {&nbsp;</div></li><li><div>      $format_to_edit = array('post_content', 'post_excerpt', 'post_title', 'post_password');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $prefixed ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the value of a specific post field to edit.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$field`, refers to the post</span>&nbsp;</div></li><li><div><span class="comment">           * field name.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param mixed $value   Value of the post field.</span>&nbsp;</div></li><li><div><span class="comment">           * @param int   $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $value = apply_filters( &quot;edit_{$field}&quot;, $value, $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the value of a specific post field to edit.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$field_no_prefix`, refers to</span>&nbsp;</div></li><li><div><span class="comment">           * the post field name.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param mixed $value   Value of the post field.</span>&nbsp;</div></li><li><div><span class="comment">           * @param int   $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $value = apply_filters( &quot;{$field_no_prefix}_edit_pre&quot;, $value, $post_id );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $value = apply_filters( &quot;edit_post_{$field}&quot;, $value, $post_id );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( in_array($field, $format_to_edit) ) {&nbsp;</div></li><li><div>          if ( 'post_content' == $field )&nbsp;</div></li><li><div>              $value = format_to_edit($value, user_can_richedit());&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $value = format_to_edit($value);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $value = esc_attr($value);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } elseif ( 'db' == $context ) {&nbsp;</div></li><li><div>      if ( $prefixed ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the value of a specific post field before saving.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$field`, refers to the post</span>&nbsp;</div></li><li><div><span class="comment">           * field name.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param mixed $value Value of the post field.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $value = apply_filters( &quot;pre_{$field}&quot;, $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the value of a specific field before saving.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$field_no_prefix`, refers</span>&nbsp;</div></li><li><div><span class="comment">           * to the post field name.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param mixed $value Value of the post field.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $value = apply_filters( &quot;{$field_no_prefix}_save_pre&quot;, $value );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $value = apply_filters( &quot;pre_post_{$field}&quot;, $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the value of a specific post field before saving.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$field`, refers to the post</span>&nbsp;</div></li><li><div><span class="comment">           * field name.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param mixed $value Value of the post field.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $value = apply_filters( &quot;{$field}_pre&quot;, $value );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Use display filters by default.</span>&nbsp;</div></li><li><div>      if ( $prefixed ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the value of a specific post field for display.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$field`, refers to the post</span>&nbsp;</div></li><li><div><span class="comment">           * field name.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param mixed  $value   Value of the prefixed post field.</span>&nbsp;</div></li><li><div><span class="comment">           * @param int    $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $context Context for how to sanitize the field. Possible</span>&nbsp;</div></li><li><div><span class="comment">           *                        values include 'raw', 'edit', 'db', 'display', </span>&nbsp;</div></li><li><div><span class="comment">           *                        'attribute' and 'js'.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $value = apply_filters( $field, $value, $post_id, $context );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $value = apply_filters( &quot;post_{$field}&quot;, $value, $post_id, $context );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'attribute' == $context ) {&nbsp;</div></li><li><div>          $value = esc_attr( $value );&nbsp;</div></li><li><div>      } elseif ( 'js' == $context ) {&nbsp;</div></li><li><div>          $value = esc_js( $value );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $value;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Make a post sticky.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Sticky posts should be displayed at the top of the front page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function stick_post( $post_id ) {&nbsp;</div></li><li><div>  $stickies = get_option('sticky_posts');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($stickies) )&nbsp;</div></li><li><div>      $stickies = array($post_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! in_array($post_id, $stickies) )&nbsp;</div></li><li><div>      $stickies[] = $post_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $updated = update_option( 'sticky_posts', $stickies );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $updated ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires once a post has been added to the sticky list.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.6.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $post_id ID of the post that was stuck.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'post_stuck', $post_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Un-stick a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Sticky posts should be displayed at the top of the front page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function unstick_post( $post_id ) {&nbsp;</div></li><li><div>  $stickies = get_option('sticky_posts');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !is_array($stickies) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! in_array($post_id, $stickies) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $offset = array_search($post_id, $stickies);&nbsp;</div></li><li><div>  if ( false === $offset )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  array_splice($stickies, $offset, 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $updated = update_option( 'sticky_posts', $stickies );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $updated ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires once a post has been removed from the sticky list.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.6.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $post_id ID of the post that was unstuck.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'post_unstuck', $post_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Return the cache key for wp_count_posts() based on the passed arguments.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $type Optional. Post type to retrieve count Default 'post'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $perm Optional. 'readable' or empty. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string The cache key.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _count_posts_cache_key( $type = 'post', $perm = '' ) {&nbsp;</div></li><li><div>  $cache_key = 'posts-' . $type;&nbsp;</div></li><li><div>  if ( 'readable' == $perm && is_user_logged_in() ) {&nbsp;</div></li><li><div>      $post_type_object = get_post_type_object( $type );&nbsp;</div></li><li><div>      if ( $post_type_object && ! current_user_can( $post_type_object-&gt;cap-&gt;read_private_posts ) ) {&nbsp;</div></li><li><div>          $cache_key .= '_' . $perm . '_' . get_current_user_id();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $cache_key;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Count number of posts of a post type and if user has permissions to view.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function provides an efficient method of finding the amount of post's</span>&nbsp;</div></li><li><div><span class="comment"> * type a blog has. Another method is to count the amount of items in</span>&nbsp;</div></li><li><div><span class="comment"> * get_posts(), but that method has a lot of overhead with doing so. Therefore, </span>&nbsp;</div></li><li><div><span class="comment"> * when developing for 2.5+, use this function instead.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The $perm parameter checks for 'readable' value and if the user can read</span>&nbsp;</div></li><li><div><span class="comment"> * private posts, it will display that for the user that is signed in.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $type Optional. Post type to retrieve count. Default 'post'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $perm Optional. 'readable' or empty. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object Number of posts for each status.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_count_posts( $type = 'post', $perm = '' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! post_type_exists( $type ) )&nbsp;</div></li><li><div>      return new stdClass;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $cache_key = _count_posts_cache_key( $type, $perm );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $counts = wp_cache_get( $cache_key, 'counts' );&nbsp;</div></li><li><div>  if ( false !== $counts ) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/post.php */</span></span></span>&nbsp;</div></li><li><div>      return apply_filters( 'wp_count_posts', $counts, $type, $perm );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $query = &quot;SELECT post_status, COUNT( * ) AS num_posts FROM {$wpdb-&gt;posts} WHERE post_type = %s&quot;;&nbsp;</div></li><li><div>  if ( 'readable' == $perm && is_user_logged_in() ) {&nbsp;</div></li><li><div>      $post_type_object = get_post_type_object($type);&nbsp;</div></li><li><div>      if ( ! current_user_can( $post_type_object-&gt;cap-&gt;read_private_posts ) ) {&nbsp;</div></li><li><div>          $query .= $wpdb-&gt;prepare( &quot; AND (post_status != 'private' OR ( post_author = %d AND post_status = 'private' ))&quot;, &nbsp;</div></li><li><div>              get_current_user_id()&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $query .= ' GROUP BY post_status';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $results = (array) $wpdb-&gt;get_results( $wpdb-&gt;prepare( $query, $type ), ARRAY_A );&nbsp;</div></li><li><div>  $counts = array_fill_keys( get_post_stati(), 0 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $results as $row ) {&nbsp;</div></li><li><div>      $counts[ $row['post_status'] ] = $row['num_posts'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $counts = (object) $counts;&nbsp;</div></li><li><div>  wp_cache_set( $cache_key, $counts, 'counts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Modify returned post counts by status for the current post type.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $counts An object containing the current post_type's post</span>&nbsp;</div></li><li><div><span class="comment">   *                       counts by status.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $type   Post type.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $perm   The permission to determine if the posts are 'readable'</span>&nbsp;</div></li><li><div><span class="comment">   *                       by the current user.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_count_posts', $counts, $type, $perm );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Count number of attachments for the mime type(s).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If you set the optional mime_type parameter, then an array will still be</span>&nbsp;</div></li><li><div><span class="comment"> * returned, but will only have the item you are looking for. It does not give</span>&nbsp;</div></li><li><div><span class="comment"> * you the number of attachments that are children of a post. You can get that</span>&nbsp;</div></li><li><div><span class="comment"> * by counting the number of children that post has.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $mime_type Optional. Array or comma-separated list of</span>&nbsp;</div></li><li><div><span class="comment"> *                                MIME patterns. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return object An object containing the attachment counts by mime type.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_count_attachments( $mime_type = '' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $and = wp_post_mime_type_where( $mime_type );&nbsp;</div></li><li><div>  $count = $wpdb-&gt;get_results( &quot;SELECT post_mime_type, COUNT( * ) AS num_posts FROM $wpdb-&gt;posts WHERE post_type = 'attachment' AND post_status != 'trash' $and GROUP BY post_mime_type&quot;, ARRAY_A );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $counts = array();&nbsp;</div></li><li><div>  foreach ( (array) $count as $row ) {&nbsp;</div></li><li><div>      $counts[ $row['post_mime_type'] ] = $row['num_posts'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $counts['trash'] = $wpdb-&gt;get_var( &quot;SELECT COUNT( * ) FROM $wpdb-&gt;posts WHERE post_type = 'attachment' AND post_status = 'trash' $and&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Modify returned attachment counts by mime type.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $counts    An object containing the attachment counts by</span>&nbsp;</div></li><li><div><span class="comment">   *                          mime type.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $mime_type The mime type pattern used to filter the attachments</span>&nbsp;</div></li><li><div><span class="comment">   *                          counted.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_count_attachments', (object) $counts, $mime_type );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get default post mime types.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of post mime types.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_post_mime_types() {&nbsp;</div></li><li><div>  $post_mime_types = array(    <span class="comment">//    array( adj, noun )</span>&nbsp;</div></li><li><div>      'image' =&gt; array(__('Images'), __('Manage Images'), _n_noop('Image &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Images &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;')), &nbsp;</div></li><li><div>      'audio' =&gt; array(__('Audio'), __('Manage Audio'), _n_noop('Audio &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Audio &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;')), &nbsp;</div></li><li><div>      'video' =&gt; array(__('Video'), __('Manage Video'), _n_noop('Video &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;', 'Video &lt;span class=&quot;count&quot;&gt;(%s)&lt;/span&gt;')), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the default list of post mime types.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $post_mime_types Default list of post mime types.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'post_mime_types', $post_mime_types );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check a MIME-Type against a list.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the wildcard_mime_types parameter is a string, it must be comma separated</span>&nbsp;</div></li><li><div><span class="comment"> * list. If the real_mime_types is a string, it is also comma separated to</span>&nbsp;</div></li><li><div><span class="comment"> * create the list.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $wildcard_mime_types Mime types, e.g. audio/mpeg or image (same as image/**)</span>&nbsp;</div></li><li><div><span class="comment"> *                                          or flash (same as *flash*).</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $real_mime_types     Real post mime type values.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array array(wildcard=&gt;array(real types)).</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_match_mime_types( $wildcard_mime_types, $real_mime_types ) {&nbsp;</div></li><li><div>  $matches = array();&nbsp;</div></li><li><div>  if ( is_string( $wildcard_mime_types ) ) {&nbsp;</div></li><li><div>      $wildcard_mime_types = array_map( 'trim', explode( ', ', $wildcard_mime_types ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( is_string( $real_mime_types ) ) {&nbsp;</div></li><li><div>      $real_mime_types = array_map( 'trim', explode( ', ', $real_mime_types ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $patternses = array();&nbsp;</div></li><li><div>  $wild = '[-._a-z0-9]*';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $wildcard_mime_types as $type ) {&nbsp;</div></li><li><div>      $mimes = array_map( 'trim', explode( ', ', $type ) );&nbsp;</div></li><li><div>      foreach ( $mimes as $mime ) {&nbsp;</div></li><li><div>          $regex = str_replace( '__wildcard__', $wild, preg_quote( str_replace( '*', '__wildcard__', $mime ) ) );&nbsp;</div></li><li><div>          $patternses[][$type] = &quot;^$regex$&quot;;&nbsp;</div></li><li><div>          if ( false === strpos( $mime, '/' ) ) {&nbsp;</div></li><li><div>              $patternses[][$type] = &quot;^$regex/&quot;;&nbsp;</div></li><li><div>              $patternses[][$type] = $regex;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  asort( $patternses );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $patternses as $patterns ) {&nbsp;</div></li><li><div>      foreach ( $patterns as $type =&gt; $pattern ) {&nbsp;</div></li><li><div>          foreach ( (array) $real_mime_types as $real ) {&nbsp;</div></li><li><div>              if ( preg_match( &quot;#$pattern#&quot;, $real ) && ( empty( $matches[$type] ) || false === array_search( $real, $matches[$type] ) ) ) {&nbsp;</div></li><li><div>                  $matches[$type][] = $real;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $matches;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Convert MIME types into SQL.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $post_mime_types List of mime types or comma separated string</span>&nbsp;</div></li><li><div><span class="comment"> *                                      of mime types.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $table_alias     Optional. Specify a table alias, if needed.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string The SQL AND clause for mime searching.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_post_mime_type_where( $post_mime_types, $table_alias = '' ) {&nbsp;</div></li><li><div>  $where = '';&nbsp;</div></li><li><div>  $wildcards = array('', '%', '%/%');&nbsp;</div></li><li><div>  if ( is_string($post_mime_types) )&nbsp;</div></li><li><div>      $post_mime_types = array_map('trim', explode(', ', $post_mime_types));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wheres = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $post_mime_types as $mime_type ) {&nbsp;</div></li><li><div>      $mime_type = preg_replace('/\s/', '', $mime_type);&nbsp;</div></li><li><div>      $slashpos = strpos($mime_type, '/');&nbsp;</div></li><li><div>      if ( false !== $slashpos ) {&nbsp;</div></li><li><div>          $mime_group = preg_replace('/[^-*.a-zA-Z0-9]/', '', substr($mime_type, 0, $slashpos));&nbsp;</div></li><li><div>          $mime_subgroup = preg_replace('/[^-*.+a-zA-Z0-9]/', '', substr($mime_type, $slashpos + 1));&nbsp;</div></li><li><div>          if ( empty($mime_subgroup) )&nbsp;</div></li><li><div>              $mime_subgroup = '*';&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $mime_subgroup = str_replace('/', '', $mime_subgroup);&nbsp;</div></li><li><div>          $mime_pattern = &quot;$mime_group/$mime_subgroup&quot;;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $mime_pattern = preg_replace('/[^-*.a-zA-Z0-9]/', '', $mime_type);&nbsp;</div></li><li><div>          if ( false === strpos($mime_pattern, '*') )&nbsp;</div></li><li><div>              $mime_pattern .= '<span class="comment">/*';</span>&nbsp;</div></li><li><div><span class="comment">      }</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">      $mime_pattern = preg_replace('/\*+/', '%', $mime_pattern);</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">      if ( in_array( $mime_type, $wildcards ) )</span>&nbsp;</div></li><li><div><span class="comment">          return '';</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">      if ( false !== strpos($mime_pattern, '%') )</span>&nbsp;</div></li><li><div><span class="comment">          $wheres[] = empty($table_alias) ? &quot;post_mime_type LIKE '$mime_pattern'&quot; : &quot;$table_alias.post_mime_type LIKE '$mime_pattern'&quot;;</span>&nbsp;</div></li><li><div><span class="comment">      else</span>&nbsp;</div></li><li><div><span class="comment">          $wheres[] = empty($table_alias) ? &quot;post_mime_type = '$mime_pattern'&quot; : &quot;$table_alias.post_mime_type = '$mime_pattern'&quot;;</span>&nbsp;</div></li><li><div><span class="comment">  }</span>&nbsp;</div></li><li><div><span class="comment">  if ( !empty($wheres) )</span>&nbsp;</div></li><li><div><span class="comment">      $where = ' AND (' . join(' OR ', $wheres) . ') ';</span>&nbsp;</div></li><li><div><span class="comment">  return $where;</span>&nbsp;</div></li><li><div><span class="comment">}</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Trash or delete a post or page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * When the post and page is permanently deleted, everything that is tied to</span>&nbsp;</div></li><li><div><span class="comment"> * it is deleted also. This includes comments, post meta fields, and terms</span>&nbsp;</div></li><li><div><span class="comment"> * associated with the post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The post or page is moved to trash instead of permanently deleted unless</span>&nbsp;</div></li><li><div><span class="comment"> * trash is disabled, item is already in the trash, or $force_delete is true.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_delete_attachment()</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_trash_post()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int  $postid       Optional. Post ID. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $force_delete Optional. Whether to bypass trash and force deletion.</span>&nbsp;</div></li><li><div><span class="comment"> *                           Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false|WP_Post False on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_delete_post( $postid = 0, $force_delete = false ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$post = $wpdb-&gt;get_row($wpdb-&gt;prepare(&quot;SELECT * FROM $wpdb-&gt;posts WHERE ID = %d&quot;, $postid)) )&nbsp;</div></li><li><div>      return $post;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$force_delete && ( $post-&gt;post_type == 'post' || $post-&gt;post_type == 'page') && get_post_status( $postid ) != 'trash' && EMPTY_TRASH_DAYS )&nbsp;</div></li><li><div>      return wp_trash_post( $postid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $post-&gt;post_type == 'attachment' )&nbsp;</div></li><li><div>      return wp_delete_attachment( $postid, $force_delete );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters whether a post deletion should take place.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool    $delete       Whether to go forward with deletion.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post         Post object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool    $force_delete Whether to bypass the trash.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $check = apply_filters( 'pre_delete_post', null, $post, $force_delete );&nbsp;</div></li><li><div>  if ( null !== $check ) {&nbsp;</div></li><li><div>      return $check;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires before a post is deleted, at the start of wp_delete_post().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see wp_delete_post()</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $postid Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'before_delete_post', $postid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  delete_post_meta($postid, '_wp_trash_meta_status');&nbsp;</div></li><li><div>  delete_post_meta($postid, '_wp_trash_meta_time');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_delete_object_term_relationships($postid, get_object_taxonomies($post-&gt;post_type));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $parent_data = array( 'post_parent' =&gt; $post-&gt;post_parent );&nbsp;</div></li><li><div>  $parent_where = array( 'post_parent' =&gt; $postid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_post_type_hierarchical( $post-&gt;post_type ) ) {&nbsp;</div></li><li><div>      <span class="comment">// Point children of this page to its parent, also clean the cache of affected children.</span>&nbsp;</div></li><li><div>      $children_query = $wpdb-&gt;prepare( &quot;SELECT * FROM $wpdb-&gt;posts WHERE post_parent = %d AND post_type = %s&quot;, $postid, $post-&gt;post_type );&nbsp;</div></li><li><div>      $children = $wpdb-&gt;get_results( $children_query );&nbsp;</div></li><li><div>      if ( $children ) {&nbsp;</div></li><li><div>          $wpdb-&gt;update( $wpdb-&gt;posts, $parent_data, $parent_where + array( 'post_type' =&gt; $post-&gt;post_type ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Do raw query. wp_get_post_revisions() is filtered.</span>&nbsp;</div></li><li><div>  $revision_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT ID FROM $wpdb-&gt;posts WHERE post_parent = %d AND post_type = 'revision'&quot;, $postid ) );&nbsp;</div></li><li><div>  <span class="comment">// Use wp_delete_post (via wp_delete_post_revision) again. Ensures any meta/misplaced data gets cleaned up.</span>&nbsp;</div></li><li><div>  foreach ( $revision_ids as $revision_id )&nbsp;</div></li><li><div>      wp_delete_post_revision( $revision_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Point all attachments to this post up one level.</span>&nbsp;</div></li><li><div>  $wpdb-&gt;update( $wpdb-&gt;posts, $parent_data, $parent_where + array( 'post_type' =&gt; 'attachment' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_defer_comment_counting( true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT comment_ID FROM $wpdb-&gt;comments WHERE comment_post_ID = %d&quot;, $postid ));&nbsp;</div></li><li><div>  foreach ( $comment_ids as $comment_id ) {&nbsp;</div></li><li><div>      wp_delete_comment( $comment_id, true );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_defer_comment_counting( false );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_meta_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT meta_id FROM $wpdb-&gt;postmeta WHERE post_id = %d &quot;, $postid ));&nbsp;</div></li><li><div>  foreach ( $post_meta_ids as $mid )&nbsp;</div></li><li><div>      delete_metadata_by_mid( 'post', $mid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately before a post is deleted from the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $postid Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'delete_post', $postid );&nbsp;</div></li><li><div>  $result = $wpdb-&gt;delete( $wpdb-&gt;posts, array( 'ID' =&gt; $postid ) );&nbsp;</div></li><li><div>  if ( ! $result ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after a post is deleted from the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $postid Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'deleted_post', $postid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_post_cache( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_post_type_hierarchical( $post-&gt;post_type ) && $children ) {&nbsp;</div></li><li><div>      foreach ( $children as $child )&nbsp;</div></li><li><div>          clean_post_cache( $child );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_clear_scheduled_hook('publish_future_post', array( $postid ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a post is deleted, at the conclusion of wp_delete_post().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.2.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see wp_delete_post()</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $postid Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'after_delete_post', $postid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Reset the page_on_front, show_on_front, and page_for_post settings when</span>&nbsp;</div></li><li><div><span class="comment"> * a linked page is deleted or trashed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Also ensures the post is no longer sticky.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _reset_front_page_settings_for_post( $post_id ) {&nbsp;</div></li><li><div>  $post = get_post( $post_id );&nbsp;</div></li><li><div>  if ( 'page' == $post-&gt;post_type ) {&nbsp;</div></li><li><div>       <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">        * If the page is defined in option page_on_front or post_for_posts, </span>&nbsp;</div></li><li><div><span class="comment">        * adjust the corresponding options.</span>&nbsp;</div></li><li><div><span class="comment">        */</span>&nbsp;</div></li><li><div>      if ( get_option( 'page_on_front' ) == $post-&gt;ID ) {&nbsp;</div></li><li><div>          update_option( 'show_on_front', 'posts' );&nbsp;</div></li><li><div>          update_option( 'page_on_front', 0 );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( get_option( 'page_for_posts' ) == $post-&gt;ID ) {&nbsp;</div></li><li><div>          delete_option( 'page_for_posts', 0 );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  unstick_post( $post-&gt;ID );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Move a post or page to the Trash</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If trash is disabled, the post or page is permanently deleted.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_delete_post()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Post ID. Default is ID of the global $post</span>&nbsp;</div></li><li><div><span class="comment"> *                     if EMPTY_TRASH_DAYS equals true.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|array|WP_Post|null Post data array, otherwise false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_trash_post( $post_id = 0 ) {&nbsp;</div></li><li><div>  if ( !EMPTY_TRASH_DAYS )&nbsp;</div></li><li><div>      return wp_delete_post($post_id, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$post = get_post($post_id, ARRAY_A) )&nbsp;</div></li><li><div>      return $post;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $post['post_status'] == 'trash' )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires before a post is sent to the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'wp_trash_post', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  add_post_meta($post_id, '_wp_trash_meta_status', $post['post_status']);&nbsp;</div></li><li><div>  add_post_meta($post_id, '_wp_trash_meta_time', time());&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post['post_status'] = 'trash';&nbsp;</div></li><li><div>  wp_insert_post( wp_slash( $post ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_trash_post_comments($post_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a post is sent to the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'trashed_post', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Restore a post or page from the Trash.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Post ID. Default is ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Post|false WP_Post object. False on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_untrash_post( $post_id = 0 ) {&nbsp;</div></li><li><div>  if ( !$post = get_post($post_id, ARRAY_A) )&nbsp;</div></li><li><div>      return $post;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $post['post_status'] != 'trash' )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires before a post is restored from the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'untrash_post', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_status = get_post_meta($post_id, '_wp_trash_meta_status', true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post['post_status'] = $post_status;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  delete_post_meta($post_id, '_wp_trash_meta_status');&nbsp;</div></li><li><div>  delete_post_meta($post_id, '_wp_trash_meta_time');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_insert_post( wp_slash( $post ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_untrash_post_comments($post_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after a post is restored from the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'untrashed_post', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Moves comments for a post to the trash.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post|null $post Optional. Post ID or post object. Defaults to global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed|void False on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_trash_post_comments( $post = null ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post($post);&nbsp;</div></li><li><div>  if ( empty($post) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_id = $post-&gt;ID;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires before comments are sent to the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'trash_post_comments', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comments = $wpdb-&gt;get_results( $wpdb-&gt;prepare(&quot;SELECT comment_ID, comment_approved FROM $wpdb-&gt;comments WHERE comment_post_ID = %d&quot;, $post_id) );&nbsp;</div></li><li><div>  if ( empty($comments) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Cache current status for each comment.</span>&nbsp;</div></li><li><div>  $statuses = array();&nbsp;</div></li><li><div>  foreach ( $comments as $comment )&nbsp;</div></li><li><div>      $statuses[$comment-&gt;comment_ID] = $comment-&gt;comment_approved;&nbsp;</div></li><li><div>  add_post_meta($post_id, '_wp_trash_meta_comments_status', $statuses);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Set status for all comments to post-trashed.</span>&nbsp;</div></li><li><div>  $result = $wpdb-&gt;update($wpdb-&gt;comments, array('comment_approved' =&gt; 'post-trashed'), array('comment_post_ID' =&gt; $post_id));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_comment_cache( array_keys($statuses) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after comments are sent to the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $post_id  Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $statuses Array of comment statuses.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'trashed_post_comments', $post_id, $statuses );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Restore comments for a post from the trash.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post|null $post Optional. Post ID or post object. Defaults to global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return true|void</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_untrash_post_comments( $post = null ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post($post);&nbsp;</div></li><li><div>  if ( empty($post) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_id = $post-&gt;ID;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $statuses = get_post_meta($post_id, '_wp_trash_meta_comments_status', true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($statuses) )&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires before comments are restored for a post from the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'untrash_post_comments', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Restore each comment to its original status.</span>&nbsp;</div></li><li><div>  $group_by_status = array();&nbsp;</div></li><li><div>  foreach ( $statuses as $comment_id =&gt; $comment_status )&nbsp;</div></li><li><div>      $group_by_status[$comment_status][] = $comment_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $group_by_status as $status =&gt; $comments ) {&nbsp;</div></li><li><div>      <span class="comment">// Sanity check. This shouldn't happen.</span>&nbsp;</div></li><li><div>      if ( 'post-trashed' == $status ) {&nbsp;</div></li><li><div>          $status = '0';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $comments_in = implode( ', ', array_map( 'intval', $comments ) );&nbsp;</div></li><li><div>      $wpdb-&gt;query( $wpdb-&gt;prepare( &quot;UPDATE $wpdb-&gt;comments SET comment_approved = %s WHERE comment_ID IN ($comments_in)&quot;, $status ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_comment_cache( array_keys($statuses) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  delete_post_meta($post_id, '_wp_trash_meta_comments_status');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after comments are restored for a post from the trash.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'untrashed_post_comments', $post_id );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the list of categories for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Compatibility layer for themes and plugins. Also an easy layer of abstraction</span>&nbsp;</div></li><li><div><span class="comment"> * away from the complexity of the taxonomy layer.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_get_object_terms()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $post_id Optional. The Post ID. Does not default to the ID of the</span>&nbsp;</div></li><li><div><span class="comment"> *                       global $post. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $args    Optional. Category arguments. See wp_get_object_terms(). Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of categories. If the `$fields` argument passed via `$args` is 'all' or</span>&nbsp;</div></li><li><div><span class="comment"> *               'all_with_object_id', an array of WP_Term objects will be returned. If `$fields`</span>&nbsp;</div></li><li><div><span class="comment"> *               is 'ids', an array of category ids. If `$fields` is 'names', an array of category names.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_post_categories( $post_id = 0, $args = array() ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array('fields' =&gt; 'ids');&nbsp;</div></li><li><div>  $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $cats = wp_get_object_terms($post_id, 'category', $args);&nbsp;</div></li><li><div>  return $cats;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the tags for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * There is only one default for this function, called 'fields' and by default</span>&nbsp;</div></li><li><div><span class="comment"> * is set to 'all'. There are other defaults that can be overridden in</span>&nbsp;</div></li><li><div><span class="comment"> * wp_get_object_terms().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $post_id Optional. The Post ID. Does not default to the ID of the</span>&nbsp;</div></li><li><div><span class="comment"> *                       global $post. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $args Optional. Overwrite the defaults</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of post tags.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_post_tags( $post_id = 0, $args = array() ) {&nbsp;</div></li><li><div>  return wp_get_post_terms( $post_id, 'post_tag', $args);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the terms for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * There is only one default for this function, called 'fields' and by default</span>&nbsp;</div></li><li><div><span class="comment"> * is set to 'all'. There are other defaults that can be overridden in</span>&nbsp;</div></li><li><div><span class="comment"> * wp_get_object_terms().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id  Optional. The Post ID. Does not default to the ID of the</span>&nbsp;</div></li><li><div><span class="comment"> *                         global $post. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $taxonomy Optional. The taxonomy for which to retrieve terms. Default 'post_tag'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $args     Optional. wp_get_object_terms() arguments. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|WP_Error  List of post terms or empty array if no terms were found. WP_Error object</span>&nbsp;</div></li><li><div><span class="comment"> *                         if `$taxonomy` doesn't exist.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_post_terms( $post_id = 0, $taxonomy = 'post_tag', $args = array() ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array('fields' =&gt; 'all');&nbsp;</div></li><li><div>  $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $tags = wp_get_object_terms($post_id, $taxonomy, $args);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $tags;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve a number of recent posts.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see get_posts()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $args   Optional. Arguments to retrieve posts. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $output Optional. The required return type. One of OBJECT or ARRAY_A, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                       a WP_Post object or an associative array, respectively. Default ARRAY_A.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false Array of recent posts, where the type of each element is determined by $output parameter.</span>&nbsp;</div></li><li><div><span class="comment"> *                     Empty array on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_recent_posts( $args = array(), $output = ARRAY_A ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_numeric( $args ) ) {&nbsp;</div></li><li><div>      _deprecated_argument( __FUNCTION__, '3.1.0', __( 'Passing an integer number of posts is deprecated. Pass an array of arguments instead.' ) );&nbsp;</div></li><li><div>      $args = array( 'numberposts' =&gt; absint( $args ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Set default arguments.</span>&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'numberposts' =&gt; 10, 'offset' =&gt; 0, &nbsp;</div></li><li><div>      'category' =&gt; 0, 'orderby' =&gt; 'post_date', &nbsp;</div></li><li><div>      'order' =&gt; 'DESC', 'include' =&gt; '', &nbsp;</div></li><li><div>      'exclude' =&gt; '', 'meta_key' =&gt; '', &nbsp;</div></li><li><div>      'meta_value' =&gt;'', 'post_type' =&gt; 'post', 'post_status' =&gt; 'draft, publish, future, pending, private', &nbsp;</div></li><li><div>      'suppress_filters' =&gt; true&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $results = get_posts( $r );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Backward compatibility. Prior to 3.1 expected posts to be returned in array.</span>&nbsp;</div></li><li><div>  if ( ARRAY_A == $output ) {&nbsp;</div></li><li><div>      foreach ( $results as $key =&gt; $result ) {&nbsp;</div></li><li><div>          $results[$key] = get_object_vars( $result );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $results ? $results : array();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $results ? $results : false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Insert or update a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the $postarr parameter has 'ID' set to a value, then post will be updated.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * You can set the post date manually, by setting the values for 'post_date'</span>&nbsp;</div></li><li><div><span class="comment"> * and 'post_date_gmt' keys. You can close the comments or open the comments by</span>&nbsp;</div></li><li><div><span class="comment"> * setting the value for 'comment_status' key.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0 Support was added for encoding emoji in the post title, content, and excerpt.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 A 'meta_input' array can now be passed to `$postarr` to add post meta data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see sanitize_post()</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $postarr {</span>&nbsp;</div></li><li><div><span class="comment"> *     An array of elements that make up a post to update or insert.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $ID                    The post ID. If equal to something other than 0, </span>&nbsp;</div></li><li><div><span class="comment"> *                                         the post with that ID will be updated. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $post_author           The ID of the user who added the post. Default is</span>&nbsp;</div></li><li><div><span class="comment"> *                                         the current user ID.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_date             The date of the post. Default is the current time.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_date_gmt         The date of the post in the GMT timezone. Default is</span>&nbsp;</div></li><li><div><span class="comment"> *                                         the value of `$post_date`.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type mixed  $post_content          The post content. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_content_filtered The filtered post content. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_title            The post title. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_excerpt          The post excerpt. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_status           The post status. Default 'draft'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_type             The post type. Default 'post'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $comment_status        Whether the post can accept comments. Accepts 'open' or 'closed'.</span>&nbsp;</div></li><li><div><span class="comment"> *                                         Default is the value of 'default_comment_status' option.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $ping_status           Whether the post can accept pings. Accepts 'open' or 'closed'.</span>&nbsp;</div></li><li><div><span class="comment"> *                                         Default is the value of 'default_ping_status' option.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_password         The password to access the post. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_name             The post name. Default is the sanitized post title</span>&nbsp;</div></li><li><div><span class="comment"> *                                         when creating a new post.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $to_ping               Space or carriage return-separated list of URLs to ping.</span>&nbsp;</div></li><li><div><span class="comment"> *                                         Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $pinged                Space or carriage return-separated list of URLs that have</span>&nbsp;</div></li><li><div><span class="comment"> *                                         been pinged. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_modified         The date when the post was last modified. Default is</span>&nbsp;</div></li><li><div><span class="comment"> *                                         the current time.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_modified_gmt     The date when the post was last modified in the GMT</span>&nbsp;</div></li><li><div><span class="comment"> *                                         timezone. Default is the current time.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $post_parent           Set this for the post it belongs to, if any. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int    $menu_order            The order the post should be displayed in. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $post_mime_type        The mime type of the post. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $guid                  Global Unique ID for referencing the post. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array  $post_category         Array of category names, slugs, or IDs.</span>&nbsp;</div></li><li><div><span class="comment"> *                                         Defaults to value of the 'default_category' option.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array  $tax_input             Array of taxonomy terms keyed by their taxonomy name. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array  $meta_input            Array of post meta values keyed by their post meta key. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $wp_error Optional. Whether to return a WP_Error on failure. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|WP_Error The post ID on success. The value 0 or WP_Error on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_insert_post( $postarr, $wp_error = false ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $user_id = get_current_user_id();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'post_author' =&gt; $user_id, &nbsp;</div></li><li><div>      'post_content' =&gt; '', &nbsp;</div></li><li><div>      'post_content_filtered' =&gt; '', &nbsp;</div></li><li><div>      'post_title' =&gt; '', &nbsp;</div></li><li><div>      'post_excerpt' =&gt; '', &nbsp;</div></li><li><div>      'post_status' =&gt; 'draft', &nbsp;</div></li><li><div>      'post_type' =&gt; 'post', &nbsp;</div></li><li><div>      'comment_status' =&gt; '', &nbsp;</div></li><li><div>      'ping_status' =&gt; '', &nbsp;</div></li><li><div>      'post_password' =&gt; '', &nbsp;</div></li><li><div>      'to_ping' =&gt;  '', &nbsp;</div></li><li><div>      'pinged' =&gt; '', &nbsp;</div></li><li><div>      'post_parent' =&gt; 0, &nbsp;</div></li><li><div>      'menu_order' =&gt; 0, &nbsp;</div></li><li><div>      'guid' =&gt; '', &nbsp;</div></li><li><div>      'import_id' =&gt; 0, &nbsp;</div></li><li><div>      'context' =&gt; '', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $postarr = wp_parse_args($postarr, $defaults);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  unset( $postarr[ 'filter' ] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $postarr = sanitize_post($postarr, 'db');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Are we updating or creating?</span>&nbsp;</div></li><li><div>  $post_ID = 0;&nbsp;</div></li><li><div>  $update = false;&nbsp;</div></li><li><div>  $guid = $postarr['guid'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $postarr['ID'] ) ) {&nbsp;</div></li><li><div>      $update = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Get the post ID and GUID.</span>&nbsp;</div></li><li><div>      $post_ID = $postarr['ID'];&nbsp;</div></li><li><div>      $post_before = get_post( $post_ID );&nbsp;</div></li><li><div>      if ( is_null( $post_before ) ) {&nbsp;</div></li><li><div>          if ( $wp_error ) {&nbsp;</div></li><li><div>              return new WP_Error( 'invalid_post', __( 'Invalid post ID.' ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $guid = get_post_field( 'guid', $post_ID );&nbsp;</div></li><li><div>      $previous_status = get_post_field('post_status', $post_ID );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $previous_status = 'new';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type = empty( $postarr['post_type'] ) ? 'post' : $postarr['post_type'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_title = $postarr['post_title'];&nbsp;</div></li><li><div>  $post_content = $postarr['post_content'];&nbsp;</div></li><li><div>  $post_excerpt = $postarr['post_excerpt'];&nbsp;</div></li><li><div>  if ( isset( $postarr['post_name'] ) ) {&nbsp;</div></li><li><div>      $post_name = $postarr['post_name'];&nbsp;</div></li><li><div>  } elseif ( $update ) {&nbsp;</div></li><li><div>      <span class="comment">// For an update, don't modify the post_name if it wasn't supplied as an argument.</span>&nbsp;</div></li><li><div>      $post_name = $post_before-&gt;post_name;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $maybe_empty = 'attachment' !== $post_type&nbsp;</div></li><li><div>      && ! $post_content && ! $post_title && ! $post_excerpt&nbsp;</div></li><li><div>      && post_type_supports( $post_type, 'editor' )&nbsp;</div></li><li><div>      && post_type_supports( $post_type, 'title' )&nbsp;</div></li><li><div>      && post_type_supports( $post_type, 'excerpt' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters whether the post should be considered &quot;empty&quot;.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The post is considered &quot;empty&quot; if both:</span>&nbsp;</div></li><li><div><span class="comment">   * 1. The post type supports the title, editor, and excerpt fields</span>&nbsp;</div></li><li><div><span class="comment">   * 2. The title, editor, and excerpt fields are all empty</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Returning a truthy value to the filter will effectively short-circuit</span>&nbsp;</div></li><li><div><span class="comment">   * the new post being inserted, returning 0. If $wp_error is true, a WP_Error</span>&nbsp;</div></li><li><div><span class="comment">   * will be returned instead.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool  $maybe_empty Whether the post should be considered &quot;empty&quot;.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $postarr     Array of post data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( apply_filters( 'wp_insert_post_empty_content', $maybe_empty, $postarr ) ) {&nbsp;</div></li><li><div>      if ( $wp_error ) {&nbsp;</div></li><li><div>          return new WP_Error( 'empty_content', __( 'Content, title, and excerpt are empty.' ) );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_status = empty( $postarr['post_status'] ) ? 'draft' : $postarr['post_status'];&nbsp;</div></li><li><div>  if ( 'attachment' === $post_type && ! in_array( $post_status, array( 'inherit', 'private', 'trash', 'auto-draft' ), true ) ) {&nbsp;</div></li><li><div>      $post_status = 'inherit';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $postarr['post_category'] ) ) {&nbsp;</div></li><li><div>      <span class="comment">// Filter out empty terms.</span>&nbsp;</div></li><li><div>      $post_category = array_filter( $postarr['post_category'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Make sure we set a valid category.</span>&nbsp;</div></li><li><div>  if ( empty( $post_category ) || 0 == count( $post_category ) || ! is_array( $post_category ) ) {&nbsp;</div></li><li><div>      <span class="comment">// 'post' requires at least one category.</span>&nbsp;</div></li><li><div>      if ( 'post' == $post_type && 'auto-draft' != $post_status ) {&nbsp;</div></li><li><div>          $post_category = array( get_option('default_category') );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $post_category = array();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Don't allow contributors to set the post slug for pending review posts.</span>&nbsp;</div></li><li><div>  if ( 'pending' == $post_status && !current_user_can( 'publish_posts' ) ) {&nbsp;</div></li><li><div>      $post_name = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Create a valid post name. Drafts and pending posts are allowed to have</span>&nbsp;</div></li><li><div><span class="comment">   * an empty post name.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( empty($post_name) ) {&nbsp;</div></li><li><div>      if ( !in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) ) {&nbsp;</div></li><li><div>          $post_name = sanitize_title($post_title);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $post_name = '';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment">// On updates, we need to check to see if it's using the old, fixed sanitization context.</span>&nbsp;</div></li><li><div>      $check_name = sanitize_title( $post_name, '', 'old-save' );&nbsp;</div></li><li><div>      if ( $update && strtolower( urlencode( $post_name ) ) == $check_name && get_post_field( 'post_name', $post_ID ) == $check_name ) {&nbsp;</div></li><li><div>          $post_name = $check_name;&nbsp;</div></li><li><div>      } else { <span class="comment">// new post, or slug has changed.</span>&nbsp;</div></li><li><div>          $post_name = sanitize_title($post_name);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * If the post date is empty (due to having been new or a draft) and status</span>&nbsp;</div></li><li><div><span class="comment">   * is not 'draft' or 'pending', set date to now.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( empty( $postarr['post_date'] ) || '0000-00-00 00:00:00' == $postarr['post_date'] ) {&nbsp;</div></li><li><div>      if ( empty( $postarr['post_date_gmt'] ) || '0000-00-00 00:00:00' == $postarr['post_date_gmt'] ) {&nbsp;</div></li><li><div>          $post_date = current_time( 'mysql' );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $post_date = get_date_from_gmt( $postarr['post_date_gmt'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_date = $postarr['post_date'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Validate the date.</span>&nbsp;</div></li><li><div>  $mm = substr( $post_date, 5, 2 );&nbsp;</div></li><li><div>  $jj = substr( $post_date, 8, 2 );&nbsp;</div></li><li><div>  $aa = substr( $post_date, 0, 4 );&nbsp;</div></li><li><div>  $valid_date = wp_checkdate( $mm, $jj, $aa, $post_date );&nbsp;</div></li><li><div>  if ( ! $valid_date ) {&nbsp;</div></li><li><div>      if ( $wp_error ) {&nbsp;</div></li><li><div>          return new WP_Error( 'invalid_date', __( 'Invalid date.' ) );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $postarr['post_date_gmt'] ) || '0000-00-00 00:00:00' == $postarr['post_date_gmt'] ) {&nbsp;</div></li><li><div>      if ( ! in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) ) {&nbsp;</div></li><li><div>          $post_date_gmt = get_gmt_from_date( $post_date );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $post_date_gmt = '0000-00-00 00:00:00';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_date_gmt = $postarr['post_date_gmt'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $update || '0000-00-00 00:00:00' == $post_date ) {&nbsp;</div></li><li><div>      $post_modified = current_time( 'mysql' );&nbsp;</div></li><li><div>      $post_modified_gmt = current_time( 'mysql', 1 );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_modified = $post_date;&nbsp;</div></li><li><div>      $post_modified_gmt = $post_date_gmt;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' !== $post_type ) {&nbsp;</div></li><li><div>      if ( 'publish' == $post_status ) {&nbsp;</div></li><li><div>          $now = gmdate('Y-m-d H:i:59');&nbsp;</div></li><li><div>          if ( mysql2date('U', $post_date_gmt, false) &gt; mysql2date('U', $now, false) ) {&nbsp;</div></li><li><div>              $post_status = 'future';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } elseif ( 'future' == $post_status ) {&nbsp;</div></li><li><div>          $now = gmdate('Y-m-d H:i:59');&nbsp;</div></li><li><div>          if ( mysql2date('U', $post_date_gmt, false) &lt;= mysql2date('U', $now, false) ) {&nbsp;</div></li><li><div>              $post_status = 'publish';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Comment status.</span>&nbsp;</div></li><li><div>  if ( empty( $postarr['comment_status'] ) ) {&nbsp;</div></li><li><div>      if ( $update ) {&nbsp;</div></li><li><div>          $comment_status = 'closed';&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $comment_status = get_default_comment_status( $post_type );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $comment_status = $postarr['comment_status'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// These variables are needed by compact() later.</span>&nbsp;</div></li><li><div>  $post_content_filtered = $postarr['post_content_filtered'];&nbsp;</div></li><li><div>  $post_author = isset( $postarr['post_author'] ) ? $postarr['post_author'] : $user_id;&nbsp;</div></li><li><div>  $ping_status = empty( $postarr['ping_status'] ) ? get_default_comment_status( $post_type, 'pingback' ) : $postarr['ping_status'];&nbsp;</div></li><li><div>  $to_ping = isset( $postarr['to_ping'] ) ? sanitize_trackback_urls( $postarr['to_ping'] ) : '';&nbsp;</div></li><li><div>  $pinged = isset( $postarr['pinged'] ) ? $postarr['pinged'] : '';&nbsp;</div></li><li><div>  $import_id = isset( $postarr['import_id'] ) ? $postarr['import_id'] : 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The 'wp_insert_post_parent' filter expects all variables to be present.</span>&nbsp;</div></li><li><div><span class="comment">   * Previously, these variables would have already been extracted</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( isset( $postarr['menu_order'] ) ) {&nbsp;</div></li><li><div>      $menu_order = (int) $postarr['menu_order'];&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $menu_order = 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_password = isset( $postarr['post_password'] ) ? $postarr['post_password'] : '';&nbsp;</div></li><li><div>  if ( 'private' == $post_status ) {&nbsp;</div></li><li><div>      $post_password = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $postarr['post_parent'] ) ) {&nbsp;</div></li><li><div>      $post_parent = (int) $postarr['post_parent'];&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_parent = 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the post parent -- used to check for and prevent hierarchy loops.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $post_parent Post parent ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $post_ID     Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $new_postarr Array of parsed post data.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $postarr     Array of sanitized, but otherwise unmodified post data.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $post_parent = apply_filters( 'wp_insert_post_parent', $post_parent, $post_ID, compact( array_keys( $postarr ) ), $postarr );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * If the post is being untrashed and it has a desired slug stored in post meta, </span>&nbsp;</div></li><li><div><span class="comment">   * reassign it.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( 'trash' === $previous_status && 'trash' !== $post_status ) {&nbsp;</div></li><li><div>      $desired_post_slug = get_post_meta( $post_ID, '_wp_desired_post_slug', true );&nbsp;</div></li><li><div>      if ( $desired_post_slug ) {&nbsp;</div></li><li><div>          delete_post_meta( $post_ID, '_wp_desired_post_slug' );&nbsp;</div></li><li><div>          $post_name = $desired_post_slug;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If a trashed post has the desired slug, change it and let this post have it.</span>&nbsp;</div></li><li><div>  if ( 'trash' !== $post_status && $post_name ) {&nbsp;</div></li><li><div>      wp_add_trashed_suffix_to_post_name_for_trashed_posts( $post_name, $post_ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// When trashing an existing post, change its slug to allow non-trashed posts to use it.</span>&nbsp;</div></li><li><div>  if ( 'trash' === $post_status && 'trash' !== $previous_status && 'new' !== $previous_status ) {&nbsp;</div></li><li><div>      $post_name = wp_add_trashed_suffix_to_post_name_for_post( $post_ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_name = wp_unique_post_slug( $post_name, $post_ID, $post_status, $post_type, $post_parent );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Don't unslash.</span>&nbsp;</div></li><li><div>  $post_mime_type = isset( $postarr['post_mime_type'] ) ? $postarr['post_mime_type'] : '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Expected_slashed (everything!).</span>&nbsp;</div></li><li><div>  $data = compact( 'post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_content_filtered', 'post_title', 'post_excerpt', 'post_status', 'post_type', 'comment_status', 'ping_status', 'post_password', 'post_name', 'to_ping', 'pinged', 'post_modified', 'post_modified_gmt', 'post_parent', 'menu_order', 'post_mime_type', 'guid' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $emoji_fields = array( 'post_title', 'post_content', 'post_excerpt' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $emoji_fields as $emoji_field ) {&nbsp;</div></li><li><div>      if ( isset( $data[ $emoji_field ] ) ) {&nbsp;</div></li><li><div>          $charset = $wpdb-&gt;get_col_charset( $wpdb-&gt;posts, $emoji_field );&nbsp;</div></li><li><div>          if ( 'utf8' === $charset ) {&nbsp;</div></li><li><div>              $data[ $emoji_field ] = wp_encode_emoji( $data[ $emoji_field ] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' === $post_type ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters attachment post data before it is updated in or added to the database.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.9.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $data    An array of sanitized attachment post data.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $postarr An array of unsanitized attachment post data.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $data = apply_filters( 'wp_insert_attachment_data', $data, $postarr );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters slashed post data just before it is inserted into the database.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $data    An array of slashed post data.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $postarr An array of sanitized, but otherwise unmodified post data.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $data = apply_filters( 'wp_insert_post_data', $data, $postarr );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $data = wp_unslash( $data );&nbsp;</div></li><li><div>  $where = array( 'ID' =&gt; $post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $update ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately before an existing post is updated in the database.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int   $post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $data    Array of unslashed post data.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'pre_post_update', $post_ID, $data );&nbsp;</div></li><li><div>      if ( false === $wpdb-&gt;update( $wpdb-&gt;posts, $data, $where ) ) {&nbsp;</div></li><li><div>          if ( $wp_error ) {&nbsp;</div></li><li><div>              return new WP_Error('db_update_error', __('Could not update post in the database'), $wpdb-&gt;last_error);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              return 0;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment">// If there is a suggested ID, use it if not already present.</span>&nbsp;</div></li><li><div>      if ( ! empty( $import_id ) ) {&nbsp;</div></li><li><div>          $import_id = (int) $import_id;&nbsp;</div></li><li><div>          if ( ! $wpdb-&gt;get_var( $wpdb-&gt;prepare(&quot;SELECT ID FROM $wpdb-&gt;posts WHERE ID = %d&quot;, $import_id) ) ) {&nbsp;</div></li><li><div>              $data['ID'] = $import_id;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( false === $wpdb-&gt;insert( $wpdb-&gt;posts, $data ) ) {&nbsp;</div></li><li><div>          if ( $wp_error ) {&nbsp;</div></li><li><div>              return new WP_Error('db_insert_error', __('Could not insert post into the database'), $wpdb-&gt;last_error);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              return 0;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $post_ID = (int) $wpdb-&gt;insert_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Use the newly generated $post_ID.</span>&nbsp;</div></li><li><div>      $where = array( 'ID' =&gt; $post_ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $data['post_name'] ) && ! in_array( $data['post_status'], array( 'draft', 'pending', 'auto-draft' ) ) ) {&nbsp;</div></li><li><div>      $data['post_name'] = wp_unique_post_slug( sanitize_title( $data['post_title'], $post_ID ), $post_ID, $data['post_status'], $post_type, $post_parent );&nbsp;</div></li><li><div>      $wpdb-&gt;update( $wpdb-&gt;posts, array( 'post_name' =&gt; $data['post_name'] ), $where );&nbsp;</div></li><li><div>      clean_post_cache( $post_ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_object_in_taxonomy( $post_type, 'category' ) ) {&nbsp;</div></li><li><div>      wp_set_post_categories( $post_ID, $post_category );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $postarr['tags_input'] ) && is_object_in_taxonomy( $post_type, 'post_tag' ) ) {&nbsp;</div></li><li><div>      wp_set_post_tags( $post_ID, $postarr['tags_input'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// New-style support for all custom taxonomies.</span>&nbsp;</div></li><li><div>  if ( ! empty( $postarr['tax_input'] ) ) {&nbsp;</div></li><li><div>      foreach ( $postarr['tax_input'] as $taxonomy =&gt; $tags ) {&nbsp;</div></li><li><div>          $taxonomy_obj = get_taxonomy($taxonomy);&nbsp;</div></li><li><div>          if ( ! $taxonomy_obj ) {&nbsp;</div></li><li><div>              <span class="comment">/** translators: %s: taxonomy name */</span>&nbsp;</div></li><li><div>              _doing_it_wrong( __FUNCTION__, sprintf( __( 'Invalid taxonomy: %s.' ), $taxonomy ), '4.4.0' );&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// array = hierarchical, string = non-hierarchical.</span>&nbsp;</div></li><li><div>          if ( is_array( $tags ) ) {&nbsp;</div></li><li><div>              $tags = array_filter($tags);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ( current_user_can( $taxonomy_obj-&gt;cap-&gt;assign_terms ) ) {&nbsp;</div></li><li><div>              wp_set_post_terms( $post_ID, $tags, $taxonomy );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $postarr['meta_input'] ) ) {&nbsp;</div></li><li><div>      foreach ( $postarr['meta_input'] as $field =&gt; $value ) {&nbsp;</div></li><li><div>          update_post_meta( $post_ID, $field, $value );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $current_guid = get_post_field( 'guid', $post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Set GUID.</span>&nbsp;</div></li><li><div>  if ( ! $update && '' == $current_guid ) {&nbsp;</div></li><li><div>      $wpdb-&gt;update( $wpdb-&gt;posts, array( 'guid' =&gt; get_permalink( $post_ID ) ), $where );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' === $postarr['post_type'] ) {&nbsp;</div></li><li><div>      if ( ! empty( $postarr['file'] ) ) {&nbsp;</div></li><li><div>          update_attached_file( $post_ID, $postarr['file'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty( $postarr['context'] ) ) {&nbsp;</div></li><li><div>          add_post_meta( $post_ID, '_wp_attachment_context', $postarr['context'], true );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Set or remove featured image.</span>&nbsp;</div></li><li><div>  if ( isset( $postarr['_thumbnail_id'] ) ) {&nbsp;</div></li><li><div>      $thumbnail_support = current_theme_supports( 'post-thumbnails', $post_type ) && post_type_supports( $post_type, 'thumbnail' ) || 'revision' === $post_type;&nbsp;</div></li><li><div>      if ( ! $thumbnail_support && 'attachment' === $post_type && $post_mime_type ) {&nbsp;</div></li><li><div>          if ( wp_attachment_is( 'audio', $post_ID ) ) {&nbsp;</div></li><li><div>              $thumbnail_support = post_type_supports( 'attachment:audio', 'thumbnail' ) || current_theme_supports( 'post-thumbnails', 'attachment:audio' );&nbsp;</div></li><li><div>          } elseif ( wp_attachment_is( 'video', $post_ID ) ) {&nbsp;</div></li><li><div>              $thumbnail_support = post_type_supports( 'attachment:video', 'thumbnail' ) || current_theme_supports( 'post-thumbnails', 'attachment:video' );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $thumbnail_support ) {&nbsp;</div></li><li><div>          $thumbnail_id = intval( $postarr['_thumbnail_id'] );&nbsp;</div></li><li><div>          if ( -1 === $thumbnail_id ) {&nbsp;</div></li><li><div>              delete_post_thumbnail( $post_ID );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              set_post_thumbnail( $post_ID, $thumbnail_id );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_post_cache( $post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post( $post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $postarr['page_template'] ) ) {&nbsp;</div></li><li><div>      $post-&gt;page_template = $postarr['page_template'];&nbsp;</div></li><li><div>      $page_templates = wp_get_theme()-&gt;get_page_templates( $post );&nbsp;</div></li><li><div>      if ( 'default' != $postarr['page_template'] && ! isset( $page_templates[ $postarr['page_template'] ] ) ) {&nbsp;</div></li><li><div>          if ( $wp_error ) {&nbsp;</div></li><li><div>              return new WP_Error( 'invalid_page_template', __( 'Invalid page template.' ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          update_post_meta( $post_ID, '_wp_page_template', 'default' );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          update_post_meta( $post_ID, '_wp_page_template', $postarr['page_template'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' !== $postarr['post_type'] ) {&nbsp;</div></li><li><div>      wp_transition_post_status( $data['post_status'], $previous_status, $post );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      if ( $update ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires once an existing attachment has been updated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param int $post_ID Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'edit_attachment', $post_ID );&nbsp;</div></li><li><div>          $post_after = get_post( $post_ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires once an existing attachment has been updated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param int     $post_ID      Post ID.</span>&nbsp;</div></li><li><div><span class="comment">           * @param WP_Post $post_after   Post object following the update.</span>&nbsp;</div></li><li><div><span class="comment">           * @param WP_Post $post_before  Post object before the update.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'attachment_updated', $post_ID, $post_after, $post_before );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires once an attachment has been added.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param int $post_ID Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'add_attachment', $post_ID );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $post_ID;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $update ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires once an existing post has been updated.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int     $post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Post $post    Post object.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'edit_post', $post_ID, $post );&nbsp;</div></li><li><div>      $post_after = get_post($post_ID);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires once an existing post has been updated.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int     $post_ID      Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Post $post_after   Post object following the update.</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Post $post_before  Post object before the update.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'post_updated', $post_ID, $post_after, $post_before);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires once a post has been saved.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portion of the hook name, `$post-&gt;post_type`, refers to</span>&nbsp;</div></li><li><div><span class="comment">   * the post type slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post    Post object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool    $update  Whether this is an existing post being updated or not.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;save_post_{$post-&gt;post_type}&quot;, $post_ID, $post, $update );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires once a post has been saved.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post    Post object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool    $update  Whether this is an existing post being updated or not.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'save_post', $post_ID, $post, $update );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires once a post has been saved.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $post_ID Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post    Post object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool    $update  Whether this is an existing post being updated or not.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'wp_insert_post', $post_ID, $post, $update );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post_ID;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update a post with new post data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The date does not have to be set for drafts. You can set the date and it will</span>&nbsp;</div></li><li><div><span class="comment"> * not be overridden.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|object $postarr  Optional. Post data. Arrays are expected to be escaped, </span>&nbsp;</div></li><li><div><span class="comment"> *                               objects are not. Default array.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool         $wp_error Optional. Allow return of WP_Error on failure. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|WP_Error The value 0 or WP_Error on failure. The post ID on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_post( $postarr = array(), $wp_error = false ) {&nbsp;</div></li><li><div>  if ( is_object($postarr) ) {&nbsp;</div></li><li><div>      <span class="comment">// Non-escaped post was passed.</span>&nbsp;</div></li><li><div>      $postarr = get_object_vars($postarr);&nbsp;</div></li><li><div>      $postarr = wp_slash($postarr);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// First, get all of the original fields.</span>&nbsp;</div></li><li><div>  $post = get_post($postarr['ID'], ARRAY_A);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_null( $post ) ) {&nbsp;</div></li><li><div>      if ( $wp_error )&nbsp;</div></li><li><div>          return new WP_Error( 'invalid_post', __( 'Invalid post ID.' ) );&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Escape data pulled from DB.</span>&nbsp;</div></li><li><div>  $post = wp_slash($post);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Passed post category list overwrites existing category list if not empty.</span>&nbsp;</div></li><li><div>  if ( isset($postarr['post_category']) && is_array($postarr['post_category'])&nbsp;</div></li><li><div>           && 0 != count($postarr['post_category']) )&nbsp;</div></li><li><div>      $post_cats = $postarr['post_category'];&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $post_cats = $post['post_category'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Drafts shouldn't be assigned a date unless explicitly done so by the user.</span>&nbsp;</div></li><li><div>  if ( isset( $post['post_status'] ) && in_array($post['post_status'], array('draft', 'pending', 'auto-draft')) && empty($postarr['edit_date']) &&&nbsp;</div></li><li><div>           ('0000-00-00 00:00:00' == $post['post_date_gmt']) )&nbsp;</div></li><li><div>      $clear_date = true;&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $clear_date = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Merge old and new fields with new fields overwriting old ones.</span>&nbsp;</div></li><li><div>  $postarr = array_merge($post, $postarr);&nbsp;</div></li><li><div>  $postarr['post_category'] = $post_cats;&nbsp;</div></li><li><div>  if ( $clear_date ) {&nbsp;</div></li><li><div>      $postarr['post_date'] = current_time('mysql');&nbsp;</div></li><li><div>      $postarr['post_date_gmt'] = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ($postarr['post_type'] == 'attachment')&nbsp;</div></li><li><div>      return wp_insert_attachment($postarr);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_insert_post( $postarr, $wp_error );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Publish a post by transitioning the post status.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Post ID or post object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_publish_post( $post ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $post = get_post( $post ) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'publish' == $post-&gt;post_status )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wpdb-&gt;update( $wpdb-&gt;posts, array( 'post_status' =&gt; 'publish' ), array( 'ID' =&gt; $post-&gt;ID ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_post_cache( $post-&gt;ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $old_status = $post-&gt;post_status;&nbsp;</div></li><li><div>  $post-&gt;post_status = 'publish';&nbsp;</div></li><li><div>  wp_transition_post_status( 'publish', $old_status, $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/post.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  do_action( 'edit_post', $post-&gt;ID, $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/post.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  do_action( &quot;save_post_{$post-&gt;post_type}&quot;, $post-&gt;ID, $post, true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/post.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  do_action( 'save_post', $post-&gt;ID, $post, true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/post.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  do_action( 'wp_insert_post', $post-&gt;ID, $post, true );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Publish future post and make sure post ID has future post status.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Invoked by cron 'publish_future_post' event. This safeguard prevents cron</span>&nbsp;</div></li><li><div><span class="comment"> * from publishing drafts, etc.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post_id Post ID or post object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function check_and_publish_future_post( $post_id ) {&nbsp;</div></li><li><div>  $post = get_post($post_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($post) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'future' != $post-&gt;post_status )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $time = strtotime( $post-&gt;post_date_gmt . ' GMT' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Uh oh, someone jumped the gun!</span>&nbsp;</div></li><li><div>  if ( $time &gt; time() ) {&nbsp;</div></li><li><div>      wp_clear_scheduled_hook( 'publish_future_post', array( $post_id ) ); <span class="comment">// clear anything else in the system</span>&nbsp;</div></li><li><div>      wp_schedule_single_event( $time, 'publish_future_post', array( $post_id ) );&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// wp_publish_post() returns no meaningful value.</span>&nbsp;</div></li><li><div>  wp_publish_post( $post_id );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Computes a unique slug for the post, when given the desired slug and some post details.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb       $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Rewrite $wp_rewrite</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $slug        The desired slug (post_name).</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_ID     Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_status No uniqueness checks are made if the post is still draft or pending.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type   Post type.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_parent Post parent ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string Unique slug for the post, based on $post_name (with a -1, -2, etc. suffix)</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_unique_post_slug( $slug, $post_ID, $post_status, $post_type, $post_parent ) {&nbsp;</div></li><li><div>  if ( in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) || ( 'inherit' == $post_status && 'revision' == $post_type ) )&nbsp;</div></li><li><div>      return $slug;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  global $wpdb, $wp_rewrite;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $original_slug = $slug;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $feeds = $wp_rewrite-&gt;feeds;&nbsp;</div></li><li><div>  if ( ! is_array( $feeds ) )&nbsp;</div></li><li><div>      $feeds = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' == $post_type ) {&nbsp;</div></li><li><div>      <span class="comment">// Attachment slugs must be unique across all types.</span>&nbsp;</div></li><li><div>      $check_sql = &quot;SELECT post_name FROM $wpdb-&gt;posts WHERE post_name = %s AND ID != %d LIMIT 1&quot;;&nbsp;</div></li><li><div>      $post_name_check = $wpdb-&gt;get_var( $wpdb-&gt;prepare( $check_sql, $slug, $post_ID ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters whether the post slug would make a bad attachment slug.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool   $bad_slug Whether the slug would be bad as an attachment slug.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $slug     The post slug.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( $post_name_check || in_array( $slug, $feeds ) || 'embed' === $slug || apply_filters( 'wp_unique_post_slug_is_bad_attachment_slug', false, $slug ) ) {&nbsp;</div></li><li><div>          $suffix = 2;&nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              $alt_post_name = _truncate_post_slug( $slug, 200 - ( strlen( $suffix ) + 1 ) ) . &quot;-$suffix&quot;;&nbsp;</div></li><li><div>              $post_name_check = $wpdb-&gt;get_var( $wpdb-&gt;prepare( $check_sql, $alt_post_name, $post_ID ) );&nbsp;</div></li><li><div>              $suffix++;&nbsp;</div></li><li><div>          } while ( $post_name_check );&nbsp;</div></li><li><div>          $slug = $alt_post_name;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } elseif ( is_post_type_hierarchical( $post_type ) ) {&nbsp;</div></li><li><div>      if ( 'nav_menu_item' == $post_type )&nbsp;</div></li><li><div>          return $slug;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Page slugs must be unique within their own trees. Pages are in a separate</span>&nbsp;</div></li><li><div><span class="comment">       * namespace than posts so page slugs are allowed to overlap post slugs.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $check_sql = &quot;SELECT post_name FROM $wpdb-&gt;posts WHERE post_name = %s AND post_type IN ( %s, 'attachment' ) AND ID != %d AND post_parent = %d LIMIT 1&quot;;&nbsp;</div></li><li><div>      $post_name_check = $wpdb-&gt;get_var( $wpdb-&gt;prepare( $check_sql, $slug, $post_type, $post_ID, $post_parent ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters whether the post slug would make a bad hierarchical post slug.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool   $bad_slug    Whether the post slug would be bad in a hierarchical post context.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $slug        The post slug.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $post_type   Post type.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $post_parent Post parent ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( $post_name_check || in_array( $slug, $feeds ) || 'embed' === $slug || preg_match( &quot;@^($wp_rewrite-&gt;pagination_base)?\d+$@&quot;, $slug )  || apply_filters( 'wp_unique_post_slug_is_bad_hierarchical_slug', false, $slug, $post_type, $post_parent ) ) {&nbsp;</div></li><li><div>          $suffix = 2;&nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              $alt_post_name = _truncate_post_slug( $slug, 200 - ( strlen( $suffix ) + 1 ) ) . &quot;-$suffix&quot;;&nbsp;</div></li><li><div>              $post_name_check = $wpdb-&gt;get_var( $wpdb-&gt;prepare( $check_sql, $alt_post_name, $post_type, $post_ID, $post_parent ) );&nbsp;</div></li><li><div>              $suffix++;&nbsp;</div></li><li><div>          } while ( $post_name_check );&nbsp;</div></li><li><div>          $slug = $alt_post_name;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      <span class="comment">// Post slugs must be unique across all posts.</span>&nbsp;</div></li><li><div>      $check_sql = &quot;SELECT post_name FROM $wpdb-&gt;posts WHERE post_name = %s AND post_type = %s AND ID != %d LIMIT 1&quot;;&nbsp;</div></li><li><div>      $post_name_check = $wpdb-&gt;get_var( $wpdb-&gt;prepare( $check_sql, $slug, $post_type, $post_ID ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Prevent new post slugs that could result in URLs that conflict with date archives.</span>&nbsp;</div></li><li><div>      $post = get_post( $post_ID );&nbsp;</div></li><li><div>      $conflicts_with_date_archive = false;&nbsp;</div></li><li><div>      if ( 'post' === $post_type && ( ! $post || $post-&gt;post_name !== $slug ) && preg_match( '/^[0-9]+$/', $slug ) && $slug_num = intval( $slug ) ) {&nbsp;</div></li><li><div>          $permastructs = array_values( array_filter( explode( '/', get_option( 'permalink_structure' ) ) ) );&nbsp;</div></li><li><div>          $postname_index = array_search( '%postname%', $permastructs );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Potential date clashes are as follows:</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * - Any integer in the first permastruct position could be a year.</span>&nbsp;</div></li><li><div><span class="comment">           * - An integer between 1 and 12 that follows 'year' conflicts with 'monthnum'.</span>&nbsp;</div></li><li><div><span class="comment">           * - An integer between 1 and 31 that follows 'monthnum' conflicts with 'day'.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          if ( 0 === $postname_index ||&nbsp;</div></li><li><div>              ( $postname_index && '%year%' === $permastructs[ $postname_index - 1 ] && 13 &gt; $slug_num ) ||&nbsp;</div></li><li><div>              ( $postname_index && '%monthnum%' === $permastructs[ $postname_index - 1 ] && 32 &gt; $slug_num )&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>              $conflicts_with_date_archive = true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters whether the post slug would be bad as a flat slug.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool   $bad_slug  Whether the post slug would be bad as a flat slug.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $slug      The post slug.</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $post_type Post type.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( $post_name_check || in_array( $slug, $feeds ) || 'embed' === $slug || $conflicts_with_date_archive || apply_filters( 'wp_unique_post_slug_is_bad_flat_slug', false, $slug, $post_type ) ) {&nbsp;</div></li><li><div>          $suffix = 2;&nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              $alt_post_name = _truncate_post_slug( $slug, 200 - ( strlen( $suffix ) + 1 ) ) . &quot;-$suffix&quot;;&nbsp;</div></li><li><div>              $post_name_check = $wpdb-&gt;get_var( $wpdb-&gt;prepare( $check_sql, $alt_post_name, $post_type, $post_ID ) );&nbsp;</div></li><li><div>              $suffix++;&nbsp;</div></li><li><div>          } while ( $post_name_check );&nbsp;</div></li><li><div>          $slug = $alt_post_name;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the unique post slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $slug          The post slug.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $post_ID       Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $post_status   The post status.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $post_type     Post type.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $post_parent   Post parent ID</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $original_slug The original post slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_unique_post_slug', $slug, $post_ID, $post_status, $post_type, $post_parent, $original_slug );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Truncate a post slug.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.6.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see utf8_uri_encode()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $slug   The slug to truncate.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $length Optional. Max length of the slug. Default 200 (characters).</span>&nbsp;</div></li><li><div><span class="comment"> * @return string The truncated slug.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _truncate_post_slug( $slug, $length = 200 ) {&nbsp;</div></li><li><div>  if ( strlen( $slug ) &gt; $length ) {&nbsp;</div></li><li><div>      $decoded_slug = urldecode( $slug );&nbsp;</div></li><li><div>      if ( $decoded_slug === $slug )&nbsp;</div></li><li><div>          $slug = substr( $slug, 0, $length );&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $slug = utf8_uri_encode( $decoded_slug, $length );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return rtrim( $slug, '-' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add tags to a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_set_post_tags()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int          $post_id Optional. The Post ID. Does not default to the ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $tags    Optional. An array of tags to set for the post, or a string of tags</span>&nbsp;</div></li><li><div><span class="comment"> *                              separated by commas. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false|WP_Error Array of affected term IDs. WP_Error or false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_add_post_tags( $post_id = 0, $tags = '' ) {&nbsp;</div></li><li><div>  return wp_set_post_tags($post_id, $tags, true);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Set the tags for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_set_object_terms()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int          $post_id Optional. The Post ID. Does not default to the ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $tags    Optional. An array of tags to set for the post, or a string of tags</span>&nbsp;</div></li><li><div><span class="comment"> *                              separated by commas. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool         $append  Optional. If true, don't delete existing tags, just add on. If false, </span>&nbsp;</div></li><li><div><span class="comment"> *                              replace the tags with the new tags. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false|WP_Error Array of term taxonomy IDs of affected terms. WP_Error or false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_set_post_tags( $post_id = 0, $tags = '', $append = false ) {&nbsp;</div></li><li><div>  return wp_set_post_terms( $post_id, $tags, 'post_tag', $append);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Set the terms for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_set_object_terms()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int          $post_id  Optional. The Post ID. Does not default to the ID of the global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $tags     Optional. An array of terms to set for the post, or a string of terms</span>&nbsp;</div></li><li><div><span class="comment"> *                               separated by commas. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $taxonomy Optional. Taxonomy name. Default 'post_tag'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool         $append   Optional. If true, don't delete existing terms, just add on. If false, </span>&nbsp;</div></li><li><div><span class="comment"> *                               replace the terms with the new terms. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false|WP_Error Array of term taxonomy IDs of affected terms. WP_Error or false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_set_post_terms( $post_id = 0, $tags = '', $taxonomy = 'post_tag', $append = false ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$post_id )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($tags) )&nbsp;</div></li><li><div>      $tags = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_array( $tags ) ) {&nbsp;</div></li><li><div>      $comma = _x( ', ', 'tag delimiter' );&nbsp;</div></li><li><div>      if ( ', ' !== $comma )&nbsp;</div></li><li><div>          $tags = str_replace( $comma, ', ', $tags );&nbsp;</div></li><li><div>      $tags = explode( ', ', trim( $tags, &quot; \n\t\r\0\x0B, &quot; ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Hierarchical taxonomies must always pass IDs rather than names so that</span>&nbsp;</div></li><li><div><span class="comment">   * children with the same names but different parents aren't confused.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( is_taxonomy_hierarchical( $taxonomy ) ) {&nbsp;</div></li><li><div>      $tags = array_unique( array_map( 'intval', $tags ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_set_object_terms( $post_id, $tags, $taxonomy, $append );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Set categories for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the post categories parameter is not set, then the default category is</span>&nbsp;</div></li><li><div><span class="comment"> * going used.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int       $post_ID         Optional. The Post ID. Does not default to the ID</span>&nbsp;</div></li><li><div><span class="comment"> *                                   of the global $post. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|int $post_categories Optional. List of categories or ID of category.</span>&nbsp;</div></li><li><div><span class="comment"> *                                   Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool      $append         If true, don't delete existing categories, just add on.</span>&nbsp;</div></li><li><div><span class="comment"> *                                  If false, replace the categories with the new categories.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false|WP_Error Array of term taxonomy IDs of affected categories. WP_Error or false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_set_post_categories( $post_ID = 0, $post_categories = array(), $append = false ) {&nbsp;</div></li><li><div>  $post_ID = (int) $post_ID;&nbsp;</div></li><li><div>  $post_type = get_post_type( $post_ID );&nbsp;</div></li><li><div>  $post_status = get_post_status( $post_ID );&nbsp;</div></li><li><div>  <span class="comment">// If $post_categories isn't already an array, make it one:</span>&nbsp;</div></li><li><div>  $post_categories = (array) $post_categories;&nbsp;</div></li><li><div>  if ( empty( $post_categories ) ) {&nbsp;</div></li><li><div>      if ( 'post' == $post_type && 'auto-draft' != $post_status ) {&nbsp;</div></li><li><div>          $post_categories = array( get_option('default_category') );&nbsp;</div></li><li><div>          $append = false;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $post_categories = array();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } elseif ( 1 == count( $post_categories ) && '' == reset( $post_categories ) ) {&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_set_post_terms( $post_ID, $post_categories, 'category', $append );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Fires actions related to the transitioning of a post's status.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * When a post is saved, the post status is &quot;transitioned&quot; from one status to another, </span>&nbsp;</div></li><li><div><span class="comment"> * though this does not always mean the status has actually changed before and after</span>&nbsp;</div></li><li><div><span class="comment"> * the save. This function fires a number of action hooks related to that transition:</span>&nbsp;</div></li><li><div><span class="comment"> * the generic {@see 'transition_post_status'} action, as well as the dynamic hooks</span>&nbsp;</div></li><li><div><span class="comment"> * {@see '$old_status_to_$new_status'} and {@see '$new_status_$post-&gt;post_type'}. Note</span>&nbsp;</div></li><li><div><span class="comment"> * that the function does not transition the post object in the database.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * For instance: When publishing a post for the first time, the post status may transition</span>&nbsp;</div></li><li><div><span class="comment"> * from 'draft' * or some other status * to 'publish'. However, if a post is already</span>&nbsp;</div></li><li><div><span class="comment"> * published and is simply being updated, the &quot;old&quot; and &quot;new&quot; statuses may both be 'publish'</span>&nbsp;</div></li><li><div><span class="comment"> * before and after the transition.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string  $new_status Transition to this post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string  $old_status Previous post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post $post Post data.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_transition_post_status( $new_status, $old_status, $post ) {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires when a post is transitioned from one status to another.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string  $new_status New post status.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string  $old_status Old post status.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post       Post object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'transition_post_status', $new_status, $old_status, $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires when a post is transitioned from one status to another.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portions of the hook name, `$new_status` and `$old status`, </span>&nbsp;</div></li><li><div><span class="comment">   * refer to the old and new post statuses, respectively.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post Post object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;{$old_status}_to_{$new_status}&quot;, $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires when a post is transitioned from one status to another.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The dynamic portions of the hook name, `$new_status` and `$post-&gt;post_type`, </span>&nbsp;</div></li><li><div><span class="comment">   * refer to the new post status and post type, respectively.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Please note: When this action is hooked using a particular post status (like</span>&nbsp;</div></li><li><div><span class="comment">   * 'publish', as `publish_{$post-&gt;post_type}`), it will fire both when a post is</span>&nbsp;</div></li><li><div><span class="comment">   * first transitioned to that status from something else, as well as upon</span>&nbsp;</div></li><li><div><span class="comment">   * subsequent post updates (old and new status are both the same).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Therefore, if you are looking to only fire a callback when a post is first</span>&nbsp;</div></li><li><div><span class="comment">   * transitioned to a status, use the {@see 'transition_post_status'} hook instead.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post    Post object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( &quot;{$new_status}_{$post-&gt;post_type}&quot;, $post-&gt;ID, $post );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Comment, trackback, and pingback functions.&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add a URL to those already pinged.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 $post_id can be a WP_Post object.</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 $uri can be an array of URIs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post  $post_id Post object or ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $uri     Ping URI or array of URIs.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false How many rows were updated.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_ping( $post_id, $uri ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post( $post_id );&nbsp;</div></li><li><div>  if ( ! $post ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $pung = trim( $post-&gt;pinged );&nbsp;</div></li><li><div>  $pung = preg_split( '/\s/', $pung );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array( $uri ) ) {&nbsp;</div></li><li><div>      $pung = array_merge( $pung, $uri );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  else {&nbsp;</div></li><li><div>      $pung[] = $uri;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $new = implode(&quot;\n&quot;, $pung);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the new ping URL to add for the given post.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $new New ping URL to add.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $new = apply_filters( 'add_ping', $new );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $return = $wpdb-&gt;update( $wpdb-&gt;posts, array( 'pinged' =&gt; $new ), array( 'ID' =&gt; $post-&gt;ID ) );&nbsp;</div></li><li><div>  clean_post_cache( $post-&gt;ID );&nbsp;</div></li><li><div>  return $return;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve enclosures already enclosed for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of enclosures.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_enclosed( $post_id ) {&nbsp;</div></li><li><div>  $custom_fields = get_post_custom( $post_id );&nbsp;</div></li><li><div>  $pung = array();&nbsp;</div></li><li><div>  if ( !is_array( $custom_fields ) )&nbsp;</div></li><li><div>      return $pung;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $custom_fields as $key =&gt; $val ) {&nbsp;</div></li><li><div>      if ( 'enclosure' != $key || !is_array( $val ) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      foreach ( $val as $enc ) {&nbsp;</div></li><li><div>          $enclosure = explode( &quot;\n&quot;, $enc );&nbsp;</div></li><li><div>          $pung[] = trim( $enclosure[ 0 ] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the list of enclosures already enclosed for the given post.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $pung    Array of enclosures for the given post.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_enclosed', $pung, $post_id );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve URLs already pinged for a post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 $post_id can be a WP_Post object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post_id Post ID or object.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_pung( $post_id ) {&nbsp;</div></li><li><div>  $post = get_post( $post_id );&nbsp;</div></li><li><div>  if ( ! $post ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $pung = trim( $post-&gt;pinged );&nbsp;</div></li><li><div>  $pung = preg_split( '/\s/', $pung );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the list of already-pinged URLs for the given post.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $pung Array of URLs already pinged for the given post.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_pung', $pung );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve URLs that need to be pinged.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 $post_id can be a WP_Post object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post_id Post Object or ID</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_to_ping( $post_id ) {&nbsp;</div></li><li><div>  $post = get_post( $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $post ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $to_ping = sanitize_trackback_urls( $post-&gt;to_ping );&nbsp;</div></li><li><div>  $to_ping = preg_split('/\s/', $to_ping, -1, PREG_SPLIT_NO_EMPTY);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the list of URLs yet to ping for the given post.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $to_ping List of URLs yet to ping.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_to_ping', $to_ping );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Do trackbacks for a list of URLs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $tb_list Comma separated list of URLs.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int    $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function trackback_url_list( $tb_list, $post_id ) {&nbsp;</div></li><li><div>  if ( ! empty( $tb_list ) ) {&nbsp;</div></li><li><div>      <span class="comment">// Get post data.</span>&nbsp;</div></li><li><div>      $postdata = get_post( $post_id, ARRAY_A );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Form an excerpt.</span>&nbsp;</div></li><li><div>      $excerpt = strip_tags( $postdata['post_excerpt'] ? $postdata['post_excerpt'] : $postdata['post_content'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( strlen( $excerpt ) &gt; 255 ) {&nbsp;</div></li><li><div>          $excerpt = substr( $excerpt, 0, 252 ) . '&hellip;';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $trackback_urls = explode( ', ', $tb_list );&nbsp;</div></li><li><div>      foreach ( (array) $trackback_urls as $tb_url ) {&nbsp;</div></li><li><div>          $tb_url = trim( $tb_url );&nbsp;</div></li><li><div>          trackback( $tb_url, wp_unslash( $postdata['post_title'] ), $excerpt, $post_id );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Page functions&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get a list of page IDs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of page IDs.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_all_page_ids() {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $page_ids = wp_cache_get('all_page_ids', 'posts');&nbsp;</div></li><li><div>  if ( ! is_array( $page_ids ) ) {&nbsp;</div></li><li><div>      $page_ids = $wpdb-&gt;get_col(&quot;SELECT ID FROM $wpdb-&gt;posts WHERE post_type = 'page'&quot;);&nbsp;</div></li><li><div>      wp_cache_add('all_page_ids', $page_ids, 'posts');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $page_ids;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves page data given a page ID or page object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Use get_post() instead of get_page().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.1</span>&nbsp;</div></li><li><div><span class="comment"> * @deprecated 3.5.0 Use get_post()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed  $page   Page object or page ID. Passed by reference.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $output Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                       a WP_Post object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $filter Optional. How the return value should be filtered. Accepts 'raw', </span>&nbsp;</div></li><li><div><span class="comment"> *                       'edit', 'db', 'display'. Default 'raw'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Post|array|null WP_Post (or array) on success, or null on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page( $page, $output = OBJECT, $filter = 'raw') {&nbsp;</div></li><li><div>  return get_post( $page, $output, $filter );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves a page given its path.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $page_path Page path.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $output    Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                                a WP_Post object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $post_type Optional. Post type or array of post types. Default 'page'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Post|array|null WP_Post (or array) on success, or null on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page_by_path( $page_path, $output = OBJECT, $post_type = 'page' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $last_changed = wp_cache_get_last_changed( 'posts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $hash = md5( $page_path . serialize( $post_type ) );&nbsp;</div></li><li><div>  $cache_key = &quot;get_page_by_path:$hash:$last_changed&quot;;&nbsp;</div></li><li><div>  $cached = wp_cache_get( $cache_key, 'posts' );&nbsp;</div></li><li><div>  if ( false !== $cached ) {&nbsp;</div></li><li><div>      <span class="comment">// Special case: '0' is a bad `$page_path`.</span>&nbsp;</div></li><li><div>      if ( '0' === $cached || 0 === $cached ) {&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return get_post( $cached, $output );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $page_path = rawurlencode(urldecode($page_path));&nbsp;</div></li><li><div>  $page_path = str_replace('%2F', '/', $page_path);&nbsp;</div></li><li><div>  $page_path = str_replace('%20', ' ', $page_path);&nbsp;</div></li><li><div>  $parts = explode( '/', trim( $page_path, '/' ) );&nbsp;</div></li><li><div>  $parts = esc_sql( $parts );&nbsp;</div></li><li><div>  $parts = array_map( 'sanitize_title_for_query', $parts );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $in_string = &quot;'&quot; . implode( &quot;', '&quot;, $parts ) . &quot;'&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array( $post_type ) ) {&nbsp;</div></li><li><div>      $post_types = $post_type;&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_types = array( $post_type, 'attachment' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_types = esc_sql( $post_types );&nbsp;</div></li><li><div>  $post_type_in_string = &quot;'&quot; . implode( &quot;', '&quot;, $post_types ) . &quot;'&quot;;&nbsp;</div></li><li><div>  $sql = &quot;&nbsp;</div></li><li><div>      SELECT ID, post_name, post_parent, post_type&nbsp;</div></li><li><div>      FROM $wpdb-&gt;posts&nbsp;</div></li><li><div>      WHERE post_name IN ($in_string)&nbsp;</div></li><li><div>      AND post_type IN ($post_type_in_string)&nbsp;</div></li><li><div>  &quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $pages = $wpdb-&gt;get_results( $sql, OBJECT_K );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $revparts = array_reverse( $parts );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $foundid = 0;&nbsp;</div></li><li><div>  foreach ( (array) $pages as $page ) {&nbsp;</div></li><li><div>      if ( $page-&gt;post_name == $revparts[0] ) {&nbsp;</div></li><li><div>          $count = 0;&nbsp;</div></li><li><div>          $p = $page;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Loop through the given path parts from right to left, </span>&nbsp;</div></li><li><div><span class="comment">           * ensuring each matches the post ancestry.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          while ( $p-&gt;post_parent != 0 && isset( $pages[ $p-&gt;post_parent ] ) ) {&nbsp;</div></li><li><div>              $count++;&nbsp;</div></li><li><div>              $parent = $pages[ $p-&gt;post_parent ];&nbsp;</div></li><li><div>              if ( ! isset( $revparts[ $count ] ) || $parent-&gt;post_name != $revparts[ $count ] )&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              $p = $parent;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $p-&gt;post_parent == 0 && $count+1 == count( $revparts ) && $p-&gt;post_name == $revparts[ $count ] ) {&nbsp;</div></li><li><div>              $foundid = $page-&gt;ID;&nbsp;</div></li><li><div>              if ( $page-&gt;post_type == $post_type )&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// We cache misses as well as hits.</span>&nbsp;</div></li><li><div>  wp_cache_set( $cache_key, $foundid, 'posts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $foundid ) {&nbsp;</div></li><li><div>      return get_post( $foundid, $output );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve a page given its title.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $page_title Page title</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $output     Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to</span>&nbsp;</div></li><li><div><span class="comment"> *                                 a WP_Post object, an associative array, or a numeric array, respectively. Default OBJECT.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $post_type  Optional. Post type or array of post types. Default 'page'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Post|array|null WP_Post (or array) on success, or null on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page_by_title( $page_title, $output = OBJECT, $post_type = 'page' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array( $post_type ) ) {&nbsp;</div></li><li><div>      $post_type = esc_sql( $post_type );&nbsp;</div></li><li><div>      $post_type_in_string = &quot;'&quot; . implode( &quot;', '&quot;, $post_type ) . &quot;'&quot;;&nbsp;</div></li><li><div>      $sql = $wpdb-&gt;prepare( &quot;&nbsp;</div></li><li><div>          SELECT ID&nbsp;</div></li><li><div>          FROM $wpdb-&gt;posts&nbsp;</div></li><li><div>          WHERE post_title = %s&nbsp;</div></li><li><div>          AND post_type IN ($post_type_in_string)&nbsp;</div></li><li><div>      &quot;, $page_title );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $sql = $wpdb-&gt;prepare( &quot;&nbsp;</div></li><li><div>          SELECT ID&nbsp;</div></li><li><div>          FROM $wpdb-&gt;posts&nbsp;</div></li><li><div>          WHERE post_title = %s&nbsp;</div></li><li><div>          AND post_type = %s&nbsp;</div></li><li><div>      &quot;, $page_title, $post_type );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $page = $wpdb-&gt;get_var( $sql );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $page ) {&nbsp;</div></li><li><div>      return get_post( $page, $output );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Identify descendants of a given page ID in a list of page objects.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Descendants are identified from the `$pages` array passed to the function. No database queries are performed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.1</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $page_id Page ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $pages   List of page objects from which descendants should be identified.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of page children.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page_children( $page_id, $pages ) {&nbsp;</div></li><li><div>  <span class="comment">// Build a hash of ID -&gt; children.</span>&nbsp;</div></li><li><div>  $children = array();&nbsp;</div></li><li><div>  foreach ( (array) $pages as $page ) {&nbsp;</div></li><li><div>      $children[ intval( $page-&gt;post_parent ) ][] = $page;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $page_list = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Start the search by looking at immediate children.</span>&nbsp;</div></li><li><div>  if ( isset( $children[ $page_id ] ) ) {&nbsp;</div></li><li><div>      <span class="comment">// Always start at the end of the stack in order to preserve original `$pages` order.</span>&nbsp;</div></li><li><div>      $to_look = array_reverse( $children[ $page_id ] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      while ( $to_look ) {&nbsp;</div></li><li><div>          $p = array_pop( $to_look );&nbsp;</div></li><li><div>          $page_list[] = $p;&nbsp;</div></li><li><div>          if ( isset( $children[ $p-&gt;ID ] ) ) {&nbsp;</div></li><li><div>              foreach ( array_reverse( $children[ $p-&gt;ID ] ) as $child ) {&nbsp;</div></li><li><div>                  <span class="comment">// Append to the `$to_look` stack to descend the tree.</span>&nbsp;</div></li><li><div>                  $to_look[] = $child;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $page_list;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Order the pages with children under parents in a flat list.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * It uses auxiliary structure to hold parent-children relationships and</span>&nbsp;</div></li><li><div><span class="comment"> * runs in O(N) complexity</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $pages   Posts array, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $page_id Optional. Parent page ID. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array A list arranged by hierarchy. Children immediately follow their parents.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page_hierarchy( &$pages, $page_id = 0 ) {&nbsp;</div></li><li><div>  if ( empty( $pages ) ) {&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $children = array();&nbsp;</div></li><li><div>  foreach ( (array) $pages as $p ) {&nbsp;</div></li><li><div>      $parent_id = intval( $p-&gt;post_parent );&nbsp;</div></li><li><div>      $children[ $parent_id ][] = $p;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $result = array();&nbsp;</div></li><li><div>  _page_traverse_name( $page_id, $children, $result );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $result;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Traverse and return all the nested children post names of a root page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * $children contains parent-children relations</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see _page_traverse_name()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $page_id   Page ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $children  Parent-children relations, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $result    Result, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _page_traverse_name( $page_id, &$children, &$result ) {&nbsp;</div></li><li><div>  if ( isset( $children[ $page_id ] ) ) {&nbsp;</div></li><li><div>      foreach ( (array)$children[ $page_id ] as $child ) {&nbsp;</div></li><li><div>          $result[ $child-&gt;ID ] = $child-&gt;post_name;&nbsp;</div></li><li><div>          _page_traverse_name( $child-&gt;ID, $children, $result );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Build the URI path for a page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Sub pages will be in the &quot;directory&quot; under the parent page post name.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.6.0 Converted the `$page` parameter to optional.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post|object|int $page Optional. Page ID or WP_Post object. Default is global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false Page URI, false on error.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_page_uri( $page = 0 ) {&nbsp;</div></li><li><div>  if ( ! $page instanceof WP_Post ) {&nbsp;</div></li><li><div>      $page = get_post( $page );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $page )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $uri = $page-&gt;post_name;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $page-&gt;ancestors as $parent ) {&nbsp;</div></li><li><div>      $parent = get_post( $parent );&nbsp;</div></li><li><div>      if ( $parent && $parent-&gt;post_name ) {&nbsp;</div></li><li><div>          $uri = $parent-&gt;post_name . '/' . $uri;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the URI for a page.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string  $uri  Page URI.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $page Page object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_page_uri', $uri, $page );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve a list of pages.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string $args {</span>&nbsp;</div></li><li><div><span class="comment"> *     Optional. Array or string of arguments to retrieve pages.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int          $child_of     Page ID to return child and grandchild pages of. Note: The value</span>&nbsp;</div></li><li><div><span class="comment"> *                                      of `$hierarchical` has no bearing on whether `$child_of` returns</span>&nbsp;</div></li><li><div><span class="comment"> *                                      hierarchical results. Default 0, or no restriction.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $sort_order   How to sort retrieved pages. Accepts 'ASC', 'DESC'. Default 'ASC'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $sort_column  What columns to sort pages by, comma-separated. Accepts 'post_author', </span>&nbsp;</div></li><li><div><span class="comment"> *                                      'post_date', 'post_title', 'post_name', 'post_modified', 'menu_order', </span>&nbsp;</div></li><li><div><span class="comment"> *                                      'post_modified_gmt', 'post_parent', 'ID', 'rand', 'comment_count'.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      'post_' can be omitted for any values that start with it.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default 'post_title'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool         $hierarchical Whether to return pages hierarchically. If false in conjunction with</span>&nbsp;</div></li><li><div><span class="comment"> *                                      `$child_of` also being false, both arguments will be disregarded.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default true.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array        $exclude      Array of page IDs to exclude. Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type array        $include      Array of page IDs to include. Cannot be used with `$child_of`, </span>&nbsp;</div></li><li><div><span class="comment"> *                                      `$parent`, `$exclude`, `$meta_key`, `$meta_value`, or `$hierarchical`.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $meta_key     Only include pages with this meta key. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $meta_value   Only include pages with this meta value. Requires `$meta_key`.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $authors      A comma-separated list of author IDs. Default empty.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int          $parent       Page ID to return direct children of. Default -1, or no restriction.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|array $exclude_tree Comma-separated string or array of page IDs to exclude.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default empty array.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int          $number       The number of pages to return. Default 0, or all pages.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type int          $offset       The number of pages to skip before returning. Requires `$number`.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string       $post_type    The post type to query. Default 'page'.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string|array $post_status  A comma-separated list or array of post statuses to include.</span>&nbsp;</div></li><li><div><span class="comment"> *                                      Default 'publish'.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false List of pages matching defaults or `$args`.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_pages( $args = array() ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'child_of' =&gt; 0, &nbsp;</div></li><li><div>      'sort_order' =&gt; 'ASC', &nbsp;</div></li><li><div>      'sort_column' =&gt; 'post_title', &nbsp;</div></li><li><div>      'hierarchical' =&gt; 1, &nbsp;</div></li><li><div>      'exclude' =&gt; array(), &nbsp;</div></li><li><div>      'include' =&gt; array(), &nbsp;</div></li><li><div>      'meta_key' =&gt; '', &nbsp;</div></li><li><div>      'meta_value' =&gt; '', &nbsp;</div></li><li><div>      'authors' =&gt; '', &nbsp;</div></li><li><div>      'parent' =&gt; -1, &nbsp;</div></li><li><div>      'exclude_tree' =&gt; array(), &nbsp;</div></li><li><div>      'number' =&gt; '', &nbsp;</div></li><li><div>      'offset' =&gt; 0, &nbsp;</div></li><li><div>      'post_type' =&gt; 'page', &nbsp;</div></li><li><div>      'post_status' =&gt; 'publish', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $number = (int) $r['number'];&nbsp;</div></li><li><div>  $offset = (int) $r['offset'];&nbsp;</div></li><li><div>  $child_of = (int) $r['child_of'];&nbsp;</div></li><li><div>  $hierarchical = $r['hierarchical'];&nbsp;</div></li><li><div>  $exclude = $r['exclude'];&nbsp;</div></li><li><div>  $meta_key = $r['meta_key'];&nbsp;</div></li><li><div>  $meta_value = $r['meta_value'];&nbsp;</div></li><li><div>  $parent = $r['parent'];&nbsp;</div></li><li><div>  $post_status = $r['post_status'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Make sure the post type is hierarchical.</span>&nbsp;</div></li><li><div>  $hierarchical_post_types = get_post_types( array( 'hierarchical' =&gt; true ) );&nbsp;</div></li><li><div>  if ( ! in_array( $r['post_type'], $hierarchical_post_types ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $parent &gt; 0 && ! $child_of ) {&nbsp;</div></li><li><div>      $hierarchical = false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Make sure we have a valid post status.</span>&nbsp;</div></li><li><div>  if ( ! is_array( $post_status ) ) {&nbsp;</div></li><li><div>      $post_status = explode( ', ', $post_status );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  if ( array_diff( $post_status, get_post_stati() ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// $args can be whatever, only use the args defined in defaults to compute the key.</span>&nbsp;</div></li><li><div>  $key = md5( serialize( wp_array_slice_assoc( $r, array_keys( $defaults ) ) ) );&nbsp;</div></li><li><div>  $last_changed = wp_cache_get_last_changed( 'posts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $cache_key = &quot;get_pages:$key:$last_changed&quot;;&nbsp;</div></li><li><div>  if ( $cache = wp_cache_get( $cache_key, 'posts' ) ) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// Convert to WP_Post instances</span>.</span>&nbsp;</div></li><li><div>      $pages = array_map( 'get_post', $cache );&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/post.php */</span></span></span>&nbsp;</div></li><li><div>      $pages = apply_filters( 'get_pages', $pages, $r );&nbsp;</div></li><li><div>      return $pages;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $inclusions = '';&nbsp;</div></li><li><div>  if ( ! empty( $r['include'] ) ) {&nbsp;</div></li><li><div>      $child_of = 0; <span class="comment">//ignore child_of, parent, exclude, meta_key, and meta_value params if using include</span>&nbsp;</div></li><li><div>      $parent = -1;&nbsp;</div></li><li><div>      $exclude = '';&nbsp;</div></li><li><div>      $meta_key = '';&nbsp;</div></li><li><div>      $meta_value = '';&nbsp;</div></li><li><div>      $hierarchical = false;&nbsp;</div></li><li><div>      $incpages = wp_parse_id_list( $r['include'] );&nbsp;</div></li><li><div>      if ( ! empty( $incpages ) ) {&nbsp;</div></li><li><div>          $inclusions = ' AND ID IN (' . implode( ', ', $incpages ) .  ')';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $exclusions = '';&nbsp;</div></li><li><div>  if ( ! empty( $exclude ) ) {&nbsp;</div></li><li><div>      $expages = wp_parse_id_list( $exclude );&nbsp;</div></li><li><div>      if ( ! empty( $expages ) ) {&nbsp;</div></li><li><div>          $exclusions = ' AND ID NOT IN (' . implode( ', ', $expages ) .  ')';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $author_query = '';&nbsp;</div></li><li><div>  if ( ! empty( $r['authors'] ) ) {&nbsp;</div></li><li><div>      $post_authors = preg_split( '/[\s, ]+/', $r['authors'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty( $post_authors ) ) {&nbsp;</div></li><li><div>          foreach ( $post_authors as $post_author ) {&nbsp;</div></li><li><div>              <span class="comment">//Do we have an author id or an author login?</span>&nbsp;</div></li><li><div>              if ( 0 == intval($post_author) ) {&nbsp;</div></li><li><div>                  $post_author = get_user_by('login', $post_author);&nbsp;</div></li><li><div>                  if ( empty( $post_author ) ) {&nbsp;</div></li><li><div>                      continue;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  if ( empty( $post_author-&gt;ID ) ) {&nbsp;</div></li><li><div>                      continue;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  $post_author = $post_author-&gt;ID;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( '' == $author_query ) {&nbsp;</div></li><li><div>                  $author_query = $wpdb-&gt;prepare(' post_author = %d ', $post_author);&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $author_query .= $wpdb-&gt;prepare(' OR post_author = %d ', $post_author);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ( '' != $author_query ) {&nbsp;</div></li><li><div>              $author_query = &quot; AND ($author_query)&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $join = '';&nbsp;</div></li><li><div>  $where = &quot;$exclusions $inclusions &quot;;&nbsp;</div></li><li><div>  if ( '' !== $meta_key || '' !== $meta_value ) {&nbsp;</div></li><li><div>      $join = &quot; LEFT JOIN $wpdb-&gt;postmeta ON ( $wpdb-&gt;posts.ID = $wpdb-&gt;postmeta.post_id )&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// meta_key and meta_value might be slashed</span>&nbsp;</div></li><li><div>      $meta_key = wp_unslash($meta_key);&nbsp;</div></li><li><div>      $meta_value = wp_unslash($meta_value);&nbsp;</div></li><li><div>      if ( '' !== $meta_key ) {&nbsp;</div></li><li><div>          $where .= $wpdb-&gt;prepare(&quot; AND $wpdb-&gt;postmeta.meta_key = %s&quot;, $meta_key);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( '' !== $meta_value ) {&nbsp;</div></li><li><div>          $where .= $wpdb-&gt;prepare(&quot; AND $wpdb-&gt;postmeta.meta_value = %s&quot;, $meta_value);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array( $parent ) ) {&nbsp;</div></li><li><div>      $post_parent__in = implode( ', ', array_map( 'absint', (array) $parent ) );&nbsp;</div></li><li><div>      if ( ! empty( $post_parent__in ) ) {&nbsp;</div></li><li><div>          $where .= &quot; AND post_parent IN ($post_parent__in)&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } elseif ( $parent &gt;= 0 ) {&nbsp;</div></li><li><div>      $where .= $wpdb-&gt;prepare(' AND post_parent = %d ', $parent);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 1 == count( $post_status ) ) {&nbsp;</div></li><li><div>      $where_post_type = $wpdb-&gt;prepare( &quot;post_type = %s AND post_status = %s&quot;, $r['post_type'], reset( $post_status ) );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_status = implode( &quot;', '&quot;, $post_status );&nbsp;</div></li><li><div>      $where_post_type = $wpdb-&gt;prepare( &quot;post_type = %s AND post_status IN ('$post_status')&quot;, $r['post_type'] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $orderby_array = array();&nbsp;</div></li><li><div>  $allowed_keys = array( 'author', 'post_author', 'date', 'post_date', 'title', 'post_title', 'name', 'post_name', 'modified', &nbsp;</div></li><li><div>      'post_modified', 'modified_gmt', 'post_modified_gmt', 'menu_order', 'parent', 'post_parent', &nbsp;</div></li><li><div>      'ID', 'rand', 'comment_count' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( explode( ', ', $r['sort_column'] ) as $orderby ) {&nbsp;</div></li><li><div>      $orderby = trim( $orderby );&nbsp;</div></li><li><div>      if ( ! in_array( $orderby, $allowed_keys ) ) {&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      switch ( $orderby ) {&nbsp;</div></li><li><div>          case 'menu_order':&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case 'ID':&nbsp;</div></li><li><div>              $orderby = &quot;$wpdb-&gt;posts.ID&quot;;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case 'rand':&nbsp;</div></li><li><div>              $orderby = 'RAND()';&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case 'comment_count':&nbsp;</div></li><li><div>              $orderby = &quot;$wpdb-&gt;posts.comment_count&quot;;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          default:&nbsp;</div></li><li><div>              if ( 0 === strpos( $orderby, 'post_' ) ) {&nbsp;</div></li><li><div>                  $orderby = &quot;$wpdb-&gt;posts.&quot; . $orderby;&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $orderby = &quot;$wpdb-&gt;posts.post_&quot; . $orderby;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $orderby_array[] = $orderby;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $sort_column = ! empty( $orderby_array ) ? implode( ', ', $orderby_array ) : &quot;$wpdb-&gt;posts.post_title&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $sort_order = strtoupper( $r['sort_order'] );&nbsp;</div></li><li><div>  if ( '' !== $sort_order && ! in_array( $sort_order, array( 'ASC', 'DESC' ) ) ) {&nbsp;</div></li><li><div>      $sort_order = 'ASC';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $query = &quot;SELECT * FROM $wpdb-&gt;posts $join WHERE ($where_post_type) $where &quot;;&nbsp;</div></li><li><div>  $query .= $author_query;&nbsp;</div></li><li><div>  $query .= &quot; ORDER BY &quot; . $sort_column . &quot; &quot; . $sort_order ;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $number ) ) {&nbsp;</div></li><li><div>      $query .= ' LIMIT ' . $offset . ', ' . $number;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $pages = $wpdb-&gt;get_results($query);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($pages) ) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/post.php */</span></span></span>&nbsp;</div></li><li><div>      $pages = apply_filters( 'get_pages', array(), $r );&nbsp;</div></li><li><div>      return $pages;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Sanitize before caching so it'll only get done once.</span>&nbsp;</div></li><li><div>  $num_pages = count($pages);&nbsp;</div></li><li><div>  for ($i = 0; $i &lt; $num_pages; $i++) {&nbsp;</div></li><li><div>      $pages[$i] = sanitize_post($pages[$i], 'raw');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Update cache.</span>&nbsp;</div></li><li><div>  update_post_cache( $pages );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $child_of || $hierarchical ) {&nbsp;</div></li><li><div>      $pages = get_page_children($child_of, $pages);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $r['exclude_tree'] ) ) {&nbsp;</div></li><li><div>      $exclude = wp_parse_id_list( $r['exclude_tree'] );&nbsp;</div></li><li><div>      foreach ( $exclude as $id ) {&nbsp;</div></li><li><div>          $children = get_page_children( $id, $pages );&nbsp;</div></li><li><div>          foreach ( $children as $child ) {&nbsp;</div></li><li><div>              $exclude[] = $child-&gt;ID;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $num_pages = count( $pages );&nbsp;</div></li><li><div>      for ( $i = 0; $i &lt; $num_pages; $i++ ) {&nbsp;</div></li><li><div>          if ( in_array( $pages[$i]-&gt;ID, $exclude ) ) {&nbsp;</div></li><li><div>              unset( $pages[$i] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $page_structure = array();&nbsp;</div></li><li><div>  foreach ( $pages as $page ) {&nbsp;</div></li><li><div>      $page_structure[] = $page-&gt;ID;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_set( $cache_key, $page_structure, 'posts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Convert to WP_Post instances</span>&nbsp;</div></li><li><div>  $pages = array_map( 'get_post', $pages );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the retrieved list of pages.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $pages List of pages to retrieve.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $r     Array of get_pages() arguments.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_pages', $pages, $r );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Attachment functions&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check if the attachment URI is local one and is really an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $url URL to check</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_local_attachment($url) {&nbsp;</div></li><li><div>  if (strpos($url, home_url()) === false)&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  if (strpos($url, home_url('/?attachment_id=')) !== false)&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  if ( $id = url_to_postid($url) ) {&nbsp;</div></li><li><div>      $post = get_post($id);&nbsp;</div></li><li><div>      if ( 'attachment' == $post-&gt;post_type )&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Insert an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If you set the 'ID' in the $args parameter, it will mean that you are</span>&nbsp;</div></li><li><div><span class="comment"> * updating and attempt to update the attachment. You can also set the</span>&nbsp;</div></li><li><div><span class="comment"> * attachment name or title by setting the key 'post_name' or 'post_title'.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * You can set the dates for the attachment manually by setting the 'post_date'</span>&nbsp;</div></li><li><div><span class="comment"> * and 'post_date_gmt' keys' values.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * By default, the comments will use the default settings for whether the</span>&nbsp;</div></li><li><div><span class="comment"> * comments are allowed. You can close them manually or keep them open by</span>&nbsp;</div></li><li><div><span class="comment"> * setting the value for the 'comment_status' key.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0 Added the `$wp_error` parameter to allow a WP_Error to be returned on failure.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_insert_post()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $args     Arguments for inserting an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string       $file     Optional. Filename.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int          $parent   Optional. Parent post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool         $wp_error Optional. Whether to return a WP_Error on failure. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|WP_Error The attachment ID on success. The value 0 or WP_Error on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_insert_attachment( $args, $file = false, $parent = 0, $wp_error = false ) {&nbsp;</div></li><li><div>  $defaults = array(&nbsp;</div></li><li><div>      'file' =&gt; $file, &nbsp;</div></li><li><div>      'post_parent' =&gt; 0&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $data = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $parent ) ) {&nbsp;</div></li><li><div>      $data['post_parent'] = $parent;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $data['post_type'] = 'attachment';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return wp_insert_post( $data, $wp_error );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Trash or delete an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * When an attachment is permanently deleted, the file will also be removed.</span>&nbsp;</div></li><li><div><span class="comment"> * Deletion removes all post meta fields, taxonomy, comments, etc. associated</span>&nbsp;</div></li><li><div><span class="comment"> * with the attachment (except the main post).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The attachment is moved to the trash instead of permanently deleted unless trash</span>&nbsp;</div></li><li><div><span class="comment"> * for media is disabled, item is already in the trash, or $force_delete is true.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int  $post_id      Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $force_delete Optional. Whether to bypass trash and force deletion.</span>&nbsp;</div></li><li><div><span class="comment"> *                           Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed False on failure. Post data on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_delete_attachment( $post_id, $force_delete = false ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$post = $wpdb-&gt;get_row( $wpdb-&gt;prepare(&quot;SELECT * FROM $wpdb-&gt;posts WHERE ID = %d&quot;, $post_id) ) )&nbsp;</div></li><li><div>      return $post;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' != $post-&gt;post_type )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$force_delete && EMPTY_TRASH_DAYS && MEDIA_TRASH && 'trash' != $post-&gt;post_status )&nbsp;</div></li><li><div>      return wp_trash_post( $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  delete_post_meta($post_id, '_wp_trash_meta_status');&nbsp;</div></li><li><div>  delete_post_meta($post_id, '_wp_trash_meta_time');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $meta = wp_get_attachment_metadata( $post_id );&nbsp;</div></li><li><div>  $backup_sizes = get_post_meta( $post-&gt;ID, '_wp_attachment_backup_sizes', true );&nbsp;</div></li><li><div>  $file = get_attached_file( $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_multisite() )&nbsp;</div></li><li><div>      delete_transient( 'dirsize_cache' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires before an attachment is deleted, at the start of wp_delete_attachment().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $post_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'delete_attachment', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_delete_object_term_relationships($post_id, array('category', 'post_tag'));&nbsp;</div></li><li><div>  wp_delete_object_term_relationships($post_id, get_object_taxonomies($post-&gt;post_type));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Delete all for any posts.</span>&nbsp;</div></li><li><div>  delete_metadata( 'post', null, '_thumbnail_id', $post_id, true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_defer_comment_counting( true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $comment_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT comment_ID FROM $wpdb-&gt;comments WHERE comment_post_ID = %d&quot;, $post_id ));&nbsp;</div></li><li><div>  foreach ( $comment_ids as $comment_id ) {&nbsp;</div></li><li><div>      wp_delete_comment( $comment_id, true );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_defer_comment_counting( false );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_meta_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT meta_id FROM $wpdb-&gt;postmeta WHERE post_id = %d &quot;, $post_id ));&nbsp;</div></li><li><div>  foreach ( $post_meta_ids as $mid )&nbsp;</div></li><li><div>      delete_metadata_by_mid( 'post', $mid );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/post.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  do_action( 'delete_post', $post_id );&nbsp;</div></li><li><div>  $result = $wpdb-&gt;delete( $wpdb-&gt;posts, array( 'ID' =&gt; $post_id ) );&nbsp;</div></li><li><div>  if ( ! $result ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">/** This action is documented in wp-includes/post.php */</span></span></span></span></span></span>&nbsp;</div></li><li><div>  do_action( 'deleted_post', $post_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $uploadpath = wp_get_upload_dir();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty($meta['thumb']) ) {&nbsp;</div></li><li><div>      <span class="comment">// Don't delete the thumb if another attachment uses it.</span>&nbsp;</div></li><li><div>      if (! $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;SELECT meta_id FROM $wpdb-&gt;postmeta WHERE meta_key = '_wp_attachment_metadata' AND meta_value LIKE %s AND post_id &lt;&gt; %d&quot;, '%' . $wpdb-&gt;esc_like( $meta['thumb'] ) . '%', $post_id)) ) {&nbsp;</div></li><li><div>          $thumbfile = str_replace(basename($file), $meta['thumb'], $file);&nbsp;</div></li><li><div>          <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/functions.php */</span></span></span>&nbsp;</div></li><li><div>          $thumbfile = apply_filters( 'wp_delete_file', $thumbfile );&nbsp;</div></li><li><div>          @ unlink( path_join($uploadpath['basedir'], $thumbfile) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Remove intermediate and backup images if there are any.</span>&nbsp;</div></li><li><div>  if ( isset( $meta['sizes'] ) && is_array( $meta['sizes'] ) ) {&nbsp;</div></li><li><div>      foreach ( $meta['sizes'] as $size =&gt; $sizeinfo ) {&nbsp;</div></li><li><div>          $intermediate_file = str_replace( basename( $file ), $sizeinfo['file'], $file );&nbsp;</div></li><li><div>          <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/functions.php */</span></span></span>&nbsp;</div></li><li><div>          $intermediate_file = apply_filters( 'wp_delete_file', $intermediate_file );&nbsp;</div></li><li><div>          @ unlink( path_join( $uploadpath['basedir'], $intermediate_file ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array($backup_sizes) ) {&nbsp;</div></li><li><div>      foreach ( $backup_sizes as $size ) {&nbsp;</div></li><li><div>          $del_file = path_join( dirname($meta['file']), $size['file'] );&nbsp;</div></li><li><div>          <span class="comment"><span class="comment"><span class="comment">/** This filter is documented in wp-includes/functions.php */</span></span></span>&nbsp;</div></li><li><div>          $del_file = apply_filters( 'wp_delete_file', $del_file );&nbsp;</div></li><li><div>          @ unlink( path_join($uploadpath['basedir'], $del_file) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_delete_file( $file );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_post_cache( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve attachment meta field for attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int  $post_id    Attachment ID. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $unfiltered Optional. If true, filters are not run. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return mixed Attachment meta field. False on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_attachment_metadata( $post_id = 0, $unfiltered = false ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>  if ( !$post = get_post( $post_id ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $data = get_post_meta( $post-&gt;ID, '_wp_attachment_metadata', true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $unfiltered )&nbsp;</div></li><li><div>      return $data;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the attachment meta data.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|bool $data    Array of meta data for the given attachment, or false</span>&nbsp;</div></li><li><div><span class="comment">   *                            if the object does not exist.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int        $post_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_get_attachment_metadata', $data, $post-&gt;ID );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update metadata for an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int   $post_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $data    Attachment data.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|bool False if $post is invalid.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_update_attachment_metadata( $post_id, $data ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>  if ( !$post = get_post( $post_id ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the updated attachment meta data.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $data    Array of updated attachment meta data.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $post_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( $data = apply_filters( 'wp_update_attachment_metadata', $data, $post-&gt;ID ) )&nbsp;</div></li><li><div>      return update_post_meta( $post-&gt;ID, '_wp_attachment_metadata', $data );&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      return delete_post_meta( $post-&gt;ID, '_wp_attachment_metadata' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the URL for an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global string $pagenow</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Attachment ID. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false Attachment URL, otherwise false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_attachment_url( $post_id = 0 ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>  if ( !$post = get_post( $post_id ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' != $post-&gt;post_type )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $url = '';&nbsp;</div></li><li><div>  <span class="comment">// Get attached file.</span>&nbsp;</div></li><li><div>  if ( $file = get_post_meta( $post-&gt;ID, '_wp_attached_file', true ) ) {&nbsp;</div></li><li><div>      <span class="comment">// Get upload directory.</span>&nbsp;</div></li><li><div>      if ( ( $uploads = wp_get_upload_dir() ) && false === $uploads['error'] ) {&nbsp;</div></li><li><div>          <span class="comment">// Check that the upload base exists in the file location.</span>&nbsp;</div></li><li><div>          if ( 0 === strpos( $file, $uploads['basedir'] ) ) {&nbsp;</div></li><li><div>              <span class="comment">// Replace file location with url location.</span>&nbsp;</div></li><li><div>              $url = str_replace($uploads['basedir'], $uploads['baseurl'], $file);&nbsp;</div></li><li><div>          } elseif ( false !== strpos($file, 'wp-content/uploads') ) {&nbsp;</div></li><li><div>              <span class="comment">// Get the directory name relative to the basedir (back compat for pre-2.7 uploads)</span>&nbsp;</div></li><li><div>              $url = trailingslashit( $uploads['baseurl'] . '/' . _wp_get_attachment_relative_path( $file ) ) . basename( $file );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              <span class="comment">// It's a newly-uploaded file, therefore $file is relative to the basedir.</span>&nbsp;</div></li><li><div>              $url = $uploads['baseurl'] . &quot;/$file&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * If any of the above options failed, Fallback on the GUID as used pre-2.7, </span>&nbsp;</div></li><li><div><span class="comment">   * not recommended to rely upon this.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( empty($url) ) {&nbsp;</div></li><li><div>      $url = get_the_guid( $post-&gt;ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// On SSL front end, URLs should be HTTPS.</span>&nbsp;</div></li><li><div>  if ( is_ssl() && ! is_admin() && 'wp-login.php' !== $GLOBALS['pagenow'] ) {&nbsp;</div></li><li><div>      $url = set_url_scheme( $url );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the attachment URL.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url     URL for the given attachment.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $post_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $url = apply_filters( 'wp_get_attachment_url', $url, $post-&gt;ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $url ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $url;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieves the caption for an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.6.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Attachment ID. Default is the ID of the global `$post`.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false False on failure. Attachment caption on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_attachment_caption( $post_id = 0 ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>  if ( ! $post = get_post( $post_id ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'attachment' !== $post-&gt;post_type ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $caption = $post-&gt;post_excerpt;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the attachment caption.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.6.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $caption Caption for the given attachment.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $post_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_get_attachment_caption', $caption, $post-&gt;ID );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve thumbnail for an attachment.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Attachment ID. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false False on failure. Thumbnail file path on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_attachment_thumb_file( $post_id = 0 ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>  if ( !$post = get_post( $post_id ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  if ( !is_array( $imagedata = wp_get_attachment_metadata( $post-&gt;ID ) ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $file = get_attached_file( $post-&gt;ID );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !empty($imagedata['thumb']) && ($thumbfile = str_replace(basename($file), $imagedata['thumb'], $file)) && file_exists($thumbfile) ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the attachment thumbnail file path.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $thumbfile File path to the attachment thumbnail.</span>&nbsp;</div></li><li><div><span class="comment">       * @param int    $post_id   Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'wp_get_attachment_thumb_file', $thumbfile, $post-&gt;ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve URL for an attachment thumbnail.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id Optional. Attachment ID. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false False on failure. Thumbnail URL on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_attachment_thumb_url( $post_id = 0 ) {&nbsp;</div></li><li><div>  $post_id = (int) $post_id;&nbsp;</div></li><li><div>  if ( !$post = get_post( $post_id ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  if ( !$url = wp_get_attachment_url( $post-&gt;ID ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $sized = image_downsize( $post_id, 'thumbnail' );&nbsp;</div></li><li><div>  if ( $sized )&nbsp;</div></li><li><div>      return $sized[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !$thumb = wp_get_attachment_thumb_file( $post-&gt;ID ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $url = str_replace(basename($url), basename($thumb), $url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the attachment thumbnail URL.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url     URL for the attachment thumbnail.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $post_id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_get_attachment_thumb_url', $url, $post-&gt;ID );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Verifies an attachment is of a given type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string      $type Attachment type. Accepts 'image', 'audio', or 'video'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Optional. Attachment ID or object. Default is global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True if one of the accepted types, false otherwise.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_attachment_is( $type, $post = null ) {&nbsp;</div></li><li><div>  if ( ! $post = get_post( $post ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $file = get_attached_file( $post-&gt;ID ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 0 === strpos( $post-&gt;post_mime_type, $type . '/' ) ) {&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $check = wp_check_filetype( $file );&nbsp;</div></li><li><div>  if ( empty( $check['ext'] ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $ext = $check['ext'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'import' !== $post-&gt;post_mime_type ) {&nbsp;</div></li><li><div>      return $type === $ext;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  switch ( $type ) {&nbsp;</div></li><li><div>  case 'image':&nbsp;</div></li><li><div>      $image_exts = array( 'jpg', 'jpeg', 'jpe', 'gif', 'png' );&nbsp;</div></li><li><div>      return in_array( $ext, $image_exts );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  case 'audio':&nbsp;</div></li><li><div>      return in_array( $ext, wp_get_audio_extensions() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  case 'video':&nbsp;</div></li><li><div>      return in_array( $ext, wp_get_video_extensions() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  default:&nbsp;</div></li><li><div>      return $type === $ext;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Checks if the attachment is an image.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.2.0 Modified into wrapper for wp_attachment_is() and</span>&nbsp;</div></li><li><div><span class="comment"> *              allowed WP_Post object to be passed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Optional. Attachment ID or object. Default is global $post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether the attachment is an image.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_attachment_is_image( $post = null ) {&nbsp;</div></li><li><div>  return wp_attachment_is( 'image', $post );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the icon for a MIME type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|int $mime MIME type or attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false Icon, false otherwise.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_mime_type_icon( $mime = 0 ) {&nbsp;</div></li><li><div>  if ( !is_numeric($mime) )&nbsp;</div></li><li><div>      $icon = wp_cache_get(&quot;mime_type_icon_$mime&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_id = 0;&nbsp;</div></li><li><div>  if ( empty($icon) ) {&nbsp;</div></li><li><div>      $post_mimes = array();&nbsp;</div></li><li><div>      if ( is_numeric($mime) ) {&nbsp;</div></li><li><div>          $mime = (int) $mime;&nbsp;</div></li><li><div>          if ( $post = get_post( $mime ) ) {&nbsp;</div></li><li><div>              $post_id = (int) $post-&gt;ID;&nbsp;</div></li><li><div>              $file = get_attached_file( $post_id );&nbsp;</div></li><li><div>              $ext = preg_replace('/^.+?\.([^.]+)$/', '$1', $file);&nbsp;</div></li><li><div>              if ( !empty($ext) ) {&nbsp;</div></li><li><div>                  $post_mimes[] = $ext;&nbsp;</div></li><li><div>                  if ( $ext_type = wp_ext2type( $ext ) )&nbsp;</div></li><li><div>                      $post_mimes[] = $ext_type;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $mime = $post-&gt;post_mime_type;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $mime = 0;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $post_mimes[] = $mime;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $icon_files = wp_cache_get('icon_files');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($icon_files) ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the icon directory path.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $path Icon directory absolute path.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $icon_dir = apply_filters( 'icon_dir', ABSPATH . WPINC . '/images/media' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the icon directory URI.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $uri Icon directory URI.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $icon_dir_uri = apply_filters( 'icon_dir_uri', includes_url( 'images/media' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filters the list of icon directory URIs.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param array $uris List of icon directory URIs.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $dirs = apply_filters( 'icon_dirs', array( $icon_dir =&gt; $icon_dir_uri ) );&nbsp;</div></li><li><div>          $icon_files = array();&nbsp;</div></li><li><div>          while ( $dirs ) {&nbsp;</div></li><li><div>              $keys = array_keys( $dirs );&nbsp;</div></li><li><div>              $dir = array_shift( $keys );&nbsp;</div></li><li><div>              $uri = array_shift($dirs);&nbsp;</div></li><li><div>              if ( $dh = opendir($dir) ) {&nbsp;</div></li><li><div>                  while ( false !== $file = readdir($dh) ) {&nbsp;</div></li><li><div>                      $file = basename($file);&nbsp;</div></li><li><div>                      if ( substr($file, 0, 1) == '.' )&nbsp;</div></li><li><div>                          continue;&nbsp;</div></li><li><div>                      if ( !in_array(strtolower(substr($file, -4)), array('.png', '.gif', '.jpg') ) ) {&nbsp;</div></li><li><div>                          if ( is_dir(&quot;$dir/$file&quot;) )&nbsp;</div></li><li><div>                              $dirs[&quot;$dir/$file&quot;] = &quot;$uri/$file&quot;;&nbsp;</div></li><li><div>                          continue;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      $icon_files[&quot;$dir/$file&quot;] = &quot;$uri/$file&quot;;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  closedir($dh);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          wp_cache_add( 'icon_files', $icon_files, 'default', 600 );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $types = array();&nbsp;</div></li><li><div>      <span class="comment">// Icon basename - extension = MIME wildcard.</span>&nbsp;</div></li><li><div>      foreach ( $icon_files as $file =&gt; $uri )&nbsp;</div></li><li><div>          $types[ preg_replace('/^([^.]*).*$/', '$1', basename($file)) ] =& $icon_files[$file];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty($mime) ) {&nbsp;</div></li><li><div>          $post_mimes[] = substr($mime, 0, strpos($mime, '/'));&nbsp;</div></li><li><div>          $post_mimes[] = substr($mime, strpos($mime, '/') + 1);&nbsp;</div></li><li><div>          $post_mimes[] = str_replace('/', '_', $mime);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $matches = wp_match_mime_types(array_keys($types), $post_mimes);&nbsp;</div></li><li><div>      $matches['default'] = array('default');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $matches as $match =&gt; $wilds ) {&nbsp;</div></li><li><div>          foreach ( $wilds as $wild ) {&nbsp;</div></li><li><div>              if ( ! isset( $types[ $wild ] ) ) {&nbsp;</div></li><li><div>                  continue;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $icon = $types[ $wild ];&nbsp;</div></li><li><div>              if ( ! is_numeric( $mime ) ) {&nbsp;</div></li><li><div>                  wp_cache_add( &quot;mime_type_icon_$mime&quot;, $icon );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              break 2;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the mime type icon.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $icon    Path to the mime type icon.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $mime    Mime type.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int    $post_id Attachment ID. Will equal 0 if the function passed</span>&nbsp;</div></li><li><div><span class="comment">   *                        the mime type.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'wp_mime_type_icon', $icon, $mime, $post_id );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check for changed slugs for published post objects and save the old slug.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function is used when a post object of any type is updated, </span>&nbsp;</div></li><li><div><span class="comment"> * by comparing the current and previous post objects.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the slug was changed and not already part of the old slugs then it will be</span>&nbsp;</div></li><li><div><span class="comment"> * added to the post meta field ('_wp_old_slug') for storing old slugs for that</span>&nbsp;</div></li><li><div><span class="comment"> * post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The most logically usage of this function is redirecting changed post objects, so</span>&nbsp;</div></li><li><div><span class="comment"> * that those that linked to an changed post will be redirected to the new post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int     $post_id     Post ID.</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post $post        The Post Object</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post $post_before The Previous Post Object</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_check_for_changed_slugs( $post_id, $post, $post_before ) {&nbsp;</div></li><li><div>  <span class="comment">// Don't bother if it hasn't changed.</span>&nbsp;</div></li><li><div>  if ( $post-&gt;post_name == $post_before-&gt;post_name ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// We're only concerned with published, non-hierarchical objects.</span>&nbsp;</div></li><li><div>  if ( ! ( 'publish' === $post-&gt;post_status || ( 'attachment' === get_post_type( $post ) && 'inherit' === $post-&gt;post_status ) ) || is_post_type_hierarchical( $post-&gt;post_type ) ) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $old_slugs = (array) get_post_meta( $post_id, '_wp_old_slug' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If we haven't added this old slug before, add it now.</span>&nbsp;</div></li><li><div>  if ( ! empty( $post_before-&gt;post_name ) && ! in_array( $post_before-&gt;post_name, $old_slugs ) ) {&nbsp;</div></li><li><div>      add_post_meta( $post_id, '_wp_old_slug', $post_before-&gt;post_name );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If the new slug was used previously, delete it from the list.</span>&nbsp;</div></li><li><div>  if ( in_array( $post-&gt;post_name, $old_slugs ) ) {&nbsp;</div></li><li><div>      delete_post_meta( $post_id, '_wp_old_slug', $post-&gt;post_name );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the private post SQL based on capability.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function provides a standardized way to appropriately select on the</span>&nbsp;</div></li><li><div><span class="comment"> * post_status of a post type. The function will return a piece of SQL code</span>&nbsp;</div></li><li><div><span class="comment"> * that can be added to a WHERE clause; this SQL is constructed to allow all</span>&nbsp;</div></li><li><div><span class="comment"> * published posts, and all private posts to which the user has access.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.2.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0 Added the ability to pass an array to `$post_type`.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $post_type Single post type or an array of post types. Currently only supports 'post' or 'page'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string SQL code that can be added to a where clause.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_private_posts_cap_sql( $post_type ) {&nbsp;</div></li><li><div>  return get_posts_by_author_sql( $post_type, false );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the post SQL based on capability, author, and type.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.3.0 Introduced the ability to pass an array of post types to `$post_type`.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see get_private_posts_cap_sql()</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array|string   $post_type   Single post type or an array of post types.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool           $full        Optional. Returns a full WHERE statement instead of just</span>&nbsp;</div></li><li><div><span class="comment"> *                                    an 'andalso' term. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int            $post_author Optional. Query posts having a single author ID. Default null.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool           $public_only Optional. Only return public posts. Skips cap checks for</span>&nbsp;</div></li><li><div><span class="comment"> *                                    $current_user.  Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string SQL WHERE code that can be added to a query.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_posts_by_author_sql( $post_type, $full = true, $post_author = null, $public_only = false ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array( $post_type ) ) {&nbsp;</div></li><li><div>      $post_types = $post_type;&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_types = array( $post_type );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_type_clauses = array();&nbsp;</div></li><li><div>  foreach ( $post_types as $post_type ) {&nbsp;</div></li><li><div>      $post_type_obj = get_post_type_object( $post_type );&nbsp;</div></li><li><div>      if ( ! $post_type_obj ) {&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filters the capability to read private posts for a custom post type</span>&nbsp;</div></li><li><div><span class="comment">       * when generating SQL for getting posts by author.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.2.0</span>&nbsp;</div></li><li><div><span class="comment">       * @deprecated 3.2.0 The hook transitioned from &quot;somewhat useless&quot; to &quot;totally useless&quot;.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $cap Capability.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( ! $cap = apply_filters( 'pub_priv_sql_capability', '' ) ) {&nbsp;</div></li><li><div>          $cap = current_user_can( $post_type_obj-&gt;cap-&gt;read_private_posts );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Only need to check the cap if $public_only is false.</span>&nbsp;</div></li><li><div>      $post_status_sql = &quot;post_status = 'publish'&quot;;&nbsp;</div></li><li><div>      if ( false === $public_only ) {&nbsp;</div></li><li><div>          if ( $cap ) {&nbsp;</div></li><li><div>              <span class="comment">// Does the user have the capability to view private posts? Guess so.</span>&nbsp;</div></li><li><div>              $post_status_sql .= &quot; OR post_status = 'private'&quot;;&nbsp;</div></li><li><div>          } elseif ( is_user_logged_in() ) {&nbsp;</div></li><li><div>              <span class="comment">// Users can view their own private posts.</span>&nbsp;</div></li><li><div>              $id = get_current_user_id();&nbsp;</div></li><li><div>              if ( null === $post_author || ! $full ) {&nbsp;</div></li><li><div>                  $post_status_sql .= &quot; OR post_status = 'private' AND post_author = $id&quot;;&nbsp;</div></li><li><div>              } elseif ( $id == (int) $post_author ) {&nbsp;</div></li><li><div>                  $post_status_sql .= &quot; OR post_status = 'private'&quot;;&nbsp;</div></li><li><div>              } <span class="comment"><span class="comment">// else none</span></span>&nbsp;</div></li><li><div>          } <span class="comment"><span class="comment">// else none</span></span>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $post_type_clauses[] = &quot;( post_type = '&quot; . $post_type . &quot;' AND ( $post_status_sql ) )&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $post_type_clauses ) ) {&nbsp;</div></li><li><div>      return $full ? 'WHERE 1 = 0' : '1 = 0';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $sql = '( '. implode( ' OR ', $post_type_clauses ) . ' )';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null !== $post_author ) {&nbsp;</div></li><li><div>      $sql .= $wpdb-&gt;prepare( ' AND post_author = %d', $post_author );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $full ) {&nbsp;</div></li><li><div>      $sql = 'WHERE ' . $sql;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $sql;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Retrieve the date that the last post was published.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The server timezone is the default and is the difference between GMT and</span>&nbsp;</div></li><li><div><span class="comment"> * server time. The 'blog' value is the date when the last post was posted. The</span>&nbsp;</div></li><li><div><span class="comment"> * 'gmt' is when the last post was posted in GMT formatted date.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 0.71</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 The `$post_type` argument was added.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $timezone  Optional. The timezone for the timestamp. Accepts 'server', 'blog', or 'gmt'.</span>&nbsp;</div></li><li><div><span class="comment"> *                          'server' uses the server's internal timezone.</span>&nbsp;</div></li><li><div><span class="comment"> *                          'blog' uses the `post_modified` field, which proxies to the timezone set for the site.</span>&nbsp;</div></li><li><div><span class="comment"> *                          'gmt' uses the `post_modified_gmt` field.</span>&nbsp;</div></li><li><div><span class="comment"> *                          Default 'server'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Optional. The post type to check. Default 'any'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string The date of the last post.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_lastpostdate( $timezone = 'server', $post_type = 'any' ) {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the date the last post was published.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $date     Date the last post was published.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $timezone Location to use for getting the post published date.</span>&nbsp;</div></li><li><div><span class="comment">   *                         See get_lastpostdate() for accepted `$timezone` values.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_lastpostdate', _get_last_post_time( $timezone, 'date', $post_type ), $timezone );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get the timestamp of the last time any post was modified.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The server timezone is the default and is the difference between GMT and</span>&nbsp;</div></li><li><div><span class="comment"> * server time. The 'blog' value is just when the last post was modified. The</span>&nbsp;</div></li><li><div><span class="comment"> * 'gmt' is when the last post was modified in GMT time.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.2.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 The `$post_type` argument was added.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $timezone  Optional. The timezone for the timestamp. See get_lastpostdate()</span>&nbsp;</div></li><li><div><span class="comment"> *                          for information on accepted values.</span>&nbsp;</div></li><li><div><span class="comment"> *                          Default 'server'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Optional. The post type to check. Default 'any'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string The timestamp.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_lastpostmodified( $timezone = 'server', $post_type = 'any' ) {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Pre-filter the return value of get_lastpostmodified() before the query is run.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $lastpostmodified Date the last post was modified.</span>&nbsp;</div></li><li><div><span class="comment">   *                                 Returning anything other than false will short-circuit the function.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $timezone         Location to use for getting the post modified date.</span>&nbsp;</div></li><li><div><span class="comment">   *                                 See get_lastpostdate() for accepted `$timezone` values.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $post_type        The post type to check.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $lastpostmodified = apply_filters( 'pre_get_lastpostmodified', false, $timezone, $post_type );&nbsp;</div></li><li><div>  if ( false !== $lastpostmodified ) {&nbsp;</div></li><li><div>      return $lastpostmodified;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $lastpostmodified = _get_last_post_time( $timezone, 'modified', $post_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $lastpostdate = get_lastpostdate($timezone);&nbsp;</div></li><li><div>  if ( $lastpostdate &gt; $lastpostmodified ) {&nbsp;</div></li><li><div>      $lastpostmodified = $lastpostdate;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filters the date the last post was modified.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $lastpostmodified Date the last post was modified.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $timezone         Location to use for getting the post modified date.</span>&nbsp;</div></li><li><div><span class="comment">   *                                 See get_lastpostdate() for accepted `$timezone` values.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  return apply_filters( 'get_lastpostmodified', $lastpostmodified, $timezone );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get the timestamp of the last time any post was modified or published.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.4.0 The `$post_type` argument was added.</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $timezone  The timezone for the timestamp. See get_lastpostdate().</span>&nbsp;</div></li><li><div><span class="comment"> *                          for information on accepted values.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $field     Post field to check. Accepts 'date' or 'modified'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type Optional. The post type to check. Default 'any'.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|false The timestamp.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _get_last_post_time( $timezone, $field, $post_type = 'any' ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! in_array( $field, array( 'date', 'modified' ) ) ) {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $timezone = strtolower( $timezone );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $key = &quot;lastpost{$field}:$timezone&quot;;&nbsp;</div></li><li><div>  if ( 'any' !== $post_type ) {&nbsp;</div></li><li><div>      $key .= ':' . sanitize_key( $post_type );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $date = wp_cache_get( $key, 'timeinfo' );&nbsp;</div></li><li><div>  if ( false !== $date ) {&nbsp;</div></li><li><div>      return $date;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'any' === $post_type ) {&nbsp;</div></li><li><div>      $post_types = get_post_types( array( 'public' =&gt; true ) );&nbsp;</div></li><li><div>      array_walk( $post_types, array( $wpdb, 'escape_by_ref' ) );&nbsp;</div></li><li><div>      $post_types = &quot;'&quot; . implode( &quot;', '&quot;, $post_types ) . &quot;'&quot;;&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $post_types = &quot;'&quot; . sanitize_key( $post_type ) . &quot;'&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  switch ( $timezone ) {&nbsp;</div></li><li><div>      case 'gmt':&nbsp;</div></li><li><div>          $date = $wpdb-&gt;get_var(&quot;SELECT post_{$field}_gmt FROM $wpdb-&gt;posts WHERE post_status = 'publish' AND post_type IN ({$post_types}) ORDER BY post_{$field}_gmt DESC LIMIT 1&quot;);&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      case 'blog':&nbsp;</div></li><li><div>          $date = $wpdb-&gt;get_var(&quot;SELECT post_{$field} FROM $wpdb-&gt;posts WHERE post_status = 'publish' AND post_type IN ({$post_types}) ORDER BY post_{$field}_gmt DESC LIMIT 1&quot;);&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>      case 'server':&nbsp;</div></li><li><div>          $add_seconds_server = date( 'Z' );&nbsp;</div></li><li><div>          $date = $wpdb-&gt;get_var(&quot;SELECT DATE_ADD(post_{$field}_gmt, INTERVAL '$add_seconds_server' SECOND) FROM $wpdb-&gt;posts WHERE post_status = 'publish' AND post_type IN ({$post_types}) ORDER BY post_{$field}_gmt DESC LIMIT 1&quot;);&nbsp;</div></li><li><div>          break;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $date ) {&nbsp;</div></li><li><div>      wp_cache_set( $key, $date, 'timeinfo' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $date;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates posts in cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.1</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $posts Array of post objects, passed by reference.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_post_cache( &$posts ) {&nbsp;</div></li><li><div>  if ( ! $posts )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $posts as $post )&nbsp;</div></li><li><div>      wp_cache_add( $post-&gt;ID, $post, 'posts' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Will clean the post in the cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Cleaning means delete from the cache of the post. Will call to clean the term</span>&nbsp;</div></li><li><div><span class="comment"> * object cache associated with the post ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function not run if $_wp_suspend_cache_invalidation is not empty. See</span>&nbsp;</div></li><li><div><span class="comment"> * wp_suspend_cache_invalidation().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global bool $_wp_suspend_cache_invalidation</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Post ID or post object to remove from the cache.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function clean_post_cache( $post ) {&nbsp;</div></li><li><div>  global $_wp_suspend_cache_invalidation;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $_wp_suspend_cache_invalidation ) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>  if ( empty( $post ) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_delete( $post-&gt;ID, 'posts' );&nbsp;</div></li><li><div>  wp_cache_delete( $post-&gt;ID, 'post_meta' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  clean_object_term_cache( $post-&gt;ID, $post-&gt;post_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_delete( 'wp_get_archives', 'general' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires immediately after the given post's cache is cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int     $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">   * @param WP_Post $post    Post object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'clean_post_cache', $post-&gt;ID, $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( 'page' == $post-&gt;post_type ) {&nbsp;</div></li><li><div>      wp_cache_delete( 'all_page_ids', 'posts' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after the given page's cache is cleaned.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'clean_page_cache', $post-&gt;ID );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_set( 'last_changed', microtime(), 'posts' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Call major cache updating functions for list of Post objects.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $posts             Array of Post objects</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_type         Optional. Post type. Default 'post'.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $update_term_cache Optional. Whether to update the term cache. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $update_meta_cache Optional. Whether to update the meta cache. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_post_caches( &$posts, $post_type = 'post', $update_term_cache = true, $update_meta_cache = true ) {&nbsp;</div></li><li><div>  <span class="comment">// No point in doing all this work if we didn't match any posts.</span>&nbsp;</div></li><li><div>  if ( !$posts )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  update_post_cache($posts);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post_ids = array();&nbsp;</div></li><li><div>  foreach ( $posts as $post )&nbsp;</div></li><li><div>      $post_ids[] = $post-&gt;ID;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $post_type )&nbsp;</div></li><li><div>      $post_type = 'any';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $update_term_cache ) {&nbsp;</div></li><li><div>      if ( is_array($post_type) ) {&nbsp;</div></li><li><div>          $ptypes = $post_type;&nbsp;</div></li><li><div>      } elseif ( 'any' == $post_type ) {&nbsp;</div></li><li><div>          $ptypes = array();&nbsp;</div></li><li><div>          <span class="comment">// Just use the post_types in the supplied posts.</span>&nbsp;</div></li><li><div>          foreach ( $posts as $post ) {&nbsp;</div></li><li><div>              $ptypes[] = $post-&gt;post_type;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $ptypes = array_unique($ptypes);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $ptypes = array($post_type);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty($ptypes) )&nbsp;</div></li><li><div>          update_object_term_cache($post_ids, $ptypes);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $update_meta_cache )&nbsp;</div></li><li><div>      update_postmeta_cache($post_ids);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Updates metadata cache for list of post IDs.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Performs SQL query to retrieve the metadata for the post IDs and updates the</span>&nbsp;</div></li><li><div><span class="comment"> * metadata cache for the posts. Therefore, the functions, which call this</span>&nbsp;</div></li><li><div><span class="comment"> * function, do not need to perform SQL queries on their own.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $post_ids List of post IDs.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|false Returns false if there is nothing to update or an array</span>&nbsp;</div></li><li><div><span class="comment"> *                     of metadata.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function update_postmeta_cache( $post_ids ) {&nbsp;</div></li><li><div>  return update_meta_cache('post', $post_ids);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Will clean the attachment in the cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Cleaning means delete from the cache. Optionally will clean the term</span>&nbsp;</div></li><li><div><span class="comment"> * object cache associated with the attachment ID.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function will not run if $_wp_suspend_cache_invalidation is not empty.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global bool $_wp_suspend_cache_invalidation</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int  $id          The attachment ID in the cache to clean.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $clean_terms Optional. Whether to clean terms cache. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function clean_attachment_cache( $id, $clean_terms = false ) {&nbsp;</div></li><li><div>  global $_wp_suspend_cache_invalidation;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !empty($_wp_suspend_cache_invalidation) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $id = (int) $id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_cache_delete($id, 'posts');&nbsp;</div></li><li><div>  wp_cache_delete($id, 'post_meta');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $clean_terms )&nbsp;</div></li><li><div>      clean_object_term_cache($id, 'attachment');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires after the given attachment's cache is cleaned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $id Attachment ID.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'clean_attachment_cache', $id );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Hooks&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Hook for managing future post transitions to published.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_clear_scheduled_hook()</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string  $new_status New post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string  $old_status Previous post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post $post       Post object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _transition_post_status( $new_status, $old_status, $post ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $old_status != 'publish' && $new_status == 'publish' ) {&nbsp;</div></li><li><div>      <span class="comment">// Reset GUID if transitioning to publish and it is empty.</span>&nbsp;</div></li><li><div>      if ( '' == get_the_guid($post-&gt;ID) )&nbsp;</div></li><li><div>          $wpdb-&gt;update( $wpdb-&gt;posts, array( 'guid' =&gt; get_permalink( $post-&gt;ID ) ), array( 'ID' =&gt; $post-&gt;ID ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when a post's status is transitioned from private to published.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment">       * @deprecated 2.3.0 Use 'private_to_publish' instead.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action('private_to_published', $post-&gt;ID);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If published posts changed clear the lastpostmodified cache.</span>&nbsp;</div></li><li><div>  if ( 'publish' == $new_status || 'publish' == $old_status) {&nbsp;</div></li><li><div>      foreach ( array( 'server', 'gmt', 'blog' ) as $timezone ) {&nbsp;</div></li><li><div>          wp_cache_delete( &quot;lastpostmodified:$timezone&quot;, 'timeinfo' );&nbsp;</div></li><li><div>          wp_cache_delete( &quot;lastpostdate:$timezone&quot;, 'timeinfo' );&nbsp;</div></li><li><div>          wp_cache_delete( &quot;lastpostdate:$timezone:{$post-&gt;post_type}&quot;, 'timeinfo' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $new_status !== $old_status ) {&nbsp;</div></li><li><div>      wp_cache_delete( _count_posts_cache_key( $post-&gt;post_type ), 'counts' );&nbsp;</div></li><li><div>      wp_cache_delete( _count_posts_cache_key( $post-&gt;post_type, 'readable' ), 'counts' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Always clears the hook in case the post status bounced from future to draft.</span>&nbsp;</div></li><li><div>  wp_clear_scheduled_hook('publish_future_post', array( $post-&gt;ID ) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Hook used to schedule publication for a post marked for the future.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The $post properties used and must exist are 'ID' and 'post_date_gmt'.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int     $deprecated Not used. Can be set to null. Never implemented. Not marked</span>&nbsp;</div></li><li><div><span class="comment"> *                            as deprecated with _deprecated_argument() as it conflicts with</span>&nbsp;</div></li><li><div><span class="comment"> *                            wp_transition_post_status() and the default filter for _future_post_hook().</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post $post       Post object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _future_post_hook( $deprecated, $post ) {&nbsp;</div></li><li><div>  wp_clear_scheduled_hook( 'publish_future_post', array( $post-&gt;ID ) );&nbsp;</div></li><li><div>  wp_schedule_single_event( strtotime( get_gmt_from_date( $post-&gt;post_date ) . ' GMT') , 'publish_future_post', array( $post-&gt;ID ) );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Hook to schedule pings and enclosures when a post is published.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Uses XMLRPC_REQUEST and WP_IMPORTING constants.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_id The ID in the database table of the post being published.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _publish_post_hook( $post_id ) {&nbsp;</div></li><li><div>  if ( defined( 'XMLRPC_REQUEST' ) ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires when _publish_post_hook() is called during an XML-RPC request.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.1.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param int $post_id Post ID.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'xmlrpc_publish_post', $post_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( defined('WP_IMPORTING') )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( get_option('default_pingback_flag') )&nbsp;</div></li><li><div>      add_post_meta( $post_id, '_pingme', '1' );&nbsp;</div></li><li><div>  add_post_meta( $post_id, '_encloseme', '1' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  wp_schedule_single_event(time(), 'do_pings');&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Return the post's parent's post_ID</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_ID</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|false Post parent ID, otherwise false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_get_post_parent_id( $post_ID ) {&nbsp;</div></li><li><div>  $post = get_post( $post_ID );&nbsp;</div></li><li><div>  if ( !$post || is_wp_error( $post ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  return (int) $post-&gt;post_parent;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check the given subset of the post hierarchy for hierarchy loops.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Prevents loops from forming and breaks those that it finds. Attached</span>&nbsp;</div></li><li><div><span class="comment"> * to the {@see 'wp_insert_post_parent'} filter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see wp_find_hierarchy_loop()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_parent ID of the parent for the post we're checking.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int $post_ID     ID of the post we're checking.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int The new post_parent for the post, 0 otherwise.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_check_post_hierarchy_for_loops( $post_parent, $post_ID ) {&nbsp;</div></li><li><div>  <span class="comment">// Nothing fancy here - bail.</span>&nbsp;</div></li><li><div>  if ( !$post_parent )&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// New post can't cause a loop.</span>&nbsp;</div></li><li><div>  if ( empty( $post_ID ) )&nbsp;</div></li><li><div>      return $post_parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Can't be its own parent.</span>&nbsp;</div></li><li><div>  if ( $post_parent == $post_ID )&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Now look for larger loops.</span>&nbsp;</div></li><li><div>  if ( !$loop = wp_find_hierarchy_loop( 'wp_get_post_parent_id', $post_ID, $post_parent ) )&nbsp;</div></li><li><div>      return $post_parent; <span class="comment">// No loop</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Setting $post_parent to the given value causes a loop.</span>&nbsp;</div></li><li><div>  if ( isset( $loop[$post_ID] ) )&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// There's a loop, but it doesn't contain $post_ID. Break the loop.</span>&nbsp;</div></li><li><div>  foreach ( array_keys( $loop ) as $loop_member )&nbsp;</div></li><li><div>      wp_update_post( array( 'ID' =&gt; $loop_member, 'post_parent' =&gt; 0 ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $post_parent;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Set a post thumbnail.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post         Post ID or post object where thumbnail should be attached.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int         $thumbnail_id Thumbnail to attach.</span>&nbsp;</div></li><li><div><span class="comment"> * @return int|bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function set_post_thumbnail( $post, $thumbnail_id ) {&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>  $thumbnail_id = absint( $thumbnail_id );&nbsp;</div></li><li><div>  if ( $post && $thumbnail_id && get_post( $thumbnail_id ) ) {&nbsp;</div></li><li><div>      if ( wp_get_attachment_image( $thumbnail_id, 'thumbnail' ) )&nbsp;</div></li><li><div>          return update_post_meta( $post-&gt;ID, '_thumbnail_id', $thumbnail_id );&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          return delete_post_meta( $post-&gt;ID, '_thumbnail_id' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove a post thumbnail.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param int|WP_Post $post Post ID or post object where thumbnail should be removed from.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True on success, false on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function delete_post_thumbnail( $post ) {&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>  if ( $post )&nbsp;</div></li><li><div>      return delete_post_meta( $post-&gt;ID, '_thumbnail_id' );&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Delete auto-drafts for new posts that are &gt; 7 days old.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.4.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_delete_auto_drafts() {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Cleanup old auto-drafts more than 7 days old.</span>&nbsp;</div></li><li><div>  $old_posts = $wpdb-&gt;get_col( &quot;SELECT ID FROM $wpdb-&gt;posts WHERE post_status = 'auto-draft' AND DATE_SUB( NOW(), INTERVAL 7 DAY ) &gt; post_date&quot; );&nbsp;</div></li><li><div>  foreach ( (array) $old_posts as $delete ) {&nbsp;</div></li><li><div>      <span class="comment">// Force delete.</span>&nbsp;</div></li><li><div>      wp_delete_post( $delete, true );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Queues posts for lazy-loading of term meta.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $posts Array of WP_Post objects.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_queue_posts_for_term_meta_lazyload( $posts ) {&nbsp;</div></li><li><div>  $post_type_taxonomies = $term_ids = array();&nbsp;</div></li><li><div>  foreach ( $posts as $post ) {&nbsp;</div></li><li><div>      if ( ! ( $post instanceof WP_Post ) ) {&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset( $post_type_taxonomies[ $post-&gt;post_type ] ) ) {&nbsp;</div></li><li><div>          $post_type_taxonomies[ $post-&gt;post_type ] = get_object_taxonomies( $post-&gt;post_type );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $post_type_taxonomies[ $post-&gt;post_type ] as $taxonomy ) {&nbsp;</div></li><li><div>          <span class="comment">// Term cache should already be primed by `update_post_term_cache()`.</span>&nbsp;</div></li><li><div>          $terms = get_object_term_cache( $post-&gt;ID, $taxonomy );&nbsp;</div></li><li><div>          if ( false !== $terms ) {&nbsp;</div></li><li><div>              foreach ( $terms as $term ) {&nbsp;</div></li><li><div>                  if ( ! isset( $term_ids[ $term-&gt;term_id ] ) ) {&nbsp;</div></li><li><div>                      $term_ids[] = $term-&gt;term_id;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $term_ids ) {&nbsp;</div></li><li><div>      $lazyloader = wp_metadata_lazyloader();&nbsp;</div></li><li><div>      $lazyloader-&gt;queue_objects( 'term', $term_ids );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Update the custom taxonomies' term counts when a post's status is changed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * For example, default posts term counts (for custom taxonomies) don't include</span>&nbsp;</div></li><li><div><span class="comment"> * private / draft posts.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.3.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string  $new_status New post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string  $old_status Old post status.</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post $post       Post object.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _update_term_count_on_transition_post_status( $new_status, $old_status, $post ) {&nbsp;</div></li><li><div>  <span class="comment">// Update counts for the post's terms.</span>&nbsp;</div></li><li><div>  foreach ( (array) get_object_taxonomies( $post-&gt;post_type ) as $taxonomy ) {&nbsp;</div></li><li><div>      $tt_ids = wp_get_object_terms( $post-&gt;ID, $taxonomy, array( 'fields' =&gt; 'tt_ids' ) );&nbsp;</div></li><li><div>      wp_update_term_count( $tt_ids, $taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds any posts from the given ids to the cache that do not already exist in cache</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.4.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @see update_post_caches()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $ids               ID list.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $update_term_cache Optional. Whether to update the term cache. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool  $update_meta_cache Optional. Whether to update the meta cache. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _prime_post_caches( $ids, $update_term_cache = true, $update_meta_cache = true ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $non_cached_ids = _get_non_cached_ids( $ids, 'posts' );&nbsp;</div></li><li><div>  if ( !empty( $non_cached_ids ) ) {&nbsp;</div></li><li><div>      $fresh_posts = $wpdb-&gt;get_results( sprintf( &quot;SELECT $wpdb-&gt;posts.* FROM $wpdb-&gt;posts WHERE ID IN (%s)&quot;, join( &quot;, &quot;, $non_cached_ids ) ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      update_post_caches( $fresh_posts, 'any', $update_term_cache, $update_meta_cache );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds a suffix if any trashed posts have a given slug.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Store its desired (i.e. current) slug so it can try to reclaim it</span>&nbsp;</div></li><li><div><span class="comment"> * if the post is untrashed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * For internal use.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_name Slug.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $post_ID   Optional. Post ID that should be ignored. Default 0.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_add_trashed_suffix_to_post_name_for_trashed_posts( $post_name, $post_ID = 0 ) {&nbsp;</div></li><li><div>  $trashed_posts_with_desired_slug = get_posts( array(&nbsp;</div></li><li><div>      'name' =&gt; $post_name, &nbsp;</div></li><li><div>      'post_status' =&gt; 'trash', &nbsp;</div></li><li><div>      'post_type' =&gt; 'any', &nbsp;</div></li><li><div>      'nopaging' =&gt; true, &nbsp;</div></li><li><div>      'post__not_in' =&gt; array( $post_ID )&nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty( $trashed_posts_with_desired_slug ) ) {&nbsp;</div></li><li><div>      foreach ( $trashed_posts_with_desired_slug as $_post ) {&nbsp;</div></li><li><div>          wp_add_trashed_suffix_to_post_name_for_post( $_post );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds a trashed suffix for a given post.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Store its desired (i.e. current) slug so it can try to reclaim it</span>&nbsp;</div></li><li><div><span class="comment"> * if the post is untrashed.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * For internal use.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param WP_Post $post The post.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string New slug for the post.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_add_trashed_suffix_to_post_name_for_post( $post ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $post = get_post( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( '__trashed' === substr( $post-&gt;post_name, -9 ) ) {&nbsp;</div></li><li><div>      return $post-&gt;post_name;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  add_post_meta( $post-&gt;ID, '_wp_desired_post_slug', $post-&gt;post_name );&nbsp;</div></li><li><div>  $post_name = _truncate_post_slug( $post-&gt;post_name, 191 ) . '__trashed';&nbsp;</div></li><li><div>  $wpdb-&gt;update( $wpdb-&gt;posts, array( 'post_name' =&gt; $post_name ), array( 'ID' =&gt; $post-&gt;ID ) );&nbsp;</div></li><li><div>  clean_post_cache( $post-&gt;ID );&nbsp;</div></li><li><div>  return $post_name;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Filter the SQL clauses of an attachment query to include filenames.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 4.7.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global wpdb $wpdb WordPress database abstraction object.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $clauses An array including WHERE, GROUP BY, JOIN, ORDER BY, </span>&nbsp;</div></li><li><div><span class="comment"> *                       DISTINCT, fields (SELECT), and LIMITS clauses.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array The modified clauses.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _filter_query_attachment_filenames( $clauses ) {&nbsp;</div></li><li><div>  global $wpdb;&nbsp;</div></li><li><div>  remove_filter( 'posts_clauses', __FUNCTION__ );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Add a LEFT JOIN of the postmeta table so we don't trample existing JOINs.</span>&nbsp;</div></li><li><div>  $clauses['join'] .= &quot; LEFT JOIN {$wpdb-&gt;postmeta} AS sq1 ON ( {$wpdb-&gt;posts}.ID = sq1.post_id AND sq1.meta_key = '_wp_attached_file' )&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $clauses['groupby'] = &quot;{$wpdb-&gt;posts}.ID&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $clauses['where'] = preg_replace(&nbsp;</div></li><li><div>      &quot;/\({$wpdb-&gt;posts}.post_content (NOT LIKE|LIKE) (\'[^']+\')\)/&quot;, &nbsp;</div></li><li><div>      &quot;$0 OR ( sq1.meta_value $1 $2 )&quot;, &nbsp;</div></li><li><div>      $clauses['where'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $clauses;&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>file</li><li><span></span></li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2021 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>