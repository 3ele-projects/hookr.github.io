<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="wordpress" data-version="4.7.4" data-type="file" data-id="4508"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp-admin-includes-plugin | file | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, wordpress, 4.7.4" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.10"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=87c1676b6953e6377cf331c6aeb9a93e' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.10' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/wp-admin-includes-plugin/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-admin-includes-plugin%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fwp-admin-includes-plugin%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-file-wp-admin-includes-plugin","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp-admin-includes-plugin" class="blog single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="http://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp-admin-includes-plugin</span><meta property="position" content="3"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="http://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="http://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="http://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="http://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="" data-id="class" data-count="351"><a href="http://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="http://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/wp-admin/includes/plugin.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * WordPress Plugin Administration API</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage Administration</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Parses the plugin contents to retrieve plugin's metadata.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The metadata of the plugin's data searches for the following in the plugin's</span>&nbsp;</div></li><li><div><span class="comment"> * header. All plugin data must be on its own line. For plugin description, it</span>&nbsp;</div></li><li><div><span class="comment"> * must not have any newlines or only parts of the description will be displayed</span>&nbsp;</div></li><li><div><span class="comment"> * and the same goes for the plugin data. The below is formatted for printing.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     /**</span>&nbsp;</div></li><li><div><span class="comment"> *     Plugin Name: Name of Plugin</span>&nbsp;</div></li><li><div><span class="comment"> *     Plugin URI: Link to plugin information</span>&nbsp;</div></li><li><div><span class="comment"> *     Description: Plugin Description</span>&nbsp;</div></li><li><div><span class="comment"> *     Author: Plugin author's name</span>&nbsp;</div></li><li><div><span class="comment"> *     Author URI: Link to the author's web site</span>&nbsp;</div></li><li><div><span class="comment"> *     Version: Must be set in the plugin for WordPress 2.3+</span>&nbsp;</div></li><li><div><span class="comment"> *     Text Domain: Optional. Unique identifier, should be same as the one used in</span>&nbsp;</div></li><li><div><span class="comment"> *            load_plugin_textdomain()</span>&nbsp;</div></li><li><div><span class="comment"> *     Domain Path: Optional. Only useful if the translations are located in a</span>&nbsp;</div></li><li><div><span class="comment"> *            folder above the plugin's base path. For example, if .mo files are</span>&nbsp;</div></li><li><div><span class="comment"> *            located in the locale folder then Domain Path will be &quot;/locale/&quot; and</span>&nbsp;</div></li><li><div><span class="comment"> *            must have the first slash. Defaults to the base folder the plugin is</span>&nbsp;</div></li><li><div><span class="comment"> *            located in.</span>&nbsp;</div></li><li><div><span class="comment"> *     Network: Optional. Specify &quot;Network: true&quot; to require that a plugin is activated</span>&nbsp;</div></li><li><div><span class="comment"> *            across all sites in an installation. This will prevent a plugin from being</span>&nbsp;</div></li><li><div><span class="comment"> *            activated on a single site when Multisite is enabled.</span>&nbsp;</div></li><li><div><span class="comment"> *      * / # Remove the space to close comment</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Some users have issues with opening large files and manipulating the contents</span>&nbsp;</div></li><li><div><span class="comment"> * for want is usually the first 1kiB or 2kiB. This function stops pulling in</span>&nbsp;</div></li><li><div><span class="comment"> * the plugin contents when it has all of the required plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The first 8kiB of the file will be pulled in and if the plugin data is not</span>&nbsp;</div></li><li><div><span class="comment"> * within that first 8kiB, then the plugin author should correct their plugin</span>&nbsp;</div></li><li><div><span class="comment"> * and move the plugin data headers to the top.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The plugin file is assumed to have permissions to allow for scripts to read</span>&nbsp;</div></li><li><div><span class="comment"> * the file. This is not checked however and the file is only opened for</span>&nbsp;</div></li><li><div><span class="comment"> * reading.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin_file Path to the plugin file</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $markup      Optional. If the returned data should have HTML markup applied.</span>&nbsp;</div></li><li><div><span class="comment"> *                            Default true.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $translate   Optional. If the returned data should be translated. Default true.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array {</span>&nbsp;</div></li><li><div><span class="comment"> *     Plugin data. Values will be empty if not supplied by the plugin.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $Name        Name of the plugin. Should be unique.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $Title       Title of the plugin and link to the plugin's site (if set).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $Description Plugin description.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $Author      Author's name.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $AuthorURI   Author's website address (if set).</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $Version     Plugin version.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $TextDomain  Plugin textdomain.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type string $DomainPath  Plugins relative directory path to .mo files.</span>&nbsp;</div></li><li><div><span class="comment"> *     @type bool   $Network     Whether the plugin can only be activated network-wide.</span>&nbsp;</div></li><li><div><span class="comment"> * }</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_plugin_data( $plugin_file, $markup = true, $translate = true ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $default_headers = array(&nbsp;</div></li><li><div>      'Name' =&gt; 'Plugin Name', &nbsp;</div></li><li><div>      'PluginURI' =&gt; 'Plugin URI', &nbsp;</div></li><li><div>      'Version' =&gt; 'Version', &nbsp;</div></li><li><div>      'Description' =&gt; 'Description', &nbsp;</div></li><li><div>      'Author' =&gt; 'Author', &nbsp;</div></li><li><div>      'AuthorURI' =&gt; 'Author URI', &nbsp;</div></li><li><div>      'TextDomain' =&gt; 'Text Domain', &nbsp;</div></li><li><div>      'DomainPath' =&gt; 'Domain Path', &nbsp;</div></li><li><div>      'Network' =&gt; 'Network', &nbsp;</div></li><li><div>      <span class="comment">// Site Wide Only is deprecated in favor of Network.</span>&nbsp;</div></li><li><div>      '_sitewide' =&gt; 'Site Wide Only', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugin_data = get_file_data( $plugin_file, $default_headers, 'plugin' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Site Wide Only is the old header for Network</span>&nbsp;</div></li><li><div>  if ( ! $plugin_data['Network'] && $plugin_data['_sitewide'] ) {&nbsp;</div></li><li><div>      <span class="comment">/** translators: 1: Site Wide Only: true, 2: Network: true */</span>&nbsp;</div></li><li><div>      _deprecated_argument( __FUNCTION__, '3.0.0', sprintf( __( 'The %1$s plugin header is deprecated. Use %2$s instead.' ), '&lt;code&gt;Site Wide Only: true&lt;/code&gt;', '&lt;code&gt;Network: true&lt;/code&gt;' ) );&nbsp;</div></li><li><div>      $plugin_data['Network'] = $plugin_data['_sitewide'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $plugin_data['Network'] = ( 'true' == strtolower( $plugin_data['Network'] ) );&nbsp;</div></li><li><div>  unset( $plugin_data['_sitewide'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// If no text domain is defined fall back to the plugin slug.</span>&nbsp;</div></li><li><div>  if ( ! $plugin_data['TextDomain'] ) {&nbsp;</div></li><li><div>      $plugin_slug = dirname( plugin_basename( $plugin_file ) );&nbsp;</div></li><li><div>      if ( '.' !== $plugin_slug && false === strpos( $plugin_slug, '/' ) ) {&nbsp;</div></li><li><div>          $plugin_data['TextDomain'] = $plugin_slug;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $markup || $translate ) {&nbsp;</div></li><li><div>      $plugin_data = _get_plugin_data_markup_translate( $plugin_file, $plugin_data, $markup, $translate );&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $plugin_data['Title'] = $plugin_data['Name'];&nbsp;</div></li><li><div>      $plugin_data['AuthorName'] = $plugin_data['Author'];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $plugin_data;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Sanitizes plugin data, optionally adds markup, optionally translates.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> * @see get_plugin_data()</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _get_plugin_data_markup_translate( $plugin_file, $plugin_data, $markup = true, $translate = true ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Sanitize the plugin filename to a WP_PLUGIN_DIR relative path</span>&nbsp;</div></li><li><div>  $plugin_file = plugin_basename( $plugin_file );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Translate fields</span>&nbsp;</div></li><li><div>  if ( $translate ) {&nbsp;</div></li><li><div>      if ( $textdomain = $plugin_data['TextDomain'] ) {&nbsp;</div></li><li><div>          if ( ! is_textdomain_loaded( $textdomain ) ) {&nbsp;</div></li><li><div>              if ( $plugin_data['DomainPath'] ) {&nbsp;</div></li><li><div>                  load_plugin_textdomain( $textdomain, false, dirname( $plugin_file ) . $plugin_data['DomainPath'] );&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  load_plugin_textdomain( $textdomain, false, dirname( $plugin_file ) );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } elseif ( 'hello.php' == basename( $plugin_file ) ) {&nbsp;</div></li><li><div>          $textdomain = 'default';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( $textdomain ) {&nbsp;</div></li><li><div>          foreach ( array( 'Name', 'PluginURI', 'Description', 'Author', 'AuthorURI', 'Version' ) as $field )&nbsp;</div></li><li><div>              $plugin_data[ $field ] = translate( $plugin_data[ $field ], $textdomain );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Sanitize fields</span>&nbsp;</div></li><li><div>  $allowed_tags = $allowed_tags_in_links = array(&nbsp;</div></li><li><div>      'abbr' =&gt; array( 'title' =&gt; true ), &nbsp;</div></li><li><div>      'acronym' =&gt; array( 'title' =&gt; true ), &nbsp;</div></li><li><div>      'code' =&gt; true, &nbsp;</div></li><li><div>      'em' =&gt; true, &nbsp;</div></li><li><div>      'strong' =&gt; true, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  $allowed_tags['a'] = array( 'href' =&gt; true, 'title' =&gt; true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Name is marked up inside &lt;a&gt; tags. Don't allow these.</span>&nbsp;</div></li><li><div>  <span class="comment">// Author is too, but some plugins have used &lt;a&gt; here (omitting Author URI).</span>&nbsp;</div></li><li><div>  $plugin_data['Name'] = wp_kses( $plugin_data['Name'], $allowed_tags_in_links );&nbsp;</div></li><li><div>  $plugin_data['Author'] = wp_kses( $plugin_data['Author'], $allowed_tags );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugin_data['Description'] = wp_kses( $plugin_data['Description'], $allowed_tags );&nbsp;</div></li><li><div>  $plugin_data['Version'] = wp_kses( $plugin_data['Version'], $allowed_tags );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugin_data['PluginURI'] = esc_url( $plugin_data['PluginURI'] );&nbsp;</div></li><li><div>  $plugin_data['AuthorURI'] = esc_url( $plugin_data['AuthorURI'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugin_data['Title'] = $plugin_data['Name'];&nbsp;</div></li><li><div>  $plugin_data['AuthorName'] = $plugin_data['Author'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Apply markup</span>&nbsp;</div></li><li><div>  if ( $markup ) {&nbsp;</div></li><li><div>      if ( $plugin_data['PluginURI'] && $plugin_data['Name'] )&nbsp;</div></li><li><div>          $plugin_data['Title'] = '&lt;a href=&quot;' . $plugin_data['PluginURI'] . '&quot;&gt;' . $plugin_data['Name'] . '&lt;/a&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $plugin_data['AuthorURI'] && $plugin_data['Author'] )&nbsp;</div></li><li><div>          $plugin_data['Author'] = '&lt;a href=&quot;' . $plugin_data['AuthorURI'] . '&quot;&gt;' . $plugin_data['Author'] . '&lt;/a&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $plugin_data['Description'] = wptexturize( $plugin_data['Description'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $plugin_data['Author'] )&nbsp;</div></li><li><div>          $plugin_data['Description'] .= ' &lt;cite&gt;' . sprintf( __('By %s.'), $plugin_data['Author'] ) . '&lt;/cite&gt;';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $plugin_data;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get a list of a plugin's files.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.8.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Plugin ID</span>&nbsp;</div></li><li><div><span class="comment"> * @return array List of files relative to the plugin root.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_plugin_files($plugin) {&nbsp;</div></li><li><div>  $plugin_file = WP_PLUGIN_DIR . '/' . $plugin;&nbsp;</div></li><li><div>  $dir = dirname($plugin_file);&nbsp;</div></li><li><div>  $plugin_files = array($plugin);&nbsp;</div></li><li><div>  if ( is_dir($dir) && $dir != WP_PLUGIN_DIR ) {&nbsp;</div></li><li><div>      $plugins_dir = @ opendir( $dir );&nbsp;</div></li><li><div>      if ( $plugins_dir ) {&nbsp;</div></li><li><div>          while (($file = readdir( $plugins_dir ) ) !== false ) {&nbsp;</div></li><li><div>              if ( substr($file, 0, 1) == '.' )&nbsp;</div></li><li><div>                  continue;&nbsp;</div></li><li><div>              if ( is_dir( $dir . '/' . $file ) ) {&nbsp;</div></li><li><div>                  $plugins_subdir = @ opendir( $dir . '/' . $file );&nbsp;</div></li><li><div>                  if ( $plugins_subdir ) {&nbsp;</div></li><li><div>                      while (($subfile = readdir( $plugins_subdir ) ) !== false ) {&nbsp;</div></li><li><div>                          if ( substr($subfile, 0, 1) == '.' )&nbsp;</div></li><li><div>                              continue;&nbsp;</div></li><li><div>                          $plugin_files[] = plugin_basename(&quot;$dir/$file/$subfile&quot;);&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      @closedir( $plugins_subdir );&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  if ( plugin_basename(&quot;$dir/$file&quot;) != $plugin )&nbsp;</div></li><li><div>                      $plugin_files[] = plugin_basename(&quot;$dir/$file&quot;);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          @closedir( $plugins_dir );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $plugin_files;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check the plugins directory and retrieve all plugin files with plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * WordPress only supports plugin files in the base plugins directory</span>&nbsp;</div></li><li><div><span class="comment"> * (wp-content/plugins) and in one directory above the plugins directory</span>&nbsp;</div></li><li><div><span class="comment"> * (wp-content/plugins/my-plugin). The file it looks for has the plugin data</span>&nbsp;</div></li><li><div><span class="comment"> * and must be found in those two locations. It is recommended to keep your</span>&nbsp;</div></li><li><div><span class="comment"> * plugin files in their own directories.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The file with the plugin data is the file that will be included and therefore</span>&nbsp;</div></li><li><div><span class="comment"> * needs to have the main execution for the plugin. This does not mean</span>&nbsp;</div></li><li><div><span class="comment"> * everything must be contained in the file and it is recommended that the file</span>&nbsp;</div></li><li><div><span class="comment"> * be split for maintainability. Keep everything in one file for extreme</span>&nbsp;</div></li><li><div><span class="comment"> * optimization purposes.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 1.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin_folder Optional. Relative path to single plugin folder.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Key is the plugin file path and the value is an array of the plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_plugins($plugin_folder = '') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! $cache_plugins = wp_cache_get('plugins', 'plugins') )&nbsp;</div></li><li><div>      $cache_plugins = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset($cache_plugins[ $plugin_folder ]) )&nbsp;</div></li><li><div>      return $cache_plugins[ $plugin_folder ];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $wp_plugins = array ();&nbsp;</div></li><li><div>  $plugin_root = WP_PLUGIN_DIR;&nbsp;</div></li><li><div>  if ( !empty($plugin_folder) )&nbsp;</div></li><li><div>      $plugin_root .= $plugin_folder;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Files in wp-content/plugins directory</span>&nbsp;</div></li><li><div>  $plugins_dir = @ opendir( $plugin_root);&nbsp;</div></li><li><div>  $plugin_files = array();&nbsp;</div></li><li><div>  if ( $plugins_dir ) {&nbsp;</div></li><li><div>      while (($file = readdir( $plugins_dir ) ) !== false ) {&nbsp;</div></li><li><div>          if ( substr($file, 0, 1) == '.' )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          if ( is_dir( $plugin_root.'/'.$file ) ) {&nbsp;</div></li><li><div>              $plugins_subdir = @ opendir( $plugin_root.'/'.$file );&nbsp;</div></li><li><div>              if ( $plugins_subdir ) {&nbsp;</div></li><li><div>                  while (($subfile = readdir( $plugins_subdir ) ) !== false ) {&nbsp;</div></li><li><div>                      if ( substr($subfile, 0, 1) == '.' )&nbsp;</div></li><li><div>                          continue;&nbsp;</div></li><li><div>                      if ( substr($subfile, -4) == '.php' )&nbsp;</div></li><li><div>                          $plugin_files[] = &quot;$file/$subfile&quot;;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  closedir( $plugins_subdir );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              if ( substr($file, -4) == '.php' )&nbsp;</div></li><li><div>                  $plugin_files[] = $file;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      closedir( $plugins_dir );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($plugin_files) )&nbsp;</div></li><li><div>      return $wp_plugins;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $plugin_files as $plugin_file ) {&nbsp;</div></li><li><div>      if ( !is_readable( &quot;$plugin_root/$plugin_file&quot; ) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $plugin_data = get_plugin_data( &quot;$plugin_root/$plugin_file&quot;, false, false ); <span class="comment"><span class="comment"><span class="comment">//Do not apply markup/translate as it'll be cached.</span></span></span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty ( $plugin_data['Name'] ) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $wp_plugins[plugin_basename( $plugin_file )] = $plugin_data;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  uasort( $wp_plugins, '_sort_uname_callback' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $cache_plugins[ $plugin_folder ] = $wp_plugins;&nbsp;</div></li><li><div>  wp_cache_set('plugins', $cache_plugins, 'plugins');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $wp_plugins;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check the mu-plugins directory and retrieve all mu-plugin files with any plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * WordPress only includes mu-plugin files in the base mu-plugins directory (wp-content/mu-plugins).</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Key is the mu-plugin file path and the value is an array of the mu-plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_mu_plugins() {&nbsp;</div></li><li><div>  $wp_plugins = array();&nbsp;</div></li><li><div>  <span class="comment">// Files in wp-content/mu-plugins directory</span>&nbsp;</div></li><li><div>  $plugin_files = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_dir( WPMU_PLUGIN_DIR ) )&nbsp;</div></li><li><div>      return $wp_plugins;&nbsp;</div></li><li><div>  if ( $plugins_dir = @ opendir( WPMU_PLUGIN_DIR ) ) {&nbsp;</div></li><li><div>      while ( ( $file = readdir( $plugins_dir ) ) !== false ) {&nbsp;</div></li><li><div>          if ( substr( $file, -4 ) == '.php' )&nbsp;</div></li><li><div>              $plugin_files[] = $file;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      return $wp_plugins;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  @closedir( $plugins_dir );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($plugin_files) )&nbsp;</div></li><li><div>      return $wp_plugins;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $plugin_files as $plugin_file ) {&nbsp;</div></li><li><div>      if ( !is_readable( WPMU_PLUGIN_DIR . &quot;/$plugin_file&quot; ) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $plugin_data = get_plugin_data( WPMU_PLUGIN_DIR . &quot;/$plugin_file&quot;, false, false ); <span class="comment"><span class="comment"><span class="comment">//Do not apply markup/translate as it'll be cached.</span></span></span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty ( $plugin_data['Name'] ) )&nbsp;</div></li><li><div>          $plugin_data['Name'] = $plugin_file;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $wp_plugins[ $plugin_file ] = $plugin_data;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $wp_plugins['index.php'] ) && filesize( WPMU_PLUGIN_DIR . '/index.php') &lt;= 30 ) <span class="comment">// silence is golden</span>&nbsp;</div></li><li><div>      unset( $wp_plugins['index.php'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  uasort( $wp_plugins, '_sort_uname_callback' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $wp_plugins;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Callback to sort array by a 'Name' key.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> * @access private</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _sort_uname_callback( $a, $b ) {&nbsp;</div></li><li><div>  return strnatcasecmp( $a['Name'], $b['Name'] );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check the wp-content directory and retrieve all drop-ins with any plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Key is the file path and the value is an array of the plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_dropins() {&nbsp;</div></li><li><div>  $dropins = array();&nbsp;</div></li><li><div>  $plugin_files = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $_dropins = _get_dropins();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// These exist in the wp-content directory</span>&nbsp;</div></li><li><div>  if ( $plugins_dir = @ opendir( WP_CONTENT_DIR ) ) {&nbsp;</div></li><li><div>      while ( ( $file = readdir( $plugins_dir ) ) !== false ) {&nbsp;</div></li><li><div>          if ( isset( $_dropins[ $file ] ) )&nbsp;</div></li><li><div>              $plugin_files[] = $file;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      return $dropins;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  @closedir( $plugins_dir );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($plugin_files) )&nbsp;</div></li><li><div>      return $dropins;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $plugin_files as $plugin_file ) {&nbsp;</div></li><li><div>      if ( !is_readable( WP_CONTENT_DIR . &quot;/$plugin_file&quot; ) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      $plugin_data = get_plugin_data( WP_CONTENT_DIR . &quot;/$plugin_file&quot;, false, false ); <span class="comment"><span class="comment"><span class="comment">//Do not apply markup/translate as it'll be cached.</span></span></span>&nbsp;</div></li><li><div>      if ( empty( $plugin_data['Name'] ) )&nbsp;</div></li><li><div>          $plugin_data['Name'] = $plugin_file;&nbsp;</div></li><li><div>      $dropins[ $plugin_file ] = $plugin_data;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  uksort( $dropins, 'strnatcasecmp' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $dropins;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Returns drop-ins that WordPress uses.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Includes Multisite drop-ins only when is_multisite()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> * @return array Key is file name. The value is an array, with the first value the</span>&nbsp;</div></li><li><div><span class="comment"> *    purpose of the drop-in and the second value the name of the constant that must be</span>&nbsp;</div></li><li><div><span class="comment"> *    true for the drop-in to be used, or true if no constant is required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function _get_dropins() {&nbsp;</div></li><li><div>  $dropins = array(&nbsp;</div></li><li><div>      'advanced-cache.php' =&gt; array( __( 'Advanced caching plugin.' ), 'WP_CACHE' ), <span class="comment">// WP_CACHE</span>&nbsp;</div></li><li><div>      'db.php' =&gt; array( __( 'Custom database class.' ), true ), <span class="comment"><span class="comment">// auto on load</span></span>&nbsp;</div></li><li><div>      'db-error.php' =&gt; array( __( 'Custom database error message.' ), true ), <span class="comment">// auto on error</span>&nbsp;</div></li><li><div>      'install.php' =&gt; array( __( 'Custom install script.' ), true ), <span class="comment">// auto on install</span>&nbsp;</div></li><li><div>      'maintenance.php' =&gt; array( __( 'Custom maintenance message.' ), true ), <span class="comment">// auto on maintenance</span>&nbsp;</div></li><li><div>      'object-cache.php' =&gt; array( __( 'External object cache.' ), true ), <span class="comment"><span class="comment">// auto on load</span></span>&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_multisite() ) {&nbsp;</div></li><li><div>      $dropins['sunrise.php' ] = array( __( 'Executed before Multisite is loaded.' ), 'SUNRISE' ); <span class="comment">// SUNRISE</span>&nbsp;</div></li><li><div>      $dropins['blog-deleted.php' ] = array( __( 'Custom site deleted message.' ), true ); <span class="comment">// auto on deleted blog</span>&nbsp;</div></li><li><div>      $dropins['blog-inactive.php' ] = array( __( 'Custom site inactive message.' ), true ); <span class="comment">// auto on inactive blog</span>&nbsp;</div></li><li><div>      $dropins['blog-suspended.php'] = array( __( 'Custom site suspended message.' ), true ); <span class="comment">// auto on archived or spammed blog</span>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $dropins;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check whether a plugin is active.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Only plugins installed in the plugins/ folder can be active.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Plugins in the mu-plugins/ folder can't be &quot;activated, &quot; so this function will</span>&nbsp;</div></li><li><div><span class="comment"> * return false for those plugins.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Base plugin path from plugins directory.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True, if in the active plugins list. False, not in the list.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_plugin_active( $plugin ) {&nbsp;</div></li><li><div>  return in_array( $plugin, (array) get_option( 'active_plugins', array() ) ) || is_plugin_active_for_network( $plugin );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check whether the plugin is inactive.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Reverse of is_plugin_active(). Used as a callback.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> * @see is_plugin_active()</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Base plugin path from plugins directory.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True if inactive. False if active.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_plugin_inactive( $plugin ) {&nbsp;</div></li><li><div>  return ! is_plugin_active( $plugin );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check whether the plugin is active for the entire network.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Only plugins installed in the plugins/ folder can be active.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Plugins in the mu-plugins/ folder can't be &quot;activated, &quot; so this function will</span>&nbsp;</div></li><li><div><span class="comment"> * return false for those plugins.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Base plugin path from plugins directory.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True, if active for the network, otherwise false.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_plugin_active_for_network( $plugin ) {&nbsp;</div></li><li><div>  if ( !is_multisite() )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugins = get_site_option( 'active_sitewide_plugins');&nbsp;</div></li><li><div>  if ( isset($plugins[$plugin]) )&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Checks for &quot;Network: true&quot; in the plugin header to see if this should</span>&nbsp;</div></li><li><div><span class="comment"> * be activated only as a network wide plugin. The plugin would also work</span>&nbsp;</div></li><li><div><span class="comment"> * when Multisite is not enabled.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Checks for &quot;Site Wide Only: true&quot; for backward compatibility.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Plugin to check</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool True if plugin is network only, false otherwise.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_network_only_plugin( $plugin ) {&nbsp;</div></li><li><div>  $plugin_data = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin );&nbsp;</div></li><li><div>  if ( $plugin_data )&nbsp;</div></li><li><div>      return $plugin_data['Network'];&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Attempts activation of plugin in a &quot;sandbox&quot; and redirects on success.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * A plugin that is already activated will not attempt to be activated again.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The way it works is by setting the redirection to the error before trying to</span>&nbsp;</div></li><li><div><span class="comment"> * include the plugin file. If the plugin fails, then the redirection will not</span>&nbsp;</div></li><li><div><span class="comment"> * be overwritten with the success message. Also, the options will not be</span>&nbsp;</div></li><li><div><span class="comment"> * updated and the activation hook will not be called on plugin error.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * It should be noted that in no way the below code will actually prevent errors</span>&nbsp;</div></li><li><div><span class="comment"> * within the file. The code should not be used elsewhere to replicate the</span>&nbsp;</div></li><li><div><span class="comment"> * &quot;sandbox&quot;, which uses redirection to work.</span>&nbsp;</div></li><li><div><span class="comment"> * {@source 13 1}</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If any errors are found or text is outputted, then it will be captured to</span>&nbsp;</div></li><li><div><span class="comment"> * ensure that the success redirection will update the error redirection.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin       Plugin path to main plugin file with plugin data.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $redirect     Optional. URL to redirect to.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $network_wide Optional. Whether to enable the plugin for all sites in the network</span>&nbsp;</div></li><li><div><span class="comment"> *                             or just the current site. Multisite only. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool   $silent       Optional. Whether to prevent calling activation hooks. Default false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Error|null WP_Error on invalid file or null on success.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function activate_plugin( $plugin, $redirect = '', $network_wide = false, $silent = false ) {&nbsp;</div></li><li><div>  $plugin = plugin_basename( trim( $plugin ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_multisite() && ( $network_wide || is_network_only_plugin($plugin) ) ) {&nbsp;</div></li><li><div>      $network_wide = true;&nbsp;</div></li><li><div>      $current = get_site_option( 'active_sitewide_plugins', array() );&nbsp;</div></li><li><div>      $_GET['networkwide'] = 1; <span class="comment">// Back compat for plugins looking for this value.</span>&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $current = get_option( 'active_plugins', array() );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $valid = validate_plugin($plugin);&nbsp;</div></li><li><div>  if ( is_wp_error($valid) )&nbsp;</div></li><li><div>      return $valid;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ( $network_wide && ! isset( $current[ $plugin ] ) ) || ( ! $network_wide && ! in_array( $plugin, $current ) ) ) {&nbsp;</div></li><li><div>      if ( !empty($redirect) )&nbsp;</div></li><li><div>          wp_redirect(add_query_arg('_error_nonce', wp_create_nonce('plugin-activation-error_' . $plugin), $redirect)); <span class="comment">// we'll override this later if the plugin can be included without fatal error</span>&nbsp;</div></li><li><div>      ob_start();&nbsp;</div></li><li><div>      wp_register_plugin_realpath( WP_PLUGIN_DIR . '/' . $plugin );&nbsp;</div></li><li><div>      $_wp_plugin_file = $plugin;&nbsp;</div></li><li><div>      include_once( WP_PLUGIN_DIR . '/' . $plugin );&nbsp;</div></li><li><div>      $plugin = $_wp_plugin_file; <span class="comment">// Avoid stomping of the $plugin variable in a plugin.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $silent ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires before a plugin is activated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * If a plugin is silently activated (such as during an update), </span>&nbsp;</div></li><li><div><span class="comment">           * this hook does not fire.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $plugin       Plugin path to main plugin file with plugin data.</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool   $network_wide Whether to enable the plugin for all sites in the network</span>&nbsp;</div></li><li><div><span class="comment">           *                             or just the current site. Multisite only. Default is false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'activate_plugin', $plugin, $network_wide );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires as a specific plugin is being activated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * This hook is the &quot;activation&quot; hook used internally by register_activation_hook().</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$plugin`, refers to the plugin basename.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * If a plugin is silently activated (such as during an update), this hook does not fire.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool $network_wide Whether to enable the plugin for all sites in the network</span>&nbsp;</div></li><li><div><span class="comment">           *                           or just the current site. Multisite only. Default is false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( &quot;activate_{$plugin}&quot;, $network_wide );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $network_wide ) {&nbsp;</div></li><li><div>          $current = get_site_option( 'active_sitewide_plugins', array() );&nbsp;</div></li><li><div>          $current[$plugin] = time();&nbsp;</div></li><li><div>          update_site_option( 'active_sitewide_plugins', $current );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $current = get_option( 'active_plugins', array() );&nbsp;</div></li><li><div>          $current[] = $plugin;&nbsp;</div></li><li><div>          sort($current);&nbsp;</div></li><li><div>          update_option('active_plugins', $current);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $silent ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires after a plugin has been activated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * If a plugin is silently activated (such as during an update), </span>&nbsp;</div></li><li><div><span class="comment">           * this hook does not fire.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $plugin       Plugin path to main plugin file with plugin data.</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool   $network_wide Whether to enable the plugin for all sites in the network</span>&nbsp;</div></li><li><div><span class="comment">           *                             or just the current site. Multisite only. Default is false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'activated_plugin', $plugin, $network_wide );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ob_get_length() &gt; 0 ) {&nbsp;</div></li><li><div>          $output = ob_get_clean();&nbsp;</div></li><li><div>          return new WP_Error('unexpected_output', __('The plugin generated unexpected output.'), $output);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      ob_end_clean();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return null;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Deactivate a single plugin or multiple plugins.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The deactivation hook is disabled by the plugin upgrader by using the $silent</span>&nbsp;</div></li><li><div><span class="comment"> * parameter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $plugins Single plugin or list of plugins to deactivate.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $silent Prevent calling deactivation hooks. Default is false.</span>&nbsp;</div></li><li><div><span class="comment"> * @param mixed $network_wide Whether to deactivate the plugin for all sites in the network.</span>&nbsp;</div></li><li><div><span class="comment"> *     A value of null (the default) will deactivate plugins for both the site and the network.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function deactivate_plugins( $plugins, $silent = false, $network_wide = null ) {&nbsp;</div></li><li><div>  if ( is_multisite() )&nbsp;</div></li><li><div>      $network_current = get_site_option( 'active_sitewide_plugins', array() );&nbsp;</div></li><li><div>  $current = get_option( 'active_plugins', array() );&nbsp;</div></li><li><div>  $do_blog = $do_network = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( (array) $plugins as $plugin ) {&nbsp;</div></li><li><div>      $plugin = plugin_basename( trim( $plugin ) );&nbsp;</div></li><li><div>      if ( ! is_plugin_active($plugin) )&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $network_deactivating = false !== $network_wide && is_plugin_active_for_network( $plugin );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $silent ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires before a plugin is deactivated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * If a plugin is silently deactivated (such as during an update), </span>&nbsp;</div></li><li><div><span class="comment">           * this hook does not fire.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $plugin               Plugin path to main plugin file with plugin data.</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool   $network_deactivating Whether the plugin is deactivated for all sites in the network</span>&nbsp;</div></li><li><div><span class="comment">           *                                     or just the current site. Multisite only. Default is false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'deactivate_plugin', $plugin, $network_deactivating );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( false !== $network_wide ) {&nbsp;</div></li><li><div>          if ( is_plugin_active_for_network( $plugin ) ) {&nbsp;</div></li><li><div>              $do_network = true;&nbsp;</div></li><li><div>              unset( $network_current[ $plugin ] );&nbsp;</div></li><li><div>          } elseif ( $network_wide ) {&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( true !== $network_wide ) {&nbsp;</div></li><li><div>          $key = array_search( $plugin, $current );&nbsp;</div></li><li><div>          if ( false !== $key ) {&nbsp;</div></li><li><div>              $do_blog = true;&nbsp;</div></li><li><div>              unset( $current[ $key ] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $silent ) {&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires as a specific plugin is being deactivated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * This hook is the &quot;deactivation&quot; hook used internally by register_deactivation_hook().</span>&nbsp;</div></li><li><div><span class="comment">           * The dynamic portion of the hook name, `$plugin`, refers to the plugin basename.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * If a plugin is silently deactivated (such as during an update), this hook does not fire.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool $network_deactivating Whether the plugin is deactivated for all sites in the network</span>&nbsp;</div></li><li><div><span class="comment">           *                                   or just the current site. Multisite only. Default is false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( &quot;deactivate_{$plugin}&quot;, $network_deactivating );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires after a plugin is deactivated.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * If a plugin is silently deactivated (such as during an update), </span>&nbsp;</div></li><li><div><span class="comment">           * this hook does not fire.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.9.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $plugin               Plugin basename.</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool   $network_deactivating Whether the plugin is deactivated for all sites in the network</span>&nbsp;</div></li><li><div><span class="comment">           *                                     or just the current site. Multisite only. Default false.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'deactivated_plugin', $plugin, $network_deactivating );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $do_blog )&nbsp;</div></li><li><div>      update_option('active_plugins', $current);&nbsp;</div></li><li><div>  if ( $do_network )&nbsp;</div></li><li><div>      update_site_option( 'active_sitewide_plugins', $network_current );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Activate multiple plugins.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * When WP_Error is returned, it does not mean that one of the plugins had</span>&nbsp;</div></li><li><div><span class="comment"> * errors. It means that one or more of the plugins file path was invalid.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The execution will be halted as soon as one of the plugins has an error.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.6.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $plugins Single plugin or list of plugins to activate.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $redirect Redirect to page after successful activation.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $network_wide Whether to enable the plugin for all sites in the network.</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $silent Prevent calling activation hooks. Default is false.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|WP_Error True when finished or WP_Error if there were errors during a plugin activation.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function activate_plugins( $plugins, $redirect = '', $network_wide = false, $silent = false ) {&nbsp;</div></li><li><div>  if ( !is_array($plugins) )&nbsp;</div></li><li><div>      $plugins = array($plugins);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $errors = array();&nbsp;</div></li><li><div>  foreach ( $plugins as $plugin ) {&nbsp;</div></li><li><div>      if ( !empty($redirect) )&nbsp;</div></li><li><div>          $redirect = add_query_arg('plugin', $plugin, $redirect);&nbsp;</div></li><li><div>      $result = activate_plugin($plugin, $redirect, $network_wide, $silent);&nbsp;</div></li><li><div>      if ( is_wp_error($result) )&nbsp;</div></li><li><div>          $errors[$plugin] = $result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !empty($errors) )&nbsp;</div></li><li><div>      return new WP_Error('plugins_invalid', __('One of the plugins is invalid.'), $errors);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove directory and files of a plugin for a list of plugins.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.6.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global WP_Filesystem_Base $wp_filesystem</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array  $plugins    List of plugins to delete.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $deprecated Deprecated.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool|null|WP_Error True on success, false is $plugins is empty, WP_Error on failure.</span>&nbsp;</div></li><li><div><span class="comment"> *                            Null if filesystem credentials are required to proceed.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function delete_plugins( $plugins, $deprecated = '' ) {&nbsp;</div></li><li><div>  global $wp_filesystem;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($plugins) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $checked = array();&nbsp;</div></li><li><div>  foreach ( $plugins as $plugin )&nbsp;</div></li><li><div>      $checked[] = 'checked[]=' . $plugin;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $url = wp_nonce_url('plugins.php?action=delete-selected&verify-delete=1&' . implode('&', $checked), 'bulk-plugins');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ob_start();&nbsp;</div></li><li><div>  $credentials = request_filesystem_credentials( $url );&nbsp;</div></li><li><div>  $data = ob_get_clean();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( false === $credentials ) {&nbsp;</div></li><li><div>      if ( ! empty($data) ) {&nbsp;</div></li><li><div>          include_once( ABSPATH . 'wp-admin/admin-header.php');&nbsp;</div></li><li><div>          echo $data;&nbsp;</div></li><li><div>          include( ABSPATH . 'wp-admin/admin-footer.php');&nbsp;</div></li><li><div>          exit;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! WP_Filesystem( $credentials ) ) {&nbsp;</div></li><li><div>      ob_start();&nbsp;</div></li><li><div>      request_filesystem_credentials( $url, '', true ); <span class="comment">// Failed to connect, Error and request again.</span>&nbsp;</div></li><li><div>      $data = ob_get_clean();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty($data) ) {&nbsp;</div></li><li><div>          include_once( ABSPATH . 'wp-admin/admin-header.php');&nbsp;</div></li><li><div>          echo $data;&nbsp;</div></li><li><div>          include( ABSPATH . 'wp-admin/admin-footer.php');&nbsp;</div></li><li><div>          exit;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! is_object($wp_filesystem) )&nbsp;</div></li><li><div>      return new WP_Error('fs_unavailable', __('Could not access filesystem.'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_wp_error($wp_filesystem-&gt;errors) && $wp_filesystem-&gt;errors-&gt;get_error_code() )&nbsp;</div></li><li><div>      return new WP_Error('fs_error', __('Filesystem error.'), $wp_filesystem-&gt;errors);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Get the base plugin folder.</span>&nbsp;</div></li><li><div>  $plugins_dir = $wp_filesystem-&gt;wp_plugins_dir();&nbsp;</div></li><li><div>  if ( empty( $plugins_dir ) ) {&nbsp;</div></li><li><div>      return new WP_Error( 'fs_no_plugins_dir', __( 'Unable to locate WordPress plugin directory.' ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugins_dir = trailingslashit( $plugins_dir );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugin_translations = wp_get_installed_translations( 'plugins' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $errors = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $plugins as $plugin_file ) {&nbsp;</div></li><li><div>      <span class="comment">// Run Uninstall hook.</span>&nbsp;</div></li><li><div>      if ( is_uninstallable_plugin( $plugin_file ) ) {&nbsp;</div></li><li><div>          uninstall_plugin($plugin_file);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately before a plugin deletion attempt.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $plugin_file Plugin file name.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'delete_plugin', $plugin_file );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this_plugin_dir = trailingslashit( dirname( $plugins_dir . $plugin_file ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If plugin is in its own directory, recursively delete the directory.</span>&nbsp;</div></li><li><div>      if ( strpos( $plugin_file, '/' ) && $this_plugin_dir != $plugins_dir ) { <span class="comment">//base check on if plugin includes directory separator AND that it's not the root plugin folder</span>&nbsp;</div></li><li><div>          $deleted = $wp_filesystem-&gt;delete( $this_plugin_dir, true );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $deleted = $wp_filesystem-&gt;delete( $plugins_dir . $plugin_file );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires immediately after a plugin deletion attempt.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 4.4.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $plugin_file Plugin file name.</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool   $deleted     Whether the plugin deletion was successful.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'deleted_plugin', $plugin_file, $deleted );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $deleted ) {&nbsp;</div></li><li><div>          $errors[] = $plugin_file;&nbsp;</div></li><li><div>          continue;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Remove language files, silently.</span>&nbsp;</div></li><li><div>      $plugin_slug = dirname( $plugin_file );&nbsp;</div></li><li><div>      if ( '.' !== $plugin_slug && ! empty( $plugin_translations[ $plugin_slug ] ) ) {&nbsp;</div></li><li><div>          $translations = $plugin_translations[ $plugin_slug ];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          foreach ( $translations as $translation =&gt; $data ) {&nbsp;</div></li><li><div>              $wp_filesystem-&gt;delete( WP_LANG_DIR . '/plugins/' . $plugin_slug . '-' . $translation . '.po' );&nbsp;</div></li><li><div>              $wp_filesystem-&gt;delete( WP_LANG_DIR . '/plugins/' . $plugin_slug . '-' . $translation . '.mo' );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Remove deleted plugins from the plugin updates list.</span>&nbsp;</div></li><li><div>  if ( $current = get_site_transient('update_plugins') ) {&nbsp;</div></li><li><div>      <span class="comment">// Don't remove the plugins that weren't deleted.</span>&nbsp;</div></li><li><div>      $deleted = array_diff( $plugins, $errors );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $deleted as $plugin_file ) {&nbsp;</div></li><li><div>          unset( $current-&gt;response[ $plugin_file ] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      set_site_transient( 'update_plugins', $current );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty($errors) )&nbsp;</div></li><li><div>      return new WP_Error('could_not_remove_plugin', sprintf(__('Could not fully remove the plugin(s) %s.'), implode(', ', $errors)) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Validate active plugins</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Validate all active plugins, deactivates invalid and</span>&nbsp;</div></li><li><div><span class="comment"> * returns an array of deactivated ones.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> * @return array invalid plugins, plugin as key, error as value</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function validate_active_plugins() {&nbsp;</div></li><li><div>  $plugins = get_option( 'active_plugins', array() );&nbsp;</div></li><li><div>  <span class="comment">// Validate vartype: array.</span>&nbsp;</div></li><li><div>  if ( ! is_array( $plugins ) ) {&nbsp;</div></li><li><div>      update_option( 'active_plugins', array() );&nbsp;</div></li><li><div>      $plugins = array();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_multisite() && current_user_can( 'manage_network_plugins' ) ) {&nbsp;</div></li><li><div>      $network_plugins = (array) get_site_option( 'active_sitewide_plugins', array() );&nbsp;</div></li><li><div>      $plugins = array_merge( $plugins, array_keys( $network_plugins ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $plugins ) )&nbsp;</div></li><li><div>      return array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $invalid = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Invalid plugins get deactivated.</span>&nbsp;</div></li><li><div>  foreach ( $plugins as $plugin ) {&nbsp;</div></li><li><div>      $result = validate_plugin( $plugin );&nbsp;</div></li><li><div>      if ( is_wp_error( $result ) ) {&nbsp;</div></li><li><div>          $invalid[$plugin] = $result;&nbsp;</div></li><li><div>          deactivate_plugins( $plugin, true );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  return $invalid;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Validate the plugin path.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Checks that the file exists and is a valid file. See validate_file().</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Plugin Path.</span>&nbsp;</div></li><li><div><span class="comment"> * @return WP_Error|int 0 on success, WP_Error on failure.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function validate_plugin($plugin) {&nbsp;</div></li><li><div>  if ( validate_file($plugin) )&nbsp;</div></li><li><div>      return new WP_Error('plugin_invalid', __('Invalid plugin path.'));&nbsp;</div></li><li><div>  if ( ! file_exists(WP_PLUGIN_DIR . '/' . $plugin) )&nbsp;</div></li><li><div>      return new WP_Error('plugin_not_found', __('Plugin file does not exist.'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $installed_plugins = get_plugins();&nbsp;</div></li><li><div>  if ( ! isset($installed_plugins[$plugin]) )&nbsp;</div></li><li><div>      return new WP_Error('no_plugin_header', __('The plugin does not have a valid header.'));&nbsp;</div></li><li><div>  return 0;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Whether the plugin can be uninstalled.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Plugin path to check.</span>&nbsp;</div></li><li><div><span class="comment"> * @return bool Whether plugin can be uninstalled.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function is_uninstallable_plugin($plugin) {&nbsp;</div></li><li><div>  $file = plugin_basename($plugin);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $uninstallable_plugins = (array) get_option('uninstall_plugins');&nbsp;</div></li><li><div>  if ( isset( $uninstallable_plugins[$file] ) || file_exists( WP_PLUGIN_DIR . '/' . dirname($file) . '/uninstall.php' ) )&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Uninstall a single plugin.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Calls the uninstall hook, if it is available.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin Relative plugin path from Plugin Directory.</span>&nbsp;</div></li><li><div><span class="comment"> * @return true True if a plugin's uninstall.php file has been found and included.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function uninstall_plugin($plugin) {&nbsp;</div></li><li><div>  $file = plugin_basename($plugin);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $uninstallable_plugins = (array) get_option('uninstall_plugins');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Fires in uninstall_plugin() immediately before the plugin is uninstalled.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $plugin                Relative plugin path from plugin directory.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array  $uninstallable_plugins Uninstallable plugins.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  do_action( 'pre_uninstall_plugin', $plugin, $uninstallable_plugins );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( file_exists( WP_PLUGIN_DIR . '/' . dirname($file) . '/uninstall.php' ) ) {&nbsp;</div></li><li><div>      if ( isset( $uninstallable_plugins[$file] ) ) {&nbsp;</div></li><li><div>          unset($uninstallable_plugins[$file]);&nbsp;</div></li><li><div>          update_option('uninstall_plugins', $uninstallable_plugins);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      unset($uninstallable_plugins);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      define('WP_UNINSTALL_PLUGIN', $file);&nbsp;</div></li><li><div>      wp_register_plugin_realpath( WP_PLUGIN_DIR . '/' . $file );&nbsp;</div></li><li><div>      include( WP_PLUGIN_DIR . '/' . dirname($file) . '/uninstall.php' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $uninstallable_plugins[$file] ) ) {&nbsp;</div></li><li><div>      $callable = $uninstallable_plugins[$file];&nbsp;</div></li><li><div>      unset($uninstallable_plugins[$file]);&nbsp;</div></li><li><div>      update_option('uninstall_plugins', $uninstallable_plugins);&nbsp;</div></li><li><div>      unset($uninstallable_plugins);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_register_plugin_realpath( WP_PLUGIN_DIR . '/' . $file );&nbsp;</div></li><li><div>      include( WP_PLUGIN_DIR . '/' . $file );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      add_action( 'uninstall_' . $file, $callable );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires in uninstall_plugin() once the plugin has been uninstalled.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * The action concatenates the 'uninstall_' prefix with the basename of the</span>&nbsp;</div></li><li><div><span class="comment">       * plugin passed to uninstall_plugin() to create a dynamically-named action.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'uninstall_' . $file );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">// Menu</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add a top-level menu page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $menu</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $admin_page_hooks</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_registered_pages</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_parent_pages</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $icon_url   The URL to the icon to be used for this menu.</span>&nbsp;</div></li><li><div><span class="comment"> *                             * Pass a base64-encoded SVG using a data URI, which will be colored to match</span>&nbsp;</div></li><li><div><span class="comment"> *                               the color scheme. This should begin with 'data:image/svg+xml;base64, '.</span>&nbsp;</div></li><li><div><span class="comment"> *                             * Pass the name of a Dashicons helper class to use a font icon, </span>&nbsp;</div></li><li><div><span class="comment"> *                               e.g. 'dashicons-chart-pie'.</span>&nbsp;</div></li><li><div><span class="comment"> *                             * Pass 'none' to leave div.wp-menu-image empty so an icon can be added via CSS.</span>&nbsp;</div></li><li><div><span class="comment"> * @param int      $position   The position in the menu order this one should appear.</span>&nbsp;</div></li><li><div><span class="comment"> * @return string The resulting page's hook_suffix.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_menu_page( $page_title, $menu_title, $capability, $menu_slug, $function = '', $icon_url = '', $position = null ) {&nbsp;</div></li><li><div>  global $menu, $admin_page_hooks, $_registered_pages, $_parent_pages;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $menu_slug = plugin_basename( $menu_slug );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $admin_page_hooks[$menu_slug] = sanitize_title( $menu_title );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $hookname = get_plugin_page_hookname( $menu_slug, '' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !empty( $function ) && !empty( $hookname ) && current_user_can( $capability ) )&nbsp;</div></li><li><div>      add_action( $hookname, $function );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($icon_url) ) {&nbsp;</div></li><li><div>      $icon_url = 'dashicons-admin-generic';&nbsp;</div></li><li><div>      $icon_class = 'menu-icon-generic ';&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $icon_url = set_url_scheme( $icon_url );&nbsp;</div></li><li><div>      $icon_class = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $new_menu = array( $menu_title, $capability, $menu_slug, $page_title, 'menu-top ' . $icon_class . $hookname, $hookname, $icon_url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( null === $position ) {&nbsp;</div></li><li><div>      $menu[] = $new_menu;&nbsp;</div></li><li><div>  } elseif ( isset( $menu[ &quot;$position&quot; ] ) ) {&nbsp;</div></li><li><div>       $position = $position + substr( base_convert( md5( $menu_slug . $menu_title ), 16, 10 ) , -5 ) * 0.00001;&nbsp;</div></li><li><div>      $menu[ &quot;$position&quot; ] = $new_menu;&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $menu[ $position ] = $new_menu;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $_registered_pages[$hookname] = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// No parent as top level</span>&nbsp;</div></li><li><div>  $_parent_pages[$menu_slug] = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $hookname;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add a submenu page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $submenu</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $menu</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_real_parent_file</span>&nbsp;</div></li><li><div><span class="comment"> * @global bool  $_wp_submenu_nopriv</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_registered_pages</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_parent_pages</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $parent_slug The slug name for the parent menu (or the file name of a standard WordPress admin page).</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title  The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title  The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability  The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug   The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function    The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_submenu_page( $parent_slug, $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  global $submenu, $menu, $_wp_real_parent_file, $_wp_submenu_nopriv, &nbsp;</div></li><li><div>      $_registered_pages, $_parent_pages;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $menu_slug = plugin_basename( $menu_slug );&nbsp;</div></li><li><div>  $parent_slug = plugin_basename( $parent_slug);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $_wp_real_parent_file[$parent_slug] ) )&nbsp;</div></li><li><div>      $parent_slug = $_wp_real_parent_file[$parent_slug];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !current_user_can( $capability ) ) {&nbsp;</div></li><li><div>      $_wp_submenu_nopriv[$parent_slug][$menu_slug] = true;&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * If the parent doesn't already have a submenu, add a link to the parent</span>&nbsp;</div></li><li><div><span class="comment">   * as the first item in the submenu. If the submenu file is the same as the</span>&nbsp;</div></li><li><div><span class="comment">   * parent file someone is trying to link back to the parent manually. In</span>&nbsp;</div></li><li><div><span class="comment">   * this case, don't automatically add a link back to avoid duplication.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if (!isset( $submenu[$parent_slug] ) && $menu_slug != $parent_slug ) {&nbsp;</div></li><li><div>      foreach ( (array)$menu as $parent_menu ) {&nbsp;</div></li><li><div>          if ( $parent_menu[2] == $parent_slug && current_user_can( $parent_menu[1] ) )&nbsp;</div></li><li><div>              $submenu[$parent_slug][] = array_slice( $parent_menu, 0, 4 );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $submenu[$parent_slug][] = array ( $menu_title, $capability, $menu_slug, $page_title );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $hookname = get_plugin_page_hookname( $menu_slug, $parent_slug);&nbsp;</div></li><li><div>  if (!empty ( $function ) && !empty ( $hookname ))&nbsp;</div></li><li><div>      add_action( $hookname, $function );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $_registered_pages[$hookname] = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Backward-compatibility for plugins using add_management page.</span>&nbsp;</div></li><li><div><span class="comment">   * See wp-admin/admin.php for redirect from edit.php to tools.php</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( 'tools.php' == $parent_slug )&nbsp;</div></li><li><div>      $_registered_pages[get_plugin_page_hookname( $menu_slug, 'edit.php')] = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// No parent as top level</span>.&nbsp;</div></li><li><div>  $_parent_pages[$menu_slug] = $parent_slug;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $hookname;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Tools main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_management_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'tools.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Settings main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_options_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'options-general.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Appearance main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_theme_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'themes.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Plugins main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_plugins_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'plugins.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Users/Profile main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_users_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  if ( current_user_can('edit_users') )&nbsp;</div></li><li><div>      $parent = 'users.php';&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $parent = 'profile.php';&nbsp;</div></li><li><div>  return add_submenu_page( $parent, $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Dashboard main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_dashboard_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'index.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Posts main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_posts_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'edit.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Media main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_media_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'upload.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Links main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_links_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'link-manager.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Pages main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_pages_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'edit.php?post_type=page', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Add submenu page to the Comments main menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * This function takes a capability which will be used to determine whether</span>&nbsp;</div></li><li><div><span class="comment"> * or not a page is included in the menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * The function which is hooked in to handle the output of the page must check</span>&nbsp;</div></li><li><div><span class="comment"> * that the user has the required capability as well.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $page_title The text to be displayed in the title tags of the page when the menu is selected.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_title The text to be used for the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $capability The capability required for this menu to be displayed to the user.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string   $menu_slug  The slug name to refer to this menu by (should be unique for this menu).</span>&nbsp;</div></li><li><div><span class="comment"> * @param callable $function   The function to be called to output the content for this page.</span>&nbsp;</div></li><li><div><span class="comment"> * @return false|string The resulting page's hook_suffix, or false if the user does not have the capability required.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_comments_page( $page_title, $menu_title, $capability, $menu_slug, $function = '' ) {&nbsp;</div></li><li><div>  return add_submenu_page( 'edit-comments.php', $page_title, $menu_title, $capability, $menu_slug, $function );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove a top-level admin menu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $menu</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $menu_slug The slug of the menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|bool The removed menu on success, false if not found.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function remove_menu_page( $menu_slug ) {&nbsp;</div></li><li><div>  global $menu;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $menu as $i =&gt; $item ) {&nbsp;</div></li><li><div>      if ( $menu_slug == $item[2] ) {&nbsp;</div></li><li><div>          unset( $menu[$i] );&nbsp;</div></li><li><div>          return $item;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Remove an admin submenu.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.1.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $submenu</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $menu_slug    The slug for the parent menu.</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $submenu_slug The slug of the submenu.</span>&nbsp;</div></li><li><div><span class="comment"> * @return array|bool The removed submenu on success, false if not found.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function remove_submenu_page( $menu_slug, $submenu_slug ) {&nbsp;</div></li><li><div>  global $submenu;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset( $submenu[$menu_slug] ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $submenu[$menu_slug] as $i =&gt; $item ) {&nbsp;</div></li><li><div>      if ( $submenu_slug == $item[2] ) {&nbsp;</div></li><li><div>          unset( $submenu[$menu_slug][$i] );&nbsp;</div></li><li><div>          return $item;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return false;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Get the url to access a particular menu page based on the slug it was registered with.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * If the slug hasn't been registered properly no url will be returned</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.0.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_parent_pages</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $menu_slug The slug name to refer to this menu by (should be unique for this menu)</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $echo Whether or not to echo the url - default is true</span>&nbsp;</div></li><li><div><span class="comment"> * @return string the url</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function menu_page_url($menu_slug, $echo = true) {&nbsp;</div></li><li><div>  global $_parent_pages;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $_parent_pages[$menu_slug] ) ) {&nbsp;</div></li><li><div>      $parent_slug = $_parent_pages[$menu_slug];&nbsp;</div></li><li><div>      if ( $parent_slug && ! isset( $_parent_pages[$parent_slug] ) ) {&nbsp;</div></li><li><div>          $url = admin_url( add_query_arg( 'page', $menu_slug, $parent_slug ) );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $url = admin_url( 'admin.php?page=' . $menu_slug );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      $url = '';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $url = esc_url($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $echo )&nbsp;</div></li><li><div>      echo $url;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $url;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>// Pluggable Menu Support -- Private&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>/**&nbsp;</div></li><li><div> *&nbsp;</div></li><li><div> * @global string $parent_file&nbsp;</div></li><li><div> * @global array $menu&nbsp;</div></li><li><div> * @global array $submenu&nbsp;</div></li><li><div> * @global string $pagenow&nbsp;</div></li><li><div> * @global string $typenow&nbsp;</div></li><li><div> * @global string $plugin_page&nbsp;</div></li><li><div> * @global array $_wp_real_parent_file&nbsp;</div></li><li><div> * @global array $_wp_menu_nopriv&nbsp;</div></li><li><div> * @global array $_wp_submenu_nopriv&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>function get_admin_page_parent( $parent = '' ) {&nbsp;</div></li><li><div>  global $parent_file, $menu, $submenu, $pagenow, $typenow, &nbsp;</div></li><li><div>      $plugin_page, $_wp_real_parent_file, $_wp_menu_nopriv, $_wp_submenu_nopriv;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !empty ( $parent ) && 'admin.php' != $parent ) {&nbsp;</div></li><li><div>      if ( isset( $_wp_real_parent_file[$parent] ) )&nbsp;</div></li><li><div>          $parent = $_wp_real_parent_file[$parent];&nbsp;</div></li><li><div>      return $parent;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( $pagenow == 'admin.php' && isset( $plugin_page ) ) {&nbsp;</div></li><li><div>      foreach ( (array)$menu as $parent_menu ) {&nbsp;</div></li><li><div>          if ( $parent_menu[2] == $plugin_page ) {&nbsp;</div></li><li><div>              $parent_file = $plugin_page;&nbsp;</div></li><li><div>              if ( isset( $_wp_real_parent_file[$parent_file] ) )&nbsp;</div></li><li><div>                  $parent_file = $_wp_real_parent_file[$parent_file];&nbsp;</div></li><li><div>              return $parent_file;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( isset( $_wp_menu_nopriv[$plugin_page] ) ) {&nbsp;</div></li><li><div>          $parent_file = $plugin_page;&nbsp;</div></li><li><div>          if ( isset( $_wp_real_parent_file[$parent_file] ) )&nbsp;</div></li><li><div>                  $parent_file = $_wp_real_parent_file[$parent_file];&nbsp;</div></li><li><div>          return $parent_file;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $plugin_page ) && isset( $_wp_submenu_nopriv[$pagenow][$plugin_page] ) ) {&nbsp;</div></li><li><div>      $parent_file = $pagenow;&nbsp;</div></li><li><div>      if ( isset( $_wp_real_parent_file[$parent_file] ) )&nbsp;</div></li><li><div>          $parent_file = $_wp_real_parent_file[$parent_file];&nbsp;</div></li><li><div>      return $parent_file;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach (array_keys( (array)$submenu ) as $parent) {&nbsp;</div></li><li><div>      foreach ( $submenu[$parent] as $submenu_array ) {&nbsp;</div></li><li><div>          if ( isset( $_wp_real_parent_file[$parent] ) )&nbsp;</div></li><li><div>              $parent = $_wp_real_parent_file[$parent];&nbsp;</div></li><li><div>          if ( !empty($typenow) && ($submenu_array[2] == &quot;$pagenow?post_type=$typenow&quot;) ) {&nbsp;</div></li><li><div>              $parent_file = $parent;&nbsp;</div></li><li><div>              return $parent;&nbsp;</div></li><li><div>          } elseif ( $submenu_array[2] == $pagenow && empty($typenow) && ( empty($parent_file) || false === strpos($parent_file, '?') ) ) {&nbsp;</div></li><li><div>              $parent_file = $parent;&nbsp;</div></li><li><div>              return $parent;&nbsp;</div></li><li><div>          } elseif ( isset( $plugin_page ) && ($plugin_page == $submenu_array[2] ) ) {&nbsp;</div></li><li><div>              $parent_file = $parent;&nbsp;</div></li><li><div>              return $parent;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty($parent_file) )&nbsp;</div></li><li><div>      $parent_file = '';&nbsp;</div></li><li><div>  return '';&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global string $title</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $menu</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $submenu</span>&nbsp;</div></li><li><div><span class="comment"> * @global string $pagenow</span>&nbsp;</div></li><li><div><span class="comment"> * @global string $plugin_page</span>&nbsp;</div></li><li><div><span class="comment"> * @global string $typenow</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_admin_page_title() {&nbsp;</div></li><li><div>  global $title, $menu, $submenu, $pagenow, $plugin_page, $typenow;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( ! empty ( $title ) )&nbsp;</div></li><li><div>      return $title;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $hook = get_plugin_page_hook( $plugin_page, $pagenow );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $parent = $parent1 = get_admin_page_parent();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty ( $parent) ) {&nbsp;</div></li><li><div>      foreach ( (array)$menu as $menu_array ) {&nbsp;</div></li><li><div>          if ( isset( $menu_array[3] ) ) {&nbsp;</div></li><li><div>              if ( $menu_array[2] == $pagenow ) {&nbsp;</div></li><li><div>                  $title = $menu_array[3];&nbsp;</div></li><li><div>                  return $menu_array[3];&nbsp;</div></li><li><div>              } elseif ( isset( $plugin_page ) && ($plugin_page == $menu_array[2] ) && ($hook == $menu_array[3] ) ) {&nbsp;</div></li><li><div>                  $title = $menu_array[3];&nbsp;</div></li><li><div>                  return $menu_array[3];&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $title = $menu_array[0];&nbsp;</div></li><li><div>              return $title;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } else {&nbsp;</div></li><li><div>      foreach ( array_keys( $submenu ) as $parent ) {&nbsp;</div></li><li><div>          foreach ( $submenu[$parent] as $submenu_array ) {&nbsp;</div></li><li><div>              if ( isset( $plugin_page ) &&&nbsp;</div></li><li><div>                  ( $plugin_page == $submenu_array[2] ) &&&nbsp;</div></li><li><div>                  (&nbsp;</div></li><li><div>                      ( $parent == $pagenow ) ||&nbsp;</div></li><li><div>                      ( $parent == $plugin_page ) ||&nbsp;</div></li><li><div>                      ( $plugin_page == $hook ) ||&nbsp;</div></li><li><div>                      ( $pagenow == 'admin.php' && $parent1 != $submenu_array[2] ) ||&nbsp;</div></li><li><div>                      ( !empty($typenow) && $parent == $pagenow . '?post_type=' . $typenow)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                      $title = $submenu_array[3];&nbsp;</div></li><li><div>                      return $submenu_array[3];&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( $submenu_array[2] != $pagenow || isset( $_GET['page'] ) ) <span class="comment">// not the current page</span>&nbsp;</div></li><li><div>                  continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( isset( $submenu_array[3] ) ) {&nbsp;</div></li><li><div>                  $title = $submenu_array[3];&nbsp;</div></li><li><div>                  return $submenu_array[3];&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $title = $submenu_array[0];&nbsp;</div></li><li><div>                  return $title;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( empty ( $title ) ) {&nbsp;</div></li><li><div>          foreach ( $menu as $menu_array ) {&nbsp;</div></li><li><div>              if ( isset( $plugin_page ) &&&nbsp;</div></li><li><div>                  ( $plugin_page == $menu_array[2] ) &&&nbsp;</div></li><li><div>                  ( $pagenow == 'admin.php' ) &&&nbsp;</div></li><li><div>                  ( $parent1 == $menu_array[2] ) )&nbsp;</div></li><li><div>                  {&nbsp;</div></li><li><div>                      $title = $menu_array[3];&nbsp;</div></li><li><div>                      return $menu_array[3];&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $title;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin_page</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $parent_page</span>&nbsp;</div></li><li><div><span class="comment"> * @return string|null</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_plugin_page_hook( $plugin_page, $parent_page ) {&nbsp;</div></li><li><div>  $hook = get_plugin_page_hookname( $plugin_page, $parent_page );&nbsp;</div></li><li><div>  if ( has_action($hook) )&nbsp;</div></li><li><div>      return $hook;&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $admin_page_hooks</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin_page</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $parent_page</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function get_plugin_page_hookname( $plugin_page, $parent_page ) {&nbsp;</div></li><li><div>  global $admin_page_hooks;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $parent = get_admin_page_parent( $parent_page );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $page_type = 'admin';&nbsp;</div></li><li><div>  if ( empty ( $parent_page ) || 'admin.php' == $parent_page || isset( $admin_page_hooks[$plugin_page] ) ) {&nbsp;</div></li><li><div>      if ( isset( $admin_page_hooks[$plugin_page] ) ) {&nbsp;</div></li><li><div>          $page_type = 'toplevel';&nbsp;</div></li><li><div>      } elseif ( isset( $admin_page_hooks[$parent] )) {&nbsp;</div></li><li><div>          $page_type = $admin_page_hooks[$parent];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  } elseif ( isset( $admin_page_hooks[$parent] ) ) {&nbsp;</div></li><li><div>      $page_type = $admin_page_hooks[$parent];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $plugin_name = preg_replace( '!\.php!', '', $plugin_page );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $page_type . '_page_' . $plugin_name;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global string $pagenow</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $menu</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $submenu</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_menu_nopriv</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_wp_submenu_nopriv</span>&nbsp;</div></li><li><div><span class="comment"> * @global string $plugin_page</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $_registered_pages</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function user_can_access_admin_page() {&nbsp;</div></li><li><div>  global $pagenow, $menu, $submenu, $_wp_menu_nopriv, $_wp_submenu_nopriv, &nbsp;</div></li><li><div>      $plugin_page, $_registered_pages;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  $parent = get_admin_page_parent();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( !isset( $plugin_page ) && isset( $_wp_submenu_nopriv[$parent][$pagenow] ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $plugin_page ) ) {&nbsp;</div></li><li><div>      if ( isset( $_wp_submenu_nopriv[$parent][$plugin_page] ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $hookname = get_plugin_page_hookname($plugin_page, $parent);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !isset($_registered_pages[$hookname]) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( empty( $parent) ) {&nbsp;</div></li><li><div>      if ( isset( $_wp_menu_nopriv[$pagenow] ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      if ( isset( $_wp_submenu_nopriv[$pagenow][$pagenow] ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      if ( isset( $plugin_page ) && isset( $_wp_submenu_nopriv[$pagenow][$plugin_page] ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      if ( isset( $plugin_page ) && isset( $_wp_menu_nopriv[$plugin_page] ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      foreach (array_keys( $_wp_submenu_nopriv ) as $key ) {&nbsp;</div></li><li><div>          if ( isset( $_wp_submenu_nopriv[$key][$pagenow] ) )&nbsp;</div></li><li><div>              return false;&nbsp;</div></li><li><div>          if ( isset( $plugin_page ) && isset( $_wp_submenu_nopriv[$key][$plugin_page] ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $plugin_page ) && ( $plugin_page == $parent ) && isset( $_wp_menu_nopriv[$plugin_page] ) )&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( isset( $submenu[$parent] ) ) {&nbsp;</div></li><li><div>      foreach ( $submenu[$parent] as $submenu_array ) {&nbsp;</div></li><li><div>          if ( isset( $plugin_page ) && ( $submenu_array[2] == $plugin_page ) ) {&nbsp;</div></li><li><div>              if ( current_user_can( $submenu_array[1] ))&nbsp;</div></li><li><div>                  return true;&nbsp;</div></li><li><div>              else&nbsp;</div></li><li><div>                  return false;&nbsp;</div></li><li><div>          } elseif ( $submenu_array[2] == $pagenow ) {&nbsp;</div></li><li><div>              if ( current_user_can( $submenu_array[1] ))&nbsp;</div></li><li><div>                  return true;&nbsp;</div></li><li><div>              else&nbsp;</div></li><li><div>                  return false;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $menu as $menu_array ) {&nbsp;</div></li><li><div>      if ( $menu_array[2] == $parent) {&nbsp;</div></li><li><div>          if ( current_user_can( $menu_array[1] ))&nbsp;</div></li><li><div>              return true;&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return true;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/** Whitelist functions */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Refreshes the value of the options whitelist available via the 'whitelist_options' hook.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * See the {@see 'whitelist_options'} filter.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $new_whitelist_options</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array $options</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function option_update_filter( $options ) {&nbsp;</div></li><li><div>  global $new_whitelist_options;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_array( $new_whitelist_options ) )&nbsp;</div></li><li><div>      $options = add_option_whitelist( $new_whitelist_options, $options );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $options;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Adds an array of options to the options whitelist.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $whitelist_options</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array        $new_options</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $options</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function add_option_whitelist( $new_options, $options = '' ) {&nbsp;</div></li><li><div>  if ( $options == '' )&nbsp;</div></li><li><div>      global $whitelist_options;&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $whitelist_options = $options;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $new_options as $page =&gt; $keys ) {&nbsp;</div></li><li><div>      foreach ( $keys as $key ) {&nbsp;</div></li><li><div>          if ( !isset($whitelist_options[ $page ]) || !is_array($whitelist_options[ $page ]) ) {&nbsp;</div></li><li><div>              $whitelist_options[ $page ] = array();&nbsp;</div></li><li><div>              $whitelist_options[ $page ][] = $key;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $pos = array_search( $key, $whitelist_options[ $page ] );&nbsp;</div></li><li><div>              if ( $pos === false )&nbsp;</div></li><li><div>                  $whitelist_options[ $page ][] = $key;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $whitelist_options;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Removes a list of options from the options whitelist.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @global array $whitelist_options</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param array        $del_options</span>&nbsp;</div></li><li><div><span class="comment"> * @param string|array $options</span>&nbsp;</div></li><li><div><span class="comment"> * @return array</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function remove_option_whitelist( $del_options, $options = '' ) {&nbsp;</div></li><li><div>  if ( $options == '' )&nbsp;</div></li><li><div>      global $whitelist_options;&nbsp;</div></li><li><div>  else&nbsp;</div></li><li><div>      $whitelist_options = $options;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  foreach ( $del_options as $page =&gt; $keys ) {&nbsp;</div></li><li><div>      foreach ( $keys as $key ) {&nbsp;</div></li><li><div>          if ( isset($whitelist_options[ $page ]) && is_array($whitelist_options[ $page ]) ) {&nbsp;</div></li><li><div>              $pos = array_search( $key, $whitelist_options[ $page ] );&nbsp;</div></li><li><div>              if ( $pos !== false )&nbsp;</div></li><li><div>                  unset( $whitelist_options[ $page ][ $pos ] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  return $whitelist_options;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Output nonce, action, and option_page fields for a settings page.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $option_group A settings group name. This should match the group name used in register_setting().</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function settings_fields($option_group) {&nbsp;</div></li><li><div>  echo &quot;&lt;input type='hidden' name='option_page' value='&quot; . esc_attr($option_group) . &quot;' /&gt;&quot;;&nbsp;</div></li><li><div>  echo '&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;update&quot; /&gt;';&nbsp;</div></li><li><div>  wp_nonce_field(&quot;$option_group-options&quot;);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Clears the Plugins cache used by get_plugins() and by default, the Plugin Update cache.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 3.7.0</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @param bool $clear_update_cache Whether to clear the Plugin updates cache</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function wp_clean_plugins_cache( $clear_update_cache = true ) {&nbsp;</div></li><li><div>  if ( $clear_update_cache )&nbsp;</div></li><li><div>      delete_site_transient( 'update_plugins' );&nbsp;</div></li><li><div>  wp_cache_delete( 'plugins', 'plugins' );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * @param string $plugin</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function plugin_sandbox_scrape( $plugin ) {&nbsp;</div></li><li><div>  wp_register_plugin_realpath( WP_PLUGIN_DIR . '/' . $plugin );&nbsp;</div></li><li><div>  include( WP_PLUGIN_DIR . '/' . $plugin );&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>file</li><li><span></span></li><li><span></span>wp-admin</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2017 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer> <script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>