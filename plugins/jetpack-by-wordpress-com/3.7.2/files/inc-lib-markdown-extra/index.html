<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="plugin" data-version="3.7.2" data-slug="jetpack-by-wordpress-com" data-type="file" data-id="11660"><head xmlns="http://www.w3.org/1999/xhtml"><title> inc-lib-markdown-extra | file | Jetpack By WordPress Com | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, plugin, jetpack-by-wordpress-com, 3.7.2" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.26"}};!function(e,n,t){var a;function i(e){var t=n.createElement("canvas"),a=t.getContext&&t.getContext("2d"),i=String.fromCharCode;return!(!a||!a.fillText)&&(a.textBaseline="top",a.font="600 32px Arial","flag"===e?(a.fillText(i(55356,56806,55356,56826),0,0),3e3<t.toDataURL().length):"diversity"===e?(a.fillText(i(55356,57221),0,0),t=a.getImageData(16,16,1,1).data,a.fillText(i(55356,57221,55356,57343),0,0),(t=a.getImageData(16,16,1,1).data)[0],t[1],t[2],t[3],!0):("simple"===e?a.fillText(i(55357,56835),0,0):a.fillText(i(55356,57135),0,0),0!==a.getImageData(16,16,1,1).data[0]))}function o(e){var t=n.createElement("script");t.src=e,t.type="text/javascript",n.getElementsByTagName("head")[0].appendChild(t)}t.supports={simple:i("simple"),flag:i("flag"),unicode8:i("unicode8"),diversity:i("diversity")},t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.simple&&t.supports.flag&&t.supports.unicode8&&t.supports.diversity||(a=function(){t.readyCallback()},n.addEventListener?(n.addEventListener("DOMContentLoaded",a,!1),e.addEventListener("load",a,!1)):(e.attachEvent("onload",a),n.attachEvent("onreadystatechange",function(){"complete"===n.readyState&&t.readyCallback()})),(a=t.source||{}).concatemoji?o(a.concatemoji):a.wpemoji&&a.twemoji&&(o(a.twemoji),o(a.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=412f7b00f4749a5956ea542b6d5f239e' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.26' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/inc-lib-markdown-extra/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Finc-lib-markdown-extra%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Finc-lib-markdown-extra%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-jetpack-by-wordpress-com-3.7.2-file-inc-lib-markdown-extra","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="inc-lib-markdown-extra" class="single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to jetpack-by-wordpress-com." href="http://hookr.io/plugins/jetpack-by-wordpress-com/" class="plugin"><span property="name">jetpack-by-wordpress-com</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 3.7.2." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/" class="H_VERSION"><span property="name">3.7.2</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to files." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/files/" class=""><span property="name">files</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">inc-lib-markdown-extra</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="1480"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/all/" title="All">All <span class="count badge">1480</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="587"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/hooks/" title="Hooks">Hooks <span class="count badge">587</span></a></li><li class="" data-id="action" data-count="194"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/actions/" title="Actions">Actions <span class="count badge">194</span></a></li><li class="" data-id="filter" data-count="393"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/filters/" title="Filters">Filters <span class="count badge">393</span></a></li><li class="" data-id="class" data-count="259"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/classes/" title="Classes">Classes <span class="count badge">259</span></a></li><li class="" data-id="constant" data-count="62"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/constants/" title="Constants">Constants <span class="count badge">62</span></a></li><li class="" data-id="function" data-count="528"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/functions/" title="Functions">Functions <span class="count badge">528</span></a></li><li class="" data-id="shortcode" data-count="44"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">44</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/_inc/lib/markdown/extra.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># Markdown Extra  -  A text-to-HTML conversion tool for web writers&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># PHP Markdown & Extra&nbsp;</div></li><li><div># Copyright (c) 2004-2013 Michel Fortin&nbsp;</div></li><li><div># &lt;http:<span class="comment">//michelf.ca/projects/php-markdown/&gt;</span>&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># Original Markdown&nbsp;</div></li><li><div># Copyright (c) 2004-2006 John Gruber&nbsp;</div></li><li><div># &lt;http:<span class="comment">//daringfireball.net/projects/markdown/&gt;</span>&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># Tweaked to remove WordPress interface&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>define( 'MARKDOWN_VERSION', &quot;1.0.2&quot; ); # 29 Nov 2013&nbsp;</div></li><li><div>define( 'MARKDOWNEXTRA_VERSION', &quot;1.2.8&quot; ); # 29 Nov 2013&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># Global default settings:&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div>&nbsp;</div></li><li><div># Change to &quot;&gt;&quot; for HTML output&nbsp;</div></li><li><div>@define( 'MARKDOWN_EMPTY_ELEMENT_SUFFIX', &quot; /&gt;&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div># Define the width of a tab for code blocks.&nbsp;</div></li><li><div>@define( 'MARKDOWN_TAB_WIDTH', 4 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div># Optional title attribute for footnote links and backlinks.&nbsp;</div></li><li><div>@define( 'MARKDOWN_FN_LINK_TITLE', &quot;&quot; );&nbsp;</div></li><li><div>@define( 'MARKDOWN_FN_BACKLINK_TITLE', &quot;&quot; );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div># Optional class attribute for footnote links and backlinks.&nbsp;</div></li><li><div>@define( 'MARKDOWN_FN_LINK_CLASS', &quot;&quot; );&nbsp;</div></li><li><div>@define( 'MARKDOWN_FN_BACKLINK_CLASS', &quot;&quot; );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div># Optional class prefix for fenced code block.&nbsp;</div></li><li><div>@define( 'MARKDOWN_CODE_CLASS_PREFIX', &quot;&quot; );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div># Class attribute for code blocks goes on the `code` tag;&nbsp;</div></li><li><div># setting this to true will put attributes on the `pre` tag instead.&nbsp;</div></li><li><div>@define( 'MARKDOWN_CODE_ATTR_ON_PRE', false );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>### Standard Function Interface ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>@define( 'MARKDOWN_PARSER_CLASS', 'MarkdownExtra_Parser' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>function Markdown($text) {&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># Initialize the parser and return the result of its transform method.&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div>  # Setup static parser variable.&nbsp;</div></li><li><div>  static $parser;&nbsp;</div></li><li><div>  if (!isset($parser)) {&nbsp;</div></li><li><div>      $parser_class = MARKDOWN_PARSER_CLASS;&nbsp;</div></li><li><div>      $parser = new $parser_class;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Transform text using parser.&nbsp;</div></li><li><div>  return $parser-&gt;transform($text);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># Markdown Parser Class&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>class Markdown_Parser {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### Configuration Variables ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Change to &quot;&gt;&quot; for HTML output.&nbsp;</div></li><li><div>  public $empty_element_suffix = MARKDOWN_EMPTY_ELEMENT_SUFFIX;&nbsp;</div></li><li><div>  public $tab_width = MARKDOWN_TAB_WIDTH;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Change to `true` to disallow markup or entities.&nbsp;</div></li><li><div>  public $no_markup = false;&nbsp;</div></li><li><div>  public $no_entities = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Predefined urls and titles for reference links and images.&nbsp;</div></li><li><div>  public $predef_urls = array();&nbsp;</div></li><li><div>  public $predef_titles = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### Parser Implementation ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Regex to match balanced [brackets].&nbsp;</div></li><li><div>  # Needed to insert a maximum bracked depth while converting to PHP.&nbsp;</div></li><li><div>  public $nested_brackets_depth = 6;&nbsp;</div></li><li><div>  public $nested_brackets_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  public $nested_url_parenthesis_depth = 4;&nbsp;</div></li><li><div>  public $nested_url_parenthesis_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Table of hash values for escaped characters:&nbsp;</div></li><li><div>  public $escape_chars = '\`*_{}[]()&gt;#+-.!';&nbsp;</div></li><li><div>  public $escape_chars_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __construct() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Constructor function. Initialize appropriate member variables.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $this-&gt;_initDetab();&nbsp;</div></li><li><div>      $this-&gt;prepareItalicsAndBold();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;nested_brackets_re =&nbsp;</div></li><li><div>          str_repeat('(?&gt;[^\[\]]+|\[', $this-&gt;nested_brackets_depth).&nbsp;</div></li><li><div>          str_repeat('\])*', $this-&gt;nested_brackets_depth);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;nested_url_parenthesis_re =&nbsp;</div></li><li><div>          str_repeat('(?&gt;[^()\s]+|\(', $this-&gt;nested_url_parenthesis_depth).&nbsp;</div></li><li><div>          str_repeat('(?&gt;\)))*', $this-&gt;nested_url_parenthesis_depth);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;escape_chars_re = '['.preg_quote($this-&gt;escape_chars).']';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Sort document, block, and span gamut in ascendent priority order.&nbsp;</div></li><li><div>      asort($this-&gt;document_gamut);&nbsp;</div></li><li><div>      asort($this-&gt;block_gamut);&nbsp;</div></li><li><div>      asort($this-&gt;span_gamut);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Internal hashes used during transformation.&nbsp;</div></li><li><div>  public $urls = array();&nbsp;</div></li><li><div>  public $titles = array();&nbsp;</div></li><li><div>  public $html_hashes = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Status flag to avoid invalid nesting.&nbsp;</div></li><li><div>  public $in_anchor = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function setup() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Called before the transformation process starts to setup parser&nbsp;</div></li><li><div>  # states.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # Clear global hashes.&nbsp;</div></li><li><div>      $this-&gt;urls = $this-&gt;predef_urls;&nbsp;</div></li><li><div>      $this-&gt;titles = $this-&gt;predef_titles;&nbsp;</div></li><li><div>      $this-&gt;html_hashes = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;in_anchor = false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function teardown() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Called after the transformation process to clear any variable&nbsp;</div></li><li><div>  # which may be taking up memory unnecessarly.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $this-&gt;urls = array();&nbsp;</div></li><li><div>      $this-&gt;titles = array();&nbsp;</div></li><li><div>      $this-&gt;html_hashes = array();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function transform($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Main function. Performs some preprocessing on the input text&nbsp;</div></li><li><div>  # and pass it through the document gamut.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $this-&gt;setup();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Remove UTF-8 BOM and marker character in input, if present.&nbsp;</div></li><li><div>      $text = preg_replace('{^\xEF\xBB\xBF|\x1A}', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Standardize line endings:&nbsp;</div></li><li><div>      #   DOS to Unix and Mac to Unix&nbsp;</div></li><li><div>      $text = preg_replace('{\r\n?}', &quot;\n&quot;, $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Make sure $text ends with a couple of newlines:&nbsp;</div></li><li><div>      $text .= &quot;\n\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Convert all tabs to spaces.&nbsp;</div></li><li><div>      $text = $this-&gt;detab($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Turn block-level HTML blocks into hash entries&nbsp;</div></li><li><div>      $text = $this-&gt;hashHTMLBlocks($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Strip any lines consisting only of spaces and tabs.&nbsp;</div></li><li><div>      # This makes subsequent regexen easier to write, because we can&nbsp;</div></li><li><div>      # match consecutive blank lines with /\n+/ instead of something&nbsp;</div></li><li><div>      # contorted like /[ ]*\n+/ .&nbsp;</div></li><li><div>      $text = preg_replace('/^[ ]+$/m', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Run document gamut methods.&nbsp;</div></li><li><div>      foreach ($this-&gt;document_gamut as $method =&gt; $priority) {&nbsp;</div></li><li><div>          $text = $this-&gt;$method($text);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;teardown();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text . &quot;\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  public $document_gamut = array(&nbsp;</div></li><li><div>      # Strip link definitions, store in hashes.&nbsp;</div></li><li><div>      &quot;stripLinkDefinitions&quot; =&gt; 20, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      &quot;runBasicBlockGamut&quot; =&gt; 30, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function stripLinkDefinitions($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Strips link definitions from text, stores the URLs and titles in&nbsp;</div></li><li><div>  # hash references.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Link defs are in the form: ^[id]: url &quot;optional title&quot;&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>                          ^[ ]{0, '.$less_than_tab.'}\[(.+)\][ ]?:    # id = $1&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                            \n?                # maybe *one* newline&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                          (?:&nbsp;</div></li><li><div>                            &lt;(.+?)&gt;            # url = $2&nbsp;</div></li><li><div>                          |&nbsp;</div></li><li><div>                            (\S+?)            # url = $3&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                            \n?                # maybe one newline&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                          (?:&nbsp;</div></li><li><div>                              (?&lt;=\s)            # lookbehind for whitespace&nbsp;</div></li><li><div>                              [&quot;(]&nbsp;</div></li><li><div>                              (.*?)            # title = $4&nbsp;</div></li><li><div>                              [&quot;)]&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div> )?    # title is optional&nbsp;</div></li><li><div>                          (?:\n+|\Z)&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_stripLinkDefinitions_callback'), &nbsp;</div></li><li><div>          $text);&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _stripLinkDefinitions_callback($matches) {&nbsp;</div></li><li><div>      $link_id = strtolower($matches[1]);&nbsp;</div></li><li><div>      $url = $matches[2] == '' ? $matches[3] : $matches[2];&nbsp;</div></li><li><div>      $this-&gt;urls[$link_id] = $url;&nbsp;</div></li><li><div>      $this-&gt;titles[$link_id] =& $matches[4];&nbsp;</div></li><li><div>      return ''; # String that will replace the block&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function hashHTMLBlocks($text) {&nbsp;</div></li><li><div>      if ($this-&gt;no_markup)  return $text;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Hashify HTML blocks:&nbsp;</div></li><li><div>      # We only want to do this for block-level HTML tags, such as headers, &nbsp;</div></li><li><div>      # lists, and tables. That's because we still want to wrap &lt;p&gt;s around&nbsp;</div></li><li><div>      # &quot;paragraphs&quot; that are wrapped in non-block-level tags, such as anchors, &nbsp;</div></li><li><div>      # phrase emphasis, and spans. The list of tags we're looking for is&nbsp;</div></li><li><div>      # hard-coded:&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # *  List &quot;a&quot; is made of tags which can be both inline or block-level.&nbsp;</div></li><li><div>      #    These will be treated block-level when the start tag is alone on&nbsp;</div></li><li><div>      #    its line, otherwise they're not matched here and will be taken as&nbsp;</div></li><li><div>      #    inline later.&nbsp;</div></li><li><div>      # *  List &quot;b&quot; is made of tags which are always block-level;&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $block_tags_a_re = 'ins|del';&nbsp;</div></li><li><div>      $block_tags_b_re = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|'.&nbsp;</div></li><li><div>                         'script|noscript|form|fieldset|iframe|math|svg|'.&nbsp;</div></li><li><div>                         'article|section|nav|aside|hgroup|header|footer|'.&nbsp;</div></li><li><div>                         'figure';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Regular expression for the content of a block tag.&nbsp;</div></li><li><div>      $nested_tags_level = 4;&nbsp;</div></li><li><div>      $attr = '&nbsp;</div></li><li><div>          (?&gt;                # optional tag attributes&nbsp;</div></li><li><div>            \s            # starts with whitespace&nbsp;</div></li><li><div>            (?&gt;&nbsp;</div></li><li><div>              [^&gt;&quot;/]+        # text outside quotes&nbsp;</div></li><li><div>            |&nbsp;</div></li><li><div>              /+(?!&gt;)        # slash not followed by &quot;&gt;&quot;&nbsp;</div></li><li><div>            |&nbsp;</div></li><li><div>              &quot;[^&quot;]*&quot;        # text inside double quotes (tolerate &quot;&gt;&quot;)&nbsp;</div></li><li><div>            |&nbsp;</div></li><li><div>              \'[^\']*\'    # text inside single quotes (tolerate &quot;&gt;&quot;)&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>          ';&nbsp;</div></li><li><div>      $content =&nbsp;</div></li><li><div>          str_repeat('&nbsp;</div></li><li><div>              (?&gt;&nbsp;</div></li><li><div>                [^&lt;]+            # content without tag&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                &lt;\2            # nested opening tag&nbsp;</div></li><li><div>                  '.$attr.'    # attributes&nbsp;</div></li><li><div>                  (?&gt;&nbsp;</div></li><li><div>                    /&gt;&nbsp;</div></li><li><div>                  |&nbsp;</div></li><li><div>                    &gt;', $nested_tags_level).    # end of opening tag&nbsp;</div></li><li><div>                    '.*?'.                    # last level nested tag content&nbsp;</div></li><li><div>          str_repeat('&nbsp;</div></li><li><div>                    &lt;/\2\s*&gt;    # closing nested tag&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                  &lt;(?!/\2\s*&gt;    # other tags with a different name&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )*', &nbsp;</div></li><li><div>              $nested_tags_level);&nbsp;</div></li><li><div>      $content2 = str_replace('\2', '\3', $content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # First, look for nested blocks, e.g.:&nbsp;</div></li><li><div>      #     &lt;div&gt;&nbsp;</div></li><li><div>      #         &lt;div&gt;&nbsp;</div></li><li><div>      #         tags for inner block must be indented.&nbsp;</div></li><li><div>      #         &lt;/div&gt;&nbsp;</div></li><li><div>      #     &lt;/div&gt;&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # The outermost tags must start at the left margin for this to match, and&nbsp;</div></li><li><div>      # the inner nested divs must be indented.&nbsp;</div></li><li><div>      # We need to do this before the next, more liberal match, because the next&nbsp;</div></li><li><div>      # match will start at the first `&lt;div&gt;` and stop at the first `&lt;/div&gt;`.&nbsp;</div></li><li><div>      $text = preg_replace_callback('{(?&gt;&nbsp;</div></li><li><div>          (?&gt;&nbsp;</div></li><li><div>              (?&lt;=\n\n)        # Starting after a blank line&nbsp;</div></li><li><div>              |                # or&nbsp;</div></li><li><div>              \A\n?            # the beginning of the doc&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          (                        # save in $1&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # Match from `\n&lt;tag&gt;` to `&lt;/tag&gt;\n`, handling nested tags&nbsp;</div></li><li><div>            # in between.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                      [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                      &lt;('.$block_tags_b_re.')# start tag = $2&nbsp;</div></li><li><div>                      '.$attr.'&gt;            # attributes followed by &gt; and \n&nbsp;</div></li><li><div>                      '.$content.'        # content, support nesting&nbsp;</div></li><li><div>                      &lt;/\2&gt;                # the matching end tag&nbsp;</div></li><li><div>                      [ ]*                # trailing spaces/tabs&nbsp;</div></li><li><div>                      (?=\n+|\Z)    # followed by a newline or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          | # Special version for tags of group a.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                      [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                      &lt;('.$block_tags_a_re.')# start tag = $3&nbsp;</div></li><li><div>                      '.$attr.'&gt;[ ]*\n    # attributes followed by &gt;&nbsp;</div></li><li><div>                      '.$content2.'        # content, support nesting&nbsp;</div></li><li><div>                      &lt;/\3&gt;                # the matching end tag&nbsp;</div></li><li><div>                      [ ]*                # trailing spaces/tabs&nbsp;</div></li><li><div>                      (?=\n+|\Z)    # followed by a newline or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          | # Special case just for &lt;hr /&gt;. It was easier to make a special&nbsp;</div></li><li><div>            # case than to make the other regex more complicated.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                      [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                      &lt;(hr)                # start tag = $2&nbsp;</div></li><li><div>                      '.$attr.'            # attributes&nbsp;</div></li><li><div>                      /?&gt;                    # the matching end tag&nbsp;</div></li><li><div>                      [ ]*&nbsp;</div></li><li><div>                      (?=\n{2, }|\Z)        # followed by a blank line or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          | # Special case for standalone HTML comments:&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                  (?s:&nbsp;</div></li><li><div>                      &lt;!-- .*? --&gt;&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                  [ ]*&nbsp;</div></li><li><div>                  (?=\n{2, }|\Z)        # followed by a blank line or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          | # PHP and ASP-style processor instructions (&lt;? and &lt;%)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                  (?s:&nbsp;</div></li><li><div>                      &lt;([?%])            # $2&nbsp;</div></li><li><div>                      .*?&nbsp;</div></li><li><div>                      \2&gt;&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                  [ ]*&nbsp;</div></li><li><div>                  (?=\n{2, }|\Z)        # followed by a blank line or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )}Sxmi', &nbsp;</div></li><li><div>          array(&$this, '_hashHTMLBlocks_callback'), &nbsp;</div></li><li><div>          $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _hashHTMLBlocks_callback($matches) {&nbsp;</div></li><li><div>      $text = $matches[1];&nbsp;</div></li><li><div>      $key = $this-&gt;hashBlock($text);&nbsp;</div></li><li><div>      return &quot;\n\n$key\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function hashPart($text, $boundary = 'X') {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Called whenever a tag must be hashed when a function insert an atomic&nbsp;</div></li><li><div>  # element in the text stream. Passing $text to through this function gives&nbsp;</div></li><li><div>  # a unique text-token which will be reverted back when calling unhash.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # The $boundary argument specify what character should be used to surround&nbsp;</div></li><li><div>  # the token. By convension, &quot;B&quot; is used for block elements that needs not&nbsp;</div></li><li><div>  # to be wrapped into paragraph tags at the end, &quot;:&quot; is used for elements&nbsp;</div></li><li><div>  # that are word separators and &quot;X&quot; is used in the general case.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # Swap back any tag hash found in $text so we do not have to `unhash`&nbsp;</div></li><li><div>      # multiple times at the end.&nbsp;</div></li><li><div>      $text = $this-&gt;unhash($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Then hash the block.&nbsp;</div></li><li><div>      static $i = 0;&nbsp;</div></li><li><div>      $key = &quot;$boundary\x1A&quot; . ++$i . $boundary;&nbsp;</div></li><li><div>      $this-&gt;html_hashes[$key] = $text;&nbsp;</div></li><li><div>      return $key; # String that will replace the tag.&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function hashBlock($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Shortcut function for hashPart with block-level boundaries.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      return $this-&gt;hashPart($text, 'B');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  public $block_gamut = array(&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # These are all the transformations that form block-level&nbsp;</div></li><li><div>  # tags like paragraphs, headers, and list items.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      &quot;doHeaders&quot; =&gt; 10, &nbsp;</div></li><li><div>      &quot;doHorizontalRules&quot; =&gt; 20, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      &quot;doLists&quot; =&gt; 40, &nbsp;</div></li><li><div>      &quot;doCodeBlocks&quot; =&gt; 50, &nbsp;</div></li><li><div>      &quot;doBlockQuotes&quot; =&gt; 60, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function runBlockGamut($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Run block gamut tranformations.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # We need to escape raw HTML in Markdown source before doing anything&nbsp;</div></li><li><div>      # else. This need to be done for each block, and not only at the&nbsp;</div></li><li><div>      # beginning in the Markdown function since hashed blocks can be part of&nbsp;</div></li><li><div>      # list items and could have been indented. Indented blocks would have&nbsp;</div></li><li><div>      # been seen as a code block in a previous pass of hashHTMLBlocks.&nbsp;</div></li><li><div>      $text = $this-&gt;hashHTMLBlocks($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;runBasicBlockGamut($text);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function runBasicBlockGamut($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Run block gamut tranformations, without hashing HTML blocks. This is&nbsp;</div></li><li><div>  # useful when HTML blocks are known to be already hashed, like in the first&nbsp;</div></li><li><div>  # whole-document pass.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      foreach ($this-&gt;block_gamut as $method =&gt; $priority) {&nbsp;</div></li><li><div>          $text = $this-&gt;$method($text);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Finally form paragraph and restore hashed blocks.&nbsp;</div></li><li><div>      $text = $this-&gt;formParagraphs($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doHorizontalRules($text) {&nbsp;</div></li><li><div>      # Do Horizontal Rules:&nbsp;</div></li><li><div>      return preg_replace(&nbsp;</div></li><li><div>          '{&nbsp;</div></li><li><div>              ^[ ]{0, 3}    # Leading space&nbsp;</div></li><li><div>              ([-*_])        # $1: First marker&nbsp;</div></li><li><div>              (?&gt;            # Repeated marker group&nbsp;</div></li><li><div>                  [ ]{0, 2}    # Zero, one, or two spaces.&nbsp;</div></li><li><div>                  \1            # Marker character&nbsp;</div></li><li><div> ) {2, }        # Group repeated at least twice&nbsp;</div></li><li><div>              [ ]*        # Tailing spaces&nbsp;</div></li><li><div>              $            # End of line.&nbsp;</div></li><li><div>          }mx', &nbsp;</div></li><li><div>          &quot;\n&quot;.$this-&gt;hashBlock(&quot;&lt;hr$this-&gt;empty_element_suffix&quot;).&quot;\n&quot;, &nbsp;</div></li><li><div>          $text);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  public $span_gamut = array(&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # These are all the transformations that occur *within* block-level&nbsp;</div></li><li><div>  # tags like paragraphs, headers, and list items.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # Process character escapes, code spans, and inline HTML&nbsp;</div></li><li><div>      # in one shot.&nbsp;</div></li><li><div>      &quot;parseSpan&quot; =&gt; -30, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Process anchor and image tags. Images must come first, &nbsp;</div></li><li><div>      # because ![foo][f] looks like an anchor.&nbsp;</div></li><li><div>      &quot;doImages&quot; =&gt;  10, &nbsp;</div></li><li><div>      &quot;doAnchors&quot; =&gt;  20, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Make links out of things like `&lt;http:<span class="comment">//example.com/&gt;`</span>&nbsp;</div></li><li><div>      # Must come after doAnchors, because you can use &lt; and &gt;&nbsp;</div></li><li><div>      # delimiters in inline links like [this](&lt;url&gt;).&nbsp;</div></li><li><div>      &quot;doAutoLinks&quot; =&gt;  30, &nbsp;</div></li><li><div>      &quot;encodeAmpsAndAngles&quot; =&gt;  40, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      &quot;doItalicsAndBold&quot; =&gt;  50, &nbsp;</div></li><li><div>      &quot;doHardBreaks&quot; =&gt;  60, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function runSpanGamut($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Run span gamut tranformations.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      foreach ($this-&gt;span_gamut as $method =&gt; $priority) {&nbsp;</div></li><li><div>          $text = $this-&gt;$method($text);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doHardBreaks($text) {&nbsp;</div></li><li><div>      # Do hard breaks:&nbsp;</div></li><li><div>      return preg_replace_callback('/ {2, }\n/', &nbsp;</div></li><li><div>          array(&$this, '_doHardBreaks_callback'), $text);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doHardBreaks_callback($matches) {&nbsp;</div></li><li><div>      return $this-&gt;hashPart(&quot;&lt;br$this-&gt;empty_element_suffix\n&quot;);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doAnchors($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Turn Markdown link shortcuts into XHTML &lt;a&gt; tags.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if ($this-&gt;in_anchor) return $text;&nbsp;</div></li><li><div>      $this-&gt;in_anchor = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # First, handle reference-style links: [link text] [id]&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                    # wrap whole match in $1&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            [ ]?                # one optional space&nbsp;</div></li><li><div>            (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              (.*?)        # id = $3&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Next, inline-style links: [link text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                # wrap whole match in $1&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>            \(            # literal paren&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  &lt;(.+?)&gt;    # href = $3&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  ('.$this-&gt;nested_url_parenthesis_re.')    # href = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (            # $5&nbsp;</div></li><li><div>                ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                (.*?)        # Title = $7&nbsp;</div></li><li><div>                \6        # matching quote&nbsp;</div></li><li><div>                [ \n]*    # ignore any spaces/tabs between closing quote and )&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>            \)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doAnchors_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Last, handle reference-style shortcuts: [link text]&nbsp;</div></li><li><div>      # These must come last in case you've also got [link text][1]&nbsp;</div></li><li><div>      # or [link text](/foo)&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                    # wrap whole match in $1&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              ([^\[\]]+)        # link text = $2; can\'t contain [ or ]&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;in_anchor = false;&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAnchors_reference_callback($matches) {&nbsp;</div></li><li><div>      $whole_match =  $matches[1];&nbsp;</div></li><li><div>      $link_text =  $matches[2];&nbsp;</div></li><li><div>      $link_id =& $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>          # for shortcut links like [this][] or [this].&nbsp;</div></li><li><div>          $link_id = $link_text;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # lower-case and turn embedded newlines into spaces&nbsp;</div></li><li><div>      $link_id = strtolower($link_id);&nbsp;</div></li><li><div>      $link_id = preg_replace('{[ ]?\n}', ' ', $link_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>          $url = $this-&gt;urls[$link_id];&nbsp;</div></li><li><div>          $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>          if ( isset( $this-&gt;titles[$link_id] ) ) {&nbsp;</div></li><li><div>              $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>              $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>              $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>          $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>          $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>          $result = $whole_match;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAnchors_inline_callback($matches) {&nbsp;</div></li><li><div>      $whole_match =  $matches[1];&nbsp;</div></li><li><div>      $link_text =  $this-&gt;runSpanGamut($matches[2]);&nbsp;</div></li><li><div>      $url =  $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>      $title =& $matches[7];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>      if (isset($title)) {&nbsp;</div></li><li><div>          $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>          $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>      $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doImages($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Turn Markdown image shortcuts into &lt;img&gt; tags.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # First, handle reference-style labeled images: ![alt text][id]&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                # wrap whole match in $1&nbsp;</div></li><li><div>            !\[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            [ ]?                # one optional space&nbsp;</div></li><li><div>            (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              (.*?)        # id = $3&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doImages_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Next, handle inline images:  ![alt text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>      # Don't forget: encode * and _&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                # wrap whole match in $1&nbsp;</div></li><li><div>            !\[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>            \s?            # One optional whitespace character&nbsp;</div></li><li><div>            \(            # literal paren&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  &lt;(\S*)&gt;    # src url = $3&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  ('.$this-&gt;nested_url_parenthesis_re.')    # src url = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (            # $5&nbsp;</div></li><li><div>                ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                (.*?)        # title = $7&nbsp;</div></li><li><div>                \6        # matching quote&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>            \)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doImages_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doImages_reference_callback($matches) {&nbsp;</div></li><li><div>      $whole_match = $matches[1];&nbsp;</div></li><li><div>      $alt_text = $matches[2];&nbsp;</div></li><li><div>      $link_id = strtolower($matches[3]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>          $link_id = strtolower($alt_text); # for shortcut links like ![this][].&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>      if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>          $url = $this-&gt;encodeAttribute($this-&gt;urls[$link_id]);&nbsp;</div></li><li><div>          $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>          if (isset($this-&gt;titles[$link_id])) {&nbsp;</div></li><li><div>              $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>              $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>              $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>          $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>          # If there's no such link ID, leave intact:&nbsp;</div></li><li><div>          $result = $whole_match;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doImages_inline_callback($matches) {&nbsp;</div></li><li><div>      $whole_match = $matches[1];&nbsp;</div></li><li><div>      $alt_text = $matches[2];&nbsp;</div></li><li><div>      $url = $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>      $title =& $matches[7];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>      $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>      $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>      if (isset($title)) {&nbsp;</div></li><li><div>          $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>          $result .=  &quot; title=\&quot;$title\&quot;&quot;; # $title already quoted&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doHeaders($text) {&nbsp;</div></li><li><div>      # Setext-style headers:&nbsp;</div></li><li><div>      #      Header 1&nbsp;</div></li><li><div>      # ========&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      #      Header 2&nbsp;</div></li><li><div>      #      --------&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{ ^(.+?)[ ]*\n(=+|-+)[ ]*\n+ }mx', &nbsp;</div></li><li><div>          array(&$this, '_doHeaders_callback_setext'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # atx-style headers:&nbsp;</div></li><li><div>      #    # Header 1&nbsp;</div></li><li><div>      #    ## Header 2&nbsp;</div></li><li><div>      #    ## Header 2 with closing hashes ##&nbsp;</div></li><li><div>      #    ...&nbsp;</div></li><li><div>      #    ###### Header 6&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>              ^(\#{1, 6})    # $1 = string of #\'s&nbsp;</div></li><li><div>              [ ]*&nbsp;</div></li><li><div>              (.+?)        # $2 = Header text&nbsp;</div></li><li><div>              [ ]*&nbsp;</div></li><li><div>              \#*            # optional closing #\'s (not counted)&nbsp;</div></li><li><div>              \n+&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_doHeaders_callback_atx'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doHeaders_callback_setext($matches) {&nbsp;</div></li><li><div>      # Terrible hack to check we haven't found an empty list item.&nbsp;</div></li><li><div>      if ($matches[2] == '-' && preg_match('{^-(?: |$)}', $matches[1]))&nbsp;</div></li><li><div>          return $matches[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $level = $matches[2]{0} == '=' ? 1 : 2;&nbsp;</div></li><li><div>      $block = &quot;&lt;h$level&gt;&quot;.$this-&gt;runSpanGamut($matches[1]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>      return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doHeaders_callback_atx($matches) {&nbsp;</div></li><li><div>      $level = strlen($matches[1]);&nbsp;</div></li><li><div>      $block = &quot;&lt;h$level&gt;&quot;.$this-&gt;runSpanGamut($matches[2]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>      return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doLists($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Form HTML ordered (numbered) and unordered (bulleted) lists.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Re-usable patterns to match list item bullets and number markers:&nbsp;</div></li><li><div>      $marker_ul_re = '[*+-]';&nbsp;</div></li><li><div>      $marker_ol_re = '\d+[\.]';&nbsp;</div></li><li><div>      $marker_any_re = &quot;(?:$marker_ul_re|$marker_ol_re)&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $markers_relist = array(&nbsp;</div></li><li><div>          $marker_ul_re =&gt; $marker_ol_re, &nbsp;</div></li><li><div>          $marker_ol_re =&gt; $marker_ul_re, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ($markers_relist as $marker_re =&gt; $other_marker_re) {&nbsp;</div></li><li><div>          # Re-usable pattern to match any entirel ul or ol list:&nbsp;</div></li><li><div>          $whole_list_re = '&nbsp;</div></li><li><div>              (                                # $1 = whole list&nbsp;</div></li><li><div>                (                                # $2&nbsp;</div></li><li><div>                  ([ ]{0, '.$less_than_tab.'})    # $3 = number of spaces&nbsp;</div></li><li><div>                  ('.$marker_re.')            # $4 = first list item marker&nbsp;</div></li><li><div>                  [ ]+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                (?s:.+?)&nbsp;</div></li><li><div>                (                                # $5&nbsp;</div></li><li><div>                    \z&nbsp;</div></li><li><div>                  |&nbsp;</div></li><li><div>                    \n{2, }&nbsp;</div></li><li><div>                    (?=\S)&nbsp;</div></li><li><div>                    (?!                        # Negative lookahead for another list item marker&nbsp;</div></li><li><div>                      [ ]*&nbsp;</div></li><li><div>                      '.$marker_re.'[ ]+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                  |&nbsp;</div></li><li><div>                    (?=                        # Lookahead for another kind of list&nbsp;</div></li><li><div>                      \n&nbsp;</div></li><li><div>                      \3                        # Must have the same indentation&nbsp;</div></li><li><div>                      '.$other_marker_re.'[ ]+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          '; <span class="comment"><span class="comment">// mx</span></span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          # We use a different prefix before nested lists than top-level lists.&nbsp;</div></li><li><div>          # See extended comment in _ProcessListItems().&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($this-&gt;list_level) {&nbsp;</div></li><li><div>              $text = preg_replace_callback('{&nbsp;</div></li><li><div>                      ^&nbsp;</div></li><li><div>                      '.$whole_list_re.'&nbsp;</div></li><li><div>                  }mx', &nbsp;</div></li><li><div>                  array(&$this, '_doLists_callback'), $text);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else {&nbsp;</div></li><li><div>              $text = preg_replace_callback('{&nbsp;</div></li><li><div>                      (?:(?&lt;=\n)\n|\A\n?) # Must eat the newline&nbsp;</div></li><li><div>                      '.$whole_list_re.'&nbsp;</div></li><li><div>                  }mx', &nbsp;</div></li><li><div>                  array(&$this, '_doLists_callback'), $text);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doLists_callback($matches) {&nbsp;</div></li><li><div>      # Re-usable patterns to match list item bullets and number markers:&nbsp;</div></li><li><div>      $marker_ul_re = '[*+-]';&nbsp;</div></li><li><div>      $marker_ol_re = '\d+[\.]';&nbsp;</div></li><li><div>      $marker_any_re = &quot;(?:$marker_ul_re|$marker_ol_re)&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $list = $matches[1];&nbsp;</div></li><li><div>      $list_type = preg_match(&quot;/$marker_ul_re/&quot;, $matches[4]) ? &quot;ul&quot; : &quot;ol&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $marker_any_re = ( $list_type == &quot;ul&quot; ? $marker_ul_re : $marker_ol_re );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $list .= &quot;\n&quot;;&nbsp;</div></li><li><div>      $result = $this-&gt;processListItems($list, $marker_any_re);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $result = $this-&gt;hashBlock(&quot;&lt;$list_type&gt;\n&quot; . $result . &quot;&lt;/$list_type&gt;&quot;);&nbsp;</div></li><li><div>      return &quot;\n&quot;. $result .&quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  public $list_level = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function processListItems($list_str, $marker_any_re) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Process the contents of a single ordered or unordered list, splitting it&nbsp;</div></li><li><div>  #    into individual list items.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # The $this-&gt;list_level global keeps track of when we're inside a list.&nbsp;</div></li><li><div>      # Each time we enter a list, we increment it; when we leave a list, &nbsp;</div></li><li><div>      # we decrement. If it's zero, we're not in a list anymore.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # We do this because when we're not inside a list, we want to treat&nbsp;</div></li><li><div>      # something like this:&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      #        I recommend upgrading to version&nbsp;</div></li><li><div>      #        8. Oops, now this line is treated&nbsp;</div></li><li><div>      #        as a sub-list.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # As a single paragraph, despite the fact that the second line starts&nbsp;</div></li><li><div>      # with a digit-period-space sequence.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Whereas when we're inside a list (or sub-list), that line will be&nbsp;</div></li><li><div>      # treated as the start of a sub-list. What a kludge, huh? This is&nbsp;</div></li><li><div>      # an aspect of Markdown's syntax that's hard to parse perfectly&nbsp;</div></li><li><div>      # without resorting to mind-reading. Perhaps the solution is to&nbsp;</div></li><li><div>      # change the syntax rules such that sub-lists must start with a&nbsp;</div></li><li><div>      # starting cardinal number; e.g. &quot;1.&quot; or &quot;a.&quot;.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;list_level++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # trim trailing blank lines:&nbsp;</div></li><li><div>      $list_str = preg_replace(&quot;/\n{2, }\\z/&quot;, &quot;\n&quot;, $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $list_str = preg_replace_callback('{&nbsp;</div></li><li><div>          (\n)?                            # leading line = $1&nbsp;</div></li><li><div>          (^[ ]*)                            # leading whitespace = $2&nbsp;</div></li><li><div>          ('.$marker_any_re.'                # list marker and space = $3&nbsp;</div></li><li><div>              (?:[ ]+|(?=\n))    # space only required if item is not empty&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          ((?s:.*?))                        # list item text = $4&nbsp;</div></li><li><div>          (?:(\n+(?=\n))|\n)                # tailing blank line = $5&nbsp;</div></li><li><div>          (?= \n* (\z | \2 ('.$marker_any_re.') (?:[ ]+|(?=\n))))&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_processListItems_callback'), $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;list_level--;&nbsp;</div></li><li><div>      return $list_str;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _processListItems_callback($matches) {&nbsp;</div></li><li><div>      $item = $matches[4];&nbsp;</div></li><li><div>      $leading_line =& $matches[1];&nbsp;</div></li><li><div>      $leading_space =& $matches[2];&nbsp;</div></li><li><div>      $marker_space = $matches[3];&nbsp;</div></li><li><div>      $tailing_blank_line =& $matches[5];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($leading_line || $tailing_blank_line ||&nbsp;</div></li><li><div>          preg_match('/\n{2, }/', $item))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          # Replace marker with the appropriate whitespace indentation&nbsp;</div></li><li><div>          $item = $leading_space . str_repeat(' ', strlen($marker_space)) . $item;&nbsp;</div></li><li><div>          $item = $this-&gt;runBlockGamut($this-&gt;outdent($item).&quot;\n&quot;);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>          # Recursion for sub-lists:&nbsp;</div></li><li><div>          $item = $this-&gt;doLists($this-&gt;outdent($item));&nbsp;</div></li><li><div>          $item = preg_replace('/\n+$/', '', $item);&nbsp;</div></li><li><div>          $item = $this-&gt;runSpanGamut($item);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return &quot;&lt;li&gt;&quot; . $item . &quot;&lt;/li&gt;\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doCodeBlocks($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Process Markdown `&lt;pre&gt;&lt;code&gt;` blocks.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>              (?:\n\n|\A\n?)&nbsp;</div></li><li><div>              (                # $1 = the code block -- one or more lines, starting with a space/tab&nbsp;</div></li><li><div>                (?&gt;&nbsp;</div></li><li><div>                  [ ]{'.$this-&gt;tab_width.'}  # Lines must start with a tab or a tab-width of spaces&nbsp;</div></li><li><div>                  .*\n+&nbsp;</div></li><li><div> )+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              ((?=^[ ]{0, '.$this-&gt;tab_width.'}\S)|\Z)    # Lookahead for non-space at line-start, or end of doc&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_doCodeBlocks_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doCodeBlocks_callback($matches) {&nbsp;</div></li><li><div>      $codeblock = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $codeblock = $this-&gt;outdent($codeblock);&nbsp;</div></li><li><div>      $codeblock = htmlspecialchars($codeblock, ENT_NOQUOTES);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # trim leading newlines and trailing newlines&nbsp;</div></li><li><div>      $codeblock = preg_replace('/\A\n+|\n+\z/', '', $codeblock);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $codeblock = &quot;&lt;pre&gt;&lt;code&gt;$codeblock\n&lt;/code&gt;&lt;/pre&gt;&quot;;&nbsp;</div></li><li><div>      return &quot;\n\n&quot;.$this-&gt;hashBlock($codeblock).&quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function makeCodeSpan($code) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Create a code span markup for $code. Called from handleSpanToken.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $code = htmlspecialchars(trim($code), ENT_NOQUOTES);&nbsp;</div></li><li><div>      return $this-&gt;hashPart(&quot;&lt;code&gt;$code&lt;/code&gt;&quot;);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  public $em_relist = array(&nbsp;</div></li><li><div>      '' =&gt; '(?:(?&lt;!\*)\*(?!\*)|(?&lt;!_)_(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>      '*' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*(?!\*)', &nbsp;</div></li><li><div>      '_' =&gt; '(?&lt;=\S|^)(?&lt;!_)_(?!_)', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  public $strong_relist = array(&nbsp;</div></li><li><div>      '' =&gt; '(?:(?&lt;!\*)\*\*(?!\*)|(?&lt;!_)__(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>      '**' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*(?!\*)', &nbsp;</div></li><li><div>      '__' =&gt; '(?&lt;=\S|^)(?&lt;!_)__(?!_)', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  public $em_strong_relist = array(&nbsp;</div></li><li><div>      '' =&gt; '(?:(?&lt;!\*)\*\*\*(?!\*)|(?&lt;!_)___(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>      '***' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*\*(?!\*)', &nbsp;</div></li><li><div>      '___' =&gt; '(?&lt;=\S|^)(?&lt;!_)___(?!_)', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  public $em_strong_prepared_relist;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function prepareItalicsAndBold() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Prepare regular expressions for searching emphasis tokens in any&nbsp;</div></li><li><div>  # context.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      foreach ($this-&gt;em_relist as $em =&gt; $em_re) {&nbsp;</div></li><li><div>          foreach ($this-&gt;strong_relist as $strong =&gt; $strong_re) {&nbsp;</div></li><li><div>              # Construct list of allowed token expressions.&nbsp;</div></li><li><div>              $token_relist = array();&nbsp;</div></li><li><div>              if (isset($this-&gt;em_strong_relist[&quot;$em$strong&quot;])) {&nbsp;</div></li><li><div>                  $token_relist[] = $this-&gt;em_strong_relist[&quot;$em$strong&quot;];&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $token_relist[] = $em_re;&nbsp;</div></li><li><div>              $token_relist[] = $strong_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              # Construct master expression from list.&nbsp;</div></li><li><div>              $token_re = '{('. implode('|', $token_relist) .')}';&nbsp;</div></li><li><div>              $this-&gt;em_strong_prepared_relist[&quot;$em$strong&quot;] = $token_re;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doItalicsAndBold($text) {&nbsp;</div></li><li><div>      $token_stack = array('');&nbsp;</div></li><li><div>      $text_stack = array('');&nbsp;</div></li><li><div>      $em = '';&nbsp;</div></li><li><div>      $strong = '';&nbsp;</div></li><li><div>      $tree_char_em = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      while (1) {&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Get prepared regular expression for seraching emphasis tokens&nbsp;</div></li><li><div>          # in current context.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          $token_re = $this-&gt;em_strong_prepared_relist[&quot;$em$strong&quot;];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Each loop iteration search for the next emphasis token.&nbsp;</div></li><li><div>          # Each token is then passed to handleSpanToken.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          $parts = preg_split($token_re, $text, 2, PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>          $text_stack[0] .= $parts[0];&nbsp;</div></li><li><div>          $token =& $parts[1];&nbsp;</div></li><li><div>          $text =& $parts[2];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if (empty($token)) {&nbsp;</div></li><li><div>              # Reached end of text span: empty stack without emitting.&nbsp;</div></li><li><div>              # any more emphasis.&nbsp;</div></li><li><div>              while ($token_stack[0]) {&nbsp;</div></li><li><div>                  $text_stack[1] .= array_shift($token_stack);&nbsp;</div></li><li><div>                  $text_stack[0] .= array_shift($text_stack);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $token_len = strlen($token);&nbsp;</div></li><li><div>          if ($tree_char_em) {&nbsp;</div></li><li><div>              # Reached closing marker while inside a three-char emphasis.&nbsp;</div></li><li><div>              if ($token_len == 3) {&nbsp;</div></li><li><div>                  # Three-char closing marker, close em and strong.&nbsp;</div></li><li><div>                  array_shift($token_stack);&nbsp;</div></li><li><div>                  $span = array_shift($text_stack);&nbsp;</div></li><li><div>                  $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                  $span = &quot;&lt;strong&gt;&lt;em&gt;$span&lt;/em&gt;&lt;/strong&gt;&quot;;&nbsp;</div></li><li><div>                  $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                  $em = '';&nbsp;</div></li><li><div>                  $strong = '';&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  # Other closing marker: close one em or strong and&nbsp;</div></li><li><div>                  # change current token state to match the other&nbsp;</div></li><li><div>                  $token_stack[0] = str_repeat($token{0}, 3-$token_len);&nbsp;</div></li><li><div>                  $tag = $token_len == 2 ? &quot;strong&quot; : &quot;em&quot;;&nbsp;</div></li><li><div>                  $span = $text_stack[0];&nbsp;</div></li><li><div>                  $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                  $span = &quot;&lt;$tag&gt;$span&lt;/$tag&gt;&quot;;&nbsp;</div></li><li><div>                  $text_stack[0] = $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                  $$tag = ''; # $$tag stands for $em or $strong&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $tree_char_em = false;&nbsp;</div></li><li><div>          } else if ($token_len == 3) {&nbsp;</div></li><li><div>              if ($em) {&nbsp;</div></li><li><div>                  # Reached closing marker for both em and strong.&nbsp;</div></li><li><div>                  # Closing strong marker:&nbsp;</div></li><li><div>                  for ($i = 0; $i &lt; 2; ++$i) {&nbsp;</div></li><li><div>                      $shifted_token = array_shift($token_stack);&nbsp;</div></li><li><div>                      $tag = strlen($shifted_token) == 2 ? &quot;strong&quot; : &quot;em&quot;;&nbsp;</div></li><li><div>                      $span = array_shift($text_stack);&nbsp;</div></li><li><div>                      $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                      $span = &quot;&lt;$tag&gt;$span&lt;/$tag&gt;&quot;;&nbsp;</div></li><li><div>                      $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                      $$tag = ''; # $$tag stands for $em or $strong&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  # Reached opening three-char emphasis marker. Push on token&nbsp;</div></li><li><div>                  # stack; will be handled by the special condition above.&nbsp;</div></li><li><div>                  $em = $token{0};&nbsp;</div></li><li><div>                  $strong = &quot;$em$em&quot;;&nbsp;</div></li><li><div>                  array_unshift($token_stack, $token);&nbsp;</div></li><li><div>                  array_unshift($text_stack, '');&nbsp;</div></li><li><div>                  $tree_char_em = true;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          } else if ($token_len == 2) {&nbsp;</div></li><li><div>              if ($strong) {&nbsp;</div></li><li><div>                  # Unwind any dangling emphasis marker:&nbsp;</div></li><li><div>                  if (strlen($token_stack[0]) == 1) {&nbsp;</div></li><li><div>                      $text_stack[1] .= array_shift($token_stack);&nbsp;</div></li><li><div>                      $text_stack[0] .= array_shift($text_stack);&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  # Closing strong marker:&nbsp;</div></li><li><div>                  array_shift($token_stack);&nbsp;</div></li><li><div>                  $span = array_shift($text_stack);&nbsp;</div></li><li><div>                  $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                  $span = &quot;&lt;strong&gt;$span&lt;/strong&gt;&quot;;&nbsp;</div></li><li><div>                  $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                  $strong = '';&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  array_unshift($token_stack, $token);&nbsp;</div></li><li><div>                  array_unshift($text_stack, '');&nbsp;</div></li><li><div>                  $strong = $token;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              # Here $token_len == 1&nbsp;</div></li><li><div>              if ($em) {&nbsp;</div></li><li><div>                  if (strlen($token_stack[0]) == 1) {&nbsp;</div></li><li><div>                      # Closing emphasis marker:&nbsp;</div></li><li><div>                      array_shift($token_stack);&nbsp;</div></li><li><div>                      $span = array_shift($text_stack);&nbsp;</div></li><li><div>                      $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                      $span = &quot;&lt;em&gt;$span&lt;/em&gt;&quot;;&nbsp;</div></li><li><div>                      $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                      $em = '';&nbsp;</div></li><li><div>                  } else {&nbsp;</div></li><li><div>                      $text_stack[0] .= $token;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  array_unshift($token_stack, $token);&nbsp;</div></li><li><div>                  array_unshift($text_stack, '');&nbsp;</div></li><li><div>                  $em = $token;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $text_stack[0];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doBlockQuotes($text) {&nbsp;</div></li><li><div>      $text = preg_replace_callback('/&nbsp;</div></li><li><div>            (                                # Wrap whole match in $1&nbsp;</div></li><li><div>              (?&gt;&nbsp;</div></li><li><div>                ^[ ]*&gt;[ ]?            # &quot;&gt;&quot; at the start of a line&nbsp;</div></li><li><div>                  .+\n                    # rest of the first line&nbsp;</div></li><li><div>                (.+\n)*                    # subsequent consecutive lines&nbsp;</div></li><li><div>                \n*                        # blanks&nbsp;</div></li><li><div> )+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          /xm', &nbsp;</div></li><li><div>          array(&$this, '_doBlockQuotes_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doBlockQuotes_callback($matches) {&nbsp;</div></li><li><div>      $bq = $matches[1];&nbsp;</div></li><li><div>      # trim one level of quoting - trim whitespace-only lines&nbsp;</div></li><li><div>      $bq = preg_replace('/^[ ]*&gt;[ ]?|^[ ]+$/m', '', $bq);&nbsp;</div></li><li><div>      $bq = $this-&gt;runBlockGamut($bq);        # recurse&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $bq = preg_replace('/^/m', &quot;  &quot;, $bq);&nbsp;</div></li><li><div>      # These leading spaces cause problem with &lt;pre&gt; content, &nbsp;</div></li><li><div>      # so we need to fix that:&nbsp;</div></li><li><div>      $bq = preg_replace_callback('{(\s*&lt;pre&gt;.+?&lt;/pre&gt;)}sx', &nbsp;</div></li><li><div>          array(&$this, '_doBlockQuotes_callback2'), $bq);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return &quot;\n&quot;. $this-&gt;hashBlock(&quot;&lt;blockquote&gt;\n$bq\n&lt;/blockquote&gt;&quot;).&quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doBlockQuotes_callback2($matches) {&nbsp;</div></li><li><div>      $pre = $matches[1];&nbsp;</div></li><li><div>      $pre = preg_replace('/^  /m', '', $pre);&nbsp;</div></li><li><div>      return $pre;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function formParagraphs($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Params:&nbsp;</div></li><li><div>  #        $text - string to process with html &lt;p&gt; tags&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # Strip leading and trailing lines:&nbsp;</div></li><li><div>      $text = preg_replace('/\A\n+|\n+\z/', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $grafs = preg_split('/\n{2, }/', $text, -1, PREG_SPLIT_NO_EMPTY);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Wrap &lt;p&gt; tags and unhashify HTML blocks&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      foreach ($grafs as $key =&gt; $value) {&nbsp;</div></li><li><div>          if (!preg_match('/^B\x1A[0-9]+B$/', $value)) {&nbsp;</div></li><li><div>              # Is a paragraph.&nbsp;</div></li><li><div>              $value = $this-&gt;runSpanGamut($value);&nbsp;</div></li><li><div>              $value = preg_replace('/^([ ]*)/', &quot;&lt;p&gt;&quot;, $value);&nbsp;</div></li><li><div>              $value .= &quot;&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>              $grafs[$key] = $this-&gt;unhash($value);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else {&nbsp;</div></li><li><div>              # Is a block.&nbsp;</div></li><li><div>              # Modify elements of @grafs in-place...&nbsp;</div></li><li><div>              $graf = $value;&nbsp;</div></li><li><div>              $block = $this-&gt;html_hashes[$graf];&nbsp;</div></li><li><div>              $graf = $block;&nbsp;</div></li><li><div><span class="comment">//                if (preg_match('{</span>&nbsp;</div></li><li><div><span class="comment">//                    \A</span>&nbsp;</div></li><li><div><span class="comment">//                    (                            # $1 = &lt;div&gt; tag</span>&nbsp;</div></li><li><div><span class="comment">//                      &lt;div  \s+</span>&nbsp;</div></li><li><div><span class="comment"><span class="comment">//                      [^&gt;]*</span></span>&nbsp;</div></li><li><div><span class="comment">//                      \b</span>&nbsp;</div></li><li><div><span class="comment">//                      markdown\s*=\s*  ([\'&quot;])    #    $2 = attr quote char</span>&nbsp;</div></li><li><div><span class="comment">//                      1</span>&nbsp;</div></li><li><div><span class="comment">//                      \2</span>&nbsp;</div></li><li><div><span class="comment"><span class="comment">//                      [^&gt;]*</span></span>&nbsp;</div></li><li><div><span class="comment">//                      &gt;</span>&nbsp;</div></li><li><div><span class="comment"><span class="comment">// )</span></span>&nbsp;</div></li><li><div><span class="comment">//                    (                            # $3 = contents</span>&nbsp;</div></li><li><div><span class="comment">//                    .*</span>&nbsp;</div></li><li><div><span class="comment"><span class="comment">// )</span></span>&nbsp;</div></li><li><div><span class="comment">//                    (&lt;/div&gt;)                    # $4 = closing tag</span>&nbsp;</div></li><li><div><span class="comment">//                    \z</span>&nbsp;</div></li><li><div><span class="comment"><span class="comment">//                    }</span>xs', $block, $matches))</span>&nbsp;</div></li><li><div><span class="comment">//                {</span>&nbsp;</div></li><li><div><span class="comment">//                    list(, $div_open, , $div_content, $div_close) = $matches;</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">//                    # We can't call Markdown(), because that resets the hash;</span>&nbsp;</div></li><li><div><span class="comment">//                    # that initialization code should be pulled into its own sub, though.</span>&nbsp;</div></li><li><div><span class="comment">//                    $div_content = $this-&gt;hashHTMLBlocks($div_content);</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">//                    # Run document gamut methods on the content.</span>&nbsp;</div></li><li><div><span class="comment">//                    foreach ($this-&gt;document_gamut as $method =&gt; $priority) {</span>&nbsp;</div></li><li><div><span class="comment">//                        $div_content = $this-&gt;$method($div_content);</span>&nbsp;</div></li><li><div><span class="comment">//                    }</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">//                    $div_open = preg_replace(</span>&nbsp;</div></li><li><div><span class="comment">//                        '{\smarkdown\s*=\s*([\'&quot;]).+?\1}', '', $div_open);</span>&nbsp;</div></li><li><div><span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">//                    $graf = $div_open . &quot;\n&quot; . $div_content . &quot;\n&quot; . $div_close;</span>&nbsp;</div></li><li><div><span class="comment">//                }</span>&nbsp;</div></li><li><div>              $grafs[$key] = $graf;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return implode(&quot;\n\n&quot;, $grafs);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function encodeAttribute($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Encode text for a double-quoted HTML attribute. This function&nbsp;</div></li><li><div>  # is *not* suitable for attributes enclosed in single quotes.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $text = $this-&gt;encodeAmpsAndAngles($text);&nbsp;</div></li><li><div>      $text = str_replace('&quot;', '&quot;', $text);&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function encodeAmpsAndAngles($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Smart processing for ampersands and angle brackets that need to&nbsp;</div></li><li><div>  # be encoded. Valid character entities are left alone unless the&nbsp;</div></li><li><div>  # no-entities mode is set.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if ($this-&gt;no_entities) {&nbsp;</div></li><li><div>          $text = str_replace('&', '&amp;', $text);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          # Ampersand-encoding based entirely on Nat Irons's Amputator&nbsp;</div></li><li><div>          # MT plugin: &lt;http:<span class="comment">//bumppo.net/projects/amputator/&gt;</span>&nbsp;</div></li><li><div>          $text = preg_replace('/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/', &nbsp;</div></li><li><div>                              '&amp;', $text);;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      # Encode remaining &lt;'s&nbsp;</div></li><li><div>      $text = str_replace('&lt;', '&lt;', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doAutoLinks($text) {&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&lt;((https?|ftp|dict):[^\'&quot;&gt;\s]+)&gt;}i', &nbsp;</div></li><li><div>          array(&$this, '_doAutoLinks_url_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Email addresses: &lt;address@domain.foo&gt;&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          &lt;&nbsp;</div></li><li><div>          (?:mailto:)?&nbsp;</div></li><li><div>          (&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  [-!#$%&\'*+/=?^_`.{|}~\w\x80-\xFF]+&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &quot;.*?&quot;&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              \@&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  [-a-z0-9\x80-\xFF]+(\.[-a-z0-9\x80-\xFF]+)*\.[a-z]+&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  \[[\d.a-fA-F:]+\]    # IPv4 & IPv6&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          &gt;&nbsp;</div></li><li><div>          }xi', &nbsp;</div></li><li><div>          array(&$this, '_doAutoLinks_email_callback'), $text);&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&lt;(tel:([^\'&quot;&gt;\s]+))&gt;}i', array(&$this, '_doAutoLinks_tel_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAutoLinks_tel_callback($matches) {&nbsp;</div></li><li><div>      $url = $this-&gt;encodeAttribute($matches[1]);&nbsp;</div></li><li><div>      $tel = $this-&gt;encodeAttribute($matches[2]);&nbsp;</div></li><li><div>      $link = &quot;&lt;a href=\&quot;$url\&quot;&gt;$tel&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>      return $this-&gt;hashPart($link);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAutoLinks_url_callback($matches) {&nbsp;</div></li><li><div>      $url = $this-&gt;encodeAttribute($matches[1]);&nbsp;</div></li><li><div>      $link = &quot;&lt;a href=\&quot;$url\&quot;&gt;$url&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>      return $this-&gt;hashPart($link);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAutoLinks_email_callback($matches) {&nbsp;</div></li><li><div>      $address = $matches[1];&nbsp;</div></li><li><div>      $link = $this-&gt;encodeEmailAddress($address);&nbsp;</div></li><li><div>      return $this-&gt;hashPart($link);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function encodeEmailAddress($addr) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Input: an email address, e.g. &quot;foo@example.com&quot;&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Output: the email address as a mailto link, with each character&nbsp;</div></li><li><div>  #        of the address encoded as either a decimal or hex entity, in&nbsp;</div></li><li><div>  #        the hopes of foiling most address harvesting spam bots. E.g.:&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #      &lt;p&gt;&lt;a href=&quot;&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x66;o&#111;&nbsp;</div></li><li><div>  #        &#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&nbsp;</div></li><li><div>  #        &#x6d;&quot;&gt;&#x66;o&#111;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&nbsp;</div></li><li><div>  #        &#101;&#46;&#x63;&#111;&#x6d;&lt;/a&gt;&lt;/p&gt;&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Based by a filter by Matthew Wickline, posted to BBEdit-Talk.&nbsp;</div></li><li><div>  #   With some optimizations by Milian Wolff.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $addr = &quot;mailto:&quot; . $addr;&nbsp;</div></li><li><div>      $chars = preg_split('/(?&lt;!^)(?!$)/', $addr);&nbsp;</div></li><li><div>      $seed = (int)abs(crc32($addr) / strlen($addr)); # Deterministic seed.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ($chars as $key =&gt; $char) {&nbsp;</div></li><li><div>          $ord = ord($char);&nbsp;</div></li><li><div>          # Ignore non-ascii chars.&nbsp;</div></li><li><div>          if ($ord &lt; 128) {&nbsp;</div></li><li><div>              $r = ($seed * (1 + $key)) % 100; # Pseudo-random function.&nbsp;</div></li><li><div>              # roughly 10% raw, 45% hex, 45% dec&nbsp;</div></li><li><div>              # '@' *must* be encoded. I insist.&nbsp;</div></li><li><div>              if ($r &gt; 90 && $char != '@') <span class="comment">/** do nothing */</span>;&nbsp;</div></li><li><div>              else if ($r &lt; 45) $chars[$key] = '&#x'.dechex($ord).';';&nbsp;</div></li><li><div>              else              $chars[$key] = '&#'.$ord.';';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $addr = implode('', $chars);&nbsp;</div></li><li><div>      $text = implode('', array_slice($chars, 7)); # text without `mailto:`&nbsp;</div></li><li><div>      $addr = &quot;&lt;a href=\&quot;$addr\&quot;&gt;$text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $addr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function parseSpan($str) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Take the string $str and parse it into tokens, hashing embedded HTML, &nbsp;</div></li><li><div>  # escaped characters and handling code spans.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $output = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $span_re = '{&nbsp;</div></li><li><div>              (&nbsp;</div></li><li><div>                  \\\\'.$this-&gt;escape_chars_re.'&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  (?&lt;![`\\\\])&nbsp;</div></li><li><div>                  `+                        # code span marker&nbsp;</div></li><li><div>          '.( $this-&gt;no_markup ? '' : '&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;!--    .*?     --&gt;        # comment&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;\?.*?\?&gt; | &lt;%.*?%&gt;        # processing instruction&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;[!$]?[-a-zA-Z0-9:_]+    # regular tags&nbsp;</div></li><li><div>                  (?&gt;&nbsp;</div></li><li><div>                      \s&nbsp;</div></li><li><div>                      (?&gt;[^&quot;\'&gt;]+|&quot;[^&quot;]*&quot;|\'[^\']*\')*&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                  &gt;&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;[-a-zA-Z0-9:_]+\s*/&gt; # xml-style empty tag&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;/[-a-zA-Z0-9:_]+\s*&gt; # closing tag&nbsp;</div></li><li><div>          ').'&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      while (1) {&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Each loop iteration search for either the next tag, the next&nbsp;</div></li><li><div>          # openning code span marker, or the next escaped character.&nbsp;</div></li><li><div>          # Each token is then passed to handleSpanToken.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          $parts = preg_split($span_re, $str, 2, PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          # Create token from text preceding tag.&nbsp;</div></li><li><div>          if ($parts[0] != &quot;&quot;) {&nbsp;</div></li><li><div>              $output .= $parts[0];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          # Check if we reach the end.&nbsp;</div></li><li><div>          if (isset($parts[1])) {&nbsp;</div></li><li><div>              $output .= $this-&gt;handleSpanToken($parts[1], $parts[2]);&nbsp;</div></li><li><div>              $str = $parts[2];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $output;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function handleSpanToken($token, &$str) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Handle $token provided by parseSpan by determining its nature and&nbsp;</div></li><li><div>  # returning the corresponding value that should replace it.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      switch ($token{0}) {&nbsp;</div></li><li><div>          case &quot;\\&quot;:&nbsp;</div></li><li><div>              return $this-&gt;hashPart(&quot;&#&quot;. ord($token{1}). &quot;;&quot;);&nbsp;</div></li><li><div>          case &quot;`&quot;:&nbsp;</div></li><li><div>              # Search for end marker in remaining text.&nbsp;</div></li><li><div>              if (preg_match('/^(.*?[^`])'.preg_quote($token).'(?!`)(.*)$/sm', &nbsp;</div></li><li><div>                  $str, $matches))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $str = $matches[2];&nbsp;</div></li><li><div>                  $codespan = $this-&gt;makeCodeSpan($matches[1]);&nbsp;</div></li><li><div>                  return $this-&gt;hashPart($codespan);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              return $token; <span class="comment">// return as text since no ending marker found.</span>&nbsp;</div></li><li><div>          default:&nbsp;</div></li><li><div>              return $this-&gt;hashPart($token);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function outdent($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Remove one level of line-leading tabs or spaces&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      return preg_replace('/^(\t|[ ]{1, '.$this-&gt;tab_width.'})/m', '', $text);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # String length function for detab. `_initDetab` will create a function to&nbsp;</div></li><li><div>  # hanlde UTF-8 if the default function does not exist.&nbsp;</div></li><li><div>  public $utf8_strlen = 'mb_strlen';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function detab($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Replace tabs with the appropriate amount of space.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # For each line we separate the line in blocks delemited by&nbsp;</div></li><li><div>      # tab characters. Then we reconstruct every line by adding the&nbsp;</div></li><li><div>      # appropriate number of space between each blocks.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $text = preg_replace_callback('/^.*\t.*$/m', &nbsp;</div></li><li><div>          array(&$this, '_detab_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _detab_callback($matches) {&nbsp;</div></li><li><div>      $line = $matches[0];&nbsp;</div></li><li><div>      $strlen = $this-&gt;utf8_strlen; # strlen function for UTF-8.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Split in blocks.&nbsp;</div></li><li><div>      $blocks = explode(&quot;\t&quot;, $line);&nbsp;</div></li><li><div>      # Add each blocks to the line.&nbsp;</div></li><li><div>      $line = $blocks[0];&nbsp;</div></li><li><div>      unset($blocks[0]); # Do not add first block twice.&nbsp;</div></li><li><div>      foreach ($blocks as $block) {&nbsp;</div></li><li><div>          # Calculate amount of space, insert spaces, insert block.&nbsp;</div></li><li><div>          $amount = $this-&gt;tab_width -&nbsp;</div></li><li><div>              $strlen($line, 'UTF-8') % $this-&gt;tab_width;&nbsp;</div></li><li><div>          $line .= str_repeat(&quot; &quot;, $amount) . $block;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $line;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _initDetab() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Check for the availability of the function in the `utf8_strlen` property&nbsp;</div></li><li><div>  # (initially `mb_strlen`). If the function is not available, create a&nbsp;</div></li><li><div>  # function that will loosely count the number of UTF-8 characters with a&nbsp;</div></li><li><div>  # regular expression.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if (function_exists($this-&gt;utf8_strlen)) return;&nbsp;</div></li><li><div>      $this-&gt;utf8_strlen = create_function('$text', 'return preg_match_all(&nbsp;</div></li><li><div>          &quot;/[\\\\x00-\\\\xBF]|[\\\\xC0-\\\\xFF][\\\\x80-\\\\xBF]*/&quot;, &nbsp;</div></li><li><div>          $text, $m);');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function unhash($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Swap back in all the tags hashed by _HashHTMLBlocks.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      return preg_replace_callback('/(.)\x1A[0-9]+\1/', &nbsp;</div></li><li><div>          array(&$this, '_unhash_callback'), $text);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _unhash_callback($matches) {&nbsp;</div></li><li><div>      return $this-&gt;html_hashes[$matches[0]];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div># Markdown Extra Parser Class&nbsp;</div></li><li><div>#&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>class MarkdownExtra_Parser extends Markdown_Parser {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### Configuration Variables ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Prefix for footnote ids.&nbsp;</div></li><li><div>  public $fn_id_prefix = &quot;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Optional title attribute for footnote links and backlinks.&nbsp;</div></li><li><div>  public $fn_link_title = MARKDOWN_FN_LINK_TITLE;&nbsp;</div></li><li><div>  public $fn_backlink_title = MARKDOWN_FN_BACKLINK_TITLE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Optional class attribute for footnote links and backlinks.&nbsp;</div></li><li><div>  public $fn_link_class = MARKDOWN_FN_LINK_CLASS;&nbsp;</div></li><li><div>  public $fn_backlink_class = MARKDOWN_FN_BACKLINK_CLASS;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Optional class prefix for fenced code block.&nbsp;</div></li><li><div>  public $code_class_prefix = MARKDOWN_CODE_CLASS_PREFIX;&nbsp;</div></li><li><div>  # Class attribute for code blocks goes on the `code` tag;&nbsp;</div></li><li><div>  # setting this to true will put attributes on the `pre` tag instead.&nbsp;</div></li><li><div>  public $code_attr_on_pre = MARKDOWN_CODE_ATTR_ON_PRE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Predefined abbreviations.&nbsp;</div></li><li><div>  public $predef_abbr = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### Parser Implementation ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __construct() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Constructor function. Initialize the parser object.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # Add extra escapable characters before parent constructor&nbsp;</div></li><li><div>      # initialize the table.&nbsp;</div></li><li><div>      $this-&gt;escape_chars .= ':|';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Insert extra document, block, and span transformations.&nbsp;</div></li><li><div>      # Parent constructor will do the sorting.&nbsp;</div></li><li><div>      $this-&gt;document_gamut += array(&nbsp;</div></li><li><div>          &quot;doFencedCodeBlocks&quot; =&gt; 5, &nbsp;</div></li><li><div>          &quot;stripFootnotes&quot; =&gt; 15, &nbsp;</div></li><li><div>          &quot;stripAbbreviations&quot; =&gt; 25, &nbsp;</div></li><li><div>          &quot;appendFootnotes&quot; =&gt; 50, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      $this-&gt;block_gamut += array(&nbsp;</div></li><li><div>          &quot;doFencedCodeBlocks&quot; =&gt; 5, &nbsp;</div></li><li><div>          &quot;doTables&quot; =&gt; 15, &nbsp;</div></li><li><div>          &quot;doDefLists&quot; =&gt; 45, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      $this-&gt;span_gamut += array(&nbsp;</div></li><li><div>          &quot;doFootnotes&quot; =&gt; 5, &nbsp;</div></li><li><div>          &quot;doAbbreviations&quot; =&gt; 70, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      parent::__construct();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Extra variables used during extra transformations.&nbsp;</div></li><li><div>  public $footnotes = array();&nbsp;</div></li><li><div>  public $footnotes_ordered = array();&nbsp;</div></li><li><div>  public $footnotes_ref_count = array();&nbsp;</div></li><li><div>  public $footnotes_numbers = array();&nbsp;</div></li><li><div>  public $abbr_desciptions = array();&nbsp;</div></li><li><div>  public $abbr_word_re = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Give the current footnote number.&nbsp;</div></li><li><div>  public $footnote_counter = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function setup() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Setting up Extra-specific variables.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      parent::setup();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;footnotes = array();&nbsp;</div></li><li><div>      $this-&gt;footnotes_ordered = array();&nbsp;</div></li><li><div>      $this-&gt;footnotes_ref_count = array();&nbsp;</div></li><li><div>      $this-&gt;footnotes_numbers = array();&nbsp;</div></li><li><div>      $this-&gt;abbr_desciptions = array();&nbsp;</div></li><li><div>      $this-&gt;abbr_word_re = '';&nbsp;</div></li><li><div>      $this-&gt;footnote_counter = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ($this-&gt;predef_abbr as $abbr_word =&gt; $abbr_desc) {&nbsp;</div></li><li><div>          if ($this-&gt;abbr_word_re)&nbsp;</div></li><li><div>              $this-&gt;abbr_word_re .= '|';&nbsp;</div></li><li><div>          $this-&gt;abbr_word_re .= preg_quote($abbr_word);&nbsp;</div></li><li><div>          $this-&gt;abbr_desciptions[$abbr_word] = trim($abbr_desc);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function teardown() {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Clearing Extra-specific variables.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $this-&gt;footnotes = array();&nbsp;</div></li><li><div>      $this-&gt;footnotes_ordered = array();&nbsp;</div></li><li><div>      $this-&gt;footnotes_ref_count = array();&nbsp;</div></li><li><div>      $this-&gt;footnotes_numbers = array();&nbsp;</div></li><li><div>      $this-&gt;abbr_desciptions = array();&nbsp;</div></li><li><div>      $this-&gt;abbr_word_re = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      parent::teardown();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### Extra Attribute Parser ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Expression to use to catch attributes (includes the braces)&nbsp;</div></li><li><div>  public $id_class_attr_catch_re = '\{((?:[ ]*[#.][-_:a-zA-Z0-9]+) {1, })[ ]*\}';&nbsp;</div></li><li><div>  # Expression to use when parsing in a context when no capture is desired&nbsp;</div></li><li><div>  public $id_class_attr_nocatch_re = '\{(?:[ ]*[#.][-_:a-zA-Z0-9]+) {1, }[ ]*\}';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doExtraAttributes($tag_name, $attr) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Parse attributes caught by the $this-&gt;id_class_attr_catch_re expression&nbsp;</div></li><li><div>  # and return the HTML-formatted list of attributes.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Currently supported attributes are .class and #id.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if (empty($attr)) return &quot;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Split on components&nbsp;</div></li><li><div>      preg_match_all('/[#.][-_:a-zA-Z0-9]+/', $attr, $matches);&nbsp;</div></li><li><div>      $elements = $matches[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # handle classes and ids (only first id taken into account)&nbsp;</div></li><li><div>      $classes = array();&nbsp;</div></li><li><div>      $id = false;&nbsp;</div></li><li><div>      foreach ($elements as $element) {&nbsp;</div></li><li><div>          if ($element{0} == '.') {&nbsp;</div></li><li><div>              $classes[] = substr($element, 1);&nbsp;</div></li><li><div>          } else if ($element{0} == '#') {&nbsp;</div></li><li><div>              if ($id === false) $id = substr($element, 1);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # compose attributes as string&nbsp;</div></li><li><div>      $attr_str = &quot;&quot;;&nbsp;</div></li><li><div>      if (!empty($id)) {&nbsp;</div></li><li><div>          $attr_str .= ' id=&quot;'.$id.'&quot;';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (!empty($classes)) {&nbsp;</div></li><li><div>          $attr_str .= ' class=&quot;'.implode(&quot; &quot;, $classes).'&quot;';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $attr_str;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function stripLinkDefinitions($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Strips link definitions from text, stores the URLs and titles in&nbsp;</div></li><li><div>  # hash references.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Link defs are in the form: ^[id]: url &quot;optional title&quot;&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>                          ^[ ]{0, '.$less_than_tab.'}\[(.+)\][ ]?:    # id = $1&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                            \n?                # maybe *one* newline&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                          (?:&nbsp;</div></li><li><div>                            &lt;(.+?)&gt;            # url = $2&nbsp;</div></li><li><div>                          |&nbsp;</div></li><li><div>                            (\S+?)            # url = $3&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                            \n?                # maybe one newline&nbsp;</div></li><li><div>                            [ ]*&nbsp;</div></li><li><div>                          (?:&nbsp;</div></li><li><div>                              (?&lt;=\s)            # lookbehind for whitespace&nbsp;</div></li><li><div>                              [&quot;(]&nbsp;</div></li><li><div>                              (.*?)            # title = $4&nbsp;</div></li><li><div>                              [&quot;)]&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div> )?    # title is optional&nbsp;</div></li><li><div>                  (?:[ ]* '.$this-&gt;id_class_attr_catch_re.' )?  # $5 = extra id & class attr&nbsp;</div></li><li><div>                          (?:\n+|\Z)&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_stripLinkDefinitions_callback'), &nbsp;</div></li><li><div>          $text);&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _stripLinkDefinitions_callback($matches) {&nbsp;</div></li><li><div>      $link_id = strtolower($matches[1]);&nbsp;</div></li><li><div>      $url = $matches[2] == '' ? $matches[3] : $matches[2];&nbsp;</div></li><li><div>      $this-&gt;urls[$link_id] = $url;&nbsp;</div></li><li><div>      $this-&gt;titles[$link_id] =& $matches[4];&nbsp;</div></li><li><div>      $this-&gt;ref_attr[$link_id] = $this-&gt;doExtraAttributes(&quot;&quot;, $dummy =& $matches[5]);&nbsp;</div></li><li><div>      return ''; # String that will replace the block&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### HTML Block Parser ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Tags that are always treated as block tags:&nbsp;</div></li><li><div>  public $block_tags_re = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|form|fieldset|iframe|hr|legend|article|section|nav|aside|hgroup|header|footer|figcaption';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Tags treated as block tags only if the opening tag is alone on its line:&nbsp;</div></li><li><div>  public $context_block_tags_re = 'script|noscript|ins|del|iframe|object|source|track|param|math|svg|canvas|audio|video';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Tags where markdown=&quot;1&quot; default to span mode:&nbsp;</div></li><li><div>  public $contain_span_tags_re = 'p|h[1-6]|li|dd|dt|td|th|legend|address';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Tags which must not have their contents modified, no matter where&nbsp;</div></li><li><div>  # they appear:&nbsp;</div></li><li><div>  public $clean_tags_re = 'script|math|svg';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  # Tags that do not need to be closed.&nbsp;</div></li><li><div>  public $auto_close_tags_re = 'hr|img|param|source|track';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function hashHTMLBlocks($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Hashify HTML Blocks and &quot;clean tags&quot;.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # We only want to do this for block-level HTML tags, such as headers, &nbsp;</div></li><li><div>  # lists, and tables. That's because we still want to wrap &lt;p&gt;s around&nbsp;</div></li><li><div>  # &quot;paragraphs&quot; that are wrapped in non-block-level tags, such as anchors, &nbsp;</div></li><li><div>  # phrase emphasis, and spans. The list of tags we're looking for is&nbsp;</div></li><li><div>  # hard-coded.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # This works by calling _HashHTMLBlocks_InMarkdown, which then calls&nbsp;</div></li><li><div>  # _HashHTMLBlocks_InHTML when it encounter block tags. When the markdown=&quot;1&quot;&nbsp;</div></li><li><div>  # attribute is found within a tag, _HashHTMLBlocks_InHTML calls back&nbsp;</div></li><li><div>  #  _HashHTMLBlocks_InMarkdown to handle the Markdown syntax within the tag.&nbsp;</div></li><li><div>  # These two functions are calling each other. It's recursive!&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if ($this-&gt;no_markup)  return $text;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Call the HTML-in-Markdown hasher.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      list($text, ) = $this-&gt;_hashHTMLBlocks_inMarkdown($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _hashHTMLBlocks_inMarkdown($text, $indent = 0, &nbsp;</div></li><li><div>                                      $enclosing_tag_re = '', $span = false)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Parse markdown text, calling _HashHTMLBlocks_InHTML for block tags.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # *   $indent is the number of space to be ignored when checking for code&nbsp;</div></li><li><div>  #     blocks. This is important because if we don't take the indent into&nbsp;</div></li><li><div>  #     account, something like this (which looks right) won't work as expected:&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #     &lt;div&gt;&nbsp;</div></li><li><div>  #         &lt;div markdown=&quot;1&quot;&gt;&nbsp;</div></li><li><div>  #         Hello World.  &lt;-- Is this a Markdown code block or text?&nbsp;</div></li><li><div>  #         &lt;/div&gt;  &lt;-- Is this a Markdown code block or a real tag?&nbsp;</div></li><li><div>  #     &lt;div&gt;&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #     If you don't like this, just don't indent the tag on which&nbsp;</div></li><li><div>  #     you apply the markdown=&quot;1&quot; attribute.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # *   If $enclosing_tag_re is not empty, stops at the first unmatched closing&nbsp;</div></li><li><div>  #     tag with that name. Nested tags supported.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # *   If $span is true, text inside must treated as span. So any double&nbsp;</div></li><li><div>  #     newline will be replaced by a single newline so that it does not create&nbsp;</div></li><li><div>  #     paragraphs.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Returns an array of that form: ( processed text , remaining text )&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if ($text === '') return array('', '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Regex to check for the presence of newlines around a block tag.&nbsp;</div></li><li><div>      $newline_before_re = '/(?:^\n?|\n\n)*$/';&nbsp;</div></li><li><div>      $newline_after_re =&nbsp;</div></li><li><div>          '{&nbsp;</div></li><li><div>              ^                        # Start of text following the tag.&nbsp;</div></li><li><div>              (?&gt;[ ]*&lt;!--.*?--&gt;)?        # Optional comment.&nbsp;</div></li><li><div>              [ ]*\n                    # Must be followed by newline.&nbsp;</div></li><li><div>          }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Regex to match any tag.&nbsp;</div></li><li><div>      $block_tag_re =&nbsp;</div></li><li><div>          '{&nbsp;</div></li><li><div>              (                    # $2: Capture whole tag.&nbsp;</div></li><li><div>                  &lt;/?                    # Any opening or closing tag.&nbsp;</div></li><li><div>                      (?&gt;                # Tag name.&nbsp;</div></li><li><div>                          '.$this-&gt;block_tags_re.'            |&nbsp;</div></li><li><div>                          '.$this-&gt;context_block_tags_re.'    |&nbsp;</div></li><li><div>                          '.$this-&gt;clean_tags_re.'            |&nbsp;</div></li><li><div>                          (?!\s)'.$enclosing_tag_re.'&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                      (?:&nbsp;</div></li><li><div>                          (?=[\s&quot;\'/a-zA-Z0-9])    # Allowed characters after tag name.&nbsp;</div></li><li><div>                          (?&gt;&nbsp;</div></li><li><div>                              &quot;.*?&quot;        |    # Double quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                              \'.*?\'       |    # Single quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                              .+?                # Anything but quotes and `&gt;`.&nbsp;</div></li><li><div> )*?&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                  &gt;                    # End of tag.&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;!--    .*?     --&gt;    # HTML Comment&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;\?.*?\?&gt; | &lt;%.*?%&gt;    # Processing instruction&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;!\[CDATA\[.*?\]\]&gt;    # CData Block&nbsp;</div></li><li><div>              '. ( !$span ? ' # If not in span.&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  # Indented code block&nbsp;</div></li><li><div>                  (?: ^[ ]*\n | ^ | \n[ ]*\n )&nbsp;</div></li><li><div>                  [ ]{'.($indent+4).'}[^\n]* \n&nbsp;</div></li><li><div>                  (?&gt;&nbsp;</div></li><li><div>                      (?: [ ]{'.($indent+4).'}[^\n]* | [ ]* ) \n&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  # Fenced code block marker&nbsp;</div></li><li><div>                  (?&lt;= ^ | \n )&nbsp;</div></li><li><div>                  [ ]{0, '.($indent+3).'}(?:~{3, }|`{3, })&nbsp;</div></li><li><div>                                  [ ]*&nbsp;</div></li><li><div>                  (?:&nbsp;</div></li><li><div>                  \.?[-_:a-zA-Z0-9]+ # standalone class name&nbsp;</div></li><li><div>                  |&nbsp;</div></li><li><div>                      '.$this-&gt;id_class_attr_nocatch_re.' # extra attributes&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                  [ ]*&nbsp;</div></li><li><div>                  (?= \n )&nbsp;</div></li><li><div>              ' : '' ). ' # End (if not is span).&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  # Code span marker&nbsp;</div></li><li><div>                  # Note, this regex needs to go after backtick fenced&nbsp;</div></li><li><div>                  # code blocks but it should also be kept outside of the&nbsp;</div></li><li><div>                  # &quot;if not in span&quot; condition adding backticks to the parser&nbsp;</div></li><li><div>                  `+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $depth = 0;        # Current depth inside the tag tree.&nbsp;</div></li><li><div>      $parsed = &quot;&quot;;    # Parsed text that will be returned.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Loop through every tag until we find the closing tag of the parent&nbsp;</div></li><li><div>      # or loop until reaching the end of text if no parent tag specified.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      do {&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Split the text using the first $tag_match pattern found.&nbsp;</div></li><li><div>          # Text before  pattern will be first in the array, text after&nbsp;</div></li><li><div>          # pattern will be at the end, and between will be any catches made&nbsp;</div></li><li><div>          # by the pattern.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          $parts = preg_split($block_tag_re, $text, 2, &nbsp;</div></li><li><div>                              PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          # If in Markdown span mode, add a empty-string span-level hash&nbsp;</div></li><li><div>          # after each newline to prevent triggering any block element.&nbsp;</div></li><li><div>          if ($span) {&nbsp;</div></li><li><div>              $void = $this-&gt;hashPart(&quot;&quot;, ':');&nbsp;</div></li><li><div>              $newline = &quot;$void\n&quot;;&nbsp;</div></li><li><div>              $parts[0] = $void . str_replace(&quot;\n&quot;, $newline, $parts[0]) . $void;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $parsed .= $parts[0]; # Text before current tag.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          # If end of $text has been reached. Stop loop.&nbsp;</div></li><li><div>          if (count($parts) &lt; 3) {&nbsp;</div></li><li><div>              $text = &quot;&quot;;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $tag = $parts[1]; # Tag to handle.&nbsp;</div></li><li><div>          $text = $parts[2]; # Remaining text after current tag.&nbsp;</div></li><li><div>          $tag_re = preg_quote($tag); # For use in a regular expression.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Check for: Fenced code block marker.&nbsp;</div></li><li><div>          # Note: need to recheck the whole tag to disambiguate backtick&nbsp;</div></li><li><div>          # fences from code spans&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          if (preg_match('{^\n?([ ]{0, '.($indent+3).'})(~{3, }|`{3, })[ ]*(?:\.?[-_:a-zA-Z0-9]+|'.$this-&gt;id_class_attr_nocatch_re.')?[ ]*\n?$}', $tag, $capture)) {&nbsp;</div></li><li><div>              # Fenced code block marker: find matching end marker.&nbsp;</div></li><li><div>              $fence_indent = strlen($capture[1]); # use captured indent in re&nbsp;</div></li><li><div>              $fence_re = $capture[2]; # use captured fence in re&nbsp;</div></li><li><div>              if (preg_match('{^(?&gt;.*\n)*?[ ]{'.($fence_indent).'}'.$fence_re.'[ ]*(?:\n|$)}', $text, &nbsp;</div></li><li><div>                  $matches))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  # End marker found: pass text unchanged until marker.&nbsp;</div></li><li><div>                  $parsed .= $tag . $matches[0];&nbsp;</div></li><li><div>                  $text = substr($text, strlen($matches[0]));&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else {&nbsp;</div></li><li><div>                  # No end marker: just skip it.&nbsp;</div></li><li><div>                  $parsed .= $tag;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Check for: Indented code block.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          else if ($tag{0} == &quot;\n&quot; || $tag{0} == &quot; &quot;) {&nbsp;</div></li><li><div>              # Indented code block: pass it unchanged, will be handled&nbsp;</div></li><li><div>              # later.&nbsp;</div></li><li><div>              $parsed .= $tag;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Check for: Code span marker&nbsp;</div></li><li><div>          # Note: need to check this after backtick fenced code blocks&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          else if ($tag{0} == &quot;`&quot;) {&nbsp;</div></li><li><div>              # Find corresponding end marker.&nbsp;</div></li><li><div>              $tag_re = preg_quote($tag);&nbsp;</div></li><li><div>              if (preg_match('{^(?&gt;.+?|\n(?!\n))*?(?&lt;!`)'.$tag_re.'(?!`)}', &nbsp;</div></li><li><div>                  $text, $matches))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  # End marker found: pass text unchanged until marker.&nbsp;</div></li><li><div>                  $parsed .= $tag . $matches[0];&nbsp;</div></li><li><div>                  $text = substr($text, strlen($matches[0]));&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else {&nbsp;</div></li><li><div>                  # Unmatched marker: just skip it.&nbsp;</div></li><li><div>                  $parsed .= $tag;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Check for: Opening Block level tag or&nbsp;</div></li><li><div>          #            Opening Context Block tag (like ins and del)&nbsp;</div></li><li><div>          #               used as a block tag (tag is alone on it's line).&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          else if (preg_match('{^&lt;(?:'.$this-&gt;block_tags_re.')\b}', $tag) ||&nbsp;</div></li><li><div>              (    preg_match('{^&lt;(?:'.$this-&gt;context_block_tags_re.')\b}', $tag) &&&nbsp;</div></li><li><div>                  preg_match($newline_before_re, $parsed) &&&nbsp;</div></li><li><div>                  preg_match($newline_after_re, $text) )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              # Need to parse tag and following text using the HTML parser.&nbsp;</div></li><li><div>              list($block_text, $text) =&nbsp;</div></li><li><div>                  $this-&gt;_hashHTMLBlocks_inHTML($tag . $text, &quot;hashBlock&quot;, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              # Make sure it stays outside of any paragraph by adding newlines.&nbsp;</div></li><li><div>              $parsed .= &quot;\n\n$block_text\n\n&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Check for: Clean tag (like script, math)&nbsp;</div></li><li><div>          #            HTML Comments, processing instructions.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          else if (preg_match('{^&lt;(?:'.$this-&gt;clean_tags_re.')\b}', $tag) ||&nbsp;</div></li><li><div>              $tag{1} == '!' || $tag{1} == '?')&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              # Need to parse tag and following text using the HTML parser.&nbsp;</div></li><li><div>              # (don't check for markdown attribute)&nbsp;</div></li><li><div>              list($block_text, $text) =&nbsp;</div></li><li><div>                  $this-&gt;_hashHTMLBlocks_inHTML($tag . $text, &quot;hashClean&quot;, false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $parsed .= $block_text;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Check for: Tag with same name as enclosing tag.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          else if ($enclosing_tag_re !== '' &&&nbsp;</div></li><li><div>              # Same name as enclosing tag.&nbsp;</div></li><li><div>              preg_match('{^&lt;/?(?:'.$enclosing_tag_re.')\b}', $tag))&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              # Increase/decrease nested tag count.&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              if ($tag{1} == '/')                        $depth--;&nbsp;</div></li><li><div>              else if ($tag{strlen($tag)-2} != '/')    $depth++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ($depth &lt; 0) {&nbsp;</div></li><li><div>                  #&nbsp;</div></li><li><div>                  # Going out of parent element. Clean up and break so we&nbsp;</div></li><li><div>                  # return to the calling function.&nbsp;</div></li><li><div>                  #&nbsp;</div></li><li><div>                  $text = $tag . $text;&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $parsed .= $tag;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else {&nbsp;</div></li><li><div>              $parsed .= $tag;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } while ($depth &gt;= 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array($parsed, $text);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _hashHTMLBlocks_inHTML($text, $hash_method, $md_attr) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Parse HTML, calling _HashHTMLBlocks_InMarkdown for block tags.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # *   Calls $hash_method to convert any blocks.&nbsp;</div></li><li><div>  # *   Stops when the first opening tag closes.&nbsp;</div></li><li><div>  # *   $md_attr indicate if the use of the `markdown=&quot;1&quot;` attribute is allowed.&nbsp;</div></li><li><div>  #     (it is not inside clean tags)&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Returns an array of that form: ( processed text , remaining text )&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if ($text === '') return array('', '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Regex to match `markdown` attribute inside of a tag.&nbsp;</div></li><li><div>      $markdown_attr_re = '&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              \s*            # Eat whitespace before the `markdown` attribute&nbsp;</div></li><li><div>              markdown&nbsp;</div></li><li><div>              \s*=\s*&nbsp;</div></li><li><div>              (?&gt;&nbsp;</div></li><li><div>                  ([&quot;\'])        # $1: quote delimiter&nbsp;</div></li><li><div>                  (.*?)        # $2: attribute value&nbsp;</div></li><li><div>                  \1            # matching delimiter&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  ([^\s&gt;]*)    # $3: unquoted attribute value&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              ()                # $4: make $3 always defined (avoid warnings)&nbsp;</div></li><li><div>          }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Regex to match any tag.&nbsp;</div></li><li><div>      $tag_re = '{&nbsp;</div></li><li><div>              (                    # $2: Capture whole tag.&nbsp;</div></li><li><div>                  &lt;/?                    # Any opening or closing tag.&nbsp;</div></li><li><div>                      [\w:$]+            # Tag name.&nbsp;</div></li><li><div>                      (?:&nbsp;</div></li><li><div>                          (?=[\s&quot;\'/a-zA-Z0-9])    # Allowed characters after tag name.&nbsp;</div></li><li><div>                          (?&gt;&nbsp;</div></li><li><div>                              &quot;.*?&quot;        |    # Double quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                              \'.*?\'       |    # Single quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                              .+?                # Anything but quotes and `&gt;`.&nbsp;</div></li><li><div> )*?&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                  &gt;                    # End of tag.&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;!--    .*?     --&gt;    # HTML Comment&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;\?.*?\?&gt; | &lt;%.*?%&gt;    # Processing instruction&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  &lt;!\[CDATA\[.*?\]\]&gt;    # CData Block&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $original_text = $text;        # Save original text in case of faliure.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $depth = 0;    # Current depth inside the tag tree.&nbsp;</div></li><li><div>      $block_text = &quot;&quot;;    # Temporary text holder for current text.&nbsp;</div></li><li><div>      $parsed = &quot;&quot;;    # Parsed text that will be returned.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Get the name of the starting tag.&nbsp;</div></li><li><div>      # (This pattern makes $base_tag_name_re safe without quoting.)&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      if (preg_match('/^&lt;([\w:$]*)\b/', $text, $matches))&nbsp;</div></li><li><div>          $base_tag_name_re = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Loop through every tag until we find the corresponding closing tag.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      do {&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Split the text using the first $tag_match pattern found.&nbsp;</div></li><li><div>          # Text before  pattern will be first in the array, text after&nbsp;</div></li><li><div>          # pattern will be at the end, and between will be any catches made&nbsp;</div></li><li><div>          # by the pattern.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          $parts = preg_split($tag_re, $text, 2, PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if (count($parts) &lt; 3) {&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              # End of $text reached with unbalenced tag(s).&nbsp;</div></li><li><div>              # In that case, we return original text unchanged and pass the&nbsp;</div></li><li><div>              # first character as filtered to prevent an infinite loop in the&nbsp;</div></li><li><div>              # parent function.&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              return array($original_text{0}, substr($original_text, 1));&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $block_text .= $parts[0]; # Text before current tag.&nbsp;</div></li><li><div>          $tag = $parts[1]; # Tag to handle.&nbsp;</div></li><li><div>          $text = $parts[2]; # Remaining text after current tag.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          # Check for: Auto-close tag (like &lt;hr/&gt;)&nbsp;</div></li><li><div>          #             Comments and Processing Instructions.&nbsp;</div></li><li><div>          #&nbsp;</div></li><li><div>          if (preg_match('{^&lt;/?(?:'.$this-&gt;auto_close_tags_re.')\b}', $tag) ||&nbsp;</div></li><li><div>              $tag{1} == '!' || $tag{1} == '?')&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              # Just add the tag to the block as if it was text.&nbsp;</div></li><li><div>              $block_text .= $tag;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else {&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              # Increase/decrease nested tag count. Only do so if&nbsp;</div></li><li><div>              # the tag's name match base tag's.&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              if (preg_match('{^&lt;/?'.$base_tag_name_re.'\b}', $tag)) {&nbsp;</div></li><li><div>                  if ($tag{1} == '/')                        $depth--;&nbsp;</div></li><li><div>                  else if ($tag{strlen($tag)-2} != '/')    $depth++;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              # Check for `markdown=&quot;1&quot;` attribute and handle it.&nbsp;</div></li><li><div>              #&nbsp;</div></li><li><div>              if ($md_attr &&&nbsp;</div></li><li><div>                  preg_match($markdown_attr_re, $tag, $attr_m) &&&nbsp;</div></li><li><div>                  preg_match('/^1|block|span$/', $attr_m[2] . $attr_m[3]))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  # Remove `markdown` attribute from opening tag.&nbsp;</div></li><li><div>                  $tag = preg_replace($markdown_attr_re, '', $tag);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # Check if text inside this tag must be parsed in span mode.&nbsp;</div></li><li><div>                  $this-&gt;mode = $attr_m[2] . $attr_m[3];&nbsp;</div></li><li><div>                  $span_mode = $this-&gt;mode == 'span' || $this-&gt;mode != 'block' &&&nbsp;</div></li><li><div>                      preg_match('{^&lt;(?:'.$this-&gt;contain_span_tags_re.')\b}', $tag);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # Calculate indent before tag.&nbsp;</div></li><li><div>                  if (preg_match('/(?:^|\n)( *?)(?! ).*?$/', $block_text, $matches)) {&nbsp;</div></li><li><div>                      $strlen = $this-&gt;utf8_strlen;&nbsp;</div></li><li><div>                      $indent = $strlen($matches[1], 'UTF-8');&nbsp;</div></li><li><div>                  } else {&nbsp;</div></li><li><div>                      $indent = 0;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # End preceding block with this tag.&nbsp;</div></li><li><div>                  $block_text .= $tag;&nbsp;</div></li><li><div>                  $parsed .= $this-&gt;$hash_method($block_text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # Get enclosing tag name for the ParseMarkdown function.&nbsp;</div></li><li><div>                  # (This pattern makes $tag_name_re safe without quoting.)&nbsp;</div></li><li><div>                  preg_match('/^&lt;([\w:$]*)\b/', $tag, $matches);&nbsp;</div></li><li><div>                  $tag_name_re = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # Parse the content using the HTML-in-Markdown parser.&nbsp;</div></li><li><div>                  list ($block_text, $text)&nbsp;</div></li><li><div> = $this-&gt;_hashHTMLBlocks_inMarkdown($text, $indent, &nbsp;</div></li><li><div>                          $tag_name_re, $span_mode);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # Outdent markdown text.&nbsp;</div></li><li><div>                  if ($indent &gt; 0) {&nbsp;</div></li><li><div>                      $block_text = preg_replace(&quot;/^[ ]{1, $indent}/m&quot;, &quot;&quot;, &nbsp;</div></li><li><div>                                                  $block_text);&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # Append tag content to parsed text.&nbsp;</div></li><li><div>                  if (!$span_mode)    $parsed .= &quot;\n\n$block_text\n\n&quot;;&nbsp;</div></li><li><div>                  else                $parsed .= &quot;$block_text&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  # Start over with a new block.&nbsp;</div></li><li><div>                  $block_text = &quot;&quot;;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else $block_text .= $tag;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      } while ($depth &gt; 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Hash last block text that wasn't processed inside the loop.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $parsed .= $this-&gt;$hash_method($block_text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array($parsed, $text);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function hashClean($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Called whenever a tag must be hashed when a function inserts a &quot;clean&quot; tag&nbsp;</div></li><li><div>  # in $text, it passes through this function and is automaticaly escaped, &nbsp;</div></li><li><div>  # blocking invalid nested overlap.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      return $this-&gt;hashPart($text, 'C');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doAnchors($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Turn Markdown link shortcuts into XHTML &lt;a&gt; tags.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if ($this-&gt;in_anchor) return $text;&nbsp;</div></li><li><div>      $this-&gt;in_anchor = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # First, handle reference-style links: [link text] [id]&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                    # wrap whole match in $1&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            [ ]?                # one optional space&nbsp;</div></li><li><div>            (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              (.*?)        # id = $3&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Next, inline-style links: [link text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                # wrap whole match in $1&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>            \(            # literal paren&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  &lt;(.+?)&gt;    # href = $3&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  ('.$this-&gt;nested_url_parenthesis_re.')    # href = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (            # $5&nbsp;</div></li><li><div>                ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                (.*?)        # Title = $7&nbsp;</div></li><li><div>                \6        # matching quote&nbsp;</div></li><li><div>                [ \n]*    # ignore any spaces/tabs between closing quote and )&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>            \)&nbsp;</div></li><li><div>            (?:[ ]? '.$this-&gt;id_class_attr_catch_re.' )?     # $8 = id/class attributes&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doAnchors_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Last, handle reference-style shortcuts: [link text]&nbsp;</div></li><li><div>      # These must come last in case you've also got [link text][1]&nbsp;</div></li><li><div>      # or [link text](/foo)&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                    # wrap whole match in $1&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              ([^\[\]]+)        # link text = $2; can\'t contain [ or ]&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;in_anchor = false;&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAnchors_reference_callback($matches) {&nbsp;</div></li><li><div>      $whole_match =  $matches[1];&nbsp;</div></li><li><div>      $link_text =  $matches[2];&nbsp;</div></li><li><div>      $link_id =& $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>          # for shortcut links like [this][] or [this].&nbsp;</div></li><li><div>          $link_id = $link_text;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # lower-case and turn embedded newlines into spaces&nbsp;</div></li><li><div>      $link_id = strtolower($link_id);&nbsp;</div></li><li><div>      $link_id = preg_replace('{[ ]?\n}', ' ', $link_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>          $url = $this-&gt;urls[$link_id];&nbsp;</div></li><li><div>          $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>          if ( isset( $this-&gt;titles[$link_id] ) ) {&nbsp;</div></li><li><div>              $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>              $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>              $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (isset($this-&gt;ref_attr[$link_id]))&nbsp;</div></li><li><div>              $result .= $this-&gt;ref_attr[$link_id];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>          $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>          $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>          $result = $whole_match;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAnchors_inline_callback($matches) {&nbsp;</div></li><li><div>      $whole_match =  $matches[1];&nbsp;</div></li><li><div>      $link_text =  $this-&gt;runSpanGamut($matches[2]);&nbsp;</div></li><li><div>      $url =  $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>      $title =& $matches[7];&nbsp;</div></li><li><div>      $attr = $this-&gt;doExtraAttributes(&quot;a&quot;, $dummy =& $matches[8]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>      if (isset($title)) {&nbsp;</div></li><li><div>          $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>          $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $result .= $attr;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>      $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doImages($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Turn Markdown image shortcuts into &lt;img&gt; tags.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # First, handle reference-style labeled images: ![alt text][id]&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                # wrap whole match in $1&nbsp;</div></li><li><div>            !\[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            [ ]?                # one optional space&nbsp;</div></li><li><div>            (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            \[&nbsp;</div></li><li><div>              (.*?)        # id = $3&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doImages_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Next, handle inline images:  ![alt text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>      # Don't forget: encode * and _&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          (                # wrap whole match in $1&nbsp;</div></li><li><div>            !\[&nbsp;</div></li><li><div>              ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>            \]&nbsp;</div></li><li><div>            \s?            # One optional whitespace character&nbsp;</div></li><li><div>            \(            # literal paren&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  &lt;(\S*)&gt;    # src url = $3&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  ('.$this-&gt;nested_url_parenthesis_re.')    # src url = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              [ \n]*&nbsp;</div></li><li><div>              (            # $5&nbsp;</div></li><li><div>                ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                (.*?)        # title = $7&nbsp;</div></li><li><div>                \6        # matching quote&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>            \)&nbsp;</div></li><li><div>            (?:[ ]? '.$this-&gt;id_class_attr_catch_re.' )?     # $8 = id/class attributes&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xs', &nbsp;</div></li><li><div>          array(&$this, '_doImages_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doImages_reference_callback($matches) {&nbsp;</div></li><li><div>      $whole_match = $matches[1];&nbsp;</div></li><li><div>      $alt_text = $matches[2];&nbsp;</div></li><li><div>      $link_id = strtolower($matches[3]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>          $link_id = strtolower($alt_text); # for shortcut links like ![this][].&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>      if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>          $url = $this-&gt;encodeAttribute($this-&gt;urls[$link_id]);&nbsp;</div></li><li><div>          $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>          if (isset($this-&gt;titles[$link_id])) {&nbsp;</div></li><li><div>              $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>              $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>              $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (isset($this-&gt;ref_attr[$link_id]))&nbsp;</div></li><li><div>              $result .= $this-&gt;ref_attr[$link_id];&nbsp;</div></li><li><div>          $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>          $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>          # If there's no such link ID, leave intact:&nbsp;</div></li><li><div>          $result = $whole_match;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doImages_inline_callback($matches) {&nbsp;</div></li><li><div>      $whole_match = $matches[1];&nbsp;</div></li><li><div>      $alt_text = $matches[2];&nbsp;</div></li><li><div>      $url = $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>      $title =& $matches[7];&nbsp;</div></li><li><div>      $attr = $this-&gt;doExtraAttributes(&quot;img&quot;, $dummy =& $matches[8]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>      $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>      $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>      if (isset($title)) {&nbsp;</div></li><li><div>          $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>          $result .=  &quot; title=\&quot;$title\&quot;&quot;; # $title already quoted&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $result .= $attr;&nbsp;</div></li><li><div>      $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doHeaders($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Redefined to add id and class attribute support.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # Setext-style headers:&nbsp;</div></li><li><div>      #      Header 1  {#header1}&nbsp;</div></li><li><div>      # ========&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      #      Header 2  {#header2 .class1 .class2}&nbsp;</div></li><li><div>      #      --------&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback(&nbsp;</div></li><li><div>          '{&nbsp;</div></li><li><div>              (^.+?)                                # $1: Header text&nbsp;</div></li><li><div>              (?:[ ]+ '.$this-&gt;id_class_attr_catch_re.' )?     # $3 = id/class attributes&nbsp;</div></li><li><div>              [ ]*\n(=+|-+)[ ]*\n+                # $3: Header footer&nbsp;</div></li><li><div>          }mx', &nbsp;</div></li><li><div>          array(&$this, '_doHeaders_callback_setext'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # atx-style headers:&nbsp;</div></li><li><div>      #    # Header 1        {#header1}&nbsp;</div></li><li><div>      #    ## Header 2       {#header2}&nbsp;</div></li><li><div>      #    ## Header 2 with closing hashes ##  {#header3.class1.class2}&nbsp;</div></li><li><div>      #    ...&nbsp;</div></li><li><div>      #    ###### Header 6   {.class2}&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>              ^(\#{1, 6})    # $1 = string of #\'s&nbsp;</div></li><li><div>              [ ]*&nbsp;</div></li><li><div>              (.+?)        # $2 = Header text&nbsp;</div></li><li><div>              [ ]*&nbsp;</div></li><li><div>              \#*            # optional closing #\'s (not counted)&nbsp;</div></li><li><div>              (?:[ ]+ '.$this-&gt;id_class_attr_catch_re.' )?     # $3 = id/class attributes&nbsp;</div></li><li><div>              [ ]*&nbsp;</div></li><li><div>              \n+&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_doHeaders_callback_atx'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doHeaders_callback_setext($matches) {&nbsp;</div></li><li><div>      if ($matches[3] == '-' && preg_match('{^- }', $matches[1]))&nbsp;</div></li><li><div>          return $matches[0];&nbsp;</div></li><li><div>      $level = $matches[3]{0} == '=' ? 1 : 2;&nbsp;</div></li><li><div>      $attr = $this-&gt;doExtraAttributes(&quot;h$level&quot;, $dummy =& $matches[2]);&nbsp;</div></li><li><div>      $block = &quot;&lt;h$level$attr&gt;&quot;.$this-&gt;runSpanGamut($matches[1]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>      return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doHeaders_callback_atx($matches) {&nbsp;</div></li><li><div>      $level = strlen($matches[1]);&nbsp;</div></li><li><div>      $attr = $this-&gt;doExtraAttributes(&quot;h$level&quot;, $dummy =& $matches[3]);&nbsp;</div></li><li><div>      $block = &quot;&lt;h$level$attr&gt;&quot;.$this-&gt;runSpanGamut($matches[2]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>      return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doTables($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Form HTML tables.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Find tables with leading pipe.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      #    | Header 1 | Header 2&nbsp;</div></li><li><div>      #    | -------- | --------&nbsp;</div></li><li><div>      #    | Cell 1   | Cell 2&nbsp;</div></li><li><div>      #    | Cell 3   | Cell 4&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              ^                            # Start of a line&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>              [|]                            # Optional leading pipe (present)&nbsp;</div></li><li><div>              (.+) \n                        # $1: Header row (at least one pipe)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>              [|] ([ ]*[-:]+[-| :]*) \n    # $2: Header underline&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              (                            # $3: Cells&nbsp;</div></li><li><div>                  (?&gt;&nbsp;</div></li><li><div>                      [ ]*                # Allowed whitespace.&nbsp;</div></li><li><div>                      [|] .* \n            # Row content.&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              (?=\n|\Z)                    # Stop at final double newline.&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_doTable_leadingPipe_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Find tables without leading pipe.&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      #    Header 1 | Header 2&nbsp;</div></li><li><div>      #    -------- | --------&nbsp;</div></li><li><div>      #    Cell 1   | Cell 2&nbsp;</div></li><li><div>      #    Cell 3   | Cell 4&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      $text = preg_replace_callback('&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              ^                            # Start of a line&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>              (\S.*[|].*) \n                # $1: Header row (at least one pipe)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>              ([-:]+[ ]*[|][-| :]*) \n    # $2: Header underline&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              (                            # $3: Cells&nbsp;</div></li><li><div>                  (?&gt;&nbsp;</div></li><li><div>                      .* [|] .* \n        # Row content&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              (?=\n|\Z)                    # Stop at final double newline.&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_DoTable_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doTable_leadingPipe_callback($matches) {&nbsp;</div></li><li><div>      $head = $matches[1];&nbsp;</div></li><li><div>      $underline = $matches[2];&nbsp;</div></li><li><div>      $content = $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Remove leading pipe for each row.&nbsp;</div></li><li><div>      $content = preg_replace('/^ *[|]/m', '', $content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;_doTable_callback(array($matches[0], $head, $underline, $content));&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doTable_callback($matches) {&nbsp;</div></li><li><div>      $head = $matches[1];&nbsp;</div></li><li><div>      $underline = $matches[2];&nbsp;</div></li><li><div>      $content = $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Remove any tailing pipes for each line.&nbsp;</div></li><li><div>      $head = preg_replace('/[|] *$/m', '', $head);&nbsp;</div></li><li><div>      $underline = preg_replace('/[|] *$/m', '', $underline);&nbsp;</div></li><li><div>      $content = preg_replace('/[|] *$/m', '', $content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Reading alignement from header underline.&nbsp;</div></li><li><div>      $separators = preg_split('/ *[|] */', $underline);&nbsp;</div></li><li><div>      foreach ($separators as $n =&gt; $s) {&nbsp;</div></li><li><div>          if (preg_match('/^ *-+: *$/', $s))        $attr[$n] = ' align=&quot;right&quot;';&nbsp;</div></li><li><div>          else if (preg_match('/^ *:-+: *$/', $s))$attr[$n] = ' align=&quot;center&quot;';&nbsp;</div></li><li><div>          else if (preg_match('/^ *:-+ *$/', $s))    $attr[$n] = ' align=&quot;left&quot;';&nbsp;</div></li><li><div>          else                                    $attr[$n] = '';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Parsing span elements, including code spans, character escapes, &nbsp;</div></li><li><div>      # and inline HTML tags, so that pipes inside those gets ignored.&nbsp;</div></li><li><div>      $head = $this-&gt;parseSpan($head);&nbsp;</div></li><li><div>      $headers = preg_split('/ *[|] */', $head);&nbsp;</div></li><li><div>      $col_count = count($headers);&nbsp;</div></li><li><div>      $attr = array_pad($attr, $col_count, '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Write column headers.&nbsp;</div></li><li><div>      $text = &quot;&lt;table&gt;\n&quot;;&nbsp;</div></li><li><div>      $text .= &quot;&lt;thead&gt;\n&quot;;&nbsp;</div></li><li><div>      $text .= &quot;&lt;tr&gt;\n&quot;;&nbsp;</div></li><li><div>      foreach ($headers as $n =&gt; $header)&nbsp;</div></li><li><div>          $text .= &quot;  &lt;th$attr[$n]&gt;&quot;.$this-&gt;runSpanGamut(trim($header)).&quot;&lt;/th&gt;\n&quot;;&nbsp;</div></li><li><div>      $text .= &quot;&lt;/tr&gt;\n&quot;;&nbsp;</div></li><li><div>      $text .= &quot;&lt;/thead&gt;\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Split content by row.&nbsp;</div></li><li><div>      $rows = explode(&quot;\n&quot;, trim($content, &quot;\n&quot;));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $text .= &quot;&lt;tbody&gt;\n&quot;;&nbsp;</div></li><li><div>      foreach ($rows as $row) {&nbsp;</div></li><li><div>          # Parsing span elements, including code spans, character escapes, &nbsp;</div></li><li><div>          # and inline HTML tags, so that pipes inside those gets ignored.&nbsp;</div></li><li><div>          $row = $this-&gt;parseSpan($row);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          # Split row by cell.&nbsp;</div></li><li><div>          $row_cells = preg_split('/ *[|] */', $row, $col_count);&nbsp;</div></li><li><div>          $row_cells = array_pad($row_cells, $col_count, '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $text .= &quot;&lt;tr&gt;\n&quot;;&nbsp;</div></li><li><div>          foreach ($row_cells as $n =&gt; $cell)&nbsp;</div></li><li><div>              $text .= &quot;  &lt;td$attr[$n]&gt;&quot;.$this-&gt;runSpanGamut(trim($cell)).&quot;&lt;/td&gt;\n&quot;;&nbsp;</div></li><li><div>          $text .= &quot;&lt;/tr&gt;\n&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $text .= &quot;&lt;/tbody&gt;\n&quot;;&nbsp;</div></li><li><div>      $text .= &quot;&lt;/table&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;hashBlock($text) . &quot;\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doDefLists($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Form HTML definition lists.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Re-usable pattern to match any entire dl list:&nbsp;</div></li><li><div>      $whole_list_re = '(?&gt;&nbsp;</div></li><li><div>          (                                # $1 = whole list&nbsp;</div></li><li><div>            (                                # $2&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>              ((?&gt;.*\S.*\n)+)                # $3 = defined term&nbsp;</div></li><li><div>              \n?&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}:[ ]+ # colon starting definition&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            (?s:.+?)&nbsp;</div></li><li><div>            (                                # $4&nbsp;</div></li><li><div>                \z&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                \n{2, }&nbsp;</div></li><li><div>                (?=\S)&nbsp;</div></li><li><div>                (?!                        # Negative lookahead for another term&nbsp;</div></li><li><div>                  [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                  (?: \S.*\n )+?            # defined term&nbsp;</div></li><li><div>                  \n?&nbsp;</div></li><li><div>                  [ ]{0, '.$less_than_tab.'}:[ ]+ # colon starting definition&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                (?!                        # Negative lookahead for another definition&nbsp;</div></li><li><div>                  [ ]{0, '.$less_than_tab.'}:[ ]+ # colon starting definition&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )'; <span class="comment"><span class="comment">// mx</span></span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>              (?&gt;\A\n?|(?&lt;=\n\n))&nbsp;</div></li><li><div>              '.$whole_list_re.'&nbsp;</div></li><li><div>          }mx', &nbsp;</div></li><li><div>          array(&$this, '_doDefLists_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doDefLists_callback($matches) {&nbsp;</div></li><li><div>      # Re-usable patterns to match list item bullets and number markers:&nbsp;</div></li><li><div>      $list = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Turn double returns into triple returns, so that we can make a&nbsp;</div></li><li><div>      # paragraph for the last item in a list, if necessary:&nbsp;</div></li><li><div>      $result = trim($this-&gt;processDefListItems($list));&nbsp;</div></li><li><div>      $result = &quot;&lt;dl&gt;\n&quot; . $result . &quot;\n&lt;/dl&gt;&quot;;&nbsp;</div></li><li><div>      return $this-&gt;hashBlock($result) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function processDefListItems($list_str) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Process the contents of a single definition list, splitting it&nbsp;</div></li><li><div>  #    into individual term and definition list items.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # trim trailing blank lines:&nbsp;</div></li><li><div>      $list_str = preg_replace(&quot;/\n{2, }\\z/&quot;, &quot;\n&quot;, $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Process definition terms.&nbsp;</div></li><li><div>      $list_str = preg_replace_callback('{&nbsp;</div></li><li><div>          (?&gt;\A\n?|\n\n+)                    # leading line&nbsp;</div></li><li><div>          (                                # definition terms = $1&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}    # leading whitespace&nbsp;</div></li><li><div>              (?!\:[ ]|[ ])                # negative lookahead for a definition&nbsp;</div></li><li><div>                                          #   mark (colon) or more whitespace.&nbsp;</div></li><li><div>              (?&gt; \S.* \n)+?                # actual term (not whitespace).&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          (?=\n?[ ]{0, 3}:[ ])                # lookahead for following line feed&nbsp;</div></li><li><div>                                          #   with a definition mark.&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_processDefListItems_callback_dt'), $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Process actual definitions.&nbsp;</div></li><li><div>      $list_str = preg_replace_callback('{&nbsp;</div></li><li><div>          \n(\n+)?                        # leading line = $1&nbsp;</div></li><li><div>          (                                # marker space = $2&nbsp;</div></li><li><div>              [ ]{0, '.$less_than_tab.'}    # whitespace before colon&nbsp;</div></li><li><div>              \:[ ]+                        # definition mark (colon)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          ((?s:.+?))                        # definition text = $3&nbsp;</div></li><li><div>          (?= \n+                         # stop at next definition mark, &nbsp;</div></li><li><div>              (?:                            # next term or end of text&nbsp;</div></li><li><div>                  [ ]{0, '.$less_than_tab.'} \:[ ]    |&nbsp;</div></li><li><div>                  &lt;dt&gt; | \z&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_processDefListItems_callback_dd'), $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $list_str;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _processDefListItems_callback_dt($matches) {&nbsp;</div></li><li><div>      $terms = explode(&quot;\n&quot;, trim($matches[1]));&nbsp;</div></li><li><div>      $text = '';&nbsp;</div></li><li><div>      foreach ($terms as $term) {&nbsp;</div></li><li><div>          $term = $this-&gt;runSpanGamut(trim($term));&nbsp;</div></li><li><div>          $text .= &quot;\n&lt;dt&gt;&quot; . $term . &quot;&lt;/dt&gt;&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $text . &quot;\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _processDefListItems_callback_dd($matches) {&nbsp;</div></li><li><div>      $leading_line = $matches[1];&nbsp;</div></li><li><div>      $marker_space = $matches[2];&nbsp;</div></li><li><div>      $def = $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($leading_line || preg_match('/\n{2, }/', $def)) {&nbsp;</div></li><li><div>          # Replace marker with the appropriate whitespace indentation&nbsp;</div></li><li><div>          $def = str_repeat(' ', strlen($marker_space)) . $def;&nbsp;</div></li><li><div>          $def = $this-&gt;runBlockGamut($this-&gt;outdent($def . &quot;\n\n&quot;));&nbsp;</div></li><li><div>          $def = &quot;\n&quot;. $def .&quot;\n&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else {&nbsp;</div></li><li><div>          $def = rtrim($def);&nbsp;</div></li><li><div>          $def = $this-&gt;runSpanGamut($this-&gt;outdent($def));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return &quot;\n&lt;dd&gt;&quot; . $def . &quot;&lt;/dd&gt;\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doFencedCodeBlocks($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Adding the fenced code block syntax to regular Markdown:&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # ~~~&nbsp;</div></li><li><div>  # Code block&nbsp;</div></li><li><div>  # ~~~&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>              (?:\n|\A)&nbsp;</div></li><li><div>              # 1: Opening marker&nbsp;</div></li><li><div>              (&nbsp;</div></li><li><div>                  (?:~{3, }|`{3, }) # 3 or more tildes/backticks.&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              [ ]*&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  \.?([-_:a-zA-Z0-9]+) # 2: standalone class name&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  '.$this-&gt;id_class_attr_catch_re.' # 3: Extra attributes&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>              [ ]* \n # Whitespace and newline following marker.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              # 4: Content&nbsp;</div></li><li><div>              (&nbsp;</div></li><li><div>                  (?&gt;&nbsp;</div></li><li><div>                      (?!\1 [ ]* \n)    # Not a closing marker.&nbsp;</div></li><li><div>                      .*\n+&nbsp;</div></li><li><div> )+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              # Closing marker.&nbsp;</div></li><li><div>              \1 [ ]* (?= \n )&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_doFencedCodeBlocks_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doFencedCodeBlocks_callback($matches) {&nbsp;</div></li><li><div>      $classname =& $matches[2];&nbsp;</div></li><li><div>      $attrs =& $matches[3];&nbsp;</div></li><li><div>      $codeblock = $matches[4];&nbsp;</div></li><li><div>      $codeblock = htmlspecialchars($codeblock, ENT_NOQUOTES);&nbsp;</div></li><li><div>      $codeblock = preg_replace_callback('/^\n+/', &nbsp;</div></li><li><div>          array(&$this, '_doFencedCodeBlocks_newlines'), $codeblock);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($classname != &quot;&quot;) {&nbsp;</div></li><li><div>          if ($classname{0} == '.')&nbsp;</div></li><li><div>              $classname = substr($classname, 1);&nbsp;</div></li><li><div>          $attr_str = ' class=&quot;'.$this-&gt;code_class_prefix.$classname.'&quot;';&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $attr_str = $this-&gt;doExtraAttributes($this-&gt;code_attr_on_pre ? &quot;pre&quot; : &quot;code&quot;, $attrs);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $pre_attr_str = $this-&gt;code_attr_on_pre ? $attr_str : '';&nbsp;</div></li><li><div>      $code_attr_str = $this-&gt;code_attr_on_pre ? '' : $attr_str;&nbsp;</div></li><li><div>      $codeblock = &quot;&lt;pre$pre_attr_str&gt;&lt;code$code_attr_str&gt;$codeblock&lt;/code&gt;&lt;/pre&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return &quot;\n\n&quot;.$this-&gt;hashBlock($codeblock).&quot;\n\n&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doFencedCodeBlocks_newlines($matches) {&nbsp;</div></li><li><div>      return str_repeat(&quot;&lt;br$this-&gt;empty_element_suffix&quot;, &nbsp;</div></li><li><div>          strlen($matches[0]));&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Redefining emphasis markers so that emphasis by underscore does not&nbsp;</div></li><li><div>  # work in the middle of a word.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  public $em_relist = array(&nbsp;</div></li><li><div>      '' =&gt; '(?:(?&lt;!\*)\*(?!\*)|(?&lt;![a-zA-Z0-9_])_(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>      '*' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*(?!\*)', &nbsp;</div></li><li><div>      '_' =&gt; '(?&lt;=\S|^)(?&lt;!_)_(?![a-zA-Z0-9_])', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  public $strong_relist = array(&nbsp;</div></li><li><div>      '' =&gt; '(?:(?&lt;!\*)\*\*(?!\*)|(?&lt;![a-zA-Z0-9_])__(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>      '**' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*(?!\*)', &nbsp;</div></li><li><div>      '__' =&gt; '(?&lt;=\S|^)(?&lt;!_)__(?![a-zA-Z0-9_])', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>  public $em_strong_relist = array(&nbsp;</div></li><li><div>      '' =&gt; '(?:(?&lt;!\*)\*\*\*(?!\*)|(?&lt;![a-zA-Z0-9_])___(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>      '***' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*\*(?!\*)', &nbsp;</div></li><li><div>      '___' =&gt; '(?&lt;=\S|^)(?&lt;!_)___(?![a-zA-Z0-9_])', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function formParagraphs($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  #    Params:&nbsp;</div></li><li><div>  #        $text - string to process with html &lt;p&gt; tags&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      # Strip leading and trailing lines:&nbsp;</div></li><li><div>      $text = preg_replace('/\A\n+|\n+\z/', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $grafs = preg_split('/\n{2, }/', $text, -1, PREG_SPLIT_NO_EMPTY);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      # Wrap &lt;p&gt; tags and unhashify HTML blocks&nbsp;</div></li><li><div>      #&nbsp;</div></li><li><div>      foreach ($grafs as $key =&gt; $value) {&nbsp;</div></li><li><div>          $value = trim($this-&gt;runSpanGamut($value));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          # Check if this should be enclosed in a paragraph.&nbsp;</div></li><li><div>          # Clean tag hashes & block tag hashes are left alone.&nbsp;</div></li><li><div>          $is_p = !preg_match('/^B\x1A[0-9]+B|^C\x1A[0-9]+C$/', $value);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($is_p) {&nbsp;</div></li><li><div>              $value = &quot;&lt;p&gt;$value&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $grafs[$key] = $value;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Join grafs in one text, then unhash HTML tags.&nbsp;</div></li><li><div>      $text = implode(&quot;\n\n&quot;, $grafs);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Finish by removing any tag hashes still present in $text.&nbsp;</div></li><li><div>      $text = $this-&gt;unhash($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### Footnotes&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function stripFootnotes($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Strips link definitions from text, stores the URLs and titles in&nbsp;</div></li><li><div>  # hash references.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Link defs are in the form: [^id]: url &quot;optional title&quot;&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          ^[ ]{0, '.$less_than_tab.'}\[\^(.+?)\][ ]?:    # note_id = $1&nbsp;</div></li><li><div>            [ ]*&nbsp;</div></li><li><div>            \n?                    # maybe *one* newline&nbsp;</div></li><li><div>          (                        # text = $2 (no blank lines allowed)&nbsp;</div></li><li><div>              (?:&nbsp;</div></li><li><div>                  .+                # actual text&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                  \n                # newlines but&nbsp;</div></li><li><div>                  (?!\[\^.+?\]:\s)# negative lookahead for footnote marker.&nbsp;</div></li><li><div>                  (?!\n+[ ]{0, 3}\S)# ensure line is not blank and followed&nbsp;</div></li><li><div>                                  # by non-indented content&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_stripFootnotes_callback'), &nbsp;</div></li><li><div>          $text);&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _stripFootnotes_callback($matches) {&nbsp;</div></li><li><div>      $note_id = $this-&gt;fn_id_prefix . $matches[1];&nbsp;</div></li><li><div>      $this-&gt;footnotes[$note_id] = $this-&gt;outdent($matches[2]);&nbsp;</div></li><li><div>      return ''; # String that will replace the block&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doFootnotes($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Replace footnote references in $text [^id] with a special text-token&nbsp;</div></li><li><div>  # which will be replaced by the actual footnote marker in appendFootnotes.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if (!$this-&gt;in_anchor) {&nbsp;</div></li><li><div>          $text = preg_replace('{\[\^(.+?)\]}', &quot;F\x1Afn:\\1\x1A:&quot;, $text);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function appendFootnotes($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Append footnote list to text.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $text = preg_replace_callback('{F\x1Afn:(.*?)\x1A:}', &nbsp;</div></li><li><div>          array(&$this, '_appendFootnotes_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (!empty($this-&gt;footnotes_ordered)) {&nbsp;</div></li><li><div>          $text .= &quot;\n\n&quot;;&nbsp;</div></li><li><div>          $text .= &quot;&lt;div class=\&quot;footnotes\&quot;&gt;\n&quot;;&nbsp;</div></li><li><div>          $text .= &quot;&lt;hr&quot;. $this-&gt;empty_element_suffix .&quot;\n&quot;;&nbsp;</div></li><li><div>          $text .= &quot;&lt;ol&gt;\n\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $attr = &quot; rev=\&quot;footnote\&quot;&quot;;&nbsp;</div></li><li><div>          if ($this-&gt;fn_backlink_class != &quot;&quot;) {&nbsp;</div></li><li><div>              $class = $this-&gt;fn_backlink_class;&nbsp;</div></li><li><div>              $class = $this-&gt;encodeAttribute($class);&nbsp;</div></li><li><div>              $attr .= &quot; class=\&quot;$class\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ($this-&gt;fn_backlink_title != &quot;&quot;) {&nbsp;</div></li><li><div>              $title = $this-&gt;fn_backlink_title;&nbsp;</div></li><li><div>              $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>              $attr .= &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $num = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          while (!empty($this-&gt;footnotes_ordered)) {&nbsp;</div></li><li><div>              $footnote = reset($this-&gt;footnotes_ordered);&nbsp;</div></li><li><div>              $note_id = key($this-&gt;footnotes_ordered);&nbsp;</div></li><li><div>              unset($this-&gt;footnotes_ordered[$note_id]);&nbsp;</div></li><li><div>              $ref_count = $this-&gt;footnotes_ref_count[$note_id];&nbsp;</div></li><li><div>              unset($this-&gt;footnotes_ref_count[$note_id]);&nbsp;</div></li><li><div>              unset($this-&gt;footnotes[$note_id]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $footnote .= &quot;\n&quot;; # Need to append newline before parsing.&nbsp;</div></li><li><div>              $footnote = $this-&gt;runBlockGamut(&quot;$footnote\n&quot;);&nbsp;</div></li><li><div>              $footnote = preg_replace_callback('{F\x1Afn:(.*?)\x1A:}', &nbsp;</div></li><li><div>                  array(&$this, '_appendFootnotes_callback'), $footnote);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $attr = str_replace(&quot;%%&quot;, ++$num, $attr);&nbsp;</div></li><li><div>              $note_id = $this-&gt;encodeAttribute($note_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              # Prepare backlink, multiple backlinks if multiple references&nbsp;</div></li><li><div>              $backlink = &quot;&lt;a href=\&quot;#fnref:$note_id\&quot;$attr&gt;&#8617;&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>              for ($ref_num = 2; $ref_num &lt;= $ref_count; ++$ref_num) {&nbsp;</div></li><li><div>                  $backlink .= &quot; &lt;a href=\&quot;#fnref$ref_num:$note_id\&quot;$attr&gt;&#8617;&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              # Add backlink to last paragraph; create new paragraph if needed.&nbsp;</div></li><li><div>              if (preg_match('{&lt;/p&gt;$}', $footnote)) {&nbsp;</div></li><li><div>                  $footnote = substr($footnote, 0, -4) . &quot;&#160;$backlink&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $footnote .= &quot;\n\n&lt;p&gt;$backlink&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $text .= &quot;&lt;li id=\&quot;fn:$note_id\&quot;&gt;\n&quot;;&nbsp;</div></li><li><div>              $text .= $footnote . &quot;\n&quot;;&nbsp;</div></li><li><div>              $text .= &quot;&lt;/li&gt;\n\n&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $text .= &quot;&lt;/ol&gt;\n&quot;;&nbsp;</div></li><li><div>          $text .= &quot;&lt;/div&gt;&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _appendFootnotes_callback($matches) {&nbsp;</div></li><li><div>      $node_id = $this-&gt;fn_id_prefix . $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Create footnote marker only if it has a corresponding footnote *and*&nbsp;</div></li><li><div>      # the footnote hasn't been used by another marker.&nbsp;</div></li><li><div>      if (isset($this-&gt;footnotes[$node_id])) {&nbsp;</div></li><li><div>          $num =& $this-&gt;footnotes_numbers[$node_id];&nbsp;</div></li><li><div>          if (!isset($num)) {&nbsp;</div></li><li><div>              # Transfer footnote content to the ordered list and give it its&nbsp;</div></li><li><div>              # number&nbsp;</div></li><li><div>              $this-&gt;footnotes_ordered[$node_id] = $this-&gt;footnotes[$node_id];&nbsp;</div></li><li><div>              $this-&gt;footnotes_ref_count[$node_id] = 1;&nbsp;</div></li><li><div>              $num = $this-&gt;footnote_counter++;&nbsp;</div></li><li><div>              $ref_count_mark = '';&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $ref_count_mark = $this-&gt;footnotes_ref_count[$node_id] += 1;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $attr = &quot; rel=\&quot;footnote\&quot;&quot;;&nbsp;</div></li><li><div>          if ($this-&gt;fn_link_class != &quot;&quot;) {&nbsp;</div></li><li><div>              $class = $this-&gt;fn_link_class;&nbsp;</div></li><li><div>              $class = $this-&gt;encodeAttribute($class);&nbsp;</div></li><li><div>              $attr .= &quot; class=\&quot;$class\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ($this-&gt;fn_link_title != &quot;&quot;) {&nbsp;</div></li><li><div>              $title = $this-&gt;fn_link_title;&nbsp;</div></li><li><div>              $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>              $attr .= &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $attr = str_replace(&quot;%%&quot;, $num, $attr);&nbsp;</div></li><li><div>          $node_id = $this-&gt;encodeAttribute($node_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return&nbsp;</div></li><li><div>              &quot;&lt;sup id=\&quot;fnref$ref_count_mark:$node_id\&quot;&gt;&quot;.&nbsp;</div></li><li><div>              &quot;&lt;a href=\&quot;#fn:$node_id\&quot;$attr&gt;$num&lt;/a&gt;&quot;.&nbsp;</div></li><li><div>              &quot;&lt;/sup&gt;&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return &quot;[^&quot;.$matches[1].&quot;]&quot;;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  ### Abbreviations ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function stripAbbreviations($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Strips abbreviations from text, stores titles in hash references.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      # Link defs are in the form: [id]*: url &quot;optional title&quot;&nbsp;</div></li><li><div>      $text = preg_replace_callback('{&nbsp;</div></li><li><div>          ^[ ]{0, '.$less_than_tab.'}\*\[(.+?)\][ ]?:    # abbr_id = $1&nbsp;</div></li><li><div>          (.*)                    # text = $2 (no blank lines allowed)&nbsp;</div></li><li><div>          }xm', &nbsp;</div></li><li><div>          array(&$this, '_stripAbbreviations_callback'), &nbsp;</div></li><li><div>          $text);&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _stripAbbreviations_callback($matches) {&nbsp;</div></li><li><div>      $abbr_word = $matches[1];&nbsp;</div></li><li><div>      $abbr_desc = $matches[2];&nbsp;</div></li><li><div>      if ($this-&gt;abbr_word_re)&nbsp;</div></li><li><div>          $this-&gt;abbr_word_re .= '|';&nbsp;</div></li><li><div>      $this-&gt;abbr_word_re .= preg_quote($abbr_word);&nbsp;</div></li><li><div>      $this-&gt;abbr_desciptions[$abbr_word] = trim($abbr_desc);&nbsp;</div></li><li><div>      return ''; # String that will replace the block&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function doAbbreviations($text) {&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>  # Find defined abbreviations in text and wrap them in &lt;abbr&gt; elements.&nbsp;</div></li><li><div>  #&nbsp;</div></li><li><div>      if ($this-&gt;abbr_word_re) {&nbsp;</div></li><li><div>          <span class="comment">// cannot use the /x modifier because abbr_word_re may</span>&nbsp;</div></li><li><div>          <span class="comment">// contain significant spaces:</span>&nbsp;</div></li><li><div>          $text = preg_replace_callback('{'.&nbsp;</div></li><li><div>              '(?&lt;![\w\x1A])'.&nbsp;</div></li><li><div>              '(?:'.$this-&gt;abbr_word_re.')'.&nbsp;</div></li><li><div>              '(?![\w\x1A])'.&nbsp;</div></li><li><div>              '}', &nbsp;</div></li><li><div>              array(&$this, '_doAbbreviations_callback'), $text);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function _doAbbreviations_callback($matches) {&nbsp;</div></li><li><div>      $abbr = $matches[0];&nbsp;</div></li><li><div>      if (isset($this-&gt;abbr_desciptions[$abbr])) {&nbsp;</div></li><li><div>          $desc = $this-&gt;abbr_desciptions[$abbr];&nbsp;</div></li><li><div>          if (empty($desc)) {&nbsp;</div></li><li><div>              return $this-&gt;hashPart(&quot;&lt;abbr&gt;$abbr&lt;/abbr&gt;&quot;);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $desc = $this-&gt;encodeAttribute($desc);&nbsp;</div></li><li><div>              return $this-&gt;hashPart(&quot;&lt;abbr title=\&quot;$desc\&quot;&gt;$abbr&lt;/abbr&gt;&quot;);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return $matches[0];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>PHP Markdown Extra&nbsp;</div></li><li><div>==================&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Description&nbsp;</div></li><li><div>-----------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>This is a PHP port of the original Markdown formatter written in Perl&nbsp;</div></li><li><div>by John Gruber. This special &quot;Extra&quot; version of PHP Markdown features&nbsp;</div></li><li><div>further enhancements to the syntax for making additional constructs&nbsp;</div></li><li><div>such as tables and definition list.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Markdown is a text-to-HTML filter; it translates an easy-to-read /&nbsp;</div></li><li><div>easy-to-write structured text format into HTML. Markdown's text format&nbsp;</div></li><li><div>is mostly similar to that of plain text email, and supports features such&nbsp;</div></li><li><div>as headers, *emphasis*, code blocks, blockquotes, and links.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Markdown's syntax is designed not as a generic markup language, but&nbsp;</div></li><li><div>specifically to serve as a front-end to (X)HTML. You can use span-level&nbsp;</div></li><li><div>HTML tags anywhere in a Markdown document, and you can use block level&nbsp;</div></li><li><div>HTML tags (like &lt;div&gt; and &lt;table&gt; as well).&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>For more information about Markdown's syntax, see:&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&lt;http:<span class="comment">//daringfireball.net/projects/markdown/&gt;</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Bugs&nbsp;</div></li><li><div>----&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>To file bug reports please send email to:&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&lt;michel.fortin@michelf.ca&gt;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Please include with your report: (1) the example input; (2) the output you&nbsp;</div></li><li><div>expected; (3) the output Markdown actually produced.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Version History&nbsp;</div></li><li><div>---------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>See the readme file for detailed release notes for this version.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Copyright and License&nbsp;</div></li><li><div>---------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>PHP Markdown & Extra&nbsp;</div></li><li><div>Copyright (c) 2004-2013 Michel Fortin&nbsp;</div></li><li><div>&lt;http://michelf.ca/&gt;&nbsp;</div></li><li><div>All rights reserved.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Based on Markdown&nbsp;</div></li><li><div>Copyright (c) 2003-2006 John Gruber&nbsp;</div></li><li><div>&lt;http://daringfireball.net/&gt;&nbsp;</div></li><li><div>All rights reserved.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>Redistribution and use in source and binary forms, with or without&nbsp;</div></li><li><div>modification, are permitted provided that the following conditions are&nbsp;</div></li><li><div>met:&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>*    Redistributions of source code must retain the above copyright notice, &nbsp;</div></li><li><div>  this list of conditions and the following disclaimer.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>*    Redistributions in binary form must reproduce the above copyright&nbsp;</div></li><li><div>  notice, this list of conditions and the following disclaimer in the&nbsp;</div></li><li><div>  documentation and/or other materials provided with the distribution.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>*    Neither the name &quot;Markdown&quot; nor the names of its contributors may&nbsp;</div></li><li><div>  be used to endorse or promote products derived from this software&nbsp;</div></li><li><div>  without specific prior written permission.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>This software is provided by the copyright holders and contributors &quot;as&nbsp;</div></li><li><div>is&quot; and any express or implied warranties, including, but not limited&nbsp;</div></li><li><div>to, the implied warranties of merchantability and fitness for a&nbsp;</div></li><li><div>particular purpose are disclaimed. In no event shall the copyright owner&nbsp;</div></li><li><div>or contributors be liable for any direct, indirect, incidental, special, &nbsp;</div></li><li><div>exemplary, or consequential damages (including, but not limited to, &nbsp;</div></li><li><div>procurement of substitute goods or services; loss of use, data, or&nbsp;</div></li><li><div>profits; or business interruption) however caused and on any theory of&nbsp;</div></li><li><div>liability, whether in contract, strict liability, or tort (including&nbsp;</div></li><li><div>negligence or otherwise) arising in any way out of the use of this&nbsp;</div></li><li><div>software, even if advised of the possibility of such damage.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>*/&nbsp;</div></li><li><div>?&gt;&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>file</li><li><span></span></li><li><span></span>Jetpack by WordPress.com</li><li><span></span>3.8.2</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2022 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>