<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="3.8.0" data-slug="jetpack-by-wordpress-com" data-type="class" data-id="12963"><head xmlns="http://www.w3.org/1999/xhtml"><title> markdown_parser | class | Jetpack By WordPress Com | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="Markdown_Parser, class, plugin, jetpack-by-wordpress-com, 3.8.0" /><meta name="description" content="The Jetpack by WordPress.com Markdown Parser class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=878cb4d7f2bda5fdc55358b0d1d5c52e' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/markdown_parser/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fmarkdown_parser%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fmarkdown_parser%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-jetpack-by-wordpress-com-3.8.0-class-markdown_parser","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="markdown_parser" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to jetpack-by-wordpress-com." href="http://hookr.io/plugins/jetpack-by-wordpress-com/" class="plugin"><span property="name">jetpack-by-wordpress-com</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 3.8.0." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/" class="H_VERSION"><span property="name">3.8.0</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">markdown_parser</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="1499"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/all/" title="All">All <span class="count badge">1499</span></a></li><li class="" data-id="new" data-count="17"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/new/" title="New">New <span class="count badge">17</span></a></li><li class="" data-id="hooks" data-count="599"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/hooks/" title="Hooks">Hooks <span class="count badge">599</span></a></li><li class="" data-id="action" data-count="195"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/actions/" title="Actions">Actions <span class="count badge">195</span></a></li><li class="" data-id="filter" data-count="404"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/filters/" title="Filters">Filters <span class="count badge">404</span></a></li><li class="active" data-id="class" data-count="262"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/" title="Classes">Classes <span class="count badge">262</span></a></li><li class="" data-id="constant" data-count="62"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/constants/" title="Constants">Constants <span class="count badge">62</span></a></li><li class="" data-id="function" data-count="530"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/functions/" title="Functions">Functions <span class="count badge">530</span></a></li><li class="" data-id="shortcode" data-count="46"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">46</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>Markdown_Parser</strong></h1><p>The Jetpack by WordPress.com <strong>Markdown Parser</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/files/inc-lib-markdown-extra/" class="file">/_inc/lib/markdown/extra.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="51" class="block" start="70"><li><div>class Markdown_Parser {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### Configuration Variables ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Change to &quot;&gt;&quot; for HTML output.&nbsp;</div></li><li><div>    public $empty_element_suffix = MARKDOWN_EMPTY_ELEMENT_SUFFIX;&nbsp;</div></li><li><div>    public $tab_width = MARKDOWN_TAB_WIDTH;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Change to `true` to disallow markup or entities.&nbsp;</div></li><li><div>    public $no_markup = false;&nbsp;</div></li><li><div>    public $no_entities = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Predefined urls and titles for reference links and images.&nbsp;</div></li><li><div>    public $predef_urls = array();&nbsp;</div></li><li><div>    public $predef_titles = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### Parser Implementation ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Regex to match balanced [brackets].&nbsp;</div></li><li><div>    # Needed to insert a maximum bracked depth while converting to PHP.&nbsp;</div></li><li><div>    public $nested_brackets_depth = 6;&nbsp;</div></li><li><div>    public $nested_brackets_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public $nested_url_parenthesis_depth = 4;&nbsp;</div></li><li><div>    public $nested_url_parenthesis_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Table of hash values for escaped characters:&nbsp;</div></li><li><div>    public $escape_chars = '\`*_{}[]()&gt;#+-.!';&nbsp;</div></li><li><div>    public $escape_chars_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function __construct() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Constructor function. Initialize appropriate member variables.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $this-&gt;_initDetab();&nbsp;</div></li><li><div>        $this-&gt;prepareItalicsAndBold();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;nested_brackets_re =&nbsp;</div></li><li><div>            str_repeat('(?&gt;[^\[\]]+|\[', $this-&gt;nested_brackets_depth).&nbsp;</div></li><li><div>            str_repeat('\])*', $this-&gt;nested_brackets_depth);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;nested_url_parenthesis_re =&nbsp;</div></li><li><div>            str_repeat('(?&gt;[^()\s]+|\(', $this-&gt;nested_url_parenthesis_depth).&nbsp;</div></li><li><div>            str_repeat('(?&gt;\)))*', $this-&gt;nested_url_parenthesis_depth);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;escape_chars_re = '['.preg_quote($this-&gt;escape_chars).']';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Sort document, block, and span gamut in ascendent priority order.&nbsp;</div></li><li><div>        asort($this-&gt;document_gamut);&nbsp;</div></li><li><div>        asort($this-&gt;block_gamut);&nbsp;</div></li><li><div>        asort($this-&gt;span_gamut);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Internal hashes used during transformation.&nbsp;</div></li><li><div>    public $urls = array();&nbsp;</div></li><li><div>    public $titles = array();&nbsp;</div></li><li><div>    public $html_hashes = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Status flag to avoid invalid nesting.&nbsp;</div></li><li><div>    public $in_anchor = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function setup() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Called before the transformation process starts to setup parser&nbsp;</div></li><li><div>    # states.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # Clear global hashes.&nbsp;</div></li><li><div>        $this-&gt;urls = $this-&gt;predef_urls;&nbsp;</div></li><li><div>        $this-&gt;titles = $this-&gt;predef_titles;&nbsp;</div></li><li><div>        $this-&gt;html_hashes = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;in_anchor = false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function teardown() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Called after the transformation process to clear any variable&nbsp;</div></li><li><div>    # which may be taking up memory unnecessarly.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $this-&gt;urls = array();&nbsp;</div></li><li><div>        $this-&gt;titles = array();&nbsp;</div></li><li><div>        $this-&gt;html_hashes = array();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function transform($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Main function. Performs some preprocessing on the input text&nbsp;</div></li><li><div>    # and pass it through the document gamut.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $this-&gt;setup();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Remove UTF-8 BOM and marker character in input, if present.&nbsp;</div></li><li><div>        $text = preg_replace('{^\xEF\xBB\xBF|\x1A}', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Standardize line endings:&nbsp;</div></li><li><div>        #   DOS to Unix and Mac to Unix&nbsp;</div></li><li><div>        $text = preg_replace('{\r\n?}', &quot;\n&quot;, $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Make sure $text ends with a couple of newlines:&nbsp;</div></li><li><div>        $text .= &quot;\n\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Convert all tabs to spaces.&nbsp;</div></li><li><div>        $text = $this-&gt;detab($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Turn block-level HTML blocks into hash entries&nbsp;</div></li><li><div>        $text = $this-&gt;hashHTMLBlocks($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Strip any lines consisting only of spaces and tabs.&nbsp;</div></li><li><div>        # This makes subsequent regexen easier to write, because we can&nbsp;</div></li><li><div>        # match consecutive blank lines with /\n+/ instead of something&nbsp;</div></li><li><div>        # contorted like /[ ]*\n+/ .&nbsp;</div></li><li><div>        $text = preg_replace('/^[ ]+$/m', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Run document gamut methods.&nbsp;</div></li><li><div>        foreach ($this-&gt;document_gamut as $method =&gt; $priority) {&nbsp;</div></li><li><div>            $text = $this-&gt;$method($text);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;teardown();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text . &quot;\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public $document_gamut = array(&nbsp;</div></li><li><div>        # Strip link definitions, store in hashes.&nbsp;</div></li><li><div>        &quot;stripLinkDefinitions&quot; =&gt; 20, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        &quot;runBasicBlockGamut&quot; =&gt; 30, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function stripLinkDefinitions($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Strips link definitions from text, stores the URLs and titles in&nbsp;</div></li><li><div>    # hash references.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Link defs are in the form: ^[id]: url &quot;optional title&quot;&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>                            ^[ ]{0, '.$less_than_tab.'}\[(.+)\][ ]?:    # id = $1&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                              \n?                # maybe *one* newline&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                            (?:&nbsp;</div></li><li><div>                              &lt;(.+?)&gt;            # url = $2&nbsp;</div></li><li><div>                            |&nbsp;</div></li><li><div>                              (\S+?)            # url = $3&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                              \n?                # maybe one newline&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                            (?:&nbsp;</div></li><li><div>                                (?&lt;=\s)            # lookbehind for whitespace&nbsp;</div></li><li><div>                                [&quot;(]&nbsp;</div></li><li><div>                                (.*?)            # title = $4&nbsp;</div></li><li><div>                                [&quot;)]&nbsp;</div></li><li><div>                                [ ]*&nbsp;</div></li><li><div> )?    # title is optional&nbsp;</div></li><li><div>                            (?:\n+|\Z)&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_stripLinkDefinitions_callback'), &nbsp;</div></li><li><div>            $text);&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _stripLinkDefinitions_callback($matches) {&nbsp;</div></li><li><div>        $link_id = strtolower($matches[1]);&nbsp;</div></li><li><div>        $url = $matches[2] == '' ? $matches[3] : $matches[2];&nbsp;</div></li><li><div>        $this-&gt;urls[$link_id] = $url;&nbsp;</div></li><li><div>        $this-&gt;titles[$link_id] =& $matches[4];&nbsp;</div></li><li><div>        return ''; # String that will replace the block&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function hashHTMLBlocks($text) {&nbsp;</div></li><li><div>        if ($this-&gt;no_markup)  return $text;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Hashify HTML blocks:&nbsp;</div></li><li><div>        # We only want to do this for block-level HTML tags, such as headers, &nbsp;</div></li><li><div>        # lists, and tables. That's because we still want to wrap &lt;p&gt;s around&nbsp;</div></li><li><div>        # &quot;paragraphs&quot; that are wrapped in non-block-level tags, such as anchors, &nbsp;</div></li><li><div>        # phrase emphasis, and spans. The list of tags we're looking for is&nbsp;</div></li><li><div>        # hard-coded:&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # *  List &quot;a&quot; is made of tags which can be both inline or block-level.&nbsp;</div></li><li><div>        #    These will be treated block-level when the start tag is alone on&nbsp;</div></li><li><div>        #    its line, otherwise they're not matched here and will be taken as&nbsp;</div></li><li><div>        #    inline later.&nbsp;</div></li><li><div>        # *  List &quot;b&quot; is made of tags which are always block-level;&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $block_tags_a_re = 'ins|del';&nbsp;</div></li><li><div>        $block_tags_b_re = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|'.&nbsp;</div></li><li><div>                           'script|noscript|form|fieldset|iframe|math|svg|'.&nbsp;</div></li><li><div>                           'article|section|nav|aside|hgroup|header|footer|'.&nbsp;</div></li><li><div>                           'figure';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Regular expression for the content of a block tag.&nbsp;</div></li><li><div>        $nested_tags_level = 4;&nbsp;</div></li><li><div>        $attr = '&nbsp;</div></li><li><div>            (?&gt;                # optional tag attributes&nbsp;</div></li><li><div>              \s            # starts with whitespace&nbsp;</div></li><li><div>              (?&gt;&nbsp;</div></li><li><div>                [^&gt;&quot;/]+        # text outside quotes&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                /+(?!&gt;)        # slash not followed by &quot;&gt;&quot;&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                &quot;[^&quot;]*&quot;        # text inside double quotes (tolerate &quot;&gt;&quot;)&nbsp;</div></li><li><div>              |&nbsp;</div></li><li><div>                \'[^\']*\'    # text inside single quotes (tolerate &quot;&gt;&quot;)&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>            ';&nbsp;</div></li><li><div>        $content =&nbsp;</div></li><li><div>            str_repeat('&nbsp;</div></li><li><div>                (?&gt;&nbsp;</div></li><li><div>                  [^&lt;]+            # content without tag&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                  &lt;\2            # nested opening tag&nbsp;</div></li><li><div>                    '.$attr.'    # attributes&nbsp;</div></li><li><div>                    (?&gt;&nbsp;</div></li><li><div>                      /&gt;&nbsp;</div></li><li><div>                    |&nbsp;</div></li><li><div>                      &gt;', $nested_tags_level).    # end of opening tag&nbsp;</div></li><li><div>                      '.*?'.                    # last level nested tag content&nbsp;</div></li><li><div>            str_repeat('&nbsp;</div></li><li><div>                      &lt;/\2\s*&gt;    # closing nested tag&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                  |&nbsp;</div></li><li><div>                    &lt;(?!/\2\s*&gt;    # other tags with a different name&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )*', &nbsp;</div></li><li><div>                $nested_tags_level);&nbsp;</div></li><li><div>        $content2 = str_replace('\2', '\3', $content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # First, look for nested blocks, e.g.:&nbsp;</div></li><li><div>        #     &lt;div&gt;&nbsp;</div></li><li><div>        #         &lt;div&gt;&nbsp;</div></li><li><div>        #         tags for inner block must be indented.&nbsp;</div></li><li><div>        #         &lt;/div&gt;&nbsp;</div></li><li><div>        #     &lt;/div&gt;&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # The outermost tags must start at the left margin for this to match, and&nbsp;</div></li><li><div>        # the inner nested divs must be indented.&nbsp;</div></li><li><div>        # We need to do this before the next, more liberal match, because the next&nbsp;</div></li><li><div>        # match will start at the first `&lt;div&gt;` and stop at the first `&lt;/div&gt;`.&nbsp;</div></li><li><div>        $text = preg_replace_callback('{(?&gt;&nbsp;</div></li><li><div>            (?&gt;&nbsp;</div></li><li><div>                (?&lt;=\n\n)        # Starting after a blank line&nbsp;</div></li><li><div>                |                # or&nbsp;</div></li><li><div>                \A\n?            # the beginning of the doc&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            (                        # save in $1&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              # Match from `\n&lt;tag&gt;` to `&lt;/tag&gt;\n`, handling nested tags&nbsp;</div></li><li><div>              # in between.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                        &lt;('.$block_tags_b_re.')# start tag = $2&nbsp;</div></li><li><div>                        '.$attr.'&gt;            # attributes followed by &gt; and \n&nbsp;</div></li><li><div>                        '.$content.'        # content, support nesting&nbsp;</div></li><li><div>                        &lt;/\2&gt;                # the matching end tag&nbsp;</div></li><li><div>                        [ ]*                # trailing spaces/tabs&nbsp;</div></li><li><div>                        (?=\n+|\Z)    # followed by a newline or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            | # Special version for tags of group a.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                        &lt;('.$block_tags_a_re.')# start tag = $3&nbsp;</div></li><li><div>                        '.$attr.'&gt;[ ]*\n    # attributes followed by &gt;&nbsp;</div></li><li><div>                        '.$content2.'        # content, support nesting&nbsp;</div></li><li><div>                        &lt;/\3&gt;                # the matching end tag&nbsp;</div></li><li><div>                        [ ]*                # trailing spaces/tabs&nbsp;</div></li><li><div>                        (?=\n+|\Z)    # followed by a newline or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            | # Special case just for &lt;hr /&gt;. It was easier to make a special&nbsp;</div></li><li><div>              # case than to make the other regex more complicated.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                        &lt;(hr)                # start tag = $2&nbsp;</div></li><li><div>                        '.$attr.'            # attributes&nbsp;</div></li><li><div>                        /?&gt;                    # the matching end tag&nbsp;</div></li><li><div>                        [ ]*&nbsp;</div></li><li><div>                        (?=\n{2, }|\Z)        # followed by a blank line or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            | # Special case for standalone HTML comments:&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                    (?s:&nbsp;</div></li><li><div>                        &lt;!-- .*? --&gt;&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                    [ ]*&nbsp;</div></li><li><div>                    (?=\n{2, }|\Z)        # followed by a blank line or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            | # PHP and ASP-style processor instructions (&lt;? and &lt;%)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                    (?s:&nbsp;</div></li><li><div>                        &lt;([?%])            # $2&nbsp;</div></li><li><div>                        .*?&nbsp;</div></li><li><div>                        \2&gt;&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                    [ ]*&nbsp;</div></li><li><div>                    (?=\n{2, }|\Z)        # followed by a blank line or end of document&nbsp;</div></li><li><div>&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )}Sxmi', &nbsp;</div></li><li><div>            array(&$this, '_hashHTMLBlocks_callback'), &nbsp;</div></li><li><div>            $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _hashHTMLBlocks_callback($matches) {&nbsp;</div></li><li><div>        $text = $matches[1];&nbsp;</div></li><li><div>        $key = $this-&gt;hashBlock($text);&nbsp;</div></li><li><div>        return &quot;\n\n$key\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function hashPart($text, $boundary = 'X') {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Called whenever a tag must be hashed when a function insert an atomic&nbsp;</div></li><li><div>    # element in the text stream. Passing $text to through this function gives&nbsp;</div></li><li><div>    # a unique text-token which will be reverted back when calling unhash.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # The $boundary argument specify what character should be used to surround&nbsp;</div></li><li><div>    # the token. By convension, &quot;B&quot; is used for block elements that needs not&nbsp;</div></li><li><div>    # to be wrapped into paragraph tags at the end, &quot;:&quot; is used for elements&nbsp;</div></li><li><div>    # that are word separators and &quot;X&quot; is used in the general case.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # Swap back any tag hash found in $text so we do not have to `unhash`&nbsp;</div></li><li><div>        # multiple times at the end.&nbsp;</div></li><li><div>        $text = $this-&gt;unhash($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Then hash the block.&nbsp;</div></li><li><div>        static $i = 0;&nbsp;</div></li><li><div>        $key = &quot;$boundary\x1A&quot; . ++$i . $boundary;&nbsp;</div></li><li><div>        $this-&gt;html_hashes[$key] = $text;&nbsp;</div></li><li><div>        return $key; # String that will replace the tag.&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function hashBlock($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Shortcut function for hashPart with block-level boundaries.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        return $this-&gt;hashPart($text, 'B');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public $block_gamut = array(&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # These are all the transformations that form block-level&nbsp;</div></li><li><div>    # tags like paragraphs, headers, and list items.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        &quot;doHeaders&quot; =&gt; 10, &nbsp;</div></li><li><div>        &quot;doHorizontalRules&quot; =&gt; 20, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        &quot;doLists&quot; =&gt; 40, &nbsp;</div></li><li><div>        &quot;doCodeBlocks&quot; =&gt; 50, &nbsp;</div></li><li><div>        &quot;doBlockQuotes&quot; =&gt; 60, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function runBlockGamut($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Run block gamut tranformations.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # We need to escape raw HTML in Markdown source before doing anything&nbsp;</div></li><li><div>        # else. This need to be done for each block, and not only at the&nbsp;</div></li><li><div>        # beginning in the Markdown function since hashed blocks can be part of&nbsp;</div></li><li><div>        # list items and could have been indented. Indented blocks would have&nbsp;</div></li><li><div>        # been seen as a code block in a previous pass of hashHTMLBlocks.&nbsp;</div></li><li><div>        $text = $this-&gt;hashHTMLBlocks($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;runBasicBlockGamut($text);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function runBasicBlockGamut($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Run block gamut tranformations, without hashing HTML blocks. This is&nbsp;</div></li><li><div>    # useful when HTML blocks are known to be already hashed, like in the first&nbsp;</div></li><li><div>    # whole-document pass.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        foreach ($this-&gt;block_gamut as $method =&gt; $priority) {&nbsp;</div></li><li><div>            $text = $this-&gt;$method($text);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Finally form paragraph and restore hashed blocks.&nbsp;</div></li><li><div>        $text = $this-&gt;formParagraphs($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doHorizontalRules($text) {&nbsp;</div></li><li><div>        # Do Horizontal Rules:&nbsp;</div></li><li><div>        return preg_replace(&nbsp;</div></li><li><div>            '{&nbsp;</div></li><li><div>                ^[ ]{0, 3}    # Leading space&nbsp;</div></li><li><div>                ([-*_])        # $1: First marker&nbsp;</div></li><li><div>                (?&gt;            # Repeated marker group&nbsp;</div></li><li><div>                    [ ]{0, 2}    # Zero, one, or two spaces.&nbsp;</div></li><li><div>                    \1            # Marker character&nbsp;</div></li><li><div> ) {2, }        # Group repeated at least twice&nbsp;</div></li><li><div>                [ ]*        # Tailing spaces&nbsp;</div></li><li><div>                $            # End of line.&nbsp;</div></li><li><div>            }mx', &nbsp;</div></li><li><div>            &quot;\n&quot;.$this-&gt;hashBlock(&quot;&lt;hr$this-&gt;empty_element_suffix&quot;).&quot;\n&quot;, &nbsp;</div></li><li><div>            $text);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public $span_gamut = array(&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # These are all the transformations that occur *within* block-level&nbsp;</div></li><li><div>    # tags like paragraphs, headers, and list items.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # Process character escapes, code spans, and inline HTML&nbsp;</div></li><li><div>        # in one shot.&nbsp;</div></li><li><div>        &quot;parseSpan&quot; =&gt; -30, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Process anchor and image tags. Images must come first, &nbsp;</div></li><li><div>        # because ![foo][f] looks like an anchor.&nbsp;</div></li><li><div>        &quot;doImages&quot; =&gt;  10, &nbsp;</div></li><li><div>        &quot;doAnchors&quot; =&gt;  20, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Make links out of things like `&lt;http://example.com/&gt;`&nbsp;</div></li><li><div>        # Must come after doAnchors, because you can use &lt; and &gt;&nbsp;</div></li><li><div>        # delimiters in inline links like [this](&lt;url&gt;).&nbsp;</div></li><li><div>        &quot;doAutoLinks&quot; =&gt;  30, &nbsp;</div></li><li><div>        &quot;encodeAmpsAndAngles&quot; =&gt;  40, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        &quot;doItalicsAndBold&quot; =&gt;  50, &nbsp;</div></li><li><div>        &quot;doHardBreaks&quot; =&gt;  60, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function runSpanGamut($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Run span gamut tranformations.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        foreach ($this-&gt;span_gamut as $method =&gt; $priority) {&nbsp;</div></li><li><div>            $text = $this-&gt;$method($text);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doHardBreaks($text) {&nbsp;</div></li><li><div>        # Do hard breaks:&nbsp;</div></li><li><div>        return preg_replace_callback('/ {2, }\n/', &nbsp;</div></li><li><div>            array(&$this, '_doHardBreaks_callback'), $text);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doHardBreaks_callback($matches) {&nbsp;</div></li><li><div>        return $this-&gt;hashPart(&quot;&lt;br$this-&gt;empty_element_suffix\n&quot;);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doAnchors($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Turn Markdown link shortcuts into XHTML &lt;a&gt; tags.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if ($this-&gt;in_anchor) return $text;&nbsp;</div></li><li><div>        $this-&gt;in_anchor = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # First, handle reference-style links: [link text] [id]&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                    # wrap whole match in $1&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              [ ]?                # one optional space&nbsp;</div></li><li><div>              (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                (.*?)        # id = $3&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Next, inline-style links: [link text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                # wrap whole match in $1&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>              \(            # literal paren&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    &lt;(.+?)&gt;    # href = $3&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    ('.$this-&gt;nested_url_parenthesis_re.')    # href = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (            # $5&nbsp;</div></li><li><div>                  ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                  (.*?)        # Title = $7&nbsp;</div></li><li><div>                  \6        # matching quote&nbsp;</div></li><li><div>                  [ \n]*    # ignore any spaces/tabs between closing quote and )&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>              \)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doAnchors_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Last, handle reference-style shortcuts: [link text]&nbsp;</div></li><li><div>        # These must come last in case you've also got [link text][1]&nbsp;</div></li><li><div>        # or [link text](/foo)&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                    # wrap whole match in $1&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                ([^\[\]]+)        # link text = $2; can\'t contain [ or ]&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;in_anchor = false;&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAnchors_reference_callback($matches) {&nbsp;</div></li><li><div>        $whole_match =  $matches[1];&nbsp;</div></li><li><div>        $link_text =  $matches[2];&nbsp;</div></li><li><div>        $link_id =& $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>            # for shortcut links like [this][] or [this].&nbsp;</div></li><li><div>            $link_id = $link_text;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # lower-case and turn embedded newlines into spaces&nbsp;</div></li><li><div>        $link_id = strtolower($link_id);&nbsp;</div></li><li><div>        $link_id = preg_replace('{[ ]?\n}', ' ', $link_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>            $url = $this-&gt;urls[$link_id];&nbsp;</div></li><li><div>            $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>            if ( isset( $this-&gt;titles[$link_id] ) ) {&nbsp;</div></li><li><div>                $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>                $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>                $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>            $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>            $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            $result = $whole_match;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAnchors_inline_callback($matches) {&nbsp;</div></li><li><div>        $whole_match =  $matches[1];&nbsp;</div></li><li><div>        $link_text =  $this-&gt;runSpanGamut($matches[2]);&nbsp;</div></li><li><div>        $url =  $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>        $title =& $matches[7];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>        if (isset($title)) {&nbsp;</div></li><li><div>            $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>            $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>        $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doImages($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Turn Markdown image shortcuts into &lt;img&gt; tags.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # First, handle reference-style labeled images: ![alt text][id]&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                # wrap whole match in $1&nbsp;</div></li><li><div>              !\[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              [ ]?                # one optional space&nbsp;</div></li><li><div>              (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                (.*?)        # id = $3&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doImages_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Next, handle inline images:  ![alt text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>        # Don't forget: encode * and _&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                # wrap whole match in $1&nbsp;</div></li><li><div>              !\[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>              \s?            # One optional whitespace character&nbsp;</div></li><li><div>              \(            # literal paren&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    &lt;(\S*)&gt;    # src url = $3&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    ('.$this-&gt;nested_url_parenthesis_re.')    # src url = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (            # $5&nbsp;</div></li><li><div>                  ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                  (.*?)        # title = $7&nbsp;</div></li><li><div>                  \6        # matching quote&nbsp;</div></li><li><div>                  [ \n]*&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>              \)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doImages_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doImages_reference_callback($matches) {&nbsp;</div></li><li><div>        $whole_match = $matches[1];&nbsp;</div></li><li><div>        $alt_text = $matches[2];&nbsp;</div></li><li><div>        $link_id = strtolower($matches[3]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>            $link_id = strtolower($alt_text); # for shortcut links like ![this][].&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>        if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>            $url = $this-&gt;encodeAttribute($this-&gt;urls[$link_id]);&nbsp;</div></li><li><div>            $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>            if (isset($this-&gt;titles[$link_id])) {&nbsp;</div></li><li><div>                $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>                $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>                $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>            $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            # If there's no such link ID, leave intact:&nbsp;</div></li><li><div>            $result = $whole_match;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doImages_inline_callback($matches) {&nbsp;</div></li><li><div>        $whole_match = $matches[1];&nbsp;</div></li><li><div>        $alt_text = $matches[2];&nbsp;</div></li><li><div>        $url = $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>        $title =& $matches[7];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>        $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>        $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>        if (isset($title)) {&nbsp;</div></li><li><div>            $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>            $result .=  &quot; title=\&quot;$title\&quot;&quot;; # $title already quoted&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doHeaders($text) {&nbsp;</div></li><li><div>        # Setext-style headers:&nbsp;</div></li><li><div>        #      Header 1&nbsp;</div></li><li><div>        # ========&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        #      Header 2&nbsp;</div></li><li><div>        #      --------&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{ ^(.+?)[ ]*\n(=+|-+)[ ]*\n+ }mx', &nbsp;</div></li><li><div>            array(&$this, '_doHeaders_callback_setext'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # atx-style headers:&nbsp;</div></li><li><div>        #    # Header 1&nbsp;</div></li><li><div>        #    ## Header 2&nbsp;</div></li><li><div>        #    ## Header 2 with closing hashes ##&nbsp;</div></li><li><div>        #    ...&nbsp;</div></li><li><div>        #    ###### Header 6&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>                ^(\#{1, 6})    # $1 = string of #\'s&nbsp;</div></li><li><div>                [ ]*&nbsp;</div></li><li><div>                (.+?)        # $2 = Header text&nbsp;</div></li><li><div>                [ ]*&nbsp;</div></li><li><div>                \#*            # optional closing #\'s (not counted)&nbsp;</div></li><li><div>                \n+&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_doHeaders_callback_atx'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doHeaders_callback_setext($matches) {&nbsp;</div></li><li><div>        # Terrible hack to check we haven't found an empty list item.&nbsp;</div></li><li><div>        if ($matches[2] == '-' && preg_match('{^-(?: |$)}', $matches[1]))&nbsp;</div></li><li><div>            return $matches[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $level = $matches[2]{0} == '=' ? 1 : 2;&nbsp;</div></li><li><div>        $block = &quot;&lt;h$level&gt;&quot;.$this-&gt;runSpanGamut($matches[1]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>        return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doHeaders_callback_atx($matches) {&nbsp;</div></li><li><div>        $level = strlen($matches[1]);&nbsp;</div></li><li><div>        $block = &quot;&lt;h$level&gt;&quot;.$this-&gt;runSpanGamut($matches[2]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>        return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doLists($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Form HTML ordered (numbered) and unordered (bulleted) lists.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Re-usable patterns to match list item bullets and number markers:&nbsp;</div></li><li><div>        $marker_ul_re = '[*+-]';&nbsp;</div></li><li><div>        $marker_ol_re = '\d+[\.]';&nbsp;</div></li><li><div>        $marker_any_re = &quot;(?:$marker_ul_re|$marker_ol_re)&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $markers_relist = array(&nbsp;</div></li><li><div>            $marker_ul_re =&gt; $marker_ol_re, &nbsp;</div></li><li><div>            $marker_ol_re =&gt; $marker_ul_re, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($markers_relist as $marker_re =&gt; $other_marker_re) {&nbsp;</div></li><li><div>            # Re-usable pattern to match any entirel ul or ol list:&nbsp;</div></li><li><div>            $whole_list_re = '&nbsp;</div></li><li><div>                (                                # $1 = whole list&nbsp;</div></li><li><div>                  (                                # $2&nbsp;</div></li><li><div>                    ([ ]{0, '.$less_than_tab.'})    # $3 = number of spaces&nbsp;</div></li><li><div>                    ('.$marker_re.')            # $4 = first list item marker&nbsp;</div></li><li><div>                    [ ]+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                  (?s:.+?)&nbsp;</div></li><li><div>                  (                                # $5&nbsp;</div></li><li><div>                      \z&nbsp;</div></li><li><div>                    |&nbsp;</div></li><li><div>                      \n{2, }&nbsp;</div></li><li><div>                      (?=\S)&nbsp;</div></li><li><div>                      (?!                        # Negative lookahead for another list item marker&nbsp;</div></li><li><div>                        [ ]*&nbsp;</div></li><li><div>                        '.$marker_re.'[ ]+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                    |&nbsp;</div></li><li><div>                      (?=                        # Lookahead for another kind of list&nbsp;</div></li><li><div>                        \n&nbsp;</div></li><li><div>                        \3                        # Must have the same indentation&nbsp;</div></li><li><div>                        '.$other_marker_re.'[ ]+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            '; // mx&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # We use a different prefix before nested lists than top-level lists.&nbsp;</div></li><li><div>            # See extended comment in _ProcessListItems().&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($this-&gt;list_level) {&nbsp;</div></li><li><div>                $text = preg_replace_callback('{&nbsp;</div></li><li><div>                        ^&nbsp;</div></li><li><div>                        '.$whole_list_re.'&nbsp;</div></li><li><div>                    }mx', &nbsp;</div></li><li><div>                    array(&$this, '_doLists_callback'), $text);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                $text = preg_replace_callback('{&nbsp;</div></li><li><div>                        (?:(?&lt;=\n)\n|\A\n?) # Must eat the newline&nbsp;</div></li><li><div>                        '.$whole_list_re.'&nbsp;</div></li><li><div>                    }mx', &nbsp;</div></li><li><div>                    array(&$this, '_doLists_callback'), $text);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doLists_callback($matches) {&nbsp;</div></li><li><div>        # Re-usable patterns to match list item bullets and number markers:&nbsp;</div></li><li><div>        $marker_ul_re = '[*+-]';&nbsp;</div></li><li><div>        $marker_ol_re = '\d+[\.]';&nbsp;</div></li><li><div>        $marker_any_re = &quot;(?:$marker_ul_re|$marker_ol_re)&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $list = $matches[1];&nbsp;</div></li><li><div>        $list_type = preg_match(&quot;/$marker_ul_re/&quot;, $matches[4]) ? &quot;ul&quot; : &quot;ol&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $marker_any_re = ( $list_type == &quot;ul&quot; ? $marker_ul_re : $marker_ol_re );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $list .= &quot;\n&quot;;&nbsp;</div></li><li><div>        $result = $this-&gt;processListItems($list, $marker_any_re);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $result = $this-&gt;hashBlock(&quot;&lt;$list_type&gt;\n&quot; . $result . &quot;&lt;/$list_type&gt;&quot;);&nbsp;</div></li><li><div>        return &quot;\n&quot;. $result .&quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public $list_level = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function processListItems($list_str, $marker_any_re) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Process the contents of a single ordered or unordered list, splitting it&nbsp;</div></li><li><div>    #    into individual list items.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # The $this-&gt;list_level global keeps track of when we're inside a list.&nbsp;</div></li><li><div>        # Each time we enter a list, we increment it; when we leave a list, &nbsp;</div></li><li><div>        # we decrement. If it's zero, we're not in a list anymore.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # We do this because when we're not inside a list, we want to treat&nbsp;</div></li><li><div>        # something like this:&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        #        I recommend upgrading to version&nbsp;</div></li><li><div>        #        8. Oops, now this line is treated&nbsp;</div></li><li><div>        #        as a sub-list.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # As a single paragraph, despite the fact that the second line starts&nbsp;</div></li><li><div>        # with a digit-period-space sequence.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Whereas when we're inside a list (or sub-list), that line will be&nbsp;</div></li><li><div>        # treated as the start of a sub-list. What a kludge, huh? This is&nbsp;</div></li><li><div>        # an aspect of Markdown's syntax that's hard to parse perfectly&nbsp;</div></li><li><div>        # without resorting to mind-reading. Perhaps the solution is to&nbsp;</div></li><li><div>        # change the syntax rules such that sub-lists must start with a&nbsp;</div></li><li><div>        # starting cardinal number; e.g. &quot;1.&quot; or &quot;a.&quot;.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;list_level++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # trim trailing blank lines:&nbsp;</div></li><li><div>        $list_str = preg_replace(&quot;/\n{2, }\\z/&quot;, &quot;\n&quot;, $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $list_str = preg_replace_callback('{&nbsp;</div></li><li><div>            (\n)?                            # leading line = $1&nbsp;</div></li><li><div>            (^[ ]*)                            # leading whitespace = $2&nbsp;</div></li><li><div>            ('.$marker_any_re.'                # list marker and space = $3&nbsp;</div></li><li><div>                (?:[ ]+|(?=\n))    # space only required if item is not empty&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            ((?s:.*?))                        # list item text = $4&nbsp;</div></li><li><div>            (?:(\n+(?=\n))|\n)                # tailing blank line = $5&nbsp;</div></li><li><div>            (?= \n* (\z | \2 ('.$marker_any_re.') (?:[ ]+|(?=\n))))&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_processListItems_callback'), $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;list_level--;&nbsp;</div></li><li><div>        return $list_str;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _processListItems_callback($matches) {&nbsp;</div></li><li><div>        $item = $matches[4];&nbsp;</div></li><li><div>        $leading_line =& $matches[1];&nbsp;</div></li><li><div>        $leading_space =& $matches[2];&nbsp;</div></li><li><div>        $marker_space = $matches[3];&nbsp;</div></li><li><div>        $tailing_blank_line =& $matches[5];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($leading_line || $tailing_blank_line ||&nbsp;</div></li><li><div>            preg_match('/\n{2, }/', $item))&nbsp;</div></li><li><div>        {&nbsp;</div></li><li><div>            # Replace marker with the appropriate whitespace indentation&nbsp;</div></li><li><div>            $item = $leading_space . str_repeat(' ', strlen($marker_space)) . $item;&nbsp;</div></li><li><div>            $item = $this-&gt;runBlockGamut($this-&gt;outdent($item).&quot;\n&quot;);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            # Recursion for sub-lists:&nbsp;</div></li><li><div>            $item = $this-&gt;doLists($this-&gt;outdent($item));&nbsp;</div></li><li><div>            $item = preg_replace('/\n+$/', '', $item);&nbsp;</div></li><li><div>            $item = $this-&gt;runSpanGamut($item);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return &quot;&lt;li&gt;&quot; . $item . &quot;&lt;/li&gt;\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doCodeBlocks($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Process Markdown `&lt;pre&gt;&lt;code&gt;` blocks.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>                (?:\n\n|\A\n?)&nbsp;</div></li><li><div>                (                # $1 = the code block -- one or more lines, starting with a space/tab&nbsp;</div></li><li><div>                  (?&gt;&nbsp;</div></li><li><div>                    [ ]{'.$this-&gt;tab_width.'}  # Lines must start with a tab or a tab-width of spaces&nbsp;</div></li><li><div>                    .*\n+&nbsp;</div></li><li><div> )+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                ((?=^[ ]{0, '.$this-&gt;tab_width.'}\S)|\Z)    # Lookahead for non-space at line-start, or end of doc&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_doCodeBlocks_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doCodeBlocks_callback($matches) {&nbsp;</div></li><li><div>        $codeblock = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $codeblock = $this-&gt;outdent($codeblock);&nbsp;</div></li><li><div>        $codeblock = htmlspecialchars($codeblock, ENT_NOQUOTES);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # trim leading newlines and trailing newlines&nbsp;</div></li><li><div>        $codeblock = preg_replace('/\A\n+|\n+\z/', '', $codeblock);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $codeblock = &quot;&lt;pre&gt;&lt;code&gt;$codeblock\n&lt;/code&gt;&lt;/pre&gt;&quot;;&nbsp;</div></li><li><div>        return &quot;\n\n&quot;.$this-&gt;hashBlock($codeblock).&quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function makeCodeSpan($code) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Create a code span markup for $code. Called from handleSpanToken.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $code = htmlspecialchars(trim($code), ENT_NOQUOTES);&nbsp;</div></li><li><div>        return $this-&gt;hashPart(&quot;&lt;code&gt;$code&lt;/code&gt;&quot;);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public $em_relist = array(&nbsp;</div></li><li><div>        '' =&gt; '(?:(?&lt;!\*)\*(?!\*)|(?&lt;!_)_(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>        '*' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*(?!\*)', &nbsp;</div></li><li><div>        '_' =&gt; '(?&lt;=\S|^)(?&lt;!_)_(?!_)', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    public $strong_relist = array(&nbsp;</div></li><li><div>        '' =&gt; '(?:(?&lt;!\*)\*\*(?!\*)|(?&lt;!_)__(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>        '**' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*(?!\*)', &nbsp;</div></li><li><div>        '__' =&gt; '(?&lt;=\S|^)(?&lt;!_)__(?!_)', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    public $em_strong_relist = array(&nbsp;</div></li><li><div>        '' =&gt; '(?:(?&lt;!\*)\*\*\*(?!\*)|(?&lt;!_)___(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>        '***' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*\*(?!\*)', &nbsp;</div></li><li><div>        '___' =&gt; '(?&lt;=\S|^)(?&lt;!_)___(?!_)', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    public $em_strong_prepared_relist;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function prepareItalicsAndBold() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Prepare regular expressions for searching emphasis tokens in any&nbsp;</div></li><li><div>    # context.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        foreach ($this-&gt;em_relist as $em =&gt; $em_re) {&nbsp;</div></li><li><div>            foreach ($this-&gt;strong_relist as $strong =&gt; $strong_re) {&nbsp;</div></li><li><div>                # Construct list of allowed token expressions.&nbsp;</div></li><li><div>                $token_relist = array();&nbsp;</div></li><li><div>                if (isset($this-&gt;em_strong_relist[&quot;$em$strong&quot;])) {&nbsp;</div></li><li><div>                    $token_relist[] = $this-&gt;em_strong_relist[&quot;$em$strong&quot;];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $token_relist[] = $em_re;&nbsp;</div></li><li><div>                $token_relist[] = $strong_re;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                # Construct master expression from list.&nbsp;</div></li><li><div>                $token_re = '{('. implode('|', $token_relist) .')}';&nbsp;</div></li><li><div>                $this-&gt;em_strong_prepared_relist[&quot;$em$strong&quot;] = $token_re;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doItalicsAndBold($text) {&nbsp;</div></li><li><div>        $token_stack = array('');&nbsp;</div></li><li><div>        $text_stack = array('');&nbsp;</div></li><li><div>        $em = '';&nbsp;</div></li><li><div>        $strong = '';&nbsp;</div></li><li><div>        $tree_char_em = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while (1) {&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Get prepared regular expression for seraching emphasis tokens&nbsp;</div></li><li><div>            # in current context.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            $token_re = $this-&gt;em_strong_prepared_relist[&quot;$em$strong&quot;];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Each loop iteration search for the next emphasis token.&nbsp;</div></li><li><div>            # Each token is then passed to handleSpanToken.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            $parts = preg_split($token_re, $text, 2, PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>            $text_stack[0] .= $parts[0];&nbsp;</div></li><li><div>            $token =& $parts[1];&nbsp;</div></li><li><div>            $text =& $parts[2];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (empty($token)) {&nbsp;</div></li><li><div>                # Reached end of text span: empty stack without emitting.&nbsp;</div></li><li><div>                # any more emphasis.&nbsp;</div></li><li><div>                while ($token_stack[0]) {&nbsp;</div></li><li><div>                    $text_stack[1] .= array_shift($token_stack);&nbsp;</div></li><li><div>                    $text_stack[0] .= array_shift($text_stack);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $token_len = strlen($token);&nbsp;</div></li><li><div>            if ($tree_char_em) {&nbsp;</div></li><li><div>                # Reached closing marker while inside a three-char emphasis.&nbsp;</div></li><li><div>                if ($token_len == 3) {&nbsp;</div></li><li><div>                    # Three-char closing marker, close em and strong.&nbsp;</div></li><li><div>                    array_shift($token_stack);&nbsp;</div></li><li><div>                    $span = array_shift($text_stack);&nbsp;</div></li><li><div>                    $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                    $span = &quot;&lt;strong&gt;&lt;em&gt;$span&lt;/em&gt;&lt;/strong&gt;&quot;;&nbsp;</div></li><li><div>                    $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                    $em = '';&nbsp;</div></li><li><div>                    $strong = '';&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    # Other closing marker: close one em or strong and&nbsp;</div></li><li><div>                    # change current token state to match the other&nbsp;</div></li><li><div>                    $token_stack[0] = str_repeat($token{0}, 3-$token_len);&nbsp;</div></li><li><div>                    $tag = $token_len == 2 ? &quot;strong&quot; : &quot;em&quot;;&nbsp;</div></li><li><div>                    $span = $text_stack[0];&nbsp;</div></li><li><div>                    $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                    $span = &quot;&lt;$tag&gt;$span&lt;/$tag&gt;&quot;;&nbsp;</div></li><li><div>                    $text_stack[0] = $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                    $$tag = ''; # $$tag stands for $em or $strong&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $tree_char_em = false;&nbsp;</div></li><li><div>            } else if ($token_len == 3) {&nbsp;</div></li><li><div>                if ($em) {&nbsp;</div></li><li><div>                    # Reached closing marker for both em and strong.&nbsp;</div></li><li><div>                    # Closing strong marker:&nbsp;</div></li><li><div>                    for ($i = 0; $i &lt; 2; ++$i) {&nbsp;</div></li><li><div>                        $shifted_token = array_shift($token_stack);&nbsp;</div></li><li><div>                        $tag = strlen($shifted_token) == 2 ? &quot;strong&quot; : &quot;em&quot;;&nbsp;</div></li><li><div>                        $span = array_shift($text_stack);&nbsp;</div></li><li><div>                        $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                        $span = &quot;&lt;$tag&gt;$span&lt;/$tag&gt;&quot;;&nbsp;</div></li><li><div>                        $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                        $$tag = ''; # $$tag stands for $em or $strong&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    # Reached opening three-char emphasis marker. Push on token&nbsp;</div></li><li><div>                    # stack; will be handled by the special condition above.&nbsp;</div></li><li><div>                    $em = $token{0};&nbsp;</div></li><li><div>                    $strong = &quot;$em$em&quot;;&nbsp;</div></li><li><div>                    array_unshift($token_stack, $token);&nbsp;</div></li><li><div>                    array_unshift($text_stack, '');&nbsp;</div></li><li><div>                    $tree_char_em = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($token_len == 2) {&nbsp;</div></li><li><div>                if ($strong) {&nbsp;</div></li><li><div>                    # Unwind any dangling emphasis marker:&nbsp;</div></li><li><div>                    if (strlen($token_stack[0]) == 1) {&nbsp;</div></li><li><div>                        $text_stack[1] .= array_shift($token_stack);&nbsp;</div></li><li><div>                        $text_stack[0] .= array_shift($text_stack);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    # Closing strong marker:&nbsp;</div></li><li><div>                    array_shift($token_stack);&nbsp;</div></li><li><div>                    $span = array_shift($text_stack);&nbsp;</div></li><li><div>                    $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                    $span = &quot;&lt;strong&gt;$span&lt;/strong&gt;&quot;;&nbsp;</div></li><li><div>                    $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                    $strong = '';&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    array_unshift($token_stack, $token);&nbsp;</div></li><li><div>                    array_unshift($text_stack, '');&nbsp;</div></li><li><div>                    $strong = $token;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                # Here $token_len == 1&nbsp;</div></li><li><div>                if ($em) {&nbsp;</div></li><li><div>                    if (strlen($token_stack[0]) == 1) {&nbsp;</div></li><li><div>                        # Closing emphasis marker:&nbsp;</div></li><li><div>                        array_shift($token_stack);&nbsp;</div></li><li><div>                        $span = array_shift($text_stack);&nbsp;</div></li><li><div>                        $span = $this-&gt;runSpanGamut($span);&nbsp;</div></li><li><div>                        $span = &quot;&lt;em&gt;$span&lt;/em&gt;&quot;;&nbsp;</div></li><li><div>                        $text_stack[0] .= $this-&gt;hashPart($span);&nbsp;</div></li><li><div>                        $em = '';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $text_stack[0] .= $token;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    array_unshift($token_stack, $token);&nbsp;</div></li><li><div>                    array_unshift($text_stack, '');&nbsp;</div></li><li><div>                    $em = $token;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $text_stack[0];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doBlockQuotes($text) {&nbsp;</div></li><li><div>        $text = preg_replace_callback('/&nbsp;</div></li><li><div>              (                                # Wrap whole match in $1&nbsp;</div></li><li><div>                (?&gt;&nbsp;</div></li><li><div>                  ^[ ]*&gt;[ ]?            # &quot;&gt;&quot; at the start of a line&nbsp;</div></li><li><div>                    .+\n                    # rest of the first line&nbsp;</div></li><li><div>                  (.+\n)*                    # subsequent consecutive lines&nbsp;</div></li><li><div>                  \n*                        # blanks&nbsp;</div></li><li><div> )+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            /xm', &nbsp;</div></li><li><div>            array(&$this, '_doBlockQuotes_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doBlockQuotes_callback($matches) {&nbsp;</div></li><li><div>        $bq = $matches[1];&nbsp;</div></li><li><div>        # trim one level of quoting - trim whitespace-only lines&nbsp;</div></li><li><div>        $bq = preg_replace('/^[ ]*&gt;[ ]?|^[ ]+$/m', '', $bq);&nbsp;</div></li><li><div>        $bq = $this-&gt;runBlockGamut($bq);        # recurse&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $bq = preg_replace('/^/m', &quot;  &quot;, $bq);&nbsp;</div></li><li><div>        # These leading spaces cause problem with &lt;pre&gt; content, &nbsp;</div></li><li><div>        # so we need to fix that:&nbsp;</div></li><li><div>        $bq = preg_replace_callback('{(\s*&lt;pre&gt;.+?&lt;/pre&gt;)}sx', &nbsp;</div></li><li><div>            array(&$this, '_doBlockQuotes_callback2'), $bq);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return &quot;\n&quot;. $this-&gt;hashBlock(&quot;&lt;blockquote&gt;\n$bq\n&lt;/blockquote&gt;&quot;).&quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doBlockQuotes_callback2($matches) {&nbsp;</div></li><li><div>        $pre = $matches[1];&nbsp;</div></li><li><div>        $pre = preg_replace('/^  /m', '', $pre);&nbsp;</div></li><li><div>        return $pre;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function formParagraphs($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Params:&nbsp;</div></li><li><div>    #        $text - string to process with html &lt;p&gt; tags&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # Strip leading and trailing lines:&nbsp;</div></li><li><div>        $text = preg_replace('/\A\n+|\n+\z/', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $grafs = preg_split('/\n{2, }/', $text, -1, PREG_SPLIT_NO_EMPTY);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Wrap &lt;p&gt; tags and unhashify HTML blocks&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        foreach ($grafs as $key =&gt; $value) {&nbsp;</div></li><li><div>            if (!preg_match('/^B\x1A[0-9]+B$/', $value)) {&nbsp;</div></li><li><div>                # Is a paragraph.&nbsp;</div></li><li><div>                $value = $this-&gt;runSpanGamut($value);&nbsp;</div></li><li><div>                $value = preg_replace('/^([ ]*)/', &quot;&lt;p&gt;&quot;, $value);&nbsp;</div></li><li><div>                $value .= &quot;&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>                $grafs[$key] = $this-&gt;unhash($value);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                # Is a block.&nbsp;</div></li><li><div>                # Modify elements of @grafs in-place...&nbsp;</div></li><li><div>                $graf = $value;&nbsp;</div></li><li><div>                $block = $this-&gt;html_hashes[$graf];&nbsp;</div></li><li><div>                $graf = $block;&nbsp;</div></li><li><div>//                if (preg_match('{&nbsp;</div></li><li><div>//                    \A&nbsp;</div></li><li><div>//                    (                            # $1 = &lt;div&gt; tag&nbsp;</div></li><li><div>//                      &lt;div  \s+&nbsp;</div></li><li><div>//                      [^&gt;]*&nbsp;</div></li><li><div>//                      \b&nbsp;</div></li><li><div>//                      markdown\s*=\s*  ([\'&quot;])    #    $2 = attr quote char&nbsp;</div></li><li><div>//                      1&nbsp;</div></li><li><div>//                      \2&nbsp;</div></li><li><div>//                      [^&gt;]*&nbsp;</div></li><li><div>//                      &gt;&nbsp;</div></li><li><div>// )&nbsp;</div></li><li><div>//                    (                            # $3 = contents&nbsp;</div></li><li><div>//                    .*&nbsp;</div></li><li><div>// )&nbsp;</div></li><li><div>//                    (&lt;/div&gt;)                    # $4 = closing tag&nbsp;</div></li><li><div>//                    \z&nbsp;</div></li><li><div>//                    }xs', $block, $matches))&nbsp;</div></li><li><div>//                {&nbsp;</div></li><li><div>//                    list(, $div_open, , $div_content, $div_close) = $matches;&nbsp;</div></li><li><div>//&nbsp;</div></li><li><div>//                    # We can't call Markdown(), because that resets the hash;&nbsp;</div></li><li><div>//                    # that initialization code should be pulled into its own sub, though.&nbsp;</div></li><li><div>//                    $div_content = $this-&gt;hashHTMLBlocks($div_content);&nbsp;</div></li><li><div>//&nbsp;</div></li><li><div>//                    # Run document gamut methods on the content.&nbsp;</div></li><li><div>//                    foreach ($this-&gt;document_gamut as $method =&gt; $priority) {&nbsp;</div></li><li><div>//                        $div_content = $this-&gt;$method($div_content);&nbsp;</div></li><li><div>//                    }&nbsp;</div></li><li><div>//&nbsp;</div></li><li><div>//                    $div_open = preg_replace(&nbsp;</div></li><li><div>//                        '{\smarkdown\s*=\s*([\'&quot;]).+?\1}', '', $div_open);&nbsp;</div></li><li><div>//&nbsp;</div></li><li><div>//                    $graf = $div_open . &quot;\n&quot; . $div_content . &quot;\n&quot; . $div_close;&nbsp;</div></li><li><div>//                }&nbsp;</div></li><li><div>                $grafs[$key] = $graf;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return implode(&quot;\n\n&quot;, $grafs);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function encodeAttribute($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Encode text for a double-quoted HTML attribute. This function&nbsp;</div></li><li><div>    # is *not* suitable for attributes enclosed in single quotes.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $text = $this-&gt;encodeAmpsAndAngles($text);&nbsp;</div></li><li><div>        $text = str_replace('&quot;', '&quot;', $text);&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function encodeAmpsAndAngles($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Smart processing for ampersands and angle brackets that need to&nbsp;</div></li><li><div>    # be encoded. Valid character entities are left alone unless the&nbsp;</div></li><li><div>    # no-entities mode is set.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if ($this-&gt;no_entities) {&nbsp;</div></li><li><div>            $text = str_replace('&', '&amp;', $text);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            # Ampersand-encoding based entirely on Nat Irons's Amputator&nbsp;</div></li><li><div>            # MT plugin: &lt;http://bumppo.net/projects/amputator/&gt;&nbsp;</div></li><li><div>            $text = preg_replace('/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/', &nbsp;</div></li><li><div>                                '&amp;', $text);;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        # Encode remaining &lt;'s&nbsp;</div></li><li><div>        $text = str_replace('&lt;', '&lt;', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doAutoLinks($text) {&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&lt;((https?|ftp|dict):[^\'&quot;&gt;\s]+)&gt;}i', &nbsp;</div></li><li><div>            array(&$this, '_doAutoLinks_url_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Email addresses: &lt;address@domain.foo&gt;&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            &lt;&nbsp;</div></li><li><div>            (?:mailto:)?&nbsp;</div></li><li><div>            (&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    [-!#$%&\'*+/=?^_`.{|}~\w\x80-\xFF]+&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &quot;.*?&quot;&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                \@&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    [-a-z0-9\x80-\xFF]+(\.[-a-z0-9\x80-\xFF]+)*\.[a-z]+&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    \[[\d.a-fA-F:]+\]    # IPv4 & IPv6&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            &gt;&nbsp;</div></li><li><div>            }xi', &nbsp;</div></li><li><div>            array(&$this, '_doAutoLinks_email_callback'), $text);&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&lt;(tel:([^\'&quot;&gt;\s]+))&gt;}i', array(&$this, '_doAutoLinks_tel_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAutoLinks_tel_callback($matches) {&nbsp;</div></li><li><div>        $url = $this-&gt;encodeAttribute($matches[1]);&nbsp;</div></li><li><div>        $tel = $this-&gt;encodeAttribute($matches[2]);&nbsp;</div></li><li><div>        $link = &quot;&lt;a href=\&quot;$url\&quot;&gt;$tel&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>        return $this-&gt;hashPart($link);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAutoLinks_url_callback($matches) {&nbsp;</div></li><li><div>        $url = $this-&gt;encodeAttribute($matches[1]);&nbsp;</div></li><li><div>        $link = &quot;&lt;a href=\&quot;$url\&quot;&gt;$url&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>        return $this-&gt;hashPart($link);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAutoLinks_email_callback($matches) {&nbsp;</div></li><li><div>        $address = $matches[1];&nbsp;</div></li><li><div>        $link = $this-&gt;encodeEmailAddress($address);&nbsp;</div></li><li><div>        return $this-&gt;hashPart($link);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function encodeEmailAddress($addr) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Input: an email address, e.g. &quot;foo@example.com&quot;&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Output: the email address as a mailto link, with each character&nbsp;</div></li><li><div>    #        of the address encoded as either a decimal or hex entity, in&nbsp;</div></li><li><div>    #        the hopes of foiling most address harvesting spam bots. E.g.:&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #      &lt;p&gt;&lt;a href=&quot;&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x66;o&#111;&nbsp;</div></li><li><div>    #        &#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&nbsp;</div></li><li><div>    #        &#x6d;&quot;&gt;&#x66;o&#111;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&nbsp;</div></li><li><div>    #        &#101;&#46;&#x63;&#111;&#x6d;&lt;/a&gt;&lt;/p&gt;&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Based by a filter by Matthew Wickline, posted to BBEdit-Talk.&nbsp;</div></li><li><div>    #   With some optimizations by Milian Wolff.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $addr = &quot;mailto:&quot; . $addr;&nbsp;</div></li><li><div>        $chars = preg_split('/(?&lt;!^)(?!$)/', $addr);&nbsp;</div></li><li><div>        $seed = (int)abs(crc32($addr) / strlen($addr)); # Deterministic seed.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($chars as $key =&gt; $char) {&nbsp;</div></li><li><div>            $ord = ord($char);&nbsp;</div></li><li><div>            # Ignore non-ascii chars.&nbsp;</div></li><li><div>            if ($ord &lt; 128) {&nbsp;</div></li><li><div>                $r = ($seed * (1 + $key)) % 100; # Pseudo-random function.&nbsp;</div></li><li><div>                # roughly 10% raw, 45% hex, 45% dec&nbsp;</div></li><li><div>                # '@' *must* be encoded. I insist.&nbsp;</div></li><li><div>                if ($r &gt; 90 && $char != '@') /** do nothing */;&nbsp;</div></li><li><div>                else if ($r &lt; 45) $chars[$key] = '&#x'.dechex($ord).';';&nbsp;</div></li><li><div>                else              $chars[$key] = '&#'.$ord.';';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $addr = implode('', $chars);&nbsp;</div></li><li><div>        $text = implode('', array_slice($chars, 7)); # text without `mailto:`&nbsp;</div></li><li><div>        $addr = &quot;&lt;a href=\&quot;$addr\&quot;&gt;$text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $addr;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function parseSpan($str) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Take the string $str and parse it into tokens, hashing embedded HTML, &nbsp;</div></li><li><div>    # escaped characters and handling code spans.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $output = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $span_re = '{&nbsp;</div></li><li><div>                (&nbsp;</div></li><li><div>                    \\\\'.$this-&gt;escape_chars_re.'&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    (?&lt;![`\\\\])&nbsp;</div></li><li><div>                    `+                        # code span marker&nbsp;</div></li><li><div>            '.( $this-&gt;no_markup ? '' : '&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;!--    .*?     --&gt;        # comment&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;\?.*?\?&gt; | &lt;%.*?%&gt;        # processing instruction&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;[!$]?[-a-zA-Z0-9:_]+    # regular tags&nbsp;</div></li><li><div>                    (?&gt;&nbsp;</div></li><li><div>                        \s&nbsp;</div></li><li><div>                        (?&gt;[^&quot;\'&gt;]+|&quot;[^&quot;]*&quot;|\'[^\']*\')*&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                    &gt;&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;[-a-zA-Z0-9:_]+\s*/&gt; # xml-style empty tag&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;/[-a-zA-Z0-9:_]+\s*&gt; # closing tag&nbsp;</div></li><li><div>            ').'&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while (1) {&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Each loop iteration search for either the next tag, the next&nbsp;</div></li><li><div>            # openning code span marker, or the next escaped character.&nbsp;</div></li><li><div>            # Each token is then passed to handleSpanToken.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            $parts = preg_split($span_re, $str, 2, PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # Create token from text preceding tag.&nbsp;</div></li><li><div>            if ($parts[0] != &quot;&quot;) {&nbsp;</div></li><li><div>                $output .= $parts[0];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # Check if we reach the end.&nbsp;</div></li><li><div>            if (isset($parts[1])) {&nbsp;</div></li><li><div>                $output .= $this-&gt;handleSpanToken($parts[1], $parts[2]);&nbsp;</div></li><li><div>                $str = $parts[2];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $output;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function handleSpanToken($token, &$str) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Handle $token provided by parseSpan by determining its nature and&nbsp;</div></li><li><div>    # returning the corresponding value that should replace it.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        switch ($token{0}) {&nbsp;</div></li><li><div>            case &quot;\\&quot;:&nbsp;</div></li><li><div>                return $this-&gt;hashPart(&quot;&#&quot;. ord($token{1}). &quot;;&quot;);&nbsp;</div></li><li><div>            case &quot;`&quot;:&nbsp;</div></li><li><div>                # Search for end marker in remaining text.&nbsp;</div></li><li><div>                if (preg_match('/^(.*?[^`])'.preg_quote($token).'(?!`)(.*)$/sm', &nbsp;</div></li><li><div>                    $str, $matches))&nbsp;</div></li><li><div>                {&nbsp;</div></li><li><div>                    $str = $matches[2];&nbsp;</div></li><li><div>                    $codespan = $this-&gt;makeCodeSpan($matches[1]);&nbsp;</div></li><li><div>                    return $this-&gt;hashPart($codespan);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return $token; // return as text since no ending marker found.&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                return $this-&gt;hashPart($token);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function outdent($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Remove one level of line-leading tabs or spaces&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        return preg_replace('/^(\t|[ ]{1, '.$this-&gt;tab_width.'})/m', '', $text);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # String length function for detab. `_initDetab` will create a function to&nbsp;</div></li><li><div>    # hanlde UTF-8 if the default function does not exist.&nbsp;</div></li><li><div>    public $utf8_strlen = 'mb_strlen';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function detab($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Replace tabs with the appropriate amount of space.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # For each line we separate the line in blocks delemited by&nbsp;</div></li><li><div>        # tab characters. Then we reconstruct every line by adding the&nbsp;</div></li><li><div>        # appropriate number of space between each blocks.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $text = preg_replace_callback('/^.*\t.*$/m', &nbsp;</div></li><li><div>            array(&$this, '_detab_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _detab_callback($matches) {&nbsp;</div></li><li><div>        $line = $matches[0];&nbsp;</div></li><li><div>        $strlen = $this-&gt;utf8_strlen; # strlen function for UTF-8.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Split in blocks.&nbsp;</div></li><li><div>        $blocks = explode(&quot;\t&quot;, $line);&nbsp;</div></li><li><div>        # Add each blocks to the line.&nbsp;</div></li><li><div>        $line = $blocks[0];&nbsp;</div></li><li><div>        unset($blocks[0]); # Do not add first block twice.&nbsp;</div></li><li><div>        foreach ($blocks as $block) {&nbsp;</div></li><li><div>            # Calculate amount of space, insert spaces, insert block.&nbsp;</div></li><li><div>            $amount = $this-&gt;tab_width -&nbsp;</div></li><li><div>                $strlen($line, 'UTF-8') % $this-&gt;tab_width;&nbsp;</div></li><li><div>            $line .= str_repeat(&quot; &quot;, $amount) . $block;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $line;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _initDetab() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Check for the availability of the function in the `utf8_strlen` property&nbsp;</div></li><li><div>    # (initially `mb_strlen`). If the function is not available, create a&nbsp;</div></li><li><div>    # function that will loosely count the number of UTF-8 characters with a&nbsp;</div></li><li><div>    # regular expression.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if (function_exists($this-&gt;utf8_strlen)) return;&nbsp;</div></li><li><div>        $this-&gt;utf8_strlen = create_function('$text', 'return preg_match_all(&nbsp;</div></li><li><div>            &quot;/[\\\\x00-\\\\xBF]|[\\\\xC0-\\\\xFF][\\\\x80-\\\\xBF]*/&quot;, &nbsp;</div></li><li><div>            $text, $m);');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function unhash($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Swap back in all the tags hashed by _HashHTMLBlocks.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        return preg_replace_callback('/(.)\x1A[0-9]+\1/', &nbsp;</div></li><li><div>            array(&$this, '_unhash_callback'), $text);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _unhash_callback($matches) {&nbsp;</div></li><li><div>        return $this-&gt;html_hashes[$matches[0]];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 3.7.1</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.2/classes/markdown_parser/" class="">3.8.2</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.1/classes/markdown_parser/" class="">3.8.1</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/markdown_parser/" class="active">3.8.0</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/classes/markdown_parser/" class="">3.7.2</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.1/classes/markdown_parser/" class="">3.7.1</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>Markdown_Parser</li><li><span></span>Jetpack by WordPress.com</li><li><span></span>3.8.2</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>