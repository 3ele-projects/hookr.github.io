<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="3.8.0" data-slug="jetpack-by-wordpress-com" data-type="class" data-id="12958"><head xmlns="http://www.w3.org/1999/xhtml"><title> markdownextra_parser | class | Jetpack By WordPress Com | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="MarkdownExtra_Parser, class, plugin, jetpack-by-wordpress-com, 3.8.0" /><meta name="description" content="The Jetpack by WordPress.com MarkdownExtra Parser class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=696a8dc09ef0a94f5fb35bc7af979f5d' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/markdown_extra_parser/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fmarkdown_extra_parser%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fmarkdown_extra_parser%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-jetpack-by-wordpress-com-3.8.0-class-markdown_extra_parser","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="markdown_extra_parser" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to jetpack-by-wordpress-com." href="http://hookr.io/plugins/jetpack-by-wordpress-com/" class="plugin"><span property="name">jetpack-by-wordpress-com</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 3.8.0." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/" class="H_VERSION"><span property="name">3.8.0</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">markdown_extra_parser</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="1499"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/all/" title="All">All <span class="count badge">1499</span></a></li><li class="" data-id="new" data-count="17"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/new/" title="New">New <span class="count badge">17</span></a></li><li class="" data-id="hooks" data-count="599"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/hooks/" title="Hooks">Hooks <span class="count badge">599</span></a></li><li class="" data-id="action" data-count="195"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/actions/" title="Actions">Actions <span class="count badge">195</span></a></li><li class="" data-id="filter" data-count="404"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/filters/" title="Filters">Filters <span class="count badge">404</span></a></li><li class="active" data-id="class" data-count="262"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/" title="Classes">Classes <span class="count badge">262</span></a></li><li class="" data-id="constant" data-count="62"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/constants/" title="Constants">Constants <span class="count badge">62</span></a></li><li class="" data-id="function" data-count="530"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/functions/" title="Functions">Functions <span class="count badge">530</span></a></li><li class="" data-id="shortcode" data-count="46"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">46</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>MarkdownExtra_Parser</strong></h1><p>The Jetpack by WordPress.com <strong>MarkdownExtra Parser</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/files/inc-lib-markdown-extra/" class="file">/_inc/lib/markdown/extra.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="51" class="block" start="1550"><li><div>class MarkdownExtra_Parser extends Markdown_Parser {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### Configuration Variables ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Prefix for footnote ids.&nbsp;</div></li><li><div>    public $fn_id_prefix = &quot;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Optional title attribute for footnote links and backlinks.&nbsp;</div></li><li><div>    public $fn_link_title = MARKDOWN_FN_LINK_TITLE;&nbsp;</div></li><li><div>    public $fn_backlink_title = MARKDOWN_FN_BACKLINK_TITLE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Optional class attribute for footnote links and backlinks.&nbsp;</div></li><li><div>    public $fn_link_class = MARKDOWN_FN_LINK_CLASS;&nbsp;</div></li><li><div>    public $fn_backlink_class = MARKDOWN_FN_BACKLINK_CLASS;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Optional class prefix for fenced code block.&nbsp;</div></li><li><div>    public $code_class_prefix = MARKDOWN_CODE_CLASS_PREFIX;&nbsp;</div></li><li><div>    # Class attribute for code blocks goes on the `code` tag;&nbsp;</div></li><li><div>    # setting this to true will put attributes on the `pre` tag instead.&nbsp;</div></li><li><div>    public $code_attr_on_pre = MARKDOWN_CODE_ATTR_ON_PRE;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Predefined abbreviations.&nbsp;</div></li><li><div>    public $predef_abbr = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### Parser Implementation ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function __construct() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Constructor function. Initialize the parser object.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # Add extra escapable characters before parent constructor&nbsp;</div></li><li><div>        # initialize the table.&nbsp;</div></li><li><div>        $this-&gt;escape_chars .= ':|';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Insert extra document, block, and span transformations.&nbsp;</div></li><li><div>        # Parent constructor will do the sorting.&nbsp;</div></li><li><div>        $this-&gt;document_gamut += array(&nbsp;</div></li><li><div>            &quot;doFencedCodeBlocks&quot; =&gt; 5, &nbsp;</div></li><li><div>            &quot;stripFootnotes&quot; =&gt; 15, &nbsp;</div></li><li><div>            &quot;stripAbbreviations&quot; =&gt; 25, &nbsp;</div></li><li><div>            &quot;appendFootnotes&quot; =&gt; 50, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        $this-&gt;block_gamut += array(&nbsp;</div></li><li><div>            &quot;doFencedCodeBlocks&quot; =&gt; 5, &nbsp;</div></li><li><div>            &quot;doTables&quot; =&gt; 15, &nbsp;</div></li><li><div>            &quot;doDefLists&quot; =&gt; 45, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        $this-&gt;span_gamut += array(&nbsp;</div></li><li><div>            &quot;doFootnotes&quot; =&gt; 5, &nbsp;</div></li><li><div>            &quot;doAbbreviations&quot; =&gt; 70, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        parent::__construct();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Extra variables used during extra transformations.&nbsp;</div></li><li><div>    public $footnotes = array();&nbsp;</div></li><li><div>    public $footnotes_ordered = array();&nbsp;</div></li><li><div>    public $footnotes_ref_count = array();&nbsp;</div></li><li><div>    public $footnotes_numbers = array();&nbsp;</div></li><li><div>    public $abbr_desciptions = array();&nbsp;</div></li><li><div>    public $abbr_word_re = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Give the current footnote number.&nbsp;</div></li><li><div>    public $footnote_counter = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function setup() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Setting up Extra-specific variables.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        parent::setup();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;footnotes = array();&nbsp;</div></li><li><div>        $this-&gt;footnotes_ordered = array();&nbsp;</div></li><li><div>        $this-&gt;footnotes_ref_count = array();&nbsp;</div></li><li><div>        $this-&gt;footnotes_numbers = array();&nbsp;</div></li><li><div>        $this-&gt;abbr_desciptions = array();&nbsp;</div></li><li><div>        $this-&gt;abbr_word_re = '';&nbsp;</div></li><li><div>        $this-&gt;footnote_counter = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($this-&gt;predef_abbr as $abbr_word =&gt; $abbr_desc) {&nbsp;</div></li><li><div>            if ($this-&gt;abbr_word_re)&nbsp;</div></li><li><div>                $this-&gt;abbr_word_re .= '|';&nbsp;</div></li><li><div>            $this-&gt;abbr_word_re .= preg_quote($abbr_word);&nbsp;</div></li><li><div>            $this-&gt;abbr_desciptions[$abbr_word] = trim($abbr_desc);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function teardown() {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Clearing Extra-specific variables.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $this-&gt;footnotes = array();&nbsp;</div></li><li><div>        $this-&gt;footnotes_ordered = array();&nbsp;</div></li><li><div>        $this-&gt;footnotes_ref_count = array();&nbsp;</div></li><li><div>        $this-&gt;footnotes_numbers = array();&nbsp;</div></li><li><div>        $this-&gt;abbr_desciptions = array();&nbsp;</div></li><li><div>        $this-&gt;abbr_word_re = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        parent::teardown();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### Extra Attribute Parser ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Expression to use to catch attributes (includes the braces)&nbsp;</div></li><li><div>    public $id_class_attr_catch_re = '\{((?:[ ]*[#.][-_:a-zA-Z0-9]+) {1, })[ ]*\}';&nbsp;</div></li><li><div>    # Expression to use when parsing in a context when no capture is desired&nbsp;</div></li><li><div>    public $id_class_attr_nocatch_re = '\{(?:[ ]*[#.][-_:a-zA-Z0-9]+) {1, }[ ]*\}';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doExtraAttributes($tag_name, $attr) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Parse attributes caught by the $this-&gt;id_class_attr_catch_re expression&nbsp;</div></li><li><div>    # and return the HTML-formatted list of attributes.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Currently supported attributes are .class and #id.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if (empty($attr)) return &quot;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Split on components&nbsp;</div></li><li><div>        preg_match_all('/[#.][-_:a-zA-Z0-9]+/', $attr, $matches);&nbsp;</div></li><li><div>        $elements = $matches[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # handle classes and ids (only first id taken into account)&nbsp;</div></li><li><div>        $classes = array();&nbsp;</div></li><li><div>        $id = false;&nbsp;</div></li><li><div>        foreach ($elements as $element) {&nbsp;</div></li><li><div>            if ($element{0} == '.') {&nbsp;</div></li><li><div>                $classes[] = substr($element, 1);&nbsp;</div></li><li><div>            } else if ($element{0} == '#') {&nbsp;</div></li><li><div>                if ($id === false) $id = substr($element, 1);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # compose attributes as string&nbsp;</div></li><li><div>        $attr_str = &quot;&quot;;&nbsp;</div></li><li><div>        if (!empty($id)) {&nbsp;</div></li><li><div>            $attr_str .= ' id=&quot;'.$id.'&quot;';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (!empty($classes)) {&nbsp;</div></li><li><div>            $attr_str .= ' class=&quot;'.implode(&quot; &quot;, $classes).'&quot;';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $attr_str;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function stripLinkDefinitions($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Strips link definitions from text, stores the URLs and titles in&nbsp;</div></li><li><div>    # hash references.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Link defs are in the form: ^[id]: url &quot;optional title&quot;&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>                            ^[ ]{0, '.$less_than_tab.'}\[(.+)\][ ]?:    # id = $1&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                              \n?                # maybe *one* newline&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                            (?:&nbsp;</div></li><li><div>                              &lt;(.+?)&gt;            # url = $2&nbsp;</div></li><li><div>                            |&nbsp;</div></li><li><div>                              (\S+?)            # url = $3&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                              \n?                # maybe one newline&nbsp;</div></li><li><div>                              [ ]*&nbsp;</div></li><li><div>                            (?:&nbsp;</div></li><li><div>                                (?&lt;=\s)            # lookbehind for whitespace&nbsp;</div></li><li><div>                                [&quot;(]&nbsp;</div></li><li><div>                                (.*?)            # title = $4&nbsp;</div></li><li><div>                                [&quot;)]&nbsp;</div></li><li><div>                                [ ]*&nbsp;</div></li><li><div> )?    # title is optional&nbsp;</div></li><li><div>                    (?:[ ]* '.$this-&gt;id_class_attr_catch_re.' )?  # $5 = extra id & class attr&nbsp;</div></li><li><div>                            (?:\n+|\Z)&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_stripLinkDefinitions_callback'), &nbsp;</div></li><li><div>            $text);&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _stripLinkDefinitions_callback($matches) {&nbsp;</div></li><li><div>        $link_id = strtolower($matches[1]);&nbsp;</div></li><li><div>        $url = $matches[2] == '' ? $matches[3] : $matches[2];&nbsp;</div></li><li><div>        $this-&gt;urls[$link_id] = $url;&nbsp;</div></li><li><div>        $this-&gt;titles[$link_id] =& $matches[4];&nbsp;</div></li><li><div>        $this-&gt;ref_attr[$link_id] = $this-&gt;doExtraAttributes(&quot;&quot;, $dummy =& $matches[5]);&nbsp;</div></li><li><div>        return ''; # String that will replace the block&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### HTML Block Parser ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Tags that are always treated as block tags:&nbsp;</div></li><li><div>    public $block_tags_re = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|form|fieldset|iframe|hr|legend|article|section|nav|aside|hgroup|header|footer|figcaption';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Tags treated as block tags only if the opening tag is alone on its line:&nbsp;</div></li><li><div>    public $context_block_tags_re = 'script|noscript|ins|del|iframe|object|source|track|param|math|svg|canvas|audio|video';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Tags where markdown=&quot;1&quot; default to span mode:&nbsp;</div></li><li><div>    public $contain_span_tags_re = 'p|h[1-6]|li|dd|dt|td|th|legend|address';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Tags which must not have their contents modified, no matter where&nbsp;</div></li><li><div>    # they appear:&nbsp;</div></li><li><div>    public $clean_tags_re = 'script|math|svg';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    # Tags that do not need to be closed.&nbsp;</div></li><li><div>    public $auto_close_tags_re = 'hr|img|param|source|track';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function hashHTMLBlocks($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Hashify HTML Blocks and &quot;clean tags&quot;.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # We only want to do this for block-level HTML tags, such as headers, &nbsp;</div></li><li><div>    # lists, and tables. That's because we still want to wrap &lt;p&gt;s around&nbsp;</div></li><li><div>    # &quot;paragraphs&quot; that are wrapped in non-block-level tags, such as anchors, &nbsp;</div></li><li><div>    # phrase emphasis, and spans. The list of tags we're looking for is&nbsp;</div></li><li><div>    # hard-coded.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # This works by calling _HashHTMLBlocks_InMarkdown, which then calls&nbsp;</div></li><li><div>    # _HashHTMLBlocks_InHTML when it encounter block tags. When the markdown=&quot;1&quot;&nbsp;</div></li><li><div>    # attribute is found within a tag, _HashHTMLBlocks_InHTML calls back&nbsp;</div></li><li><div>    #  _HashHTMLBlocks_InMarkdown to handle the Markdown syntax within the tag.&nbsp;</div></li><li><div>    # These two functions are calling each other. It's recursive!&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if ($this-&gt;no_markup)  return $text;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Call the HTML-in-Markdown hasher.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        list($text, ) = $this-&gt;_hashHTMLBlocks_inMarkdown($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _hashHTMLBlocks_inMarkdown($text, $indent = 0, &nbsp;</div></li><li><div>                                        $enclosing_tag_re = '', $span = false)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Parse markdown text, calling _HashHTMLBlocks_InHTML for block tags.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # *   $indent is the number of space to be ignored when checking for code&nbsp;</div></li><li><div>    #     blocks. This is important because if we don't take the indent into&nbsp;</div></li><li><div>    #     account, something like this (which looks right) won't work as expected:&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #     &lt;div&gt;&nbsp;</div></li><li><div>    #         &lt;div markdown=&quot;1&quot;&gt;&nbsp;</div></li><li><div>    #         Hello World.  &lt;-- Is this a Markdown code block or text?&nbsp;</div></li><li><div>    #         &lt;/div&gt;  &lt;-- Is this a Markdown code block or a real tag?&nbsp;</div></li><li><div>    #     &lt;div&gt;&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #     If you don't like this, just don't indent the tag on which&nbsp;</div></li><li><div>    #     you apply the markdown=&quot;1&quot; attribute.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # *   If $enclosing_tag_re is not empty, stops at the first unmatched closing&nbsp;</div></li><li><div>    #     tag with that name. Nested tags supported.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # *   If $span is true, text inside must treated as span. So any double&nbsp;</div></li><li><div>    #     newline will be replaced by a single newline so that it does not create&nbsp;</div></li><li><div>    #     paragraphs.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Returns an array of that form: ( processed text , remaining text )&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if ($text === '') return array('', '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Regex to check for the presence of newlines around a block tag.&nbsp;</div></li><li><div>        $newline_before_re = '/(?:^\n?|\n\n)*$/';&nbsp;</div></li><li><div>        $newline_after_re =&nbsp;</div></li><li><div>            '{&nbsp;</div></li><li><div>                ^                        # Start of text following the tag.&nbsp;</div></li><li><div>                (?&gt;[ ]*&lt;!--.*?--&gt;)?        # Optional comment.&nbsp;</div></li><li><div>                [ ]*\n                    # Must be followed by newline.&nbsp;</div></li><li><div>            }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Regex to match any tag.&nbsp;</div></li><li><div>        $block_tag_re =&nbsp;</div></li><li><div>            '{&nbsp;</div></li><li><div>                (                    # $2: Capture whole tag.&nbsp;</div></li><li><div>                    &lt;/?                    # Any opening or closing tag.&nbsp;</div></li><li><div>                        (?&gt;                # Tag name.&nbsp;</div></li><li><div>                            '.$this-&gt;block_tags_re.'            |&nbsp;</div></li><li><div>                            '.$this-&gt;context_block_tags_re.'    |&nbsp;</div></li><li><div>                            '.$this-&gt;clean_tags_re.'            |&nbsp;</div></li><li><div>                            (?!\s)'.$enclosing_tag_re.'&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                        (?:&nbsp;</div></li><li><div>                            (?=[\s&quot;\'/a-zA-Z0-9])    # Allowed characters after tag name.&nbsp;</div></li><li><div>                            (?&gt;&nbsp;</div></li><li><div>                                &quot;.*?&quot;        |    # Double quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                                \'.*?\'       |    # Single quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                                .+?                # Anything but quotes and `&gt;`.&nbsp;</div></li><li><div> )*?&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                    &gt;                    # End of tag.&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;!--    .*?     --&gt;    # HTML Comment&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;\?.*?\?&gt; | &lt;%.*?%&gt;    # Processing instruction&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;!\[CDATA\[.*?\]\]&gt;    # CData Block&nbsp;</div></li><li><div>                '. ( !$span ? ' # If not in span.&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    # Indented code block&nbsp;</div></li><li><div>                    (?: ^[ ]*\n | ^ | \n[ ]*\n )&nbsp;</div></li><li><div>                    [ ]{'.($indent+4).'}[^\n]* \n&nbsp;</div></li><li><div>                    (?&gt;&nbsp;</div></li><li><div>                        (?: [ ]{'.($indent+4).'}[^\n]* | [ ]* ) \n&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    # Fenced code block marker&nbsp;</div></li><li><div>                    (?&lt;= ^ | \n )&nbsp;</div></li><li><div>                    [ ]{0, '.($indent+3).'}(?:~{3, }|`{3, })&nbsp;</div></li><li><div>                                    [ ]*&nbsp;</div></li><li><div>                    (?:&nbsp;</div></li><li><div>                    \.?[-_:a-zA-Z0-9]+ # standalone class name&nbsp;</div></li><li><div>                    |&nbsp;</div></li><li><div>                        '.$this-&gt;id_class_attr_nocatch_re.' # extra attributes&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                    [ ]*&nbsp;</div></li><li><div>                    (?= \n )&nbsp;</div></li><li><div>                ' : '' ). ' # End (if not is span).&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    # Code span marker&nbsp;</div></li><li><div>                    # Note, this regex needs to go after backtick fenced&nbsp;</div></li><li><div>                    # code blocks but it should also be kept outside of the&nbsp;</div></li><li><div>                    # &quot;if not in span&quot; condition adding backticks to the parser&nbsp;</div></li><li><div>                    `+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $depth = 0;        # Current depth inside the tag tree.&nbsp;</div></li><li><div>        $parsed = &quot;&quot;;    # Parsed text that will be returned.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Loop through every tag until we find the closing tag of the parent&nbsp;</div></li><li><div>        # or loop until reaching the end of text if no parent tag specified.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        do {&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Split the text using the first $tag_match pattern found.&nbsp;</div></li><li><div>            # Text before  pattern will be first in the array, text after&nbsp;</div></li><li><div>            # pattern will be at the end, and between will be any catches made&nbsp;</div></li><li><div>            # by the pattern.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            $parts = preg_split($block_tag_re, $text, 2, &nbsp;</div></li><li><div>                                PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # If in Markdown span mode, add a empty-string span-level hash&nbsp;</div></li><li><div>            # after each newline to prevent triggering any block element.&nbsp;</div></li><li><div>            if ($span) {&nbsp;</div></li><li><div>                $void = $this-&gt;hashPart(&quot;&quot;, ':');&nbsp;</div></li><li><div>                $newline = &quot;$void\n&quot;;&nbsp;</div></li><li><div>                $parts[0] = $void . str_replace(&quot;\n&quot;, $newline, $parts[0]) . $void;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $parsed .= $parts[0]; # Text before current tag.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # If end of $text has been reached. Stop loop.&nbsp;</div></li><li><div>            if (count($parts) &lt; 3) {&nbsp;</div></li><li><div>                $text = &quot;&quot;;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $tag = $parts[1]; # Tag to handle.&nbsp;</div></li><li><div>            $text = $parts[2]; # Remaining text after current tag.&nbsp;</div></li><li><div>            $tag_re = preg_quote($tag); # For use in a regular expression.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Check for: Fenced code block marker.&nbsp;</div></li><li><div>            # Note: need to recheck the whole tag to disambiguate backtick&nbsp;</div></li><li><div>            # fences from code spans&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            if (preg_match('{^\n?([ ]{0, '.($indent+3).'})(~{3, }|`{3, })[ ]*(?:\.?[-_:a-zA-Z0-9]+|'.$this-&gt;id_class_attr_nocatch_re.')?[ ]*\n?$}', $tag, $capture)) {&nbsp;</div></li><li><div>                # Fenced code block marker: find matching end marker.&nbsp;</div></li><li><div>                $fence_indent = strlen($capture[1]); # use captured indent in re&nbsp;</div></li><li><div>                $fence_re = $capture[2]; # use captured fence in re&nbsp;</div></li><li><div>                if (preg_match('{^(?&gt;.*\n)*?[ ]{'.($fence_indent).'}'.$fence_re.'[ ]*(?:\n|$)}', $text, &nbsp;</div></li><li><div>                    $matches))&nbsp;</div></li><li><div>                {&nbsp;</div></li><li><div>                    # End marker found: pass text unchanged until marker.&nbsp;</div></li><li><div>                    $parsed .= $tag . $matches[0];&nbsp;</div></li><li><div>                    $text = substr($text, strlen($matches[0]));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                else {&nbsp;</div></li><li><div>                    # No end marker: just skip it.&nbsp;</div></li><li><div>                    $parsed .= $tag;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Check for: Indented code block.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            else if ($tag{0} == &quot;\n&quot; || $tag{0} == &quot; &quot;) {&nbsp;</div></li><li><div>                # Indented code block: pass it unchanged, will be handled&nbsp;</div></li><li><div>                # later.&nbsp;</div></li><li><div>                $parsed .= $tag;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Check for: Code span marker&nbsp;</div></li><li><div>            # Note: need to check this after backtick fenced code blocks&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            else if ($tag{0} == &quot;`&quot;) {&nbsp;</div></li><li><div>                # Find corresponding end marker.&nbsp;</div></li><li><div>                $tag_re = preg_quote($tag);&nbsp;</div></li><li><div>                if (preg_match('{^(?&gt;.+?|\n(?!\n))*?(?&lt;!`)'.$tag_re.'(?!`)}', &nbsp;</div></li><li><div>                    $text, $matches))&nbsp;</div></li><li><div>                {&nbsp;</div></li><li><div>                    # End marker found: pass text unchanged until marker.&nbsp;</div></li><li><div>                    $parsed .= $tag . $matches[0];&nbsp;</div></li><li><div>                    $text = substr($text, strlen($matches[0]));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                else {&nbsp;</div></li><li><div>                    # Unmatched marker: just skip it.&nbsp;</div></li><li><div>                    $parsed .= $tag;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Check for: Opening Block level tag or&nbsp;</div></li><li><div>            #            Opening Context Block tag (like ins and del)&nbsp;</div></li><li><div>            #               used as a block tag (tag is alone on it's line).&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            else if (preg_match('{^&lt;(?:'.$this-&gt;block_tags_re.')\b}', $tag) ||&nbsp;</div></li><li><div>                (    preg_match('{^&lt;(?:'.$this-&gt;context_block_tags_re.')\b}', $tag) &&&nbsp;</div></li><li><div>                    preg_match($newline_before_re, $parsed) &&&nbsp;</div></li><li><div>                    preg_match($newline_after_re, $text) )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            {&nbsp;</div></li><li><div>                # Need to parse tag and following text using the HTML parser.&nbsp;</div></li><li><div>                list($block_text, $text) =&nbsp;</div></li><li><div>                    $this-&gt;_hashHTMLBlocks_inHTML($tag . $text, &quot;hashBlock&quot;, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                # Make sure it stays outside of any paragraph by adding newlines.&nbsp;</div></li><li><div>                $parsed .= &quot;\n\n$block_text\n\n&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Check for: Clean tag (like script, math)&nbsp;</div></li><li><div>            #            HTML Comments, processing instructions.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            else if (preg_match('{^&lt;(?:'.$this-&gt;clean_tags_re.')\b}', $tag) ||&nbsp;</div></li><li><div>                $tag{1} == '!' || $tag{1} == '?')&nbsp;</div></li><li><div>            {&nbsp;</div></li><li><div>                # Need to parse tag and following text using the HTML parser.&nbsp;</div></li><li><div>                # (don't check for markdown attribute)&nbsp;</div></li><li><div>                list($block_text, $text) =&nbsp;</div></li><li><div>                    $this-&gt;_hashHTMLBlocks_inHTML($tag . $text, &quot;hashClean&quot;, false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $parsed .= $block_text;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Check for: Tag with same name as enclosing tag.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            else if ($enclosing_tag_re !== '' &&&nbsp;</div></li><li><div>                # Same name as enclosing tag.&nbsp;</div></li><li><div>                preg_match('{^&lt;/?(?:'.$enclosing_tag_re.')\b}', $tag))&nbsp;</div></li><li><div>            {&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                # Increase/decrease nested tag count.&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                if ($tag{1} == '/')                        $depth--;&nbsp;</div></li><li><div>                else if ($tag{strlen($tag)-2} != '/')    $depth++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ($depth &lt; 0) {&nbsp;</div></li><li><div>                    #&nbsp;</div></li><li><div>                    # Going out of parent element. Clean up and break so we&nbsp;</div></li><li><div>                    # return to the calling function.&nbsp;</div></li><li><div>                    #&nbsp;</div></li><li><div>                    $text = $tag . $text;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $parsed .= $tag;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                $parsed .= $tag;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } while ($depth &gt;= 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return array($parsed, $text);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _hashHTMLBlocks_inHTML($text, $hash_method, $md_attr) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Parse HTML, calling _HashHTMLBlocks_InMarkdown for block tags.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # *   Calls $hash_method to convert any blocks.&nbsp;</div></li><li><div>    # *   Stops when the first opening tag closes.&nbsp;</div></li><li><div>    # *   $md_attr indicate if the use of the `markdown=&quot;1&quot;` attribute is allowed.&nbsp;</div></li><li><div>    #     (it is not inside clean tags)&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Returns an array of that form: ( processed text , remaining text )&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if ($text === '') return array('', '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Regex to match `markdown` attribute inside of a tag.&nbsp;</div></li><li><div>        $markdown_attr_re = '&nbsp;</div></li><li><div>            {&nbsp;</div></li><li><div>                \s*            # Eat whitespace before the `markdown` attribute&nbsp;</div></li><li><div>                markdown&nbsp;</div></li><li><div>                \s*=\s*&nbsp;</div></li><li><div>                (?&gt;&nbsp;</div></li><li><div>                    ([&quot;\'])        # $1: quote delimiter&nbsp;</div></li><li><div>                    (.*?)        # $2: attribute value&nbsp;</div></li><li><div>                    \1            # matching delimiter&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    ([^\s&gt;]*)    # $3: unquoted attribute value&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                ()                # $4: make $3 always defined (avoid warnings)&nbsp;</div></li><li><div>            }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Regex to match any tag.&nbsp;</div></li><li><div>        $tag_re = '{&nbsp;</div></li><li><div>                (                    # $2: Capture whole tag.&nbsp;</div></li><li><div>                    &lt;/?                    # Any opening or closing tag.&nbsp;</div></li><li><div>                        [\w:$]+            # Tag name.&nbsp;</div></li><li><div>                        (?:&nbsp;</div></li><li><div>                            (?=[\s&quot;\'/a-zA-Z0-9])    # Allowed characters after tag name.&nbsp;</div></li><li><div>                            (?&gt;&nbsp;</div></li><li><div>                                &quot;.*?&quot;        |    # Double quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                                \'.*?\'       |    # Single quotes (can contain `&gt;`)&nbsp;</div></li><li><div>                                .+?                # Anything but quotes and `&gt;`.&nbsp;</div></li><li><div> )*?&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                    &gt;                    # End of tag.&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;!--    .*?     --&gt;    # HTML Comment&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;\?.*?\?&gt; | &lt;%.*?%&gt;    # Processing instruction&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    &lt;!\[CDATA\[.*?\]\]&gt;    # CData Block&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $original_text = $text;        # Save original text in case of faliure.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $depth = 0;    # Current depth inside the tag tree.&nbsp;</div></li><li><div>        $block_text = &quot;&quot;;    # Temporary text holder for current text.&nbsp;</div></li><li><div>        $parsed = &quot;&quot;;    # Parsed text that will be returned.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Get the name of the starting tag.&nbsp;</div></li><li><div>        # (This pattern makes $base_tag_name_re safe without quoting.)&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        if (preg_match('/^&lt;([\w:$]*)\b/', $text, $matches))&nbsp;</div></li><li><div>            $base_tag_name_re = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Loop through every tag until we find the corresponding closing tag.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        do {&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Split the text using the first $tag_match pattern found.&nbsp;</div></li><li><div>            # Text before  pattern will be first in the array, text after&nbsp;</div></li><li><div>            # pattern will be at the end, and between will be any catches made&nbsp;</div></li><li><div>            # by the pattern.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            $parts = preg_split($tag_re, $text, 2, PREG_SPLIT_DELIM_CAPTURE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (count($parts) &lt; 3) {&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                # End of $text reached with unbalenced tag(s).&nbsp;</div></li><li><div>                # In that case, we return original text unchanged and pass the&nbsp;</div></li><li><div>                # first character as filtered to prevent an infinite loop in the&nbsp;</div></li><li><div>                # parent function.&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                return array($original_text{0}, substr($original_text, 1));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $block_text .= $parts[0]; # Text before current tag.&nbsp;</div></li><li><div>            $tag = $parts[1]; # Tag to handle.&nbsp;</div></li><li><div>            $text = $parts[2]; # Remaining text after current tag.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            # Check for: Auto-close tag (like &lt;hr/&gt;)&nbsp;</div></li><li><div>            #             Comments and Processing Instructions.&nbsp;</div></li><li><div>            #&nbsp;</div></li><li><div>            if (preg_match('{^&lt;/?(?:'.$this-&gt;auto_close_tags_re.')\b}', $tag) ||&nbsp;</div></li><li><div>                $tag{1} == '!' || $tag{1} == '?')&nbsp;</div></li><li><div>            {&nbsp;</div></li><li><div>                # Just add the tag to the block as if it was text.&nbsp;</div></li><li><div>                $block_text .= $tag;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                # Increase/decrease nested tag count. Only do so if&nbsp;</div></li><li><div>                # the tag's name match base tag's.&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                if (preg_match('{^&lt;/?'.$base_tag_name_re.'\b}', $tag)) {&nbsp;</div></li><li><div>                    if ($tag{1} == '/')                        $depth--;&nbsp;</div></li><li><div>                    else if ($tag{strlen($tag)-2} != '/')    $depth++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                # Check for `markdown=&quot;1&quot;` attribute and handle it.&nbsp;</div></li><li><div>                #&nbsp;</div></li><li><div>                if ($md_attr &&&nbsp;</div></li><li><div>                    preg_match($markdown_attr_re, $tag, $attr_m) &&&nbsp;</div></li><li><div>                    preg_match('/^1|block|span$/', $attr_m[2] . $attr_m[3]))&nbsp;</div></li><li><div>                {&nbsp;</div></li><li><div>                    # Remove `markdown` attribute from opening tag.&nbsp;</div></li><li><div>                    $tag = preg_replace($markdown_attr_re, '', $tag);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # Check if text inside this tag must be parsed in span mode.&nbsp;</div></li><li><div>                    $this-&gt;mode = $attr_m[2] . $attr_m[3];&nbsp;</div></li><li><div>                    $span_mode = $this-&gt;mode == 'span' || $this-&gt;mode != 'block' &&&nbsp;</div></li><li><div>                        preg_match('{^&lt;(?:'.$this-&gt;contain_span_tags_re.')\b}', $tag);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # Calculate indent before tag.&nbsp;</div></li><li><div>                    if (preg_match('/(?:^|\n)( *?)(?! ).*?$/', $block_text, $matches)) {&nbsp;</div></li><li><div>                        $strlen = $this-&gt;utf8_strlen;&nbsp;</div></li><li><div>                        $indent = $strlen($matches[1], 'UTF-8');&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $indent = 0;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # End preceding block with this tag.&nbsp;</div></li><li><div>                    $block_text .= $tag;&nbsp;</div></li><li><div>                    $parsed .= $this-&gt;$hash_method($block_text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # Get enclosing tag name for the ParseMarkdown function.&nbsp;</div></li><li><div>                    # (This pattern makes $tag_name_re safe without quoting.)&nbsp;</div></li><li><div>                    preg_match('/^&lt;([\w:$]*)\b/', $tag, $matches);&nbsp;</div></li><li><div>                    $tag_name_re = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # Parse the content using the HTML-in-Markdown parser.&nbsp;</div></li><li><div>                    list ($block_text, $text)&nbsp;</div></li><li><div> = $this-&gt;_hashHTMLBlocks_inMarkdown($text, $indent, &nbsp;</div></li><li><div>                            $tag_name_re, $span_mode);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # Outdent markdown text.&nbsp;</div></li><li><div>                    if ($indent &gt; 0) {&nbsp;</div></li><li><div>                        $block_text = preg_replace(&quot;/^[ ]{1, $indent}/m&quot;, &quot;&quot;, &nbsp;</div></li><li><div>                                                    $block_text);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # Append tag content to parsed text.&nbsp;</div></li><li><div>                    if (!$span_mode)    $parsed .= &quot;\n\n$block_text\n\n&quot;;&nbsp;</div></li><li><div>                    else                $parsed .= &quot;$block_text&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    # Start over with a new block.&nbsp;</div></li><li><div>                    $block_text = &quot;&quot;;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                else $block_text .= $tag;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        } while ($depth &gt; 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Hash last block text that wasn't processed inside the loop.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $parsed .= $this-&gt;$hash_method($block_text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return array($parsed, $text);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function hashClean($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Called whenever a tag must be hashed when a function inserts a &quot;clean&quot; tag&nbsp;</div></li><li><div>    # in $text, it passes through this function and is automaticaly escaped, &nbsp;</div></li><li><div>    # blocking invalid nested overlap.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        return $this-&gt;hashPart($text, 'C');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doAnchors($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Turn Markdown link shortcuts into XHTML &lt;a&gt; tags.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if ($this-&gt;in_anchor) return $text;&nbsp;</div></li><li><div>        $this-&gt;in_anchor = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # First, handle reference-style links: [link text] [id]&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                    # wrap whole match in $1&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              [ ]?                # one optional space&nbsp;</div></li><li><div>              (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                (.*?)        # id = $3&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Next, inline-style links: [link text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                # wrap whole match in $1&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')    # link text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>              \(            # literal paren&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    &lt;(.+?)&gt;    # href = $3&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    ('.$this-&gt;nested_url_parenthesis_re.')    # href = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (            # $5&nbsp;</div></li><li><div>                  ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                  (.*?)        # Title = $7&nbsp;</div></li><li><div>                  \6        # matching quote&nbsp;</div></li><li><div>                  [ \n]*    # ignore any spaces/tabs between closing quote and )&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>              \)&nbsp;</div></li><li><div>              (?:[ ]? '.$this-&gt;id_class_attr_catch_re.' )?     # $8 = id/class attributes&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doAnchors_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Last, handle reference-style shortcuts: [link text]&nbsp;</div></li><li><div>        # These must come last in case you've also got [link text][1]&nbsp;</div></li><li><div>        # or [link text](/foo)&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                    # wrap whole match in $1&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                ([^\[\]]+)        # link text = $2; can\'t contain [ or ]&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doAnchors_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;in_anchor = false;&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAnchors_reference_callback($matches) {&nbsp;</div></li><li><div>        $whole_match =  $matches[1];&nbsp;</div></li><li><div>        $link_text =  $matches[2];&nbsp;</div></li><li><div>        $link_id =& $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>            # for shortcut links like [this][] or [this].&nbsp;</div></li><li><div>            $link_id = $link_text;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # lower-case and turn embedded newlines into spaces&nbsp;</div></li><li><div>        $link_id = strtolower($link_id);&nbsp;</div></li><li><div>        $link_id = preg_replace('{[ ]?\n}', ' ', $link_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>            $url = $this-&gt;urls[$link_id];&nbsp;</div></li><li><div>            $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>            if ( isset( $this-&gt;titles[$link_id] ) ) {&nbsp;</div></li><li><div>                $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>                $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>                $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($this-&gt;ref_attr[$link_id]))&nbsp;</div></li><li><div>                $result .= $this-&gt;ref_attr[$link_id];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>            $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>            $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            $result = $whole_match;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAnchors_inline_callback($matches) {&nbsp;</div></li><li><div>        $whole_match =  $matches[1];&nbsp;</div></li><li><div>        $link_text =  $this-&gt;runSpanGamut($matches[2]);&nbsp;</div></li><li><div>        $url =  $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>        $title =& $matches[7];&nbsp;</div></li><li><div>        $attr = $this-&gt;doExtraAttributes(&quot;a&quot;, $dummy =& $matches[8]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $result = &quot;&lt;a href=\&quot;$url\&quot;&quot;;&nbsp;</div></li><li><div>        if (isset($title)) {&nbsp;</div></li><li><div>            $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>            $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $result .= $attr;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $link_text = $this-&gt;runSpanGamut($link_text);&nbsp;</div></li><li><div>        $result .= &quot;&gt;$link_text&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doImages($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Turn Markdown image shortcuts into &lt;img&gt; tags.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # First, handle reference-style labeled images: ![alt text][id]&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                # wrap whole match in $1&nbsp;</div></li><li><div>              !\[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              [ ]?                # one optional space&nbsp;</div></li><li><div>              (?:\n[ ]*)?        # one optional newline followed by spaces&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              \[&nbsp;</div></li><li><div>                (.*?)        # id = $3&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doImages_reference_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Next, handle inline images:  ![alt text](url &quot;optional title&quot;)&nbsp;</div></li><li><div>        # Don't forget: encode * and _&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            (                # wrap whole match in $1&nbsp;</div></li><li><div>              !\[&nbsp;</div></li><li><div>                ('.$this-&gt;nested_brackets_re.')        # alt text = $2&nbsp;</div></li><li><div>              \]&nbsp;</div></li><li><div>              \s?            # One optional whitespace character&nbsp;</div></li><li><div>              \(            # literal paren&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    &lt;(\S*)&gt;    # src url = $3&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    ('.$this-&gt;nested_url_parenthesis_re.')    # src url = $4&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                [ \n]*&nbsp;</div></li><li><div>                (            # $5&nbsp;</div></li><li><div>                  ([\'&quot;])    # quote char = $6&nbsp;</div></li><li><div>                  (.*?)        # title = $7&nbsp;</div></li><li><div>                  \6        # matching quote&nbsp;</div></li><li><div>                  [ \n]*&nbsp;</div></li><li><div> )?            # title is optional&nbsp;</div></li><li><div>              \)&nbsp;</div></li><li><div>              (?:[ ]? '.$this-&gt;id_class_attr_catch_re.' )?     # $8 = id/class attributes&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xs', &nbsp;</div></li><li><div>            array(&$this, '_doImages_inline_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doImages_reference_callback($matches) {&nbsp;</div></li><li><div>        $whole_match = $matches[1];&nbsp;</div></li><li><div>        $alt_text = $matches[2];&nbsp;</div></li><li><div>        $link_id = strtolower($matches[3]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($link_id == &quot;&quot;) {&nbsp;</div></li><li><div>            $link_id = strtolower($alt_text); # for shortcut links like ![this][].&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>        if (isset($this-&gt;urls[$link_id])) {&nbsp;</div></li><li><div>            $url = $this-&gt;encodeAttribute($this-&gt;urls[$link_id]);&nbsp;</div></li><li><div>            $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>            if (isset($this-&gt;titles[$link_id])) {&nbsp;</div></li><li><div>                $title = $this-&gt;titles[$link_id];&nbsp;</div></li><li><div>                $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>                $result .=  &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($this-&gt;ref_attr[$link_id]))&nbsp;</div></li><li><div>                $result .= $this-&gt;ref_attr[$link_id];&nbsp;</div></li><li><div>            $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>            $result = $this-&gt;hashPart($result);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            # If there's no such link ID, leave intact:&nbsp;</div></li><li><div>            $result = $whole_match;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doImages_inline_callback($matches) {&nbsp;</div></li><li><div>        $whole_match = $matches[1];&nbsp;</div></li><li><div>        $alt_text = $matches[2];&nbsp;</div></li><li><div>        $url = $matches[3] == '' ? $matches[4] : $matches[3];&nbsp;</div></li><li><div>        $title =& $matches[7];&nbsp;</div></li><li><div>        $attr = $this-&gt;doExtraAttributes(&quot;img&quot;, $dummy =& $matches[8]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $alt_text = $this-&gt;encodeAttribute($alt_text);&nbsp;</div></li><li><div>        $url = $this-&gt;encodeAttribute($url);&nbsp;</div></li><li><div>        $result = &quot;&lt;img src=\&quot;$url\&quot; alt=\&quot;$alt_text\&quot;&quot;;&nbsp;</div></li><li><div>        if (isset($title)) {&nbsp;</div></li><li><div>            $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>            $result .=  &quot; title=\&quot;$title\&quot;&quot;; # $title already quoted&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $result .= $attr;&nbsp;</div></li><li><div>        $result .= $this-&gt;empty_element_suffix;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;hashPart($result);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doHeaders($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Redefined to add id and class attribute support.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # Setext-style headers:&nbsp;</div></li><li><div>        #      Header 1  {#header1}&nbsp;</div></li><li><div>        # ========&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        #      Header 2  {#header2 .class1 .class2}&nbsp;</div></li><li><div>        #      --------&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback(&nbsp;</div></li><li><div>            '{&nbsp;</div></li><li><div>                (^.+?)                                # $1: Header text&nbsp;</div></li><li><div>                (?:[ ]+ '.$this-&gt;id_class_attr_catch_re.' )?     # $3 = id/class attributes&nbsp;</div></li><li><div>                [ ]*\n(=+|-+)[ ]*\n+                # $3: Header footer&nbsp;</div></li><li><div>            }mx', &nbsp;</div></li><li><div>            array(&$this, '_doHeaders_callback_setext'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # atx-style headers:&nbsp;</div></li><li><div>        #    # Header 1        {#header1}&nbsp;</div></li><li><div>        #    ## Header 2       {#header2}&nbsp;</div></li><li><div>        #    ## Header 2 with closing hashes ##  {#header3.class1.class2}&nbsp;</div></li><li><div>        #    ...&nbsp;</div></li><li><div>        #    ###### Header 6   {.class2}&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>                ^(\#{1, 6})    # $1 = string of #\'s&nbsp;</div></li><li><div>                [ ]*&nbsp;</div></li><li><div>                (.+?)        # $2 = Header text&nbsp;</div></li><li><div>                [ ]*&nbsp;</div></li><li><div>                \#*            # optional closing #\'s (not counted)&nbsp;</div></li><li><div>                (?:[ ]+ '.$this-&gt;id_class_attr_catch_re.' )?     # $3 = id/class attributes&nbsp;</div></li><li><div>                [ ]*&nbsp;</div></li><li><div>                \n+&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_doHeaders_callback_atx'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doHeaders_callback_setext($matches) {&nbsp;</div></li><li><div>        if ($matches[3] == '-' && preg_match('{^- }', $matches[1]))&nbsp;</div></li><li><div>            return $matches[0];&nbsp;</div></li><li><div>        $level = $matches[3]{0} == '=' ? 1 : 2;&nbsp;</div></li><li><div>        $attr = $this-&gt;doExtraAttributes(&quot;h$level&quot;, $dummy =& $matches[2]);&nbsp;</div></li><li><div>        $block = &quot;&lt;h$level$attr&gt;&quot;.$this-&gt;runSpanGamut($matches[1]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>        return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doHeaders_callback_atx($matches) {&nbsp;</div></li><li><div>        $level = strlen($matches[1]);&nbsp;</div></li><li><div>        $attr = $this-&gt;doExtraAttributes(&quot;h$level&quot;, $dummy =& $matches[3]);&nbsp;</div></li><li><div>        $block = &quot;&lt;h$level$attr&gt;&quot;.$this-&gt;runSpanGamut($matches[2]).&quot;&lt;/h$level&gt;&quot;;&nbsp;</div></li><li><div>        return &quot;\n&quot; . $this-&gt;hashBlock($block) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doTables($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Form HTML tables.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Find tables with leading pipe.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        #    | Header 1 | Header 2&nbsp;</div></li><li><div>        #    | -------- | --------&nbsp;</div></li><li><div>        #    | Cell 1   | Cell 2&nbsp;</div></li><li><div>        #    | Cell 3   | Cell 4&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('&nbsp;</div></li><li><div>            {&nbsp;</div></li><li><div>                ^                            # Start of a line&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>                [|]                            # Optional leading pipe (present)&nbsp;</div></li><li><div>                (.+) \n                        # $1: Header row (at least one pipe)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>                [|] ([ ]*[-:]+[-| :]*) \n    # $2: Header underline&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                (                            # $3: Cells&nbsp;</div></li><li><div>                    (?&gt;&nbsp;</div></li><li><div>                        [ ]*                # Allowed whitespace.&nbsp;</div></li><li><div>                        [|] .* \n            # Row content.&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                (?=\n|\Z)                    # Stop at final double newline.&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_doTable_leadingPipe_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Find tables without leading pipe.&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        #    Header 1 | Header 2&nbsp;</div></li><li><div>        #    -------- | --------&nbsp;</div></li><li><div>        #    Cell 1   | Cell 2&nbsp;</div></li><li><div>        #    Cell 3   | Cell 4&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        $text = preg_replace_callback('&nbsp;</div></li><li><div>            {&nbsp;</div></li><li><div>                ^                            # Start of a line&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>                (\S.*[|].*) \n                # $1: Header row (at least one pipe)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}    # Allowed whitespace.&nbsp;</div></li><li><div>                ([-:]+[ ]*[|][-| :]*) \n    # $2: Header underline&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                (                            # $3: Cells&nbsp;</div></li><li><div>                    (?&gt;&nbsp;</div></li><li><div>                        .* [|] .* \n        # Row content&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                (?=\n|\Z)                    # Stop at final double newline.&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_DoTable_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doTable_leadingPipe_callback($matches) {&nbsp;</div></li><li><div>        $head = $matches[1];&nbsp;</div></li><li><div>        $underline = $matches[2];&nbsp;</div></li><li><div>        $content = $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Remove leading pipe for each row.&nbsp;</div></li><li><div>        $content = preg_replace('/^ *[|]/m', '', $content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;_doTable_callback(array($matches[0], $head, $underline, $content));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doTable_callback($matches) {&nbsp;</div></li><li><div>        $head = $matches[1];&nbsp;</div></li><li><div>        $underline = $matches[2];&nbsp;</div></li><li><div>        $content = $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Remove any tailing pipes for each line.&nbsp;</div></li><li><div>        $head = preg_replace('/[|] *$/m', '', $head);&nbsp;</div></li><li><div>        $underline = preg_replace('/[|] *$/m', '', $underline);&nbsp;</div></li><li><div>        $content = preg_replace('/[|] *$/m', '', $content);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Reading alignement from header underline.&nbsp;</div></li><li><div>        $separators = preg_split('/ *[|] */', $underline);&nbsp;</div></li><li><div>        foreach ($separators as $n =&gt; $s) {&nbsp;</div></li><li><div>            if (preg_match('/^ *-+: *$/', $s))        $attr[$n] = ' align=&quot;right&quot;';&nbsp;</div></li><li><div>            else if (preg_match('/^ *:-+: *$/', $s))$attr[$n] = ' align=&quot;center&quot;';&nbsp;</div></li><li><div>            else if (preg_match('/^ *:-+ *$/', $s))    $attr[$n] = ' align=&quot;left&quot;';&nbsp;</div></li><li><div>            else                                    $attr[$n] = '';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Parsing span elements, including code spans, character escapes, &nbsp;</div></li><li><div>        # and inline HTML tags, so that pipes inside those gets ignored.&nbsp;</div></li><li><div>        $head = $this-&gt;parseSpan($head);&nbsp;</div></li><li><div>        $headers = preg_split('/ *[|] */', $head);&nbsp;</div></li><li><div>        $col_count = count($headers);&nbsp;</div></li><li><div>        $attr = array_pad($attr, $col_count, '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Write column headers.&nbsp;</div></li><li><div>        $text = &quot;&lt;table&gt;\n&quot;;&nbsp;</div></li><li><div>        $text .= &quot;&lt;thead&gt;\n&quot;;&nbsp;</div></li><li><div>        $text .= &quot;&lt;tr&gt;\n&quot;;&nbsp;</div></li><li><div>        foreach ($headers as $n =&gt; $header)&nbsp;</div></li><li><div>            $text .= &quot;  &lt;th$attr[$n]&gt;&quot;.$this-&gt;runSpanGamut(trim($header)).&quot;&lt;/th&gt;\n&quot;;&nbsp;</div></li><li><div>        $text .= &quot;&lt;/tr&gt;\n&quot;;&nbsp;</div></li><li><div>        $text .= &quot;&lt;/thead&gt;\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Split content by row.&nbsp;</div></li><li><div>        $rows = explode(&quot;\n&quot;, trim($content, &quot;\n&quot;));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $text .= &quot;&lt;tbody&gt;\n&quot;;&nbsp;</div></li><li><div>        foreach ($rows as $row) {&nbsp;</div></li><li><div>            # Parsing span elements, including code spans, character escapes, &nbsp;</div></li><li><div>            # and inline HTML tags, so that pipes inside those gets ignored.&nbsp;</div></li><li><div>            $row = $this-&gt;parseSpan($row);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # Split row by cell.&nbsp;</div></li><li><div>            $row_cells = preg_split('/ *[|] */', $row, $col_count);&nbsp;</div></li><li><div>            $row_cells = array_pad($row_cells, $col_count, '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $text .= &quot;&lt;tr&gt;\n&quot;;&nbsp;</div></li><li><div>            foreach ($row_cells as $n =&gt; $cell)&nbsp;</div></li><li><div>                $text .= &quot;  &lt;td$attr[$n]&gt;&quot;.$this-&gt;runSpanGamut(trim($cell)).&quot;&lt;/td&gt;\n&quot;;&nbsp;</div></li><li><div>            $text .= &quot;&lt;/tr&gt;\n&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $text .= &quot;&lt;/tbody&gt;\n&quot;;&nbsp;</div></li><li><div>        $text .= &quot;&lt;/table&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;hashBlock($text) . &quot;\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doDefLists($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Form HTML definition lists.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Re-usable pattern to match any entire dl list:&nbsp;</div></li><li><div>        $whole_list_re = '(?&gt;&nbsp;</div></li><li><div>            (                                # $1 = whole list&nbsp;</div></li><li><div>              (                                # $2&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                ((?&gt;.*\S.*\n)+)                # $3 = defined term&nbsp;</div></li><li><div>                \n?&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}:[ ]+ # colon starting definition&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>              (?s:.+?)&nbsp;</div></li><li><div>              (                                # $4&nbsp;</div></li><li><div>                  \z&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                  \n{2, }&nbsp;</div></li><li><div>                  (?=\S)&nbsp;</div></li><li><div>                  (?!                        # Negative lookahead for another term&nbsp;</div></li><li><div>                    [ ]{0, '.$less_than_tab.'}&nbsp;</div></li><li><div>                    (?: \S.*\n )+?            # defined term&nbsp;</div></li><li><div>                    \n?&nbsp;</div></li><li><div>                    [ ]{0, '.$less_than_tab.'}:[ ]+ # colon starting definition&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                  (?!                        # Negative lookahead for another definition&nbsp;</div></li><li><div>                    [ ]{0, '.$less_than_tab.'}:[ ]+ # colon starting definition&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )'; // mx&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>                (?&gt;\A\n?|(?&lt;=\n\n))&nbsp;</div></li><li><div>                '.$whole_list_re.'&nbsp;</div></li><li><div>            }mx', &nbsp;</div></li><li><div>            array(&$this, '_doDefLists_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doDefLists_callback($matches) {&nbsp;</div></li><li><div>        # Re-usable patterns to match list item bullets and number markers:&nbsp;</div></li><li><div>        $list = $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Turn double returns into triple returns, so that we can make a&nbsp;</div></li><li><div>        # paragraph for the last item in a list, if necessary:&nbsp;</div></li><li><div>        $result = trim($this-&gt;processDefListItems($list));&nbsp;</div></li><li><div>        $result = &quot;&lt;dl&gt;\n&quot; . $result . &quot;\n&lt;/dl&gt;&quot;;&nbsp;</div></li><li><div>        return $this-&gt;hashBlock($result) . &quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function processDefListItems($list_str) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Process the contents of a single definition list, splitting it&nbsp;</div></li><li><div>    #    into individual term and definition list items.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # trim trailing blank lines:&nbsp;</div></li><li><div>        $list_str = preg_replace(&quot;/\n{2, }\\z/&quot;, &quot;\n&quot;, $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Process definition terms.&nbsp;</div></li><li><div>        $list_str = preg_replace_callback('{&nbsp;</div></li><li><div>            (?&gt;\A\n?|\n\n+)                    # leading line&nbsp;</div></li><li><div>            (                                # definition terms = $1&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}    # leading whitespace&nbsp;</div></li><li><div>                (?!\:[ ]|[ ])                # negative lookahead for a definition&nbsp;</div></li><li><div>                                            #   mark (colon) or more whitespace.&nbsp;</div></li><li><div>                (?&gt; \S.* \n)+?                # actual term (not whitespace).&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            (?=\n?[ ]{0, 3}:[ ])                # lookahead for following line feed&nbsp;</div></li><li><div>                                            #   with a definition mark.&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_processDefListItems_callback_dt'), $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Process actual definitions.&nbsp;</div></li><li><div>        $list_str = preg_replace_callback('{&nbsp;</div></li><li><div>            \n(\n+)?                        # leading line = $1&nbsp;</div></li><li><div>            (                                # marker space = $2&nbsp;</div></li><li><div>                [ ]{0, '.$less_than_tab.'}    # whitespace before colon&nbsp;</div></li><li><div>                \:[ ]+                        # definition mark (colon)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            ((?s:.+?))                        # definition text = $3&nbsp;</div></li><li><div>            (?= \n+                         # stop at next definition mark, &nbsp;</div></li><li><div>                (?:                            # next term or end of text&nbsp;</div></li><li><div>                    [ ]{0, '.$less_than_tab.'} \:[ ]    |&nbsp;</div></li><li><div>                    &lt;dt&gt; | \z&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_processDefListItems_callback_dd'), $list_str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $list_str;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _processDefListItems_callback_dt($matches) {&nbsp;</div></li><li><div>        $terms = explode(&quot;\n&quot;, trim($matches[1]));&nbsp;</div></li><li><div>        $text = '';&nbsp;</div></li><li><div>        foreach ($terms as $term) {&nbsp;</div></li><li><div>            $term = $this-&gt;runSpanGamut(trim($term));&nbsp;</div></li><li><div>            $text .= &quot;\n&lt;dt&gt;&quot; . $term . &quot;&lt;/dt&gt;&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $text . &quot;\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _processDefListItems_callback_dd($matches) {&nbsp;</div></li><li><div>        $leading_line = $matches[1];&nbsp;</div></li><li><div>        $marker_space = $matches[2];&nbsp;</div></li><li><div>        $def = $matches[3];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($leading_line || preg_match('/\n{2, }/', $def)) {&nbsp;</div></li><li><div>            # Replace marker with the appropriate whitespace indentation&nbsp;</div></li><li><div>            $def = str_repeat(' ', strlen($marker_space)) . $def;&nbsp;</div></li><li><div>            $def = $this-&gt;runBlockGamut($this-&gt;outdent($def . &quot;\n\n&quot;));&nbsp;</div></li><li><div>            $def = &quot;\n&quot;. $def .&quot;\n&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            $def = rtrim($def);&nbsp;</div></li><li><div>            $def = $this-&gt;runSpanGamut($this-&gt;outdent($def));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return &quot;\n&lt;dd&gt;&quot; . $def . &quot;&lt;/dd&gt;\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doFencedCodeBlocks($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Adding the fenced code block syntax to regular Markdown:&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # ~~~&nbsp;</div></li><li><div>    # Code block&nbsp;</div></li><li><div>    # ~~~&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>                (?:\n|\A)&nbsp;</div></li><li><div>                # 1: Opening marker&nbsp;</div></li><li><div>                (&nbsp;</div></li><li><div>                    (?:~{3, }|`{3, }) # 3 or more tildes/backticks.&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>                [ ]*&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    \.?([-_:a-zA-Z0-9]+) # 2: standalone class name&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    '.$this-&gt;id_class_attr_catch_re.' # 3: Extra attributes&nbsp;</div></li><li><div> )?&nbsp;</div></li><li><div>                [ ]* \n # Whitespace and newline following marker.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                # 4: Content&nbsp;</div></li><li><div>                (&nbsp;</div></li><li><div>                    (?&gt;&nbsp;</div></li><li><div>                        (?!\1 [ ]* \n)    # Not a closing marker.&nbsp;</div></li><li><div>                        .*\n+&nbsp;</div></li><li><div> )+&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                # Closing marker.&nbsp;</div></li><li><div>                \1 [ ]* (?= \n )&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_doFencedCodeBlocks_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doFencedCodeBlocks_callback($matches) {&nbsp;</div></li><li><div>        $classname =& $matches[2];&nbsp;</div></li><li><div>        $attrs =& $matches[3];&nbsp;</div></li><li><div>        $codeblock = $matches[4];&nbsp;</div></li><li><div>        $codeblock = htmlspecialchars($codeblock, ENT_NOQUOTES);&nbsp;</div></li><li><div>        $codeblock = preg_replace_callback('/^\n+/', &nbsp;</div></li><li><div>            array(&$this, '_doFencedCodeBlocks_newlines'), $codeblock);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($classname != &quot;&quot;) {&nbsp;</div></li><li><div>            if ($classname{0} == '.')&nbsp;</div></li><li><div>                $classname = substr($classname, 1);&nbsp;</div></li><li><div>            $attr_str = ' class=&quot;'.$this-&gt;code_class_prefix.$classname.'&quot;';&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $attr_str = $this-&gt;doExtraAttributes($this-&gt;code_attr_on_pre ? &quot;pre&quot; : &quot;code&quot;, $attrs);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $pre_attr_str = $this-&gt;code_attr_on_pre ? $attr_str : '';&nbsp;</div></li><li><div>        $code_attr_str = $this-&gt;code_attr_on_pre ? '' : $attr_str;&nbsp;</div></li><li><div>        $codeblock = &quot;&lt;pre$pre_attr_str&gt;&lt;code$code_attr_str&gt;$codeblock&lt;/code&gt;&lt;/pre&gt;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return &quot;\n\n&quot;.$this-&gt;hashBlock($codeblock).&quot;\n\n&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doFencedCodeBlocks_newlines($matches) {&nbsp;</div></li><li><div>        return str_repeat(&quot;&lt;br$this-&gt;empty_element_suffix&quot;, &nbsp;</div></li><li><div>            strlen($matches[0]));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Redefining emphasis markers so that emphasis by underscore does not&nbsp;</div></li><li><div>    # work in the middle of a word.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    public $em_relist = array(&nbsp;</div></li><li><div>        '' =&gt; '(?:(?&lt;!\*)\*(?!\*)|(?&lt;![a-zA-Z0-9_])_(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>        '*' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*(?!\*)', &nbsp;</div></li><li><div>        '_' =&gt; '(?&lt;=\S|^)(?&lt;!_)_(?![a-zA-Z0-9_])', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    public $strong_relist = array(&nbsp;</div></li><li><div>        '' =&gt; '(?:(?&lt;!\*)\*\*(?!\*)|(?&lt;![a-zA-Z0-9_])__(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>        '**' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*(?!\*)', &nbsp;</div></li><li><div>        '__' =&gt; '(?&lt;=\S|^)(?&lt;!_)__(?![a-zA-Z0-9_])', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    public $em_strong_relist = array(&nbsp;</div></li><li><div>        '' =&gt; '(?:(?&lt;!\*)\*\*\*(?!\*)|(?&lt;![a-zA-Z0-9_])___(?!_))(?=\S|$)(?![\., :;]\s)', &nbsp;</div></li><li><div>        '***' =&gt; '(?&lt;=\S|^)(?&lt;!\*)\*\*\*(?!\*)', &nbsp;</div></li><li><div>        '___' =&gt; '(?&lt;=\S|^)(?&lt;!_)___(?![a-zA-Z0-9_])', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function formParagraphs($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    #    Params:&nbsp;</div></li><li><div>    #        $text - string to process with html &lt;p&gt; tags&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        # Strip leading and trailing lines:&nbsp;</div></li><li><div>        $text = preg_replace('/\A\n+|\n+\z/', '', $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $grafs = preg_split('/\n{2, }/', $text, -1, PREG_SPLIT_NO_EMPTY);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        # Wrap &lt;p&gt; tags and unhashify HTML blocks&nbsp;</div></li><li><div>        #&nbsp;</div></li><li><div>        foreach ($grafs as $key =&gt; $value) {&nbsp;</div></li><li><div>            $value = trim($this-&gt;runSpanGamut($value));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            # Check if this should be enclosed in a paragraph.&nbsp;</div></li><li><div>            # Clean tag hashes & block tag hashes are left alone.&nbsp;</div></li><li><div>            $is_p = !preg_match('/^B\x1A[0-9]+B|^C\x1A[0-9]+C$/', $value);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($is_p) {&nbsp;</div></li><li><div>                $value = &quot;&lt;p&gt;$value&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $grafs[$key] = $value;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Join grafs in one text, then unhash HTML tags.&nbsp;</div></li><li><div>        $text = implode(&quot;\n\n&quot;, $grafs);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Finish by removing any tag hashes still present in $text.&nbsp;</div></li><li><div>        $text = $this-&gt;unhash($text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### Footnotes&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function stripFootnotes($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Strips link definitions from text, stores the URLs and titles in&nbsp;</div></li><li><div>    # hash references.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Link defs are in the form: [^id]: url &quot;optional title&quot;&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            ^[ ]{0, '.$less_than_tab.'}\[\^(.+?)\][ ]?:    # note_id = $1&nbsp;</div></li><li><div>              [ ]*&nbsp;</div></li><li><div>              \n?                    # maybe *one* newline&nbsp;</div></li><li><div>            (                        # text = $2 (no blank lines allowed)&nbsp;</div></li><li><div>                (?:&nbsp;</div></li><li><div>                    .+                # actual text&nbsp;</div></li><li><div>                |&nbsp;</div></li><li><div>                    \n                # newlines but&nbsp;</div></li><li><div>                    (?!\[\^.+?\]:\s)# negative lookahead for footnote marker.&nbsp;</div></li><li><div>                    (?!\n+[ ]{0, 3}\S)# ensure line is not blank and followed&nbsp;</div></li><li><div>                                    # by non-indented content&nbsp;</div></li><li><div> )*&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_stripFootnotes_callback'), &nbsp;</div></li><li><div>            $text);&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _stripFootnotes_callback($matches) {&nbsp;</div></li><li><div>        $note_id = $this-&gt;fn_id_prefix . $matches[1];&nbsp;</div></li><li><div>        $this-&gt;footnotes[$note_id] = $this-&gt;outdent($matches[2]);&nbsp;</div></li><li><div>        return ''; # String that will replace the block&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doFootnotes($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Replace footnote references in $text [^id] with a special text-token&nbsp;</div></li><li><div>    # which will be replaced by the actual footnote marker in appendFootnotes.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if (!$this-&gt;in_anchor) {&nbsp;</div></li><li><div>            $text = preg_replace('{\[\^(.+?)\]}', &quot;F\x1Afn:\\1\x1A:&quot;, $text);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function appendFootnotes($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Append footnote list to text.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $text = preg_replace_callback('{F\x1Afn:(.*?)\x1A:}', &nbsp;</div></li><li><div>            array(&$this, '_appendFootnotes_callback'), $text);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (!empty($this-&gt;footnotes_ordered)) {&nbsp;</div></li><li><div>            $text .= &quot;\n\n&quot;;&nbsp;</div></li><li><div>            $text .= &quot;&lt;div class=\&quot;footnotes\&quot;&gt;\n&quot;;&nbsp;</div></li><li><div>            $text .= &quot;&lt;hr&quot;. $this-&gt;empty_element_suffix .&quot;\n&quot;;&nbsp;</div></li><li><div>            $text .= &quot;&lt;ol&gt;\n\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $attr = &quot; rev=\&quot;footnote\&quot;&quot;;&nbsp;</div></li><li><div>            if ($this-&gt;fn_backlink_class != &quot;&quot;) {&nbsp;</div></li><li><div>                $class = $this-&gt;fn_backlink_class;&nbsp;</div></li><li><div>                $class = $this-&gt;encodeAttribute($class);&nbsp;</div></li><li><div>                $attr .= &quot; class=\&quot;$class\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($this-&gt;fn_backlink_title != &quot;&quot;) {&nbsp;</div></li><li><div>                $title = $this-&gt;fn_backlink_title;&nbsp;</div></li><li><div>                $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>                $attr .= &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $num = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            while (!empty($this-&gt;footnotes_ordered)) {&nbsp;</div></li><li><div>                $footnote = reset($this-&gt;footnotes_ordered);&nbsp;</div></li><li><div>                $note_id = key($this-&gt;footnotes_ordered);&nbsp;</div></li><li><div>                unset($this-&gt;footnotes_ordered[$note_id]);&nbsp;</div></li><li><div>                $ref_count = $this-&gt;footnotes_ref_count[$note_id];&nbsp;</div></li><li><div>                unset($this-&gt;footnotes_ref_count[$note_id]);&nbsp;</div></li><li><div>                unset($this-&gt;footnotes[$note_id]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $footnote .= &quot;\n&quot;; # Need to append newline before parsing.&nbsp;</div></li><li><div>                $footnote = $this-&gt;runBlockGamut(&quot;$footnote\n&quot;);&nbsp;</div></li><li><div>                $footnote = preg_replace_callback('{F\x1Afn:(.*?)\x1A:}', &nbsp;</div></li><li><div>                    array(&$this, '_appendFootnotes_callback'), $footnote);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $attr = str_replace(&quot;%%&quot;, ++$num, $attr);&nbsp;</div></li><li><div>                $note_id = $this-&gt;encodeAttribute($note_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                # Prepare backlink, multiple backlinks if multiple references&nbsp;</div></li><li><div>                $backlink = &quot;&lt;a href=\&quot;#fnref:$note_id\&quot;$attr&gt;&#8617;&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>                for ($ref_num = 2; $ref_num &lt;= $ref_count; ++$ref_num) {&nbsp;</div></li><li><div>                    $backlink .= &quot; &lt;a href=\&quot;#fnref$ref_num:$note_id\&quot;$attr&gt;&#8617;&lt;/a&gt;&quot;;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                # Add backlink to last paragraph; create new paragraph if needed.&nbsp;</div></li><li><div>                if (preg_match('{&lt;/p&gt;$}', $footnote)) {&nbsp;</div></li><li><div>                    $footnote = substr($footnote, 0, -4) . &quot;&#160;$backlink&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $footnote .= &quot;\n\n&lt;p&gt;$backlink&lt;/p&gt;&quot;;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $text .= &quot;&lt;li id=\&quot;fn:$note_id\&quot;&gt;\n&quot;;&nbsp;</div></li><li><div>                $text .= $footnote . &quot;\n&quot;;&nbsp;</div></li><li><div>                $text .= &quot;&lt;/li&gt;\n\n&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $text .= &quot;&lt;/ol&gt;\n&quot;;&nbsp;</div></li><li><div>            $text .= &quot;&lt;/div&gt;&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _appendFootnotes_callback($matches) {&nbsp;</div></li><li><div>        $node_id = $this-&gt;fn_id_prefix . $matches[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Create footnote marker only if it has a corresponding footnote *and*&nbsp;</div></li><li><div>        # the footnote hasn't been used by another marker.&nbsp;</div></li><li><div>        if (isset($this-&gt;footnotes[$node_id])) {&nbsp;</div></li><li><div>            $num =& $this-&gt;footnotes_numbers[$node_id];&nbsp;</div></li><li><div>            if (!isset($num)) {&nbsp;</div></li><li><div>                # Transfer footnote content to the ordered list and give it its&nbsp;</div></li><li><div>                # number&nbsp;</div></li><li><div>                $this-&gt;footnotes_ordered[$node_id] = $this-&gt;footnotes[$node_id];&nbsp;</div></li><li><div>                $this-&gt;footnotes_ref_count[$node_id] = 1;&nbsp;</div></li><li><div>                $num = $this-&gt;footnote_counter++;&nbsp;</div></li><li><div>                $ref_count_mark = '';&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $ref_count_mark = $this-&gt;footnotes_ref_count[$node_id] += 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $attr = &quot; rel=\&quot;footnote\&quot;&quot;;&nbsp;</div></li><li><div>            if ($this-&gt;fn_link_class != &quot;&quot;) {&nbsp;</div></li><li><div>                $class = $this-&gt;fn_link_class;&nbsp;</div></li><li><div>                $class = $this-&gt;encodeAttribute($class);&nbsp;</div></li><li><div>                $attr .= &quot; class=\&quot;$class\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($this-&gt;fn_link_title != &quot;&quot;) {&nbsp;</div></li><li><div>                $title = $this-&gt;fn_link_title;&nbsp;</div></li><li><div>                $title = $this-&gt;encodeAttribute($title);&nbsp;</div></li><li><div>                $attr .= &quot; title=\&quot;$title\&quot;&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $attr = str_replace(&quot;%%&quot;, $num, $attr);&nbsp;</div></li><li><div>            $node_id = $this-&gt;encodeAttribute($node_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            return&nbsp;</div></li><li><div>                &quot;&lt;sup id=\&quot;fnref$ref_count_mark:$node_id\&quot;&gt;&quot;.&nbsp;</div></li><li><div>                &quot;&lt;a href=\&quot;#fn:$node_id\&quot;$attr&gt;$num&lt;/a&gt;&quot;.&nbsp;</div></li><li><div>                &quot;&lt;/sup&gt;&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return &quot;[^&quot;.$matches[1].&quot;]&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    ### Abbreviations ###&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function stripAbbreviations($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Strips abbreviations from text, stores titles in hash references.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        $less_than_tab = $this-&gt;tab_width - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        # Link defs are in the form: [id]*: url &quot;optional title&quot;&nbsp;</div></li><li><div>        $text = preg_replace_callback('{&nbsp;</div></li><li><div>            ^[ ]{0, '.$less_than_tab.'}\*\[(.+?)\][ ]?:    # abbr_id = $1&nbsp;</div></li><li><div>            (.*)                    # text = $2 (no blank lines allowed)&nbsp;</div></li><li><div>            }xm', &nbsp;</div></li><li><div>            array(&$this, '_stripAbbreviations_callback'), &nbsp;</div></li><li><div>            $text);&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _stripAbbreviations_callback($matches) {&nbsp;</div></li><li><div>        $abbr_word = $matches[1];&nbsp;</div></li><li><div>        $abbr_desc = $matches[2];&nbsp;</div></li><li><div>        if ($this-&gt;abbr_word_re)&nbsp;</div></li><li><div>            $this-&gt;abbr_word_re .= '|';&nbsp;</div></li><li><div>        $this-&gt;abbr_word_re .= preg_quote($abbr_word);&nbsp;</div></li><li><div>        $this-&gt;abbr_desciptions[$abbr_word] = trim($abbr_desc);&nbsp;</div></li><li><div>        return ''; # String that will replace the block&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function doAbbreviations($text) {&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>    # Find defined abbreviations in text and wrap them in &lt;abbr&gt; elements.&nbsp;</div></li><li><div>    #&nbsp;</div></li><li><div>        if ($this-&gt;abbr_word_re) {&nbsp;</div></li><li><div>            // cannot use the /x modifier because abbr_word_re may&nbsp;</div></li><li><div>            // contain significant spaces:&nbsp;</div></li><li><div>            $text = preg_replace_callback('{'.&nbsp;</div></li><li><div>                '(?&lt;![\w\x1A])'.&nbsp;</div></li><li><div>                '(?:'.$this-&gt;abbr_word_re.')'.&nbsp;</div></li><li><div>                '(?![\w\x1A])'.&nbsp;</div></li><li><div>                '}', &nbsp;</div></li><li><div>                array(&$this, '_doAbbreviations_callback'), $text);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $text;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    function _doAbbreviations_callback($matches) {&nbsp;</div></li><li><div>        $abbr = $matches[0];&nbsp;</div></li><li><div>        if (isset($this-&gt;abbr_desciptions[$abbr])) {&nbsp;</div></li><li><div>            $desc = $this-&gt;abbr_desciptions[$abbr];&nbsp;</div></li><li><div>            if (empty($desc)) {&nbsp;</div></li><li><div>                return $this-&gt;hashPart(&quot;&lt;abbr&gt;$abbr&lt;/abbr&gt;&quot;);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $desc = $this-&gt;encodeAttribute($desc);&nbsp;</div></li><li><div>                return $this-&gt;hashPart(&quot;&lt;abbr title=\&quot;$desc\&quot;&gt;$abbr&lt;/abbr&gt;&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            return $matches[0];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 3.7.1</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.2/classes/markdown_extra_parser/" class="">3.8.2</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.1/classes/markdown_extra_parser/" class="">3.8.1</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/markdown_extra_parser/" class="active">3.8.0</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/classes/markdown_extra_parser/" class="">3.7.2</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.1/classes/markdown_extra_parser/" class="">3.7.1</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>MarkdownExtra_Parser</li><li><span></span>Jetpack by WordPress.com</li><li><span></span>3.8.2</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>