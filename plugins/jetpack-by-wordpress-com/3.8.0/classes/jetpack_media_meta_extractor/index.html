<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="3.8.0" data-slug="jetpack-by-wordpress-com" data-type="class" data-id="12120"><head xmlns="http://www.w3.org/1999/xhtml"><title> jetpack_media_meta_extractor | class | Jetpack By WordPress Com | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="Jetpack_Media_Meta_Extractor, class, plugin, jetpack-by-wordpress-com, 3.8.0" /><meta name="description" content="Class with methods to extract metadata from a post/page about videos, images, links, mentions embedded in or attached to the post/page." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=0725a8bd73859e8f27bad52ad89e4dea' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/jetpack_media_meta_extractor/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fjetpack_media_meta_extractor%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fjetpack_media_meta_extractor%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-jetpack-by-wordpress-com-3.8.0-class-jetpack_media_meta_extractor","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="jetpack_media_meta_extractor" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to jetpack-by-wordpress-com." href="http://hookr.io/plugins/jetpack-by-wordpress-com/" class="plugin"><span property="name">jetpack-by-wordpress-com</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 3.8.0." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/" class="H_VERSION"><span property="name">3.8.0</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">jetpack_media_meta_extractor</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="1499"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/all/" title="All">All <span class="count badge">1499</span></a></li><li class="" data-id="new" data-count="17"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/new/" title="New">New <span class="count badge">17</span></a></li><li class="" data-id="hooks" data-count="599"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/hooks/" title="Hooks">Hooks <span class="count badge">599</span></a></li><li class="" data-id="action" data-count="195"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/actions/" title="Actions">Actions <span class="count badge">195</span></a></li><li class="" data-id="filter" data-count="404"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/filters/" title="Filters">Filters <span class="count badge">404</span></a></li><li class="active" data-id="class" data-count="262"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/" title="Classes">Classes <span class="count badge">262</span></a></li><li class="" data-id="constant" data-count="62"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/constants/" title="Constants">Constants <span class="count badge">62</span></a></li><li class="" data-id="function" data-count="530"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/functions/" title="Functions">Functions <span class="count badge">530</span></a></li><li class="" data-id="shortcode" data-count="46"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">46</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>Jetpack_Media_Meta_Extractor</strong></h1><p>Class with methods to extract metadata from a post/page about videos, images, links, mentions embedded in or attached to the post/page.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/files/class-media-extractor/" class="file">/class.media-extractor.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="8" class="block" start="8"><li><div>class Jetpack_Media_Meta_Extractor {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // Some consts for what to extract&nbsp;</div></li><li><div>    const ALL = 255;&nbsp;</div></li><li><div>    const LINKS = 1;&nbsp;</div></li><li><div>    const MENTIONS = 2;&nbsp;</div></li><li><div>    const IMAGES = 4;&nbsp;</div></li><li><div>    const SHORTCODES = 8; // Only the keeper shortcodes below&nbsp;</div></li><li><div>    const EMBEDS = 16;&nbsp;</div></li><li><div>    const HASHTAGS = 32;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // For these, we try to extract some data from the shortcode, rather than just recording its presence (which we do for all)&nbsp;</div></li><li><div>    // There should be a function get_{shortcode}_id( $atts ) or static method SomethingShortcode::get_{shortcode}_id( $atts ) for these.&nbsp;</div></li><li><div>    private static $KEEPER_SHORTCODES = array(&nbsp;</div></li><li><div>        'youtube', &nbsp;</div></li><li><div>        'vimeo', &nbsp;</div></li><li><div>        'hulu', &nbsp;</div></li><li><div>        'ted', &nbsp;</div></li><li><div>        'wpvideo', &nbsp;</div></li><li><div>        'audio', &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Gets the specified media and meta info from the given post.&nbsp;</div></li><li><div>     * NOTE: If you have the post's HTML content already and don't need image data, use extract_from_content() instead.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param $blog_id The ID of the blog&nbsp;</div></li><li><div>     * @param $post_id The ID of the post&nbsp;</div></li><li><div>     * @param $what_to_extract (int) A mask of things to extract, e.g. Jetpack_Media_Meta_Extractor::IMAGES | Jetpack_Media_Meta_Extractor::MENTIONS&nbsp;</div></li><li><div>     * @returns a structure containing metadata about the embedded things, or empty array if nothing found, or WP_Error on error&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    static public function extract( $blog_id, $post_id, $what_to_extract = self::ALL ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // multisite?&nbsp;</div></li><li><div>        if ( function_exists( 'switch_to_blog') )&nbsp;</div></li><li><div>            switch_to_blog( $blog_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $post = get_post( $post_id );&nbsp;</div></li><li><div>        $content = $post-&gt;post_title . &quot;\n\n&quot; . $post-&gt;post_content;&nbsp;</div></li><li><div>        $char_cnt = strlen( $content );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //prevent running extraction on really huge amounts of content&nbsp;</div></li><li><div>        if ( $char_cnt &gt; 100000 ) //about 20k English words&nbsp;</div></li><li><div>            $content = substr( $content, 0, 100000 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $extracted = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Get images first, we need the full post for that&nbsp;</div></li><li><div>        if ( self::IMAGES & $what_to_extract ) {&nbsp;</div></li><li><div>            $extracted = self::get_image_fields( $post );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Turn off images so we can safely call extract_from_content() below&nbsp;</div></li><li><div>            $what_to_extract = $what_to_extract - self::IMAGES;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( function_exists( 'switch_to_blog') )&nbsp;</div></li><li><div>            restore_current_blog();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // All of the other things besides images can be extracted from just the content&nbsp;</div></li><li><div>        $extracted = self::extract_from_content( $content, $what_to_extract, $extracted );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $extracted;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Gets the specified meta info from the given post content.&nbsp;</div></li><li><div>     * NOTE: If you want IMAGES, call extract( $blog_id, $post_id, ...) which will give you more/better image extraction&nbsp;</div></li><li><div>     * This method will give you an error if you ask for IMAGES.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param $content The HTML post_content of a post&nbsp;</div></li><li><div>     * @param $what_to_extract (int) A mask of things to extract, e.g. Jetpack_Media_Meta_Extractor::IMAGES | Jetpack_Media_Meta_Extractor::MENTIONS&nbsp;</div></li><li><div>     * @param $already_extracted (array) Previously extracted things, e.g. images from extract(), which can be used for x-referencing here&nbsp;</div></li><li><div>     * @returns a structure containing metadata about the embedded things, or empty array if nothing found, or WP_Error on error&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    static public function extract_from_content( $content, $what_to_extract = self::ALL, $already_extracted = array() ) {&nbsp;</div></li><li><div>        $stripped_content = self::get_stripped_content( $content );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Maybe start with some previously extracted things (e.g. images from extract()&nbsp;</div></li><li><div>        $extracted = $already_extracted;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Embedded media objects will have already been converted to shortcodes by pre_kses hooks on save.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>         if ( self::IMAGES & $what_to_extract ) {&nbsp;</div></li><li><div>            $images = Jetpack_Media_Meta_Extractor::extract_images_from_content( $stripped_content, array() );&nbsp;</div></li><li><div>            $extracted = array_merge( $extracted, $images );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----------------------------------- MENTIONS ------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( self::MENTIONS & $what_to_extract ) {&nbsp;</div></li><li><div>            if ( preg_match_all( '/(^|\s)@(\w+)/u', $stripped_content, $matches ) ) {&nbsp;</div></li><li><div>                $mentions = array_values( array_unique( $matches[2] ) ); //array_unique() retains the keys!&nbsp;</div></li><li><div>                $mentions = array_map( 'strtolower', $mentions );&nbsp;</div></li><li><div>                $extracted['mention'] = array( 'name' =&gt; $mentions );&nbsp;</div></li><li><div>                if ( !isset( $extracted['has'] ) )&nbsp;</div></li><li><div>                    $extracted['has'] = array();&nbsp;</div></li><li><div>                $extracted['has']['mention'] = count( $mentions );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----------------------------------- HASHTAGS ------------------------------&nbsp;</div></li><li><div>        /** Some hosts may not compile with --enable-unicode-properties and kick a warning:&nbsp;</div></li><li><div>          *   Warning: preg_match_all() [function.preg-match-all]: Compilation failed: support for \P, \p, and \X has not been compiled&nbsp;</div></li><li><div>          * Therefore, we only run this code block on wpcom, not in Jetpack.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        if ( ( defined( 'IS_WPCOM' ) && IS_WPCOM ) && ( self::HASHTAGS & $what_to_extract ) ) {&nbsp;</div></li><li><div>            //This regex does not exactly match Twitter's&nbsp;</div></li><li><div>            // if there are problems/complaints we should implement this:&nbsp;</div></li><li><div>            //   https://github.com/twitter/twitter-text/blob/master/java/src/com/twitter/Regex.java&nbsp;</div></li><li><div>            if ( preg_match_all( '/(?:^|\s)#(\w*\p{L}+\w*)/u', $stripped_content, $matches ) ) {&nbsp;</div></li><li><div>                $hashtags = array_values( array_unique( $matches[1] ) ); //array_unique() retains the keys!&nbsp;</div></li><li><div>                $hashtags = array_map( 'strtolower', $hashtags );&nbsp;</div></li><li><div>                $extracted['hashtag'] = array( 'name' =&gt; $hashtags );&nbsp;</div></li><li><div>                if ( !isset( $extracted['has'] ) )&nbsp;</div></li><li><div>                    $extracted['has'] = array();&nbsp;</div></li><li><div>                $extracted['has']['hashtag'] = count( $hashtags );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----------------------------------- SHORTCODES ------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Always look for shortcodes.&nbsp;</div></li><li><div>        // If we don't want them, we'll just remove them, so we don't grab them as links below&nbsp;</div></li><li><div>        $shortcode_pattern = '/' . get_shortcode_regex() . '/s';&nbsp;</div></li><li><div>         if ( preg_match_all( $shortcode_pattern, $content, $matches ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $shortcode_total_count = 0;&nbsp;</div></li><li><div>            $shortcode_type_counts = array();&nbsp;</div></li><li><div>            $shortcode_types = array();&nbsp;</div></li><li><div>            $shortcode_details = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( self::SHORTCODES & $what_to_extract ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                foreach( $matches[2] as $key =&gt; $shortcode ) {&nbsp;</div></li><li><div>                    //Elasticsearch (and probably other things) doesn't deal well with some chars as key names&nbsp;</div></li><li><div>                    $shortcode_name = preg_replace( '/[., *&quot;\'\/\\\\#+ ]/', '_', $shortcode );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $attr = shortcode_parse_atts( $matches[3][ $key ] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $shortcode_total_count++;&nbsp;</div></li><li><div>                    if ( ! isset( $shortcode_type_counts[$shortcode_name] ) )&nbsp;</div></li><li><div>                        $shortcode_type_counts[$shortcode_name] = 0;&nbsp;</div></li><li><div>                    $shortcode_type_counts[$shortcode_name]++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Store (uniquely) presence of all shortcode regardless of whether it's a keeper (for those, get ID below)&nbsp;</div></li><li><div>                    // @todo Store number of occurrences?&nbsp;</div></li><li><div>                    if ( ! in_array( $shortcode_name, $shortcode_types ) )&nbsp;</div></li><li><div>                        $shortcode_types[] = $shortcode_name;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // For keeper shortcodes, also store the id/url of the object (e.g. youtube video, TED talk, etc.)&nbsp;</div></li><li><div>                    if ( in_array( $shortcode, self::$KEEPER_SHORTCODES ) ) {&nbsp;</div></li><li><div>                        unset( $id ); // Clear shortcode ID data left from the last shortcode&nbsp;</div></li><li><div>                        // We'll try to get the salient ID from the function jetpack_shortcode_get_xyz_id()&nbsp;</div></li><li><div>                        // If the shortcode is a class, we'll call XyzShortcode::get_xyz_id()&nbsp;</div></li><li><div>                        $shortcode_get_id_func = &quot;jetpack_shortcode_get_{$shortcode}_id&quot;;&nbsp;</div></li><li><div>                        $shortcode_class_name = ucfirst( $shortcode ) . 'Shortcode';&nbsp;</div></li><li><div>                        $shortcode_get_id_method = &quot;get_{$shortcode}_id&quot;;&nbsp;</div></li><li><div>                        if ( function_exists( $shortcode_get_id_func ) ) {&nbsp;</div></li><li><div>                            $id = call_user_func( $shortcode_get_id_func, $attr );&nbsp;</div></li><li><div>                        } else if ( method_exists( $shortcode_class_name, $shortcode_get_id_method ) ) {&nbsp;</div></li><li><div>                            $id = call_user_func( array( $shortcode_class_name, $shortcode_get_id_method ), $attr );&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        if ( ! empty( $id )&nbsp;</div></li><li><div>                            && ( ! isset( $shortcode_details[$shortcode_name] ) || ! in_array( $id, $shortcode_details[$shortcode_name] ) ) )&nbsp;</div></li><li><div>                            $shortcode_details[$shortcode_name][] = $id;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ( $shortcode_total_count &gt; 0 ) {&nbsp;</div></li><li><div>                    // Add the shortcode info to the $extracted array&nbsp;</div></li><li><div>                    if ( !isset( $extracted['has'] ) )&nbsp;</div></li><li><div>                        $extracted['has'] = array();&nbsp;</div></li><li><div>                    $extracted['has']['shortcode'] = $shortcode_total_count;&nbsp;</div></li><li><div>                    $extracted['shortcode'] = array();&nbsp;</div></li><li><div>                    foreach ( $shortcode_type_counts as $type =&gt; $count )&nbsp;</div></li><li><div>                        $extracted['shortcode'][$type] = array( 'count' =&gt; $count );&nbsp;</div></li><li><div>                    if ( ! empty( $shortcode_types ) )&nbsp;</div></li><li><div>                        $extracted['shortcode_types'] = $shortcode_types;&nbsp;</div></li><li><div>                    foreach ( $shortcode_details as $type =&gt; $id )&nbsp;</div></li><li><div>                        $extracted['shortcode'][$type]['id'] = $id;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Remove the shortcodes form our copy of $content, so we don't count links in them as links below.&nbsp;</div></li><li><div>            $content = preg_replace( $shortcode_pattern, ' ', $content );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----------------------------------- LINKS ------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( self::LINKS & $what_to_extract ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // To hold the extracted stuff we find&nbsp;</div></li><li><div>            $links = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // @todo Get the text inside the links?&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Grab any links, whether in &lt;a href=&quot;...&quot; or not, but subtract those from shortcodes and images&nbsp;</div></li><li><div>            // (we treat embed links as just another link)&nbsp;</div></li><li><div>            if ( preg_match_all( '#(?:^|\s|&quot;|\')(https?://([^\s()&lt;&gt;]+(?:\([\w\d]+\)|([^[:punct:]\s]|/))))#', $content, $matches ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                foreach ( $matches[1] as $link_raw ) {&nbsp;</div></li><li><div>                    $url = parse_url( $link_raw );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Data URI links&nbsp;</div></li><li><div>                    if ( isset( $url['scheme'] ) && 'data' === $url['scheme'] )&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Remove large (and likely invalid) links&nbsp;</div></li><li><div>                    if ( 4096 &lt; strlen( $link_raw ) )&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Build a simple form of the URL so we can compare it to ones we found in IMAGES or SHORTCODES and exclude those&nbsp;</div></li><li><div>                    $simple_url = $url['scheme'] . '://' . $url['host'] . ( ! empty( $url['path'] ) ? $url['path'] : '' );&nbsp;</div></li><li><div>                    if ( isset( $extracted['image']['url'] ) ) {&nbsp;</div></li><li><div>                        if ( in_array( $simple_url, (array) $extracted['image']['url'] ) )&nbsp;</div></li><li><div>                            continue;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    list( $proto, $link_all_but_proto ) = explode( '://', $link_raw );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Build a reversed hostname&nbsp;</div></li><li><div>                    $host_parts = array_reverse( explode( '.', $url['host'] ) );&nbsp;</div></li><li><div>                    $host_reversed = '';&nbsp;</div></li><li><div>                    foreach ( $host_parts as $part ) {&nbsp;</div></li><li><div>                        $host_reversed .= ( ! empty( $host_reversed ) ? '.' : '' ) . $part;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $link_analyzed = '';&nbsp;</div></li><li><div>                    if ( !empty( $url['path'] ) ) {&nbsp;</div></li><li><div>                        // The whole path (no query args or fragments)&nbsp;</div></li><li><div>                        $path = substr( $url['path'], 1 ); // strip the leading '/'&nbsp;</div></li><li><div>                        $link_analyzed .= ( ! empty( $link_analyzed ) ? ' ' : '' ) . $path;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // The path split by /&nbsp;</div></li><li><div>                        $path_split = explode( '/', $path );&nbsp;</div></li><li><div>                        if ( count( $path_split ) &gt; 1 ) {&nbsp;</div></li><li><div>                            $link_analyzed .= ' ' . implode( ' ', $path_split );&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // The fragment&nbsp;</div></li><li><div>                        if ( ! empty( $url['fragment'] ) )&nbsp;</div></li><li><div>                            $link_analyzed .= ( ! empty( $link_analyzed ) ? ' ' : '' ) . $url['fragment'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // @todo Check unique before adding&nbsp;</div></li><li><div>                    $links[] = array(&nbsp;</div></li><li><div>                        'url' =&gt; $link_all_but_proto, &nbsp;</div></li><li><div>                        'host_reversed' =&gt; $host_reversed, &nbsp;</div></li><li><div>                        'host' =&gt; $url['host'], &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $link_count = count( $links );&nbsp;</div></li><li><div>            if ( $link_count ) {&nbsp;</div></li><li><div>                $extracted[ 'link' ] = $links;&nbsp;</div></li><li><div>                if ( !isset( $extracted['has'] ) )&nbsp;</div></li><li><div>                    $extracted['has'] = array();&nbsp;</div></li><li><div>                $extracted['has']['link'] = $link_count;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ----------------------------------- EMBEDS ------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //Embeds are just individual links on their own line&nbsp;</div></li><li><div>        if ( self::EMBEDS & $what_to_extract ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( !function_exists( '_wp_oembed_get_object' ) )&nbsp;</div></li><li><div>                include( ABSPATH . WPINC . '/class-oembed.php' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // get an oembed object&nbsp;</div></li><li><div>            $oembed = _wp_oembed_get_object();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Grab any links on their own lines that may be embeds&nbsp;</div></li><li><div>            if ( preg_match_all( '|^\s*(https?://[^\s&quot;]+)\s*$|im', $content, $matches ) ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // To hold the extracted stuff we find&nbsp;</div></li><li><div>                $embeds = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                foreach ( $matches[1] as $link_raw ) {&nbsp;</div></li><li><div>                    $url = parse_url( $link_raw );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    list( $proto, $link_all_but_proto ) = explode( '://', $link_raw );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Check whether this &quot;link&quot; is really an embed.&nbsp;</div></li><li><div>                    foreach ( $oembed-&gt;providers as $matchmask =&gt; $data ) {&nbsp;</div></li><li><div>                        list( $providerurl, $regex ) = $data;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Turn the asterisk-type provider URLs into regex&nbsp;</div></li><li><div>                        if ( !$regex ) {&nbsp;</div></li><li><div>                            $matchmask = '#' . str_replace( '___wildcard___', '(.+)', preg_quote( str_replace( '*', '___wildcard___', $matchmask ), '#' ) ) . '#i';&nbsp;</div></li><li><div>                            $matchmask = preg_replace( '|^#http\\\://|', '#https?\://', $matchmask );&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ( preg_match( $matchmask, $link_raw ) ) {&nbsp;</div></li><li><div>                            $provider = str_replace( '{format}', 'json', $providerurl ); // JSON is easier to deal with than XML&nbsp;</div></li><li><div>                            $embeds[] = $link_all_but_proto; // @todo Check unique before adding&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // @todo Try to get ID's for the ones we care about (shortcode_keepers)&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ( ! empty( $embeds ) ) {&nbsp;</div></li><li><div>                    if ( !isset( $extracted['has'] ) )&nbsp;</div></li><li><div>                        $extracted['has'] = array();&nbsp;</div></li><li><div>                    $extracted['has']['embed'] = count( $embeds );&nbsp;</div></li><li><div>                    $extracted['embed'] = array( 'url' =&gt; array() );&nbsp;</div></li><li><div>                    foreach ( $embeds as $e )&nbsp;</div></li><li><div>                        $extracted['embed']['url'][] = $e;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $extracted;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param $post A post object&nbsp;</div></li><li><div>     * @param $args (array) Optional args, see defaults list for details&nbsp;</div></li><li><div>     * @returns array Returns an array of all images meeting the specified criteria in $args&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Uses Jetpack Post Images&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private static function get_image_fields( $post, $args = array() ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $defaults = array(&nbsp;</div></li><li><div>            'width' =&gt; 200, // Required minimum width (if possible to determine)&nbsp;</div></li><li><div>            'height' =&gt; 200, // Required minimum height (if possible to determine)&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $image_list = array();&nbsp;</div></li><li><div>        $image_booleans = array();&nbsp;</div></li><li><div>        $image_booleans['gallery'] = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $from_featured_image = Jetpack_PostImages::from_thumbnail( $post-&gt;ID, $args['width'], $args['height'] );&nbsp;</div></li><li><div>        if ( !empty( $from_featured_image ) ) {&nbsp;</div></li><li><div>            $srcs = wp_list_pluck( $from_featured_image, 'src' );&nbsp;</div></li><li><div>            $image_list = array_merge( $image_list, $srcs );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $from_slideshow = Jetpack_PostImages::from_slideshow( $post-&gt;ID, $args['width'], $args['height'] );&nbsp;</div></li><li><div>        if ( !empty( $from_slideshow ) ) {&nbsp;</div></li><li><div>            $srcs = wp_list_pluck( $from_slideshow, 'src' );&nbsp;</div></li><li><div>            $image_list = array_merge( $image_list, $srcs );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $from_gallery = Jetpack_PostImages::from_gallery( $post-&gt;ID );&nbsp;</div></li><li><div>        if ( !empty( $from_gallery ) ) {&nbsp;</div></li><li><div>            $srcs = wp_list_pluck( $from_gallery, 'src' );&nbsp;</div></li><li><div>            $image_list = array_merge( $image_list, $srcs );&nbsp;</div></li><li><div>            $image_booleans['gallery']++; // @todo This count isn't correct, will only every count 1&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // @todo Can we check width/height of these efficiently?  Could maybe use query args at least, before we strip them out&nbsp;</div></li><li><div>        $image_list = Jetpack_Media_Meta_Extractor::get_images_from_html( $post-&gt;post_content, $image_list );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return Jetpack_Media_Meta_Extractor::build_image_struct( $image_list );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function extract_images_from_content( $content, $image_list ) {&nbsp;</div></li><li><div>        $image_list = Jetpack_Media_Meta_Extractor::get_images_from_html( $content, $image_list );&nbsp;</div></li><li><div>        return Jetpack_Media_Meta_Extractor::build_image_struct( $image_list );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function build_image_struct( $image_list ) {&nbsp;</div></li><li><div>        if ( ! empty( $image_list ) ) {&nbsp;</div></li><li><div>            $retval = array( 'image' =&gt; array() );&nbsp;</div></li><li><div>            $image_list = array_unique( $image_list );&nbsp;</div></li><li><div>            foreach ( $image_list as $img ) {&nbsp;</div></li><li><div>                $retval['image'][] = array( 'url' =&gt; $img );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $image_booleans['image'] = count( $retval['image'] );&nbsp;</div></li><li><div>            if ( ! empty( $image_booleans ) )&nbsp;</div></li><li><div>                $retval['has'] = $image_booleans;&nbsp;</div></li><li><div>            return $retval;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            return array();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $html Some markup, possibly containing image tags&nbsp;</div></li><li><div>     * @param array $images_already_extracted (just an array of image URLs without query strings, no special structure), used for de-duplication&nbsp;</div></li><li><div>     * @return array Image URLs extracted from the HTML, stripped of query params and de-duped&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function get_images_from_html( $html, $images_already_extracted ) {&nbsp;</div></li><li><div>        $image_list = $images_already_extracted;&nbsp;</div></li><li><div>        $from_html = Jetpack_PostImages::from_html( $html );&nbsp;</div></li><li><div>        if ( !empty( $from_html ) ) {&nbsp;</div></li><li><div>            $srcs = wp_list_pluck( $from_html, 'src' );&nbsp;</div></li><li><div>            foreach( $srcs as $image_url ) {&nbsp;</div></li><li><div>                if ( ( $src = parse_url( $image_url ) ) && isset( $src['scheme'], $src['host'], $src['path'] ) ) {&nbsp;</div></li><li><div>                    // Rebuild the URL without the query string&nbsp;</div></li><li><div>                    $queryless = $src['scheme'] . '://' . $src['host'] . $src['path'];&nbsp;</div></li><li><div>                } elseif ( $length = strpos( $image_url, '?' ) ) {&nbsp;</div></li><li><div>                    // If parse_url() didn't work, strip off the query string the old fashioned way&nbsp;</div></li><li><div>                    $queryless = substr( $image_url, 0, $length );&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    // Failing that, there was no spoon! Err ... query string!&nbsp;</div></li><li><div>                    $queryless = $image_url;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Discard URLs that are longer then 4KB, these are likely data URIs or malformed HTML.&nbsp;</div></li><li><div>                if ( 4096 &lt; strlen( $queryless ) ) {&nbsp;</div></li><li><div>                    continue;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ( ! in_array( $queryless, $image_list ) ) {&nbsp;</div></li><li><div>                    $image_list[] = $queryless;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $image_list;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private static function get_stripped_content( $content ) {&nbsp;</div></li><li><div>        $clean_content = strip_tags( $content );&nbsp;</div></li><li><div>        $clean_content = html_entity_decode( $clean_content );&nbsp;</div></li><li><div>        //completely strip shortcodes and any content they enclose&nbsp;</div></li><li><div>        $clean_content = strip_shortcodes( $clean_content );&nbsp;</div></li><li><div>        return $clean_content;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 3.7.1</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.2/classes/jetpack_media_meta_extractor/" class="">3.8.2</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.1/classes/jetpack_media_meta_extractor/" class="">3.8.1</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/jetpack_media_meta_extractor/" class="active">3.8.0</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.2/classes/jetpack_media_meta_extractor/" class="">3.7.2</a></li><li><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.7.1/classes/jetpack_media_meta_extractor/" class="">3.7.1</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>Jetpack_Media_Meta_Extractor</li><li><span></span>Jetpack by WordPress.com</li><li><span></span>3.8.2</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>