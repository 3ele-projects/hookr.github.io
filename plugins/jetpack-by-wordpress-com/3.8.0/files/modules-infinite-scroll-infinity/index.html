<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="plugin" data-version="3.8.0" data-slug="jetpack-by-wordpress-com" data-type="file" data-id="13052"><head xmlns="http://www.w3.org/1999/xhtml"><title> modules-infinite-scroll-infinity | file | Jetpack By WordPress Com | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, plugin, jetpack-by-wordpress-com, 3.8.0" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.25"}};!function(e,n,t){var a;function i(e){var t=n.createElement("canvas"),a=t.getContext&&t.getContext("2d"),i=String.fromCharCode;return!(!a||!a.fillText)&&(a.textBaseline="top",a.font="600 32px Arial","flag"===e?(a.fillText(i(55356,56806,55356,56826),0,0),3e3<t.toDataURL().length):"diversity"===e?(a.fillText(i(55356,57221),0,0),t=a.getImageData(16,16,1,1).data,a.fillText(i(55356,57221,55356,57343),0,0),(t=a.getImageData(16,16,1,1).data)[0],t[1],t[2],t[3],!0):("simple"===e?a.fillText(i(55357,56835),0,0):a.fillText(i(55356,57135),0,0),0!==a.getImageData(16,16,1,1).data[0]))}function o(e){var t=n.createElement("script");t.src=e,t.type="text/javascript",n.getElementsByTagName("head")[0].appendChild(t)}t.supports={simple:i("simple"),flag:i("flag"),unicode8:i("unicode8"),diversity:i("diversity")},t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.simple&&t.supports.flag&&t.supports.unicode8&&t.supports.diversity||(a=function(){t.readyCallback()},n.addEventListener?(n.addEventListener("DOMContentLoaded",a,!1),e.addEventListener("load",a,!1)):(e.attachEvent("onload",a),n.attachEvent("onreadystatechange",function(){"complete"===n.readyState&&t.readyCallback()})),(a=t.source||{}).concatemoji?o(a.concatemoji):a.wpemoji&&a.twemoji&&(o(a.twemoji),o(a.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=ca2a26ce876c56182e5a06d0a5263abf' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.25' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/modules-infinite-scroll-infinity/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fmodules-infinite-scroll-infinity%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fmodules-infinite-scroll-infinity%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-jetpack-by-wordpress-com-3.8.0-file-modules-infinite-scroll-infinity","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="modules-infinite-scroll-infinity" class="single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to jetpack-by-wordpress-com." href="http://hookr.io/plugins/jetpack-by-wordpress-com/" class="plugin"><span property="name">jetpack-by-wordpress-com</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 3.8.0." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/" class="H_VERSION"><span property="name">3.8.0</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to files." href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/files/" class=""><span property="name">files</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">modules-infinite-scroll-infin&hellip;</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="1499"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/all/" title="All">All <span class="count badge">1499</span></a></li><li class="" data-id="new" data-count="17"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/new/" title="New">New <span class="count badge">17</span></a></li><li class="" data-id="hooks" data-count="599"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/hooks/" title="Hooks">Hooks <span class="count badge">599</span></a></li><li class="" data-id="action" data-count="195"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/actions/" title="Actions">Actions <span class="count badge">195</span></a></li><li class="" data-id="filter" data-count="404"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/filters/" title="Filters">Filters <span class="count badge">404</span></a></li><li class="" data-id="class" data-count="262"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/classes/" title="Classes">Classes <span class="count badge">262</span></a></li><li class="" data-id="constant" data-count="62"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/constants/" title="Constants">Constants <span class="count badge">62</span></a></li><li class="" data-id="function" data-count="530"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/functions/" title="Functions">Functions <span class="count badge">530</span></a></li><li class="" data-id="shortcode" data-count="46"><a href="http://hookr.io/plugins/jetpack-by-wordpress-com/3.8.0/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">46</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/modules/infinite-scroll/infinity.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">Plugin Name: The Neverending Home Page.</span>&nbsp;</div></li><li><div><span class="comment">Plugin URI: http://automattic.com/</span>&nbsp;</div></li><li><div><span class="comment">Description: Adds infinite scrolling support to the front-end blog post view for themes, pulling the next set of posts automatically into view when the reader approaches the bottom of the page.</span>&nbsp;</div></li><li><div><span class="comment">Version: 1.1</span>&nbsp;</div></li><li><div><span class="comment">Author: Automattic</span>&nbsp;</div></li><li><div><span class="comment">Author URI: http://automattic.com/</span>&nbsp;</div></li><li><div><span class="comment">License: GNU General Public License v2 or later</span>&nbsp;</div></li><li><div><span class="comment">License URI: http://www.gnu.org/licenses/gpl-2.0.html</span>&nbsp;</div></li><li><div><span class="comment">*/</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Class: The_Neverending_Home_Page relies on add_theme_support, expects specific</span>&nbsp;</div></li><li><div><span class="comment"> * styling from each theme; including fixed footer.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>class The_Neverending_Home_Page {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Register actions and filters, plus parse IS settings</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses add_action, add_filter, self::get_settings</span>&nbsp;</div></li><li><div><span class="comment">   * @return null</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function __construct() {&nbsp;</div></li><li><div>      add_action( 'pre_get_posts', array( $this, 'posts_per_page_query' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      add_action( 'admin_init', array( $this, 'settings_api_init' ) );&nbsp;</div></li><li><div>      add_action( 'template_redirect', array( $this, 'action_template_redirect' ) );&nbsp;</div></li><li><div>      add_action( 'template_redirect', array( $this, 'ajax_response' ) );&nbsp;</div></li><li><div>      add_action( 'custom_ajax_infinite_scroll', array( $this, 'query' ) );&nbsp;</div></li><li><div>      add_filter( 'infinite_scroll_query_args', array( $this, 'inject_query_args' ) );&nbsp;</div></li><li><div>      add_filter( 'infinite_scroll_allowed_vars', array( $this, 'allowed_query_vars' ) );&nbsp;</div></li><li><div>      add_action( 'the_post', array( $this, 'preserve_more_tag' ) );&nbsp;</div></li><li><div>      add_action( 'wp_footer', array( $this, 'footer' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Plugin compatibility</span>&nbsp;</div></li><li><div>      add_filter( 'grunion_contact_form_redirect_url', array( $this, 'filter_grunion_redirect_url' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Parse IS settings from theme</span>&nbsp;</div></li><li><div>      self::get_settings();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Initialize our static variables</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  static $the_time = null;&nbsp;</div></li><li><div>  static $settings = null; <span class="comment">// Don't access directly, instead use self::get_settings().</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  static $option_name_enabled = 'infinite_scroll';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Parse IS settings provided by theme</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses get_theme_support, infinite_scroll_has_footer_widgets, sanitize_title, add_action, get_option, wp_parse_args, is_active_sidebar</span>&nbsp;</div></li><li><div><span class="comment">   * @return object</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  static function get_settings() {&nbsp;</div></li><li><div>      if ( is_null( self::$settings ) ) {&nbsp;</div></li><li><div>          $css_pattern = '#[^A-Z\d\-_]#i';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $settings = $defaults = array(&nbsp;</div></li><li><div>              'type' =&gt; 'scroll', <span class="comment">// scroll | click</span>&nbsp;</div></li><li><div>              'requested_type' =&gt; 'scroll', <span class="comment">// store the original type for use when logic overrides it</span>&nbsp;</div></li><li><div>              'footer_widgets' =&gt; false, <span class="comment">// true | false | sidebar_id | array of sidebar_ids -- last two are checked with is_active_sidebar</span>&nbsp;</div></li><li><div>              'container' =&gt; 'content', <span class="comment">// container html id</span>&nbsp;</div></li><li><div>              'wrapper' =&gt; true, <span class="comment">// true | false | html class</span>&nbsp;</div></li><li><div>              'render' =&gt; false, <span class="comment">// optional function, otherwise the `content` template part will be used</span>&nbsp;</div></li><li><div>              'footer' =&gt; true, <span class="comment">// boolean to enable or disable the infinite footer | string to provide an html id to derive footer width from</span>&nbsp;</div></li><li><div>              'footer_callback' =&gt; false, <span class="comment">// function to be called to render the IS footer, in place of the default</span>&nbsp;</div></li><li><div>              'posts_per_page' =&gt; false, <span class="comment">// int | false to set based on IS type</span>&nbsp;</div></li><li><div>              'click_handle' =&gt; true, <span class="comment">// boolean to enable or disable rendering the click handler div. If type is click and this is false, page must include its own trigger with the HTML ID `infinite-handle`.</span>&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Validate settings passed through add_theme_support()</span>&nbsp;</div></li><li><div>          $_settings = get_theme_support( 'infinite-scroll' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( is_array( $_settings ) ) {&nbsp;</div></li><li><div>              <span class="comment">// Preferred implementation, where theme provides an array of options</span>&nbsp;</div></li><li><div>              if ( isset( $_settings[0] ) && is_array( $_settings[0] ) ) {&nbsp;</div></li><li><div>                  foreach ( $_settings[0] as $key =&gt; $value ) {&nbsp;</div></li><li><div>                      switch ( $key ) {&nbsp;</div></li><li><div>                          case 'type' :&nbsp;</div></li><li><div>                              if ( in_array( $value, array( 'scroll', 'click' ) ) )&nbsp;</div></li><li><div>                                  $settings[ $key ] = $settings['requested_type'] = $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          case 'footer_widgets' :&nbsp;</div></li><li><div>                              if ( is_string( $value ) )&nbsp;</div></li><li><div>                                  $settings[ $key ] = sanitize_title( $value );&nbsp;</div></li><li><div>                              elseif ( is_array( $value ) )&nbsp;</div></li><li><div>                                  $settings[ $key ] = array_map( 'sanitize_title', $value );&nbsp;</div></li><li><div>                              elseif ( is_bool( $value ) )&nbsp;</div></li><li><div>                                  $settings[ $key ] = $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          case 'container' :&nbsp;</div></li><li><div>                          case 'wrapper' :&nbsp;</div></li><li><div>                              if ( 'wrapper' == $key && is_bool( $value ) ) {&nbsp;</div></li><li><div>                                  $settings[ $key ] = $value;&nbsp;</div></li><li><div>                              } else {&nbsp;</div></li><li><div>                                  $value = preg_replace( $css_pattern, '', $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                  if ( ! empty( $value ) )&nbsp;</div></li><li><div>                                      $settings[ $key ] = $value;&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          case 'render' :&nbsp;</div></li><li><div>                              if ( false !== $value && is_callable( $value ) ) {&nbsp;</div></li><li><div>                                  $settings[ $key ] = $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                  add_action( 'infinite_scroll_render', $value );&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          case 'footer' :&nbsp;</div></li><li><div>                              if ( is_bool( $value ) ) {&nbsp;</div></li><li><div>                                  $settings[ $key ] = $value;&nbsp;</div></li><li><div>                              } elseif ( is_string( $value ) ) {&nbsp;</div></li><li><div>                                  $value = preg_replace( $css_pattern, '', $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                  if ( ! empty( $value ) )&nbsp;</div></li><li><div>                                      $settings[ $key ] = $value;&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          case 'footer_callback' :&nbsp;</div></li><li><div>                              if ( is_callable( $value ) )&nbsp;</div></li><li><div>                                  $settings[ $key ] = $value;&nbsp;</div></li><li><div>                              else&nbsp;</div></li><li><div>                                  $settings[ $key ] = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          case 'posts_per_page' :&nbsp;</div></li><li><div>                              if ( is_numeric( $value ) )&nbsp;</div></li><li><div>                                  $settings[ $key ] = (int) $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          case 'click_handle' :&nbsp;</div></li><li><div>                              if ( is_bool( $value ) ) {&nbsp;</div></li><li><div>                                  $settings[ $key ] = $value;&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                          default:&nbsp;</div></li><li><div>                              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              } elseif ( is_string( $_settings[0] ) ) {&nbsp;</div></li><li><div>                  <span class="comment">// Checks below are for backwards compatibility</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Container to append new posts to</span>&nbsp;</div></li><li><div>                  $settings['container'] = preg_replace( $css_pattern, '', $_settings[0] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Wrap IS elements?</span>&nbsp;</div></li><li><div>                  if ( isset( $_settings[1] ) )&nbsp;</div></li><li><div>                      $settings['wrapper'] = (bool) $_settings[1];&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Always ensure all values are present in the final array</span>&nbsp;</div></li><li><div>          $settings = wp_parse_args( $settings, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Check if a legacy `infinite_scroll_has_footer_widgets()` function is defined and override the footer_widgets parameter's value.</span>&nbsp;</div></li><li><div>          <span class="comment">// Otherwise, if a widget area ID or array of IDs was provided in the footer_widgets parameter, check if any contains any widgets.</span>&nbsp;</div></li><li><div>          <span class="comment">// It is safe to use `is_active_sidebar()` before the sidebar is registered as this function doesn't check for a sidebar's existence when determining if it contains any widgets.</span>&nbsp;</div></li><li><div>          if ( function_exists( 'infinite_scroll_has_footer_widgets' ) ) {&nbsp;</div></li><li><div>              $settings['footer_widgets'] = (bool) infinite_scroll_has_footer_widgets();&nbsp;</div></li><li><div>          } elseif ( is_array( $settings['footer_widgets'] ) ) {&nbsp;</div></li><li><div>              $sidebar_ids = $settings['footer_widgets'];&nbsp;</div></li><li><div>              $settings['footer_widgets'] = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              foreach ( $sidebar_ids as $sidebar_id ) {&nbsp;</div></li><li><div>                  if ( is_active_sidebar( $sidebar_id ) ) {&nbsp;</div></li><li><div>                      $settings['footer_widgets'] = true;&nbsp;</div></li><li><div>                      break;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              unset( $sidebar_ids );&nbsp;</div></li><li><div>              unset( $sidebar_id );&nbsp;</div></li><li><div>          } elseif ( is_string( $settings['footer_widgets'] ) ) {&nbsp;</div></li><li><div>              $settings['footer_widgets'] = (bool) is_active_sidebar( $settings['footer_widgets'] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filter Infinite Scroll's `footer_widgets` parameter.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param bool $settings['footer_widgets'] Does the current theme have Footer Widgets.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $settings['footer_widgets'] = apply_filters( 'infinite_scroll_has_footer_widgets', $settings['footer_widgets'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Finally, after all of the sidebar checks and filtering, ensure that a boolean value is present, otherwise set to default of `false`.</span>&nbsp;</div></li><li><div>          if ( ! is_bool( $settings['footer_widgets'] ) )&nbsp;</div></li><li><div>              $settings['footer_widgets'] = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Ensure that IS is enabled and no footer widgets exist if the IS type isn't already &quot;click&quot;.</span>&nbsp;</div></li><li><div>          if ( 'click' != $settings['type'] ) {&nbsp;</div></li><li><div>              <span class="comment">// Check the setting status</span>&nbsp;</div></li><li><div>              $disabled = '' === get_option( self::$option_name_enabled ) ? true : false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// Footer content or Reading option check</span>&nbsp;</div></li><li><div>              if ( $settings['footer_widgets'] || $disabled )&nbsp;</div></li><li><div>                  $settings['type'] = 'click';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// posts_per_page defaults to 7 for scroll, posts_per_page option for click</span>&nbsp;</div></li><li><div>          if ( false === $settings['posts_per_page'] ) {&nbsp;</div></li><li><div>              if ( 'scroll' === $settings['type'] ) {&nbsp;</div></li><li><div>                  $settings['posts_per_page'] = 7;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else {&nbsp;</div></li><li><div>                  $settings['posts_per_page'] = (int) get_option( 'posts_per_page' );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Force display of the click handler and attendant bits when the type isn't `click`</span>&nbsp;</div></li><li><div>          if ( 'click' !== $settings['type'] ) {&nbsp;</div></li><li><div>              $settings['click_handle'] = true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Store final settings in a class static to avoid reparsing</span>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filter the array of Infinite Scroll settings.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param array $settings Array of Infinite Scroll settings.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          self::$settings = apply_filters( 'infinite_scroll_settings', $settings );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return (object) self::$settings;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieve the query used with Infinite Scroll</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_the_query</span>&nbsp;</div></li><li><div><span class="comment">   * @uses apply_filters</span>&nbsp;</div></li><li><div><span class="comment">   * @return object</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  static function wp_query() {&nbsp;</div></li><li><div>      global $wp_the_query;&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the Infinite Scroll query object.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.2.1</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Query $wp_the_query WP Query.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'infinite_scroll_query_object', $wp_the_query );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Has infinite scroll been triggered?</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  static function got_infinity() {&nbsp;</div></li><li><div>      return isset( $_GET[ 'infinity' ] );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Is this guaranteed to be the last batch of posts?</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  static function is_last_batch() {&nbsp;</div></li><li><div>      return (bool) ( count( self::wp_query()-&gt;posts ) &lt; self::get_settings()-&gt;posts_per_page );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The more tag will be ignored by default if the blog page isn't our homepage.</span>&nbsp;</div></li><li><div><span class="comment">   * Let's force the $more global to false.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function preserve_more_tag( $array ) {&nbsp;</div></li><li><div>      global $more;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( self::got_infinity() )&nbsp;</div></li><li><div>          $more = 0; <span class="comment">//0 = show content up to the more tag. Add more link.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $array;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Add a checkbox field to Settings &gt; Reading</span>&nbsp;</div></li><li><div><span class="comment">   * for enabling infinite scroll.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Only show if the current theme supports infinity.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses current_theme_supports, add_settings_field, __, register_setting</span>&nbsp;</div></li><li><div><span class="comment">   * @action admin_init</span>&nbsp;</div></li><li><div><span class="comment">   * @return null</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function settings_api_init() {&nbsp;</div></li><li><div>      if ( ! current_theme_supports( 'infinite-scroll' ) )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Add the setting field [infinite_scroll] and place it in Settings &gt; Reading</span>&nbsp;</div></li><li><div>      add_settings_field( self::$option_name_enabled, '&lt;span id=&quot;infinite-scroll-options&quot;&gt;' . __( 'To infinity and beyond', 'jetpack' ) . '&lt;/span&gt;', array( $this, 'infinite_setting_html' ), 'reading' );&nbsp;</div></li><li><div>      register_setting( 'reading', self::$option_name_enabled, 'esc_attr' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * HTML code to display a checkbox true/false option</span>&nbsp;</div></li><li><div><span class="comment">   * for the infinite_scroll setting.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function infinite_setting_html() {&nbsp;</div></li><li><div>      $notice = '&lt;em&gt;' . __( 'We&rsquo;ve changed this option to a click-to-scroll version for you since you have footer widgets in Appearance &rarr; Widgets, or your theme uses click-to-scroll as the default behavior.', 'jetpack' ) . '&lt;/em&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If the blog has footer widgets, show a notice instead of the checkbox</span>&nbsp;</div></li><li><div>      if ( self::get_settings()-&gt;footer_widgets || 'click' == self::get_settings()-&gt;requested_type ) {&nbsp;</div></li><li><div>          echo '&lt;label&gt;' . $notice . '&lt;/label&gt;';&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          echo '&lt;label&gt;&lt;input name=&quot;infinite_scroll&quot; type=&quot;checkbox&quot; value=&quot;1&quot; ' . checked( 1, '' !== get_option( self::$option_name_enabled ), false ) . ' /&gt; ' . __( 'Scroll Infinitely', 'jetpack' ) . '&lt;/br&gt;&lt;small&gt;' . sprintf( __( '(Shows %s posts on each load)', 'jetpack' ), number_format_i18n( self::get_settings()-&gt;posts_per_page ) ) . '&lt;/small&gt;' . '&lt;/label&gt;';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Does the legwork to determine whether the feature is enabled.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses current_theme_supports, self::archive_supports_infinity, self::get_settings, add_filter, wp_enqueue_script, plugins_url, wp_enqueue_style, add_action</span>&nbsp;</div></li><li><div><span class="comment">   * @action template_redirect</span>&nbsp;</div></li><li><div><span class="comment">   * @return null</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function action_template_redirect() {&nbsp;</div></li><li><div>      <span class="comment">// Check that we support infinite scroll, and are on the home page.</span>&nbsp;</div></li><li><div>      if ( ! current_theme_supports( 'infinite-scroll' ) || ! self::archive_supports_infinity() )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $id = self::get_settings()-&gt;container;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Check that we have an id.</span>&nbsp;</div></li><li><div>      if ( empty( $id ) )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Make sure there are enough posts for IS</span>&nbsp;</div></li><li><div>      if ( 'click' == self::get_settings()-&gt;type && self::is_last_batch() )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Add a class to the body.</span>&nbsp;</div></li><li><div>      add_filter( 'body_class', array( $this, 'body_class' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Add our scripts.</span>&nbsp;</div></li><li><div>      wp_enqueue_script( 'the-neverending-homepage', plugins_url( 'infinity.js', __FILE__ ), array( 'jquery' ), 20141016, true );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Add our default styles.</span>&nbsp;</div></li><li><div>      wp_enqueue_style( 'the-neverending-homepage', plugins_url( 'infinity.css', __FILE__ ), array(), '20140422' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      add_action( 'wp_enqueue_scripts', array( $this, 'enqueue_spinner_scripts' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      add_action( 'wp_footer', array( $this, 'action_wp_footer_settings' ), 2 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      add_action( 'wp_footer', array( $this, 'action_wp_footer' ), 21 ); <span class="comment">// Core prints footer scripts at priority 20, so we just need to be one later than that</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      add_filter( 'infinite_scroll_results', array( $this, 'filter_infinite_scroll_results' ), 10, 3 );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Enqueue spinner scripts.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function enqueue_spinner_scripts() {&nbsp;</div></li><li><div>      wp_enqueue_script( 'jquery.spin' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Adds an 'infinite-scroll' class to the body.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function body_class( $classes ) {&nbsp;</div></li><li><div>      <span class="comment">// Do not add infinity-scroll class if disabled through the Reading page</span>&nbsp;</div></li><li><div>      $disabled = '' === get_option( self::$option_name_enabled ) ? true : false;&nbsp;</div></li><li><div>      if ( ! $disabled || 'click' == self::get_settings()-&gt;type ) {&nbsp;</div></li><li><div>          $classes[] = 'infinite-scroll';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( 'scroll' == self::get_settings()-&gt;type )&nbsp;</div></li><li><div>              $classes[] = 'neverending';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $classes;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * In case IS is activated on search page, we have to exclude initially loaded posts which match the keyword by title, not the content as they are displayed before content-matching ones</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::wp_query</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::get_last_post_date</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::has_only_title_matching_posts</span>&nbsp;</div></li><li><div><span class="comment">   * @return array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_excluded_posts() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $excluded_posts = array();&nbsp;</div></li><li><div>      <span class="comment">//loop through posts returned by wp_query call</span>&nbsp;</div></li><li><div>      foreach( self::wp_query()-&gt;get_posts() as $post ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $orderby = isset( self::wp_query()-&gt;query_vars['orderby'] ) ? self::wp_query()-&gt;query_vars['orderby'] : '';&nbsp;</div></li><li><div>          $post_date = ( ! empty( $post-&gt;post_date ) ? $post-&gt;post_date : false );&nbsp;</div></li><li><div>          if ( 'modified' === $orderby || false === $post_date ) {&nbsp;</div></li><li><div>              $post_date = $post-&gt;post_modified;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">//in case all posts initially displayed match the keyword by title we add em all to excluded posts array</span>&nbsp;</div></li><li><div>          <span class="comment">//else, we add only posts which are older than last_post_date param as newer are natually excluded by last_post_date condition in the SQL query</span>&nbsp;</div></li><li><div>          if ( self::has_only_title_matching_posts() || $post_date &lt;= self::get_last_post_date() ) {&nbsp;</div></li><li><div>              array_push( $excluded_posts, $post-&gt;ID );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $excluded_posts;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * In case IS is active on search, we have to exclude posts matched by title rather than by post_content in order to prevent dupes on next pages</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::wp_query</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::get_excluded_posts</span>&nbsp;</div></li><li><div><span class="comment">   * @return array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_query_vars() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $query_vars = self::wp_query()-&gt;query_vars;&nbsp;</div></li><li><div>      <span class="comment">//applies to search page only</span>&nbsp;</div></li><li><div>      if ( true === self::wp_query()-&gt;is_search() ) {&nbsp;</div></li><li><div>          <span class="comment">//set post__not_in array in query_vars in case it does not exists</span>&nbsp;</div></li><li><div>          if ( false === isset( $query_vars['post__not_in'] ) ) {&nbsp;</div></li><li><div>              $query_vars['post__not_in'] = array();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          <span class="comment">//get excluded posts</span>&nbsp;</div></li><li><div>          $excluded = self::get_excluded_posts();&nbsp;</div></li><li><div>          <span class="comment">//merge them with other post__not_in posts (eg.: sticky posts)</span>&nbsp;</div></li><li><div>          $query_vars['post__not_in'] = array_merge( $query_vars['post__not_in'], $excluded );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $query_vars;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * This function checks whether all posts returned by initial wp_query match the keyword by title</span>&nbsp;</div></li><li><div><span class="comment">   * The code used in this function is borrowed from WP_Query class where it is used to construct like conditions for keywords</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::wp_query</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function has_only_title_matching_posts() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">//apply following logic for search page results only</span>&nbsp;</div></li><li><div>      if ( false === self::wp_query()-&gt;is_search() ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">//grab the last posts in the stack as if the last one is title-matching the rest is title-matching as well</span>&nbsp;</div></li><li><div>      $post = end( self::wp_query()-&gt;posts );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">//code inspired by WP_Query class</span>&nbsp;</div></li><li><div>      if ( preg_match_all( '/&quot;.*?(&quot;|$)|((?&lt;=[\t &quot;, +])|^)[^\t &quot;, +]+/', self::wp_query()-&gt;get( 's' ), $matches ) ) {&nbsp;</div></li><li><div>          $search_terms = self::wp_query()-&gt;query_vars['search_terms'];&nbsp;</div></li><li><div>          <span class="comment">// if the search string has only short terms or stopwords, or is 10+ terms long, match it as sentence</span>&nbsp;</div></li><li><div>          if ( empty( $search_terms ) || count( $search_terms ) &gt; 9 ) {&nbsp;</div></li><li><div>              $search_terms = array( self::wp_query()-&gt;get( 's' ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $search_terms = array( self::wp_query()-&gt;get( 's' ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">//actual testing. As search query combines multiple keywords with AND, it's enough to check if any of the keywords is present in the title</span>&nbsp;</div></li><li><div>      $term = current( $search_terms );&nbsp;</div></li><li><div>      if ( ! empty( $term ) && false !== strpos( $post-&gt;post_title, $term ) ) {&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Grab the timestamp for the initial query's last post.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * This takes into account the query's 'orderby' parameter and returns</span>&nbsp;</div></li><li><div><span class="comment">   * false if the posts are not ordered by date.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::got_infinity</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::has_only_title_matching_posts</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::wp_query</span>&nbsp;</div></li><li><div><span class="comment">   * @return string 'Y-m-d H:i:s' or false</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_last_post_date() {&nbsp;</div></li><li><div>      if ( self::got_infinity() )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! self::wp_query()-&gt;have_posts() ) {&nbsp;</div></li><li><div>          return null;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">//In case there are only title-matching posts in the initial WP_Query result, we don't want to use the last_post_date param yet</span>&nbsp;</div></li><li><div>      if ( true === self::has_only_title_matching_posts() ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $post = end( self::wp_query()-&gt;posts );&nbsp;</div></li><li><div>      $orderby = isset( self::wp_query()-&gt;query_vars['orderby'] ) ?&nbsp;</div></li><li><div>          self::wp_query()-&gt;query_vars['orderby'] : '';&nbsp;</div></li><li><div>      $post_date = ( ! empty( $post-&gt;post_date ) ? $post-&gt;post_date : false );&nbsp;</div></li><li><div>      switch ( $orderby ) {&nbsp;</div></li><li><div>          case 'modified':&nbsp;</div></li><li><div>              return $post-&gt;post_modified;&nbsp;</div></li><li><div>          case 'date':&nbsp;</div></li><li><div>          case '':&nbsp;</div></li><li><div>              return $post_date;&nbsp;</div></li><li><div>          default:&nbsp;</div></li><li><div>              return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Returns the appropriate `wp_posts` table field for a given query's</span>&nbsp;</div></li><li><div><span class="comment">   * 'orderby' parameter, if applicable.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param optional object $query</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::wp_query</span>&nbsp;</div></li><li><div><span class="comment">   * @return string or false</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_query_sort_field( $query = null ) {&nbsp;</div></li><li><div>      if ( empty( $query ) )&nbsp;</div></li><li><div>          $query = self::wp_query();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $orderby = isset( $query-&gt;query_vars['orderby'] ) ? $query-&gt;query_vars['orderby'] : '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      switch ( $orderby ) {&nbsp;</div></li><li><div>          case 'modified':&nbsp;</div></li><li><div>              return 'post_modified';&nbsp;</div></li><li><div>          case 'date':&nbsp;</div></li><li><div>          case '':&nbsp;</div></li><li><div>              return 'post_date';&nbsp;</div></li><li><div>          default:&nbsp;</div></li><li><div>              return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Create a where clause that will make sure post queries</span>&nbsp;</div></li><li><div><span class="comment">   * will always return results prior to (descending sort)</span>&nbsp;</div></li><li><div><span class="comment">   * or before (ascending sort) the last post date.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wpdb</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $where</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $query</span>&nbsp;</div></li><li><div><span class="comment">   * @uses apply_filters</span>&nbsp;</div></li><li><div><span class="comment">   * @filter posts_where</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function query_time_filter( $where, $query ) {&nbsp;</div></li><li><div>      if ( self::got_infinity() ) {&nbsp;</div></li><li><div>          global $wpdb;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $sort_field = self::get_query_sort_field( $query );&nbsp;</div></li><li><div>          if ( false == $sort_field )&nbsp;</div></li><li><div>              return $where;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $last_post_date = $_REQUEST['last_post_date'];&nbsp;</div></li><li><div>          <span class="comment">// Sanitize timestamp</span>&nbsp;</div></li><li><div>          if ( empty( $last_post_date ) || !preg_match( '|\d{4}\-\d{2}\-\d{2}|', $last_post_date ) )&nbsp;</div></li><li><div>              return $where;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $operator = 'ASC' == $_REQUEST['query_args']['order'] ? '&gt;' : '&lt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Construct the date query using our timestamp</span>&nbsp;</div></li><li><div>          $clause = $wpdb-&gt;prepare( &quot; AND {$wpdb-&gt;posts}.{$sort_field} {$operator} %s&quot;, $last_post_date );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filter Infinite Scroll's SQL date query making sure post queries</span>&nbsp;</div></li><li><div><span class="comment">           * will always return results prior to (descending sort)</span>&nbsp;</div></li><li><div><span class="comment">           * or before (ascending sort) the last post date.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $clause SQL Date query.</span>&nbsp;</div></li><li><div><span class="comment">           * @param object $query Query.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $operator Query operator.</span>&nbsp;</div></li><li><div><span class="comment">           * @param string $last_post_date Last Post Date timestamp.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          $where .= apply_filters( 'infinite_scroll_posts_where', $clause, $query, $operator, $last_post_date );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $where;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Let's overwrite the default post_per_page setting to always display a fixed amount.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $query</span>&nbsp;</div></li><li><div><span class="comment">   * @uses is_admin, self::archive_supports_infinity, self::get_settings</span>&nbsp;</div></li><li><div><span class="comment">   * @return null</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function posts_per_page_query( $query ) {&nbsp;</div></li><li><div>      if ( ! is_admin() && self::archive_supports_infinity() && $query-&gt;is_main_query() )&nbsp;</div></li><li><div>          $query-&gt;set( 'posts_per_page', self::get_settings()-&gt;posts_per_page );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Check if the IS output should be wrapped in a div.</span>&nbsp;</div></li><li><div><span class="comment">   * Setting value can be a boolean or a string specifying the class applied to the div.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::get_settings</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function has_wrapper() {&nbsp;</div></li><li><div>      return (bool) self::get_settings()-&gt;wrapper;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Returns the Ajax url</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp</span>&nbsp;</div></li><li><div><span class="comment">   * @uses home_url, add_query_arg, apply_filters</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function ajax_url() {&nbsp;</div></li><li><div>      $base_url = set_url_scheme( home_url( '/' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $ajaxurl = add_query_arg( array( 'infinity' =&gt; 'scrolling' ), $base_url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the Infinite Scroll Ajax URL.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $ajaxurl Infinite Scroll Ajax URL.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return apply_filters( 'infinite_scroll_ajax_url', $ajaxurl );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Our own Ajax response, avoiding calling admin-ajax</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function ajax_response() {&nbsp;</div></li><li><div>      <span class="comment">// Only proceed if the url query has a key of &quot;Infinity&quot;</span>&nbsp;</div></li><li><div>      if ( ! self::got_infinity() )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// This should already be defined below, but make sure.</span>&nbsp;</div></li><li><div>      if ( ! defined( 'DOING_AJAX' ) ) {&nbsp;</div></li><li><div>          define( 'DOING_AJAX', true );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      @header( 'Content-Type: text/html; charset=' . get_option( 'blog_charset' ) );&nbsp;</div></li><li><div>      send_nosniff_header();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires at the end of the Infinite Scroll Ajax response.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'custom_ajax_infinite_scroll' );&nbsp;</div></li><li><div>      die( '0' );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Alias for renamed class method.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Previously, JS settings object was unnecessarily output in the document head.</span>&nbsp;</div></li><li><div><span class="comment">   * When the hook was changed, the method name no longer made sense.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function action_wp_head() {&nbsp;</div></li><li><div>      $this-&gt;action_wp_footer_settings();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Prints the relevant infinite scroll settings in JS.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_rewrite</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::get_settings, esc_js, esc_url_raw, self::has_wrapper, __, apply_filters, do_action, self::get_query_vars</span>&nbsp;</div></li><li><div><span class="comment">   * @action wp_footer</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function action_wp_footer_settings() {&nbsp;</div></li><li><div>      global $wp_rewrite;&nbsp;</div></li><li><div>      global $currentday;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Default click handle text</span>&nbsp;</div></li><li><div>      $click_handle_text = __( 'Older posts', 'jetpack' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If a single CPT is displayed, use its plural name instead of &quot;posts&quot;</span>&nbsp;</div></li><li><div>      <span class="comment">// Could be empty (posts) or an array of multiple post types.</span>&nbsp;</div></li><li><div>      <span class="comment">// In the latter two cases cases, the default text is used, leaving the `infinite_scroll_js_settings` filter for further customization.</span>&nbsp;</div></li><li><div>      $post_type = self::wp_query()-&gt;get( 'post_type' );&nbsp;</div></li><li><div>      if ( is_string( $post_type ) && ! empty( $post_type ) ) {&nbsp;</div></li><li><div>          $post_type = get_post_type_object( $post_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( is_object( $post_type ) && ! is_wp_error( $post_type ) ) {&nbsp;</div></li><li><div>              if ( isset( $post_type-&gt;labels-&gt;name ) ) {&nbsp;</div></li><li><div>                  $cpt_text = $post_type-&gt;labels-&gt;name;&nbsp;</div></li><li><div>              } elseif ( isset( $post_type-&gt;label ) ) {&nbsp;</div></li><li><div>                  $cpt_text = $post_type-&gt;label;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( isset( $cpt_text ) ) {&nbsp;</div></li><li><div>                  $click_handle_text = sprintf( __( 'Older %s', 'jetpack' ), $cpt_text );&nbsp;</div></li><li><div>                  unset( $cpt_text );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      unset( $post_type );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Base JS settings</span>&nbsp;</div></li><li><div>      $js_settings = array(&nbsp;</div></li><li><div>          'id' =&gt; self::get_settings()-&gt;container, &nbsp;</div></li><li><div>          'ajaxurl' =&gt; esc_url_raw( self::ajax_url() ), &nbsp;</div></li><li><div>          'type' =&gt; esc_js( self::get_settings()-&gt;type ), &nbsp;</div></li><li><div>          'wrapper' =&gt; self::has_wrapper(), &nbsp;</div></li><li><div>          'wrapper_class' =&gt; is_string( self::get_settings()-&gt;wrapper ) ? esc_js( self::get_settings()-&gt;wrapper ) : 'infinite-wrap', &nbsp;</div></li><li><div>          'footer' =&gt; is_string( self::get_settings()-&gt;footer ) ? esc_js( self::get_settings()-&gt;footer ) : self::get_settings()-&gt;footer, &nbsp;</div></li><li><div>          'click_handle' =&gt; esc_js( self::get_settings()-&gt;click_handle ), &nbsp;</div></li><li><div>          'text' =&gt; esc_js( $click_handle_text ), &nbsp;</div></li><li><div>          'totop' =&gt; esc_js( __( 'Scroll back to top', 'jetpack' ) ), &nbsp;</div></li><li><div>          'currentday' =&gt; $currentday, &nbsp;</div></li><li><div>          'order' =&gt; 'DESC', &nbsp;</div></li><li><div>          'scripts' =&gt; array(), &nbsp;</div></li><li><div>          'styles' =&gt; array(), &nbsp;</div></li><li><div>          'google_analytics' =&gt; false, &nbsp;</div></li><li><div>          'offset' =&gt; self::wp_query()-&gt;get( 'paged' ), &nbsp;</div></li><li><div>          'history' =&gt; array(&nbsp;</div></li><li><div>              'host' =&gt; preg_replace( '#^http(s)?:<span class="comment">//#i', '', untrailingslashit( get_option( 'home' ) ) ), </span>&nbsp;</div></li><li><div>              'path' =&gt; self::get_request_path(), &nbsp;</div></li><li><div>              'use_trailing_slashes' =&gt; $wp_rewrite-&gt;use_trailing_slashes, &nbsp;</div></li><li><div>              'parameters' =&gt; self::get_request_parameters(), &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>          'query_args' =&gt; self::get_query_vars(), &nbsp;</div></li><li><div>          'last_post_date' =&gt; self::get_last_post_date(), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Optional order param</span>&nbsp;</div></li><li><div>      if ( isset( $_REQUEST['order'] ) ) {&nbsp;</div></li><li><div>          $order = strtoupper( $_REQUEST['order'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( in_array( $order, array( 'ASC', 'DESC' ) ) )&nbsp;</div></li><li><div>              $js_settings['order'] = $order;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the Infinite Scroll JS settings outputted in the head.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $js_settings Infinite Scroll JS settings.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $js_settings = apply_filters( 'infinite_scroll_js_settings', $js_settings );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Fires before Infinite Scroll outputs inline Javascript in the head.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      do_action( 'infinite_scroll_wp_head' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      ?&gt;&nbsp;</div></li><li><div>      &lt;script type=&quot;text/javascript&quot;&gt;&nbsp;</div></li><li><div>      <span class="comment">//&lt;![CDATA[</span>&nbsp;</div></li><li><div>      var infiniteScroll = &lt;?php echo json_encode( array( 'settings' =&gt; $js_settings ) ); ?&gt;;&nbsp;</div></li><li><div>      <span class="comment">//]]&gt;</span>&nbsp;</div></li><li><div>      &lt;/script&gt;&nbsp;</div></li><li><div>      &lt;?php&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Build path data for current request.</span>&nbsp;</div></li><li><div><span class="comment">   * Used for Google Analytics and pushState history tracking.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_rewrite</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp</span>&nbsp;</div></li><li><div><span class="comment">   * @uses user_trailingslashit, sanitize_text_field, add_query_arg</span>&nbsp;</div></li><li><div><span class="comment">   * @return string|bool</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  private function get_request_path() {&nbsp;</div></li><li><div>      global $wp_rewrite;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $wp_rewrite-&gt;using_permalinks() ) {&nbsp;</div></li><li><div>          global $wp;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If called too early, bail</span>&nbsp;</div></li><li><div>          if ( ! isset( $wp-&gt;request ) )&nbsp;</div></li><li><div>              return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Determine path for paginated version of current request</span>&nbsp;</div></li><li><div>          if ( false != preg_match( '#' . $wp_rewrite-&gt;pagination_base . '/\d+/?$#i', $wp-&gt;request ) )&nbsp;</div></li><li><div>              $path = preg_replace( '#' . $wp_rewrite-&gt;pagination_base . '/\d+$#i', $wp_rewrite-&gt;pagination_base . '/%d', $wp-&gt;request );&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $path = $wp-&gt;request . '/' . $wp_rewrite-&gt;pagination_base . '/%d';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Slashes everywhere we need them</span>&nbsp;</div></li><li><div>          if ( 0 !== strpos( $path, '/' ) )&nbsp;</div></li><li><div>              $path = '/' . $path;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $path = user_trailingslashit( $path );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment">// Clean up raw $_REQUEST input</span>&nbsp;</div></li><li><div>          $path = array_map( 'sanitize_text_field', $_REQUEST );&nbsp;</div></li><li><div>          $path = array_filter( $path );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $path['paged'] = '%d';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $path = add_query_arg( $path, '/' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return empty( $path ) ? false : $path;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Return query string for current request, prefixed with '?'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  private function get_request_parameters() {&nbsp;</div></li><li><div>      $uri = $_SERVER[ 'REQUEST_URI' ];&nbsp;</div></li><li><div>      $uri = preg_replace( '/^[^?]*(\?.*$)/', '$1', $uri, 1, $count );&nbsp;</div></li><li><div>      if ( $count != 1 )&nbsp;</div></li><li><div>          return '';&nbsp;</div></li><li><div>      return $uri;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Provide IS with a list of the scripts and stylesheets already present on the page.</span>&nbsp;</div></li><li><div><span class="comment">   * Since posts may contain require additional assets that haven't been loaded, this data will be used to track the additional assets.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_scripts, $wp_styles</span>&nbsp;</div></li><li><div><span class="comment">   * @action wp_footer</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function action_wp_footer() {&nbsp;</div></li><li><div>      global $wp_scripts, $wp_styles;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $scripts = is_a( $wp_scripts, 'WP_Scripts' ) ? $wp_scripts-&gt;done : array();&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the list of scripts already present on the page.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.1.2</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $scripts Array of scripts present on the page.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $scripts = apply_filters( 'infinite_scroll_existing_scripts', $scripts );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $styles = is_a( $wp_styles, 'WP_Styles' ) ? $wp_styles-&gt;done : array();&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the list of styles already present on the page.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.1.2</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $styles Array of styles present on the page.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $styles = apply_filters( 'infinite_scroll_existing_stylesheets', $styles );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      ?&gt;&lt;script type=&quot;text/javascript&quot;&gt;&nbsp;</div></li><li><div>          jQuery.extend( infiniteScroll.settings.scripts, &lt;?php echo json_encode( $scripts ); ?&gt; );&nbsp;</div></li><li><div>          jQuery.extend( infiniteScroll.settings.styles, &lt;?php echo json_encode( $styles ); ?&gt; );&nbsp;</div></li><li><div>      &lt;/script&gt;&lt;?php&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Identify additional scripts required by the latest set of IS posts and provide the necessary data to the IS response handler.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_scripts</span>&nbsp;</div></li><li><div><span class="comment">   * @uses sanitize_text_field, add_query_arg</span>&nbsp;</div></li><li><div><span class="comment">   * @filter infinite_scroll_results</span>&nbsp;</div></li><li><div><span class="comment">   * @return array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function filter_infinite_scroll_results( $results, $query_args, $wp_query ) {&nbsp;</div></li><li><div>      <span class="comment">// Don't bother unless there are posts to display</span>&nbsp;</div></li><li><div>      if ( 'success' != $results['type'] )&nbsp;</div></li><li><div>          return $results;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Parse and sanitize the script handles already output</span>&nbsp;</div></li><li><div>      $initial_scripts = isset( $_REQUEST['scripts'] ) && is_array( $_REQUEST['scripts'] ) ? array_map( 'sanitize_text_field', $_REQUEST['scripts'] ) : false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_array( $initial_scripts ) ) {&nbsp;</div></li><li><div>          global $wp_scripts;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Identify new scripts needed by the latest set of IS posts</span>&nbsp;</div></li><li><div>          $new_scripts = array_diff( $wp_scripts-&gt;done, $initial_scripts );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If new scripts are needed, extract relevant data from $wp_scripts</span>&nbsp;</div></li><li><div>          if ( ! empty( $new_scripts ) ) {&nbsp;</div></li><li><div>              $results['scripts'] = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              foreach ( $new_scripts as $handle ) {&nbsp;</div></li><li><div>                  <span class="comment">// Abort if somehow the handle doesn't correspond to a registered script</span>&nbsp;</div></li><li><div>                  if ( ! isset( $wp_scripts-&gt;registered[ $handle ] ) )&nbsp;</div></li><li><div>                      continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Provide basic script data</span>&nbsp;</div></li><li><div>                  $script_data = array(&nbsp;</div></li><li><div>                      'handle' =&gt; $handle, &nbsp;</div></li><li><div>                      'footer' =&gt; ( is_array( $wp_scripts-&gt;in_footer ) && in_array( $handle, $wp_scripts-&gt;in_footer ) ), &nbsp;</div></li><li><div>                      'extra_data' =&gt; $wp_scripts-&gt;print_extra_script( $handle, false )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Base source</span></span>&nbsp;</div></li><li><div>                  $src = $wp_scripts-&gt;registered[ $handle ]-&gt;src;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Take base_url into account</span></span>&nbsp;</div></li><li><div>                  if ( strpos( $src, 'http' ) !== 0 )&nbsp;</div></li><li><div>                      $src = $wp_scripts-&gt;base_url . $src;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Version and additional arguments</span></span>&nbsp;</div></li><li><div>                  if ( null === $wp_scripts-&gt;registered[ $handle ]-&gt;ver )&nbsp;</div></li><li><div>                      $ver = '';&nbsp;</div></li><li><div>                  else&nbsp;</div></li><li><div>                      $ver = $wp_scripts-&gt;registered[ $handle ]-&gt;ver ? $wp_scripts-&gt;registered[ $handle ]-&gt;ver : $wp_scripts-&gt;default_version;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  if ( isset( $wp_scripts-&gt;args[ $handle ] ) )&nbsp;</div></li><li><div>                      $ver = $ver ? $ver . '&amp;' . $wp_scripts-&gt;args[$handle] : $wp_scripts-&gt;args[$handle];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Full script source with version info</span>&nbsp;</div></li><li><div>                  $script_data['src'] = add_query_arg( 'ver', $ver, $src );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Add script to data that will be returned to IS JS</span>&nbsp;</div></li><li><div>                  array_push( $results['scripts'], $script_data );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Expose additional script data to filters, but only include in final `$results` array if needed.</span>&nbsp;</div></li><li><div>      if ( ! isset( $results['scripts'] ) )&nbsp;</div></li><li><div>          $results['scripts'] = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the additional scripts required by the latest set of IS posts.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.1.2</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $results['scripts'] Additional scripts required by the latest set of IS posts.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array|bool $initial_scripts Set of scripts loaded on each page.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $results Array of Infinite Scroll results.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $query_args Array of Query arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Query $wp_query WP Query.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $results['scripts'] = apply_filters(&nbsp;</div></li><li><div>          'infinite_scroll_additional_scripts', &nbsp;</div></li><li><div>          $results['scripts'], &nbsp;</div></li><li><div>          $initial_scripts, &nbsp;</div></li><li><div>          $results, &nbsp;</div></li><li><div>          $query_args, &nbsp;</div></li><li><div>          $wp_query&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty( $results['scripts'] ) )&nbsp;</div></li><li><div>          unset( $results['scripts' ] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Parse and sanitize the style handles already output</span>&nbsp;</div></li><li><div>      $initial_styles = isset( $_REQUEST['styles'] ) && is_array( $_REQUEST['styles'] ) ? array_map( 'sanitize_text_field', $_REQUEST['styles'] ) : false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_array( $initial_styles ) ) {&nbsp;</div></li><li><div>          global $wp_styles;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Identify new styles needed by the latest set of IS posts</span>&nbsp;</div></li><li><div>          $new_styles = array_diff( $wp_styles-&gt;done, $initial_styles );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If new styles are needed, extract relevant data from $wp_styles</span>&nbsp;</div></li><li><div>          if ( ! empty( $new_styles ) ) {&nbsp;</div></li><li><div>              $results['styles'] = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              foreach ( $new_styles as $handle ) {&nbsp;</div></li><li><div>                  <span class="comment">// Abort if somehow the handle doesn't correspond to a registered stylesheet</span>&nbsp;</div></li><li><div>                  if ( ! isset( $wp_styles-&gt;registered[ $handle ] ) )&nbsp;</div></li><li><div>                      continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Provide basic style data</span>&nbsp;</div></li><li><div>                  $style_data = array(&nbsp;</div></li><li><div>                      'handle' =&gt; $handle, &nbsp;</div></li><li><div>                      'media' =&gt; 'all'&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Base source</span></span>&nbsp;</div></li><li><div>                  $src = $wp_styles-&gt;registered[ $handle ]-&gt;src;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Take base_url into account</span></span>&nbsp;</div></li><li><div>                  if ( strpos( $src, 'http' ) !== 0 )&nbsp;</div></li><li><div>                      $src = $wp_styles-&gt;base_url . $src;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Version and additional arguments</span></span>&nbsp;</div></li><li><div>                  if ( null === $wp_styles-&gt;registered[ $handle ]-&gt;ver )&nbsp;</div></li><li><div>                      $ver = '';&nbsp;</div></li><li><div>                  else&nbsp;</div></li><li><div>                      $ver = $wp_styles-&gt;registered[ $handle ]-&gt;ver ? $wp_styles-&gt;registered[ $handle ]-&gt;ver : $wp_styles-&gt;default_version;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  if ( isset($wp_styles-&gt;args[ $handle ] ) )&nbsp;</div></li><li><div>                      $ver = $ver ? $ver . '&amp;' . $wp_styles-&gt;args[$handle] : $wp_styles-&gt;args[$handle];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Full stylesheet source with version info</span>&nbsp;</div></li><li><div>                  $style_data['src'] = add_query_arg( 'ver', $ver, $src );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Parse stylesheet's conditional comments if present, converting to logic executable in JS</span>&nbsp;</div></li><li><div>                  if ( isset( $wp_styles-&gt;registered[ $handle ]-&gt;extra['conditional'] ) && $wp_styles-&gt;registered[ $handle ]-&gt;extra['conditional'] ) {&nbsp;</div></li><li><div>                      <span class="comment">// First, convert conditional comment operators to standard logical operators. %ver is replaced in JS with the IE version</span>&nbsp;</div></li><li><div>                      $style_data['conditional'] = str_replace( array(&nbsp;</div></li><li><div>                          'lte', &nbsp;</div></li><li><div>                          'lt', &nbsp;</div></li><li><div>                          'gte', &nbsp;</div></li><li><div>                          'gt'&nbsp;</div></li><li><div> ), array(&nbsp;</div></li><li><div>                          '%ver &lt;=', &nbsp;</div></li><li><div>                          '%ver &lt;', &nbsp;</div></li><li><div>                          '%ver &gt;=', &nbsp;</div></li><li><div>                          '%ver &gt;', &nbsp;</div></li><li><div> ), $wp_styles-&gt;registered[ $handle ]-&gt;extra['conditional'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                      <span class="comment">// Next, replace any !IE checks. These shouldn't be present since WP's conditional stylesheet implementation doesn't support them, but someone could be _doing_it_wrong().</span>&nbsp;</div></li><li><div>                      $style_data['conditional'] = preg_replace( '#!\s*IE(\s*\d+) {0}#i', '1==2', $style_data['conditional'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                      <span class="comment">// Lastly, remove the IE strings</span>&nbsp;</div></li><li><div>                      $style_data['conditional'] = str_replace( 'IE', '', $style_data['conditional'] );&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Parse requested media context for stylesheet</span>&nbsp;</div></li><li><div>                  if ( isset( $wp_styles-&gt;registered[ $handle ]-&gt;args ) )&nbsp;</div></li><li><div>                      $style_data['media'] = esc_attr( $wp_styles-&gt;registered[ $handle ]-&gt;args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// Add stylesheet to data that will be returned to IS JS</span>&nbsp;</div></li><li><div>                  array_push( $results['styles'], $style_data );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Expose additional stylesheet data to filters, but only include in final `$results` array if needed.</span>&nbsp;</div></li><li><div>      if ( ! isset( $results['styles'] ) )&nbsp;</div></li><li><div>          $results['styles'] = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the additional styles required by the latest set of IS posts.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.1.2</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $results['styles'] Additional styles required by the latest set of IS posts.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array|bool $initial_styles Set of styles loaded on each page.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $results Array of Infinite Scroll results.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $query_args Array of Query arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param WP_Query $wp_query WP Query.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $results['styles'] = apply_filters(&nbsp;</div></li><li><div>          'infinite_scroll_additional_stylesheets', &nbsp;</div></li><li><div>          $results['styles'], &nbsp;</div></li><li><div>          $initial_styles, &nbsp;</div></li><li><div>          $results, &nbsp;</div></li><li><div>          $query_args, &nbsp;</div></li><li><div>          $wp_query&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty( $results['styles'] ) )&nbsp;</div></li><li><div>          unset( $results['styles' ] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Lastly, return the IS results array</span>&nbsp;</div></li><li><div>      return $results;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Runs the query and returns the results via JSON.</span>&nbsp;</div></li><li><div><span class="comment">   * Triggered by an AJAX request.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_query</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_the_query</span>&nbsp;</div></li><li><div><span class="comment">   * @uses current_theme_supports, get_option, self::wp_query, current_user_can, apply_filters, self::get_settings, add_filter, WP_Query, remove_filter, have_posts, wp_head, do_action, add_action, this::render, this::has_wrapper, esc_attr, wp_footer, sharing_register_post_for_share_counts, get_the_id</span>&nbsp;</div></li><li><div><span class="comment">   * @return string or null</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function query() {&nbsp;</div></li><li><div>      if ( ! isset( $_REQUEST['page'] ) || ! current_theme_supports( 'infinite-scroll' ) )&nbsp;</div></li><li><div>          die;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $page = (int) $_REQUEST['page'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Sanitize and set $previousday. Expected format: dd.mm.yy</span>&nbsp;</div></li><li><div>      if ( preg_match( '/^\d{2}\.\d{2}\.\d{2}$/', $_REQUEST['currentday'] ) ) {&nbsp;</div></li><li><div>          global $previousday;&nbsp;</div></li><li><div>          $previousday = $_REQUEST['currentday'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $sticky = get_option( 'sticky_posts' );&nbsp;</div></li><li><div>      $post__not_in = self::wp_query()-&gt;get( 'post__not_in' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">//we have to take post__not_in args into consideration here not only sticky posts</span>&nbsp;</div></li><li><div>      if ( true === isset( $_REQUEST['query_args']['post__not_in'] ) ) {&nbsp;</div></li><li><div>          $post__not_in = array_merge( $post__not_in, array_map( 'intval', (array) $_REQUEST['query_args']['post__not_in'] ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! empty( $post__not_in ) )&nbsp;</div></li><li><div>          $sticky = array_unique( array_merge( $sticky, $post__not_in ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $post_status = array( 'publish' );&nbsp;</div></li><li><div>      if ( current_user_can( 'read_private_posts' ) )&nbsp;</div></li><li><div>          array_push( $post_status, 'private' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $order = in_array( $_REQUEST['order'], array( 'ASC', 'DESC' ) ) ? $_REQUEST['order'] : 'DESC';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $query_args = array_merge( self::wp_query()-&gt;query_vars, array(&nbsp;</div></li><li><div>          'paged' =&gt; $page, &nbsp;</div></li><li><div>          'post_status' =&gt; $post_status, &nbsp;</div></li><li><div>          'posts_per_page' =&gt; self::get_settings()-&gt;posts_per_page, &nbsp;</div></li><li><div>          'post__not_in' =&gt; (array) $sticky, &nbsp;</div></li><li><div>          'order' =&gt; $order&nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// 4.0 ?s= compatibility, see https://core.trac.wordpress.org/ticket/11330#comment:50</span>&nbsp;</div></li><li><div>      if ( empty( $query_args['s'] ) && ! isset( self::wp_query()-&gt;query['s'] ) ) {&nbsp;</div></li><li><div>          unset( $query_args['s'] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// By default, don't query for a specific page of a paged post object.</span>&nbsp;</div></li><li><div>      <span class="comment">// This argument can come from merging self::wp_query() into $query_args above.</span>&nbsp;</div></li><li><div>      <span class="comment">// Since IS is only used on archives, we should always display the first page of any paged content.</span>&nbsp;</div></li><li><div>      unset( $query_args['page'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the array of main query arguments.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.0.1</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $query_args Array of Query arguments.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $query_args = apply_filters( 'infinite_scroll_query_args', $query_args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Add query filter that checks for posts below the date</span>&nbsp;</div></li><li><div>      add_filter( 'posts_where', array( $this, 'query_time_filter' ), 10, 2 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $GLOBALS['wp_the_query'] = $GLOBALS['wp_query'] = new WP_Query( $query_args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      remove_filter( 'posts_where', array( $this, 'query_time_filter' ), 10, 2 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $results = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( have_posts() ) {&nbsp;</div></li><li><div>          <span class="comment">// Fire wp_head to ensure that all necessary scripts are enqueued. Output isn't used, but scripts are extracted in self::action_wp_footer.</span>&nbsp;</div></li><li><div>          ob_start();&nbsp;</div></li><li><div>          wp_head();&nbsp;</div></li><li><div>          while ( ob_get_length() ) {&nbsp;</div></li><li><div>              ob_end_clean();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $results['type'] = 'success';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// First, try theme's specified rendering handler, either specified via `add_theme_support` or by hooking to this action directly.</span>&nbsp;</div></li><li><div>          ob_start();&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Fires when rendering Infinite Scroll posts.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          do_action( 'infinite_scroll_render' );&nbsp;</div></li><li><div>          $results['html'] = ob_get_clean();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Fall back if a theme doesn't specify a rendering function. Because themes may hook additional functions to the `infinite_scroll_render` action, `has_action()` is ineffective here.</span>&nbsp;</div></li><li><div>          if ( empty( $results['html'] ) ) {&nbsp;</div></li><li><div>              add_action( 'infinite_scroll_render', array( $this, 'render' ) );&nbsp;</div></li><li><div>              rewind_posts();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              ob_start();&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">/** This action is already documented in modules/infinite-scroll/infinity.php */</span></span>&nbsp;</div></li><li><div>              do_action( 'infinite_scroll_render' );&nbsp;</div></li><li><div>              $results['html'] = ob_get_clean();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If primary and fallback rendering methods fail, prevent further IS rendering attempts. Otherwise, wrap the output if requested.</span>&nbsp;</div></li><li><div>          if ( empty( $results['html'] ) ) {&nbsp;</div></li><li><div>              unset( $results['html'] );&nbsp;</div></li><li><div>              <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">               * Fires when Infinite Scoll doesn't render any posts.</span>&nbsp;</div></li><li><div><span class="comment">               *</span>&nbsp;</div></li><li><div><span class="comment">               * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">               *</span>&nbsp;</div></li><li><div><span class="comment">               * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">               */</span>&nbsp;</div></li><li><div>              do_action( 'infinite_scroll_empty' );&nbsp;</div></li><li><div>              $results['type'] = 'empty';&nbsp;</div></li><li><div>          } elseif ( $this-&gt;has_wrapper() ) {&nbsp;</div></li><li><div>              $wrapper_classes = is_string( self::get_settings()-&gt;wrapper ) ? self::get_settings()-&gt;wrapper : 'infinite-wrap';&nbsp;</div></li><li><div>              $wrapper_classes .= ' infinite-view-' . $page;&nbsp;</div></li><li><div>              $wrapper_classes = trim( $wrapper_classes );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $results['html'] = '&lt;div class=&quot;' . esc_attr( $wrapper_classes ) . '&quot; id=&quot;infinite-view-' . $page . '&quot; data-page-num=&quot;' . $page . '&quot;&gt;' . $results['html'] . '&lt;/div&gt;';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Fire wp_footer to ensure that all necessary scripts are enqueued. Output isn't used, but scripts are extracted in self::action_wp_footer.</span>&nbsp;</div></li><li><div>          ob_start();&nbsp;</div></li><li><div>          wp_footer();&nbsp;</div></li><li><div>          while ( ob_get_length() ) {&nbsp;</div></li><li><div>              ob_end_clean();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( 'success' == $results['type'] ) {&nbsp;</div></li><li><div>              global $currentday;&nbsp;</div></li><li><div>              $results['lastbatch'] = self::is_last_batch();&nbsp;</div></li><li><div>              $results['currentday'] = $currentday;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// Loop through posts to capture sharing data for new posts loaded via Infinite Scroll</span>&nbsp;</div></li><li><div>          if ( 'success' == $results['type'] && function_exists( 'sharing_register_post_for_share_counts' ) ) {&nbsp;</div></li><li><div>              global $jetpack_sharing_counts;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              while( have_posts() ) {&nbsp;</div></li><li><div>                  the_post();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  sharing_register_post_for_share_counts( get_the_ID() );&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              $results['postflair'] = array_flip( $jetpack_sharing_counts );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">/** This action is already documented in modules/infinite-scroll/infinity.php */</span></span>&nbsp;</div></li><li><div>          do_action( 'infinite_scroll_empty' );&nbsp;</div></li><li><div>          $results['type'] = 'empty';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      echo wp_json_encode(&nbsp;</div></li><li><div>          <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">           * Filter the Infinite Scroll results.</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">           *</span>&nbsp;</div></li><li><div><span class="comment">           * @param array $results Array of Infinite Scroll results.</span>&nbsp;</div></li><li><div><span class="comment">           * @param array $query_args Array of main query arguments.</span>&nbsp;</div></li><li><div><span class="comment">           * @param WP_Query $wp_query WP Query.</span>&nbsp;</div></li><li><div><span class="comment">           */</span>&nbsp;</div></li><li><div>          apply_filters( 'infinite_scroll_results', $results, $query_args, self::wp_query() )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      die;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Update the $allowed_vars array with the standard WP public and private</span>&nbsp;</div></li><li><div><span class="comment">   * query vars, as well as taxonomy vars</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $allowed_vars</span>&nbsp;</div></li><li><div><span class="comment">   * @filter infinite_scroll_allowed_vars</span>&nbsp;</div></li><li><div><span class="comment">   * @return array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function allowed_query_vars( $allowed_vars ) {&nbsp;</div></li><li><div>      global $wp;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $allowed_vars += $wp-&gt;public_query_vars;&nbsp;</div></li><li><div>      $allowed_vars += $wp-&gt;private_query_vars;&nbsp;</div></li><li><div>      $allowed_vars += $this-&gt;get_taxonomy_vars();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( array_keys( $allowed_vars, 'paged' ) as $key ) {&nbsp;</div></li><li><div>          unset( $allowed_vars[ $key ] );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array_unique( $allowed_vars );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Returns an array of stock and custom taxonomy query vars</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @global $wp_taxonomies</span>&nbsp;</div></li><li><div><span class="comment">   * @return array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_taxonomy_vars() {&nbsp;</div></li><li><div>      global $wp_taxonomies;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $taxonomy_vars = array();&nbsp;</div></li><li><div>      foreach ( $wp_taxonomies as $taxonomy =&gt; $t ) {&nbsp;</div></li><li><div>          if ( $t-&gt;query_var )&nbsp;</div></li><li><div>              $taxonomy_vars[] = $t-&gt;query_var;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// still needed?</span>&nbsp;</div></li><li><div>      $taxonomy_vars[] = 'tag_id';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $taxonomy_vars;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Update the $query_args array with the parameters provided via AJAX/GET.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $query_args</span>&nbsp;</div></li><li><div><span class="comment">   * @filter infinite_scroll_query_args</span>&nbsp;</div></li><li><div><span class="comment">   * @return array</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function inject_query_args( $query_args ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter the array of allowed Infinite Scroll query arguments.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.6.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $args Array of allowed Infinite Scroll query arguments.</span>&nbsp;</div></li><li><div><span class="comment">       * @param array $query_args Array of query arguments.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $allowed_vars = apply_filters( 'infinite_scroll_allowed_vars', array(), $query_args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $query_args = array_merge( $query_args, array(&nbsp;</div></li><li><div>          'suppress_filters' =&gt; false, &nbsp;</div></li><li><div> ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_array( $_REQUEST[ 'query_args' ] ) ) {&nbsp;</div></li><li><div>          foreach ( $_REQUEST[ 'query_args' ] as $var =&gt; $value ) {&nbsp;</div></li><li><div>              if ( in_array( $var, $allowed_vars ) && ! empty( $value ) )&nbsp;</div></li><li><div>                  $query_args[ $var ] = $value;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $query_args;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Rendering fallback used when themes don't specify their own handler.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses have_posts, the_post, get_template_part, get_post_format</span>&nbsp;</div></li><li><div><span class="comment">   * @action infinite_scroll_render</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function render() {&nbsp;</div></li><li><div>      while ( have_posts() ) {&nbsp;</div></li><li><div>          the_post();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          get_template_part( 'content', get_post_format() );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Allow plugins to filter what archives Infinite Scroll supports</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses current_theme_supports, is_home, is_archive, apply_filters, self::get_settings</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public static function archive_supports_infinity() {&nbsp;</div></li><li><div>      $supported = current_theme_supports( 'infinite-scroll' ) && ( is_home() || is_archive() || is_search() );&nbsp;</div></li><li><div>      <span class="comment">// Disable infinite scroll in customizer previews</span>&nbsp;</div></li><li><div>      if ( isset( $_REQUEST[ 'wp_customize' ] ) && 'on' === $_REQUEST[ 'wp_customize' ] ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Allow plugins to filter what archives Infinite Scroll supports.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param bool $supported Does the Archive page support Infinite Scroll.</span>&nbsp;</div></li><li><div><span class="comment">       * @param object self::get_settings() IS settings provided by theme.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      return (bool) apply_filters( 'infinite_scroll_archive_supported', $supported, self::get_settings() );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * The Infinite Blog Footer</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses self::get_settings, self::archive_supports_infinity, self::default_footer</span>&nbsp;</div></li><li><div><span class="comment">   * @return string or null</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function footer() {&nbsp;</div></li><li><div>      <span class="comment">// Bail if theme requested footer not show</span>&nbsp;</div></li><li><div>      if ( false == self::get_settings()-&gt;footer )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// We only need the new footer for the 'scroll' type</span>&nbsp;</div></li><li><div>      if ( 'scroll' != self::get_settings()-&gt;type || ! self::archive_supports_infinity() )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Display a footer, either user-specified or a default</span>&nbsp;</div></li><li><div>      if ( false !== self::get_settings()-&gt;footer_callback && is_callable( self::get_settings()-&gt;footer_callback ) )&nbsp;</div></li><li><div>          call_user_func( self::get_settings()-&gt;footer_callback, self::get_settings() );&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          self::default_footer();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Render default IS footer</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses __, wp_get_theme, get_current_theme, apply_filters, home_url, esc_attr, get_bloginfo, bloginfo</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  private function default_footer() {&nbsp;</div></li><li><div>      $credits = sprintf(&nbsp;</div></li><li><div>          '&lt;a href=&quot;http:<span class="comment">//wordpress.org/&quot; rel=&quot;generator&quot;&gt;%1$s&lt;/a&gt; ', </span>&nbsp;</div></li><li><div>          __( 'Proudly powered by WordPress', 'jetpack' )&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      $credits .= sprintf(&nbsp;</div></li><li><div>          __( 'Theme: %1$s.', 'jetpack' ), &nbsp;</div></li><li><div>          function_exists( 'wp_get_theme' ) ? wp_get_theme()-&gt;Name : get_current_theme()&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * Filter Infinite Scroll's credit text.</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">       *</span>&nbsp;</div></li><li><div><span class="comment">       * @param string $credits Infinite Scroll credits.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      $credits = apply_filters( 'infinite_scroll_credit', $credits );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      ?&gt;&nbsp;</div></li><li><div>      &lt;div id=&quot;infinite-footer&quot;&gt;&nbsp;</div></li><li><div>          &lt;div class=&quot;container&quot;&gt;&nbsp;</div></li><li><div>              &lt;div class=&quot;blog-info&quot;&gt;&nbsp;</div></li><li><div>                  &lt;a id=&quot;infinity-blog-title&quot; href=&quot;&lt;?php echo home_url( '/' ); ?&gt;&quot; rel=&quot;home&quot;&gt;&nbsp;</div></li><li><div>                      &lt;?php bloginfo( 'name' ); ?&gt;&nbsp;</div></li><li><div>                  &lt;/a&gt;&nbsp;</div></li><li><div>              &lt;/div&gt;&nbsp;</div></li><li><div>              &lt;div class=&quot;blog-credits&quot;&gt;&nbsp;</div></li><li><div>                  &lt;?php echo $credits; ?&gt;&nbsp;</div></li><li><div>              &lt;/div&gt;&nbsp;</div></li><li><div>          &lt;/div&gt;&nbsp;</div></li><li><div>      &lt;/div&gt;&lt;!-- #infinite-footer --&gt;&nbsp;</div></li><li><div>      &lt;?php&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Ensure that IS doesn't interfere with Grunion by stripping IS query arguments from the Grunion redirect URL.</span>&nbsp;</div></li><li><div><span class="comment">   * When arguments are present, Grunion redirects to the IS AJAX endpoint.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $url</span>&nbsp;</div></li><li><div><span class="comment">   * @uses remove_query_arg</span>&nbsp;</div></li><li><div><span class="comment">   * @filter grunion_contact_form_redirect_url</span>&nbsp;</div></li><li><div><span class="comment">   * @return string</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  public function filter_grunion_redirect_url( $url ) {&nbsp;</div></li><li><div>      <span class="comment">// Remove IS query args, if present</span>&nbsp;</div></li><li><div>      if ( false !== strpos( $url, 'infinity=scrolling' ) ) {&nbsp;</div></li><li><div>          $url = remove_query_arg( array(&nbsp;</div></li><li><div>              'infinity', &nbsp;</div></li><li><div>              'action', &nbsp;</div></li><li><div>              'page', &nbsp;</div></li><li><div>              'order', &nbsp;</div></li><li><div>              'scripts', &nbsp;</div></li><li><div>              'styles'&nbsp;</div></li><li><div> ), $url );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $url;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>};&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Initialize The_Neverending_Home_Page</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function the_neverending_home_page_init() {&nbsp;</div></li><li><div>  if ( ! current_theme_supports( 'infinite-scroll' ) )&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  new The_Neverending_Home_Page;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>add_action( 'init', 'the_neverending_home_page_init', 20 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Check whether the current theme is infinite-scroll aware.</span>&nbsp;</div></li><li><div><span class="comment"> * If so, include the files which add theme support.</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>function the_neverending_home_page_theme_support() {&nbsp;</div></li><li><div>  $theme_name = get_stylesheet();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Filter the path to the Infinite Scroll compatibility file.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @module infinite-scroll</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.0.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $str IS compatibility file path.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $theme_name Theme name.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  $customization_file = apply_filters( 'infinite_scroll_customization_file', dirname( __FILE__ ) . &quot;/themes/{$theme_name}.php&quot;, $theme_name );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  if ( is_readable( $customization_file ) )&nbsp;</div></li><li><div>      require_once( $customization_file );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>add_action( 'after_setup_theme', 'the_neverending_home_page_theme_support', 5 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Early accommodation of the Infinite Scroll AJAX request</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>if ( The_Neverending_Home_Page::got_infinity() ) {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * If we're sure this is an AJAX request (i.e. the HTTP_X_REQUESTED_WITH header says so), </span>&nbsp;</div></li><li><div><span class="comment">   * indicate it as early as possible for actions like init</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  if ( ! defined( 'DOING_AJAX' ) &&&nbsp;</div></li><li><div>      isset( $_SERVER['HTTP_X_REQUESTED_WITH'] ) &&&nbsp;</div></li><li><div>      strtoupper( $_SERVER['HTTP_X_REQUESTED_WITH'] ) == 'XMLHTTPREQUEST'&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>      define( 'DOING_AJAX', true );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Don't load the admin bar when doing the AJAX response.</span>&nbsp;</div></li><li><div>  show_admin_bar( false );&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Include the wp_json_encode functions for pre-wordpress-4.1</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>if ( ! function_exists( 'wp_json_encode' ) ) :&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Encode a variable into JSON, with some sanity checks.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param mixed $data    Variable (usually an array or object) to encode as JSON.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $options Optional. Options to be passed to json_encode(). Default 0.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $depth   Optional. Maximum depth to walk through $data. Must be</span>&nbsp;</div></li><li><div><span class="comment">   *                       greater than 0. Default 512.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool|string The JSON encoded string, or false if it cannot be encoded.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function wp_json_encode( $data, $options = 0, $depth = 512 ) {&nbsp;</div></li><li><div>      <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">       * json_encode() has had extra params added over the years.</span>&nbsp;</div></li><li><div><span class="comment">       * $options was added in 5.3, and $depth in 5.5.</span>&nbsp;</div></li><li><div><span class="comment">       * We need to make sure we call it with the correct arguments.</span>&nbsp;</div></li><li><div><span class="comment">       */</span>&nbsp;</div></li><li><div>      if ( version_compare( PHP_VERSION, '5.5', '&gt;=' ) ) {&nbsp;</div></li><li><div>          $args = array( $data, $options, $depth );&nbsp;</div></li><li><div>      } elseif ( version_compare( PHP_VERSION, '5.3', '&gt;=' ) ) {&nbsp;</div></li><li><div>          $args = array( $data, $options );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $args = array( $data );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $json = call_user_func_array( 'json_encode', $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If json_encode() was successful, no need to do more sanity checking.</span>&nbsp;</div></li><li><div>      <span class="comment">// ... unless we're in an old version of PHP, and json_encode() returned</span>&nbsp;</div></li><li><div>      <span class="comment">// a string containing 'null'. Then we need to do more sanity checking.</span>&nbsp;</div></li><li><div>      if ( false !== $json && ( version_compare( PHP_VERSION, '5.5', '&gt;=' ) || false === strpos( $json, 'null' ) ) )  {&nbsp;</div></li><li><div>          return $json;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      try {&nbsp;</div></li><li><div>          $args[0] = _wp_json_sanity_check( $data, $depth );&nbsp;</div></li><li><div>      } catch ( Exception $e ) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return call_user_func_array( 'json_encode', $args );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>endif;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>if ( ! function_exists( '_wp_json_sanity_check' ) ) :&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Perform sanity checks on data that shall be encoded to JSON.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see wp_json_encode()</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @internal</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param mixed $data  Variable (usually an array or object) to encode as JSON.</span>&nbsp;</div></li><li><div><span class="comment">   * @param int   $depth Maximum depth to walk through $data. Must be greater than 0.</span>&nbsp;</div></li><li><div><span class="comment">   * @return mixed The sanitized data that shall be encoded to JSON.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function _wp_json_sanity_check( $data, $depth ) {&nbsp;</div></li><li><div>      if ( $depth &lt; 0 ) {&nbsp;</div></li><li><div>          throw new Exception( 'Reached depth limit' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_array( $data ) ) {&nbsp;</div></li><li><div>          $output = array();&nbsp;</div></li><li><div>          foreach ( $data as $id =&gt; $el ) {&nbsp;</div></li><li><div>              <span class="comment">// Don't forget to sanitize the ID!</span>&nbsp;</div></li><li><div>              if ( is_string( $id ) ) {&nbsp;</div></li><li><div>                  $clean_id = _wp_json_convert_string( $id );&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $clean_id = $id;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// Check the element type, so that we're only recursing if we really have to.</span>&nbsp;</div></li><li><div>              if ( is_array( $el ) || is_object( $el ) ) {&nbsp;</div></li><li><div>                  $output[ $clean_id ] = _wp_json_sanity_check( $el, $depth - 1 );&nbsp;</div></li><li><div>              } elseif ( is_string( $el ) ) {&nbsp;</div></li><li><div>                  $output[ $clean_id ] = _wp_json_convert_string( $el );&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $output[ $clean_id ] = $el;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } elseif ( is_object( $data ) ) {&nbsp;</div></li><li><div>          $output = new stdClass;&nbsp;</div></li><li><div>          foreach ( $data as $id =&gt; $el ) {&nbsp;</div></li><li><div>              if ( is_string( $id ) ) {&nbsp;</div></li><li><div>                  $clean_id = _wp_json_convert_string( $id );&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $clean_id = $id;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( is_array( $el ) || is_object( $el ) ) {&nbsp;</div></li><li><div>                  $output-&gt;$clean_id = _wp_json_sanity_check( $el, $depth - 1 );&nbsp;</div></li><li><div>              } elseif ( is_string( $el ) ) {&nbsp;</div></li><li><div>                  $output-&gt;$clean_id = _wp_json_convert_string( $el );&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $output-&gt;$clean_id = $el;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } elseif ( is_string( $data ) ) {&nbsp;</div></li><li><div>          return _wp_json_convert_string( $data );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return $data;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $output;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>endif;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>if ( ! function_exists( '_wp_json_convert_string' ) ) :&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Convert a string to UTF-8, so that it can be safely encoded to JSON.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see _wp_json_sanity_check()</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 4.1.0</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @internal</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $string The string which is to be converted.</span>&nbsp;</div></li><li><div><span class="comment">   * @return string The checked string.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function _wp_json_convert_string( $string ) {&nbsp;</div></li><li><div>      static $use_mb = null;&nbsp;</div></li><li><div>      if ( is_null( $use_mb ) ) {&nbsp;</div></li><li><div>          $use_mb = function_exists( 'mb_convert_encoding' );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $use_mb ) {&nbsp;</div></li><li><div>          $encoding = mb_detect_encoding( $string, mb_detect_order(), true );&nbsp;</div></li><li><div>          if ( $encoding ) {&nbsp;</div></li><li><div>              return mb_convert_encoding( $string, 'UTF-8', $encoding );&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              return mb_convert_encoding( $string, 'UTF-8', 'UTF-8' );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          return wp_check_invalid_utf8( $string, true );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>endif;&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>file</li><li><span></span></li><li><span></span>Jetpack by WordPress.com</li><li><span></span>3.8.2</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2021 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>