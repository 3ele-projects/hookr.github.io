<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="plugin" data-version="4.3.1" data-slug="rtmedia-for-wordpress-buddypress-and-bbpress" data-type="file" data-id="17921"><head xmlns="http://www.w3.org/1999/xhtml"><title> lib-simple-html-dom-simple-html-dom | file | Rtmedia For WordPress Buddypress And Bbpress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, plugin, rtmedia-for-wordpress-buddypress-and-bbpress, 4.3.1" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=a381c3ce4458eeaed94cca7e8c1fe199' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/lib-simple-html-dom-simple-html-dom/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Flib-simple-html-dom-simple-html-dom%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Flib-simple-html-dom-simple-html-dom%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-rtmedia-for-wordpress-buddypress-and-bbpress-4.3.1-file-lib-simple-html-dom-simple-html-dom","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="lib-simple-html-dom-simple-html-dom" class="single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to rtmedia-for-wordpress-buddypr&hellip;." href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/" class="plugin"><span property="name">rtmedia-for-wordpress-buddypr&hellip;</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.3.1." href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/" class="H_VERSION"><span property="name">4.3.1</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to files." href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/files/" class=""><span property="name">files</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">lib-simple-html-dom-simple-ht&hellip;</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="1084"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/all/" title="All">All <span class="count badge">1084</span></a></li><li class="" data-id="new" data-count="11"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/new/" title="New">New <span class="count badge">11</span></a></li><li class="" data-id="hooks" data-count="448"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/hooks/" title="Hooks">Hooks <span class="count badge">448</span></a></li><li class="" data-id="action" data-count="163"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/actions/" title="Actions">Actions <span class="count badge">163</span></a></li><li class="" data-id="filter" data-count="285"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/filters/" title="Filters">Filters <span class="count badge">285</span></a></li><li class="" data-id="class" data-count="157"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/classes/" title="Classes">Classes <span class="count badge">157</span></a></li><li class="" data-id="constant" data-count="258"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/constants/" title="Constants">Constants <span class="count badge">258</span></a></li><li class="" data-id="function" data-count="219"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/functions/" title="Functions">Functions <span class="count badge">219</span></a></li><li class="" data-id="shortcode" data-count="2"><a href="http://hookr.io/plugins/rtmedia-for-wordpress-buddypress-and-bbpress/4.3.1/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">2</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/lib/simple-html-dom/simple_html_dom.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Website: http://sourceforge.net/projects/simplehtmldom/</span>&nbsp;</div></li><li><div><span class="comment"> * Additional projects that may be used: http://sourceforge.net/projects/debugobject/</span>&nbsp;</div></li><li><div><span class="comment"> * Acknowledge: Jose Solorzano (https://sourceforge.net/projects/php-html/)</span>&nbsp;</div></li><li><div><span class="comment"> * Contributions by:</span>&nbsp;</div></li><li><div><span class="comment"> *     Yousuke Kumakura (Attribute filters)</span>&nbsp;</div></li><li><div><span class="comment"> *     Vadim Voituk (Negative indexes supports of &quot;find&quot; method)</span>&nbsp;</div></li><li><div><span class="comment"> *     Antcs (Constructor with automatically load contents either text or file/url)</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * all affected sections have comments starting with &quot;PaperG&quot;</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg - Added case insensitive testing of the value of the selector.</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg - Added tag_start for the starting index of tags - NOTE: This works but not accurately.</span>&nbsp;</div></li><li><div><span class="comment"> *  This tag_start gets counted AFTER \r\n have been crushed out, and after the remove_noice calls so it will not reflect the REAL position of the tag in the source, </span>&nbsp;</div></li><li><div><span class="comment"> *  it will almost always be smaller by some amount.</span>&nbsp;</div></li><li><div><span class="comment"> *  We use this to determine how far into the file the tag in question is.  This &quot;percentage will never be accurate as the $dom-&gt;size is the &quot;real&quot; number of bytes the dom was created from.</span>&nbsp;</div></li><li><div><span class="comment"> *  but for most purposes, it's a really good estimation.</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg - Added the forceTagsClosed to the dom constructor.  Forcing tags closed is great for malformed html, but it CAN lead to parsing errors.</span>&nbsp;</div></li><li><div><span class="comment"> * Allow the user to tell us how much they trust the html.</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg add the text and plaintext to the selectors for the find syntax.  plaintext implies text in the innertext of a node.  text implies that the tag is a text node.</span>&nbsp;</div></li><li><div><span class="comment"> * This allows for us to find tags based on the text they contain.</span>&nbsp;</div></li><li><div><span class="comment"> * Create find_ancestor_tag to see if a tag is - at any level - inside of another specific tag.</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg: added parse_charset so that we know about the character set of the source document.</span>&nbsp;</div></li><li><div><span class="comment"> *  NOTE:  If the user's system has a routine called get_last_retrieve_url_contents_content_type availalbe, we will assume it's returning the content-type header from the</span>&nbsp;</div></li><li><div><span class="comment"> *  last transfer or curl_exec, and we will parse that and use it in preference to any other method of charset detection.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Found infinite loop in the case of broken html in restore_noise.  Rewrote to protect from that.</span>&nbsp;</div></li><li><div><span class="comment"> * PaperG (John Schlick) Added get_display_size for &quot;IMG&quot; tags.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * Licensed under The MIT License</span>&nbsp;</div></li><li><div><span class="comment"> * Redistributions of files must retain the above copyright notice.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @author S.C. Chen &lt;me578022@gmail.com&gt;</span>&nbsp;</div></li><li><div><span class="comment"> * @author John Schlick</span>&nbsp;</div></li><li><div><span class="comment"> * @author Rus Carroll</span>&nbsp;</div></li><li><div><span class="comment"> * @version 1.5 ($Rev: 208 $)</span>&nbsp;</div></li><li><div><span class="comment"> * @package PlaceLocalInclude</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage simple_html_dom</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * All of the Defines for the classes below.</span>&nbsp;</div></li><li><div><span class="comment"> * @author S.C. Chen &lt;me578022@gmail.com&gt;</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>define('HDOM_TYPE_ELEMENT', 1);&nbsp;</div></li><li><div>define('HDOM_TYPE_COMMENT', 2);&nbsp;</div></li><li><div>define('HDOM_TYPE_TEXT', 3);&nbsp;</div></li><li><div>define('HDOM_TYPE_ENDTAG', 4);&nbsp;</div></li><li><div>define('HDOM_TYPE_ROOT', 5);&nbsp;</div></li><li><div>define('HDOM_TYPE_UNKNOWN', 6);&nbsp;</div></li><li><div>define('HDOM_QUOTE_DOUBLE', 0);&nbsp;</div></li><li><div>define('HDOM_QUOTE_SINGLE', 1);&nbsp;</div></li><li><div>define('HDOM_QUOTE_NO', 3);&nbsp;</div></li><li><div>define('HDOM_INFO_BEGIN', 0);&nbsp;</div></li><li><div>define('HDOM_INFO_END', 1);&nbsp;</div></li><li><div>define('HDOM_INFO_QUOTE', 2);&nbsp;</div></li><li><div>define('HDOM_INFO_SPACE', 3);&nbsp;</div></li><li><div>define('HDOM_INFO_TEXT', 4);&nbsp;</div></li><li><div>define('HDOM_INFO_INNER', 5);&nbsp;</div></li><li><div>define('HDOM_INFO_OUTER', 6);&nbsp;</div></li><li><div>define('HDOM_INFO_ENDSPACE', 7);&nbsp;</div></li><li><div>define('DEFAULT_TARGET_CHARSET', 'UTF-8');&nbsp;</div></li><li><div>define('DEFAULT_BR_TEXT', &quot;\r\n&quot;);&nbsp;</div></li><li><div>define('DEFAULT_SPAN_TEXT', &quot; &quot;);&nbsp;</div></li><li><div>define('MAX_FILE_SIZE', 600000);&nbsp;</div></li><li><div><span class="comment">// helper functions</span>&nbsp;</div></li><li><div><span class="comment">// -----------------------------------------------------------------------------</span>&nbsp;</div></li><li><div><span class="comment">// get html dom from file</span>&nbsp;</div></li><li><div><span class="comment">// $maxlen is defined in the code as PHP_STREAM_COPY_ALL which is defined as -1.</span>&nbsp;</div></li><li><div>function file_get_html($url, $use_include_path = false, $context=null, $offset = -1, $maxLen=-1, $lowercase = true, $forceTagsClosed=true, $target_charset = DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  <span class="comment">// We DO force the tags to be terminated.</span>&nbsp;</div></li><li><div>  $dom = new simple_html_dom(null, $lowercase, $forceTagsClosed, $target_charset, $stripRN, $defaultBRText, $defaultSpanText);&nbsp;</div></li><li><div>  <span class="comment">// For sourceforge users: uncomment the next line and comment the retreive_url_contents line 2 lines down if it is not already done.</span>&nbsp;</div></li><li><div>  $contents = file_get_contents($url, $use_include_path, $context, $offset);&nbsp;</div></li><li><div>  <span class="comment">// Paperg - use our own mechanism for getting the contents as we want to control the timeout.</span>&nbsp;</div></li><li><div>  <span class="comment">//$contents = retrieve_url_contents($url);</span>&nbsp;</div></li><li><div>  if (empty($contents) || strlen($contents) &gt; MAX_FILE_SIZE)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  <span class="comment">// The second parameter can force the selectors to all be lowercase.</span>&nbsp;</div></li><li><div>  $dom-&gt;load($contents, $lowercase, $stripRN);&nbsp;</div></li><li><div>  return $dom;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">// get html dom from string</span>&nbsp;</div></li><li><div>function str_get_html($str, $lowercase=true, $forceTagsClosed=true, $target_charset = DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $dom = new simple_html_dom(null, $lowercase, $forceTagsClosed, $target_charset, $stripRN, $defaultBRText, $defaultSpanText);&nbsp;</div></li><li><div>  if (empty($str) || strlen($str) &gt; MAX_FILE_SIZE)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $dom-&gt;clear();&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  $dom-&gt;load($str, $lowercase, $stripRN);&nbsp;</div></li><li><div>  return $dom;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">// dump html dom tree</span>&nbsp;</div></li><li><div>function dump_html_tree($node, $show_attr=true, $deep=0)&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  $node-&gt;dump($node);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * simple html dom node</span>&nbsp;</div></li><li><div><span class="comment"> * PaperG - added ability for &quot;find&quot; routine to lowercase the value of the selector.</span>&nbsp;</div></li><li><div><span class="comment"> * PaperG - added $tag_start to track the start position of the tag in the total byte index</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package PlaceLocalInclude</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>class simple_html_dom_node&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  public $nodetype = HDOM_TYPE_TEXT;&nbsp;</div></li><li><div>  public $tag = 'text';&nbsp;</div></li><li><div>  public $attr = array();&nbsp;</div></li><li><div>  public $children = array();&nbsp;</div></li><li><div>  public $nodes = array();&nbsp;</div></li><li><div>  public $parent = null;&nbsp;</div></li><li><div>  <span class="comment">// The &quot;info&quot; array - see HDOM_INFO_... for what each element contains.</span>&nbsp;</div></li><li><div>  public $_ = array();&nbsp;</div></li><li><div>  public $tag_start = 0;&nbsp;</div></li><li><div>  private $dom = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __construct($dom)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;dom = $dom;&nbsp;</div></li><li><div>      $dom-&gt;nodes[] = $this;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __destruct()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;clear();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __toString()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      return $this-&gt;outertext();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// clean up memory due to php5 circular references memory leak...</span></span>&nbsp;</div></li><li><div>  function clear()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;dom = null;&nbsp;</div></li><li><div>      $this-&gt;nodes = null;&nbsp;</div></li><li><div>      $this-&gt;parent = null;&nbsp;</div></li><li><div>      $this-&gt;children = null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// dump node's tree</span>&nbsp;</div></li><li><div>  function dump($show_attr=true, $deep=0)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $lead = str_repeat('    ', $deep);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      echo $lead.$this-&gt;tag;&nbsp;</div></li><li><div>      if ($show_attr && count($this-&gt;attr)&gt;0)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          echo '(';&nbsp;</div></li><li><div>          foreach ($this-&gt;attr as $k=&gt;$v)&nbsp;</div></li><li><div>              echo &quot;[$k]=&gt;\&quot;&quot;.$this-&gt;$k.'&quot;, ';&nbsp;</div></li><li><div>          echo ')';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      echo &quot;\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($this-&gt;nodes)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          foreach ($this-&gt;nodes as $c)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $c-&gt;dump($show_attr, $deep+1);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Debugging function to dump a single dom node with a bunch of information about it.</span>&nbsp;</div></li><li><div>  function dump_node($echo=true)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $string = $this-&gt;tag;&nbsp;</div></li><li><div>      if (count($this-&gt;attr)&gt;0)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $string .= '(';&nbsp;</div></li><li><div>          foreach ($this-&gt;attr as $k=&gt;$v)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $string .= &quot;[$k]=&gt;\&quot;&quot;.$this-&gt;$k.'&quot;, ';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $string .= ')';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (count($this-&gt;_)&gt;0)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $string .= ' $_ (';&nbsp;</div></li><li><div>          foreach ($this-&gt;_ as $k=&gt;$v)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              if (is_array($v))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $string .= &quot;[$k]=&gt;(&quot;;&nbsp;</div></li><li><div>                  foreach ($v as $k2=&gt;$v2)&nbsp;</div></li><li><div>                  {&nbsp;</div></li><li><div>                      $string .= &quot;[$k2]=&gt;\&quot;&quot;.$v2.'&quot;, ';&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  $string .= &quot;)&quot;;&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $string .= &quot;[$k]=&gt;\&quot;&quot;.$v.'&quot;, ';&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $string .= &quot;)&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (isset($this-&gt;text))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $string .= &quot; text: (&quot; . $this-&gt;text . &quot;)&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $string .= &quot; HDOM_INNER_INFO: '&quot;;&nbsp;</div></li><li><div>      if (isset($node-&gt;_[HDOM_INFO_INNER]))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $string .= $node-&gt;_[HDOM_INFO_INNER] . &quot;'&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $string .= ' NULL ';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $string .= &quot; children: &quot; . count($this-&gt;children);&nbsp;</div></li><li><div>      $string .= &quot; nodes: &quot; . count($this-&gt;nodes);&nbsp;</div></li><li><div>      $string .= &quot; tag_start: &quot; . $this-&gt;tag_start;&nbsp;</div></li><li><div>      $string .= &quot;\n&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($echo)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          echo $string;&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return $string;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// returns the parent of node</span>&nbsp;</div></li><li><div>  <span class="comment">// If a node is passed in, it will reset the parent of the current node to that one.</span>&nbsp;</div></li><li><div>  function parent($parent=null)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      <span class="comment">// I am SURE that this doesn't work properly.</span>&nbsp;</div></li><li><div>      <span class="comment">// It fails to unset the current node from it's current parents nodes or children list first.</span>&nbsp;</div></li><li><div>      if ($parent !== null)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $this-&gt;parent = $parent;&nbsp;</div></li><li><div>          $this-&gt;parent-&gt;nodes[] = $this;&nbsp;</div></li><li><div>          $this-&gt;parent-&gt;children[] = $this;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;parent;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// verify that node has children</span>&nbsp;</div></li><li><div>  function has_child()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      return !empty($this-&gt;children);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// returns children of node</span>&nbsp;</div></li><li><div>  function children($idx=-1)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if ($idx===-1)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return $this-&gt;children;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (isset($this-&gt;children[$idx]))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return $this-&gt;children[$idx];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// returns the first child of node</span>&nbsp;</div></li><li><div>  function first_child()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if (count($this-&gt;children)&gt;0)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return $this-&gt;children[0];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// returns the last child of node</span>&nbsp;</div></li><li><div>  function last_child()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if (($count=count($this-&gt;children))&gt;0)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return $this-&gt;children[$count-1];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// returns the next sibling of node</span>&nbsp;</div></li><li><div>  function next_sibling()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if ($this-&gt;parent===null)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return null;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $idx = 0;&nbsp;</div></li><li><div>      $count = count($this-&gt;parent-&gt;children);&nbsp;</div></li><li><div>      while ($idx&lt;$count && $this!==$this-&gt;parent-&gt;children[$idx])&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          ++$idx;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (++$idx&gt;=$count)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return null;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $this-&gt;parent-&gt;children[$idx];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// returns the previous sibling of node</span>&nbsp;</div></li><li><div>  function prev_sibling()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if ($this-&gt;parent===null) return null;&nbsp;</div></li><li><div>      $idx = 0;&nbsp;</div></li><li><div>      $count = count($this-&gt;parent-&gt;children);&nbsp;</div></li><li><div>      while ($idx&lt;$count && $this!==$this-&gt;parent-&gt;children[$idx])&nbsp;</div></li><li><div>          ++$idx;&nbsp;</div></li><li><div>      if (--$idx&lt;0) return null;&nbsp;</div></li><li><div>      return $this-&gt;parent-&gt;children[$idx];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// function to locate a specific ancestor tag in the path to the root.</span>&nbsp;</div></li><li><div>  function find_ancestor_tag($tag)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) { $debug_object-&gt;debug_log_entry(1); }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Start by including ourselves in the comparison.</span>&nbsp;</div></li><li><div>      $returnDom = $this;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      while (!is_null($returnDom))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          if (is_object($debug_object)) { $debug_object-&gt;debug_log(2, &quot;Current tag is: &quot; . $returnDom-&gt;tag); }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($returnDom-&gt;tag == $tag)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $returnDom = $returnDom-&gt;parent;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $returnDom;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// get dom node's inner html</span>&nbsp;</div></li><li><div>  function innertext()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_INNER])) return $this-&gt;_[HDOM_INFO_INNER];&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $ret = '';&nbsp;</div></li><li><div>      foreach ($this-&gt;nodes as $n)&nbsp;</div></li><li><div>          $ret .= $n-&gt;outertext();&nbsp;</div></li><li><div>      return $ret;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// get dom node's outer text (with tag)</span>&nbsp;</div></li><li><div>  function outertext()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $text = '';&nbsp;</div></li><li><div>          if ($this-&gt;tag == 'text')&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              if (!empty($this-&gt;text))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $text = &quot; with text: &quot; . $this-&gt;text;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $debug_object-&gt;debug_log(1, 'Innertext of tag: ' . $this-&gt;tag . $text);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($this-&gt;tag==='root') return $this-&gt;innertext();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// trigger callback</span>&nbsp;</div></li><li><div>      if ($this-&gt;dom && $this-&gt;dom-&gt;callback!==null)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          call_user_func_array($this-&gt;dom-&gt;callback, array($this));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_OUTER])) return $this-&gt;_[HDOM_INFO_OUTER];&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// render begin tag</span>&nbsp;</div></li><li><div>      if ($this-&gt;dom && $this-&gt;dom-&gt;nodes[$this-&gt;_[HDOM_INFO_BEGIN]])&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $ret = $this-&gt;dom-&gt;nodes[$this-&gt;_[HDOM_INFO_BEGIN]]-&gt;makeup();&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $ret = &quot;&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// render inner text</span>&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_INNER]))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          <span class="comment">// If it's a br tag...  don't return the HDOM_INNER_INFO that we may or may not have added.</span>&nbsp;</div></li><li><div>          if ($this-&gt;tag != &quot;br&quot;)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $ret .= $this-&gt;_[HDOM_INFO_INNER];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          if ($this-&gt;nodes)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              foreach ($this-&gt;nodes as $n)&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $ret .= $this-&gt;convert_text($n-&gt;outertext());&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// render end tag</span>&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_END]) && $this-&gt;_[HDOM_INFO_END]!=0)&nbsp;</div></li><li><div>          $ret .= '&lt;/'.$this-&gt;tag.'&gt;';&nbsp;</div></li><li><div>      return $ret;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// get dom node's plain text</span>&nbsp;</div></li><li><div>  function text()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_INNER])) return $this-&gt;_[HDOM_INFO_INNER];&nbsp;</div></li><li><div>      switch ($this-&gt;nodetype)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          case HDOM_TYPE_TEXT: return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);&nbsp;</div></li><li><div>          case HDOM_TYPE_COMMENT: return '';&nbsp;</div></li><li><div>          case HDOM_TYPE_UNKNOWN: return '';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (strcasecmp($this-&gt;tag, 'script')===0) return '';&nbsp;</div></li><li><div>      if (strcasecmp($this-&gt;tag, 'style')===0) return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $ret = '';&nbsp;</div></li><li><div>      <span class="comment">// In rare cases, (always node type 1 or HDOM_TYPE_ELEMENT - observed for some span tags, and some p tags) $this-&gt;nodes is set to NULL.</span>&nbsp;</div></li><li><div>      <span class="comment">// NOTE: This indicates that there is a problem where it's set to NULL without a clear happening.</span>&nbsp;</div></li><li><div>      <span class="comment">// WHY is this happening?</span>&nbsp;</div></li><li><div>      if (!is_null($this-&gt;nodes))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          foreach ($this-&gt;nodes as $n)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $ret .= $this-&gt;convert_text($n-&gt;text());&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// If this node is a span... add a space at the end of it so multiple spans don't run into each other.  This is plaintext after all.</span>&nbsp;</div></li><li><div>          if ($this-&gt;tag == &quot;span&quot;)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $ret .= $this-&gt;dom-&gt;default_span_text;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $ret;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function xmltext()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $ret = $this-&gt;innertext();&nbsp;</div></li><li><div>      $ret = str_ireplace('&lt;![CDATA[', '', $ret);&nbsp;</div></li><li><div>      $ret = str_replace(']]&gt;', '', $ret);&nbsp;</div></li><li><div>      return $ret;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// build node's text with tag</span>&nbsp;</div></li><li><div>  function makeup()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment">// text</span></span>, comment, unknown</span>&nbsp;</div></li><li><div>      if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $ret = '&lt;'.$this-&gt;tag;&nbsp;</div></li><li><div>      $i = -1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ($this-&gt;attr as $key=&gt;$val)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          ++$i;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// skip removed attribute</span>&nbsp;</div></li><li><div>          if ($val===null || $val===false)&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $ret .= $this-&gt;_[HDOM_INFO_SPACE][$i][0];&nbsp;</div></li><li><div>          <span class="comment"><span class="comment"><span class="comment">//no value attr: nowrap, checked selected...</span></span></span>&nbsp;</div></li><li><div>          if ($val===true)&nbsp;</div></li><li><div>              $ret .= $key;&nbsp;</div></li><li><div>          else {&nbsp;</div></li><li><div>              switch ($this-&gt;_[HDOM_INFO_QUOTE][$i])&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  case HDOM_QUOTE_DOUBLE: $quote = '&quot;'; break;&nbsp;</div></li><li><div>                  case HDOM_QUOTE_SINGLE: $quote = '\''; break;&nbsp;</div></li><li><div>                  default: $quote = '';&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $ret .= $key.$this-&gt;_[HDOM_INFO_SPACE][$i][1].'='.$this-&gt;_[HDOM_INFO_SPACE][$i][2].$quote.$val.$quote;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $ret = $this-&gt;dom-&gt;restore_noise($ret);&nbsp;</div></li><li><div>      return $ret . $this-&gt;_[HDOM_INFO_ENDSPACE] . '&gt;';&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// find elements by css selector</span>&nbsp;</div></li><li><div>  <span class="comment">//PaperG - added ability for find to lowercase the value of the selector.</span>&nbsp;</div></li><li><div>  function find($selector, $idx=null, $lowercase=false)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $selectors = $this-&gt;parse_selector($selector);&nbsp;</div></li><li><div>      if (($count=count($selectors))===0) return array();&nbsp;</div></li><li><div>      $found_keys = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// find each selector</span>&nbsp;</div></li><li><div>      for ($c=0; $c&lt;$count; ++$c)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          <span class="comment">// The change on the below line was documented on the sourceforge code tracker id 2788009</span>&nbsp;</div></li><li><div>          <span class="comment">// used to be: if (($levle=count($selectors[0]))===0) return array();</span>&nbsp;</div></li><li><div>          if (($levle=count($selectors[$c]))===0) return array();&nbsp;</div></li><li><div>          if (!isset($this-&gt;_[HDOM_INFO_BEGIN])) return array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $head = array($this-&gt;_[HDOM_INFO_BEGIN]=&gt;1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// handle descendant selectors, no recursive!</span>&nbsp;</div></li><li><div>          for ($l=0; $l&lt;$levle; ++$l)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $ret = array();&nbsp;</div></li><li><div>              foreach ($head as $k=&gt;$v)&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $n = ($k===-1) ? $this-&gt;dom-&gt;root : $this-&gt;dom-&gt;nodes[$k];&nbsp;</div></li><li><div>                  <span class="comment">//PaperG - Pass this optional parameter on to the seek function.</span>&nbsp;</div></li><li><div>                  $n-&gt;seek($selectors[$c][$l], $ret, $lowercase);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $head = $ret;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          foreach ($head as $k=&gt;$v)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              if (!isset($found_keys[$k]))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $found_keys[$k] = 1;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// sort keys</span>&nbsp;</div></li><li><div>      ksort($found_keys);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $found = array();&nbsp;</div></li><li><div>      foreach ($found_keys as $k=&gt;$v)&nbsp;</div></li><li><div>          $found[] = $this-&gt;dom-&gt;nodes[$k];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// return nth-element or array</span>&nbsp;</div></li><li><div>      if (is_null($idx)) return $found;&nbsp;</div></li><li><div>      else if ($idx&lt;0) $idx = count($found) + $idx;&nbsp;</div></li><li><div>      return (isset($found[$idx])) ? $found[$idx] : null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// seek for given conditions</span>&nbsp;</div></li><li><div>  <span class="comment">// PaperG - added parameter to allow for case insensitive testing of the value of a selector.</span>&nbsp;</div></li><li><div>  protected function seek($selector, &$ret, $lowercase=false)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) { $debug_object-&gt;debug_log_entry(1); }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      list($tag, $key, $val, $exp, $no_key) = $selector;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// xpath index</span>&nbsp;</div></li><li><div>      if ($tag && $key && is_numeric($key))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $count = 0;&nbsp;</div></li><li><div>          foreach ($this-&gt;children as $c)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              if ($tag==='*' || $tag===$c-&gt;tag) {&nbsp;</div></li><li><div>                  if (++$count==$key) {&nbsp;</div></li><li><div>                      $ret[$c-&gt;_[HDOM_INFO_BEGIN]] = 1;&nbsp;</div></li><li><div>                      return;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $end = (!empty($this-&gt;_[HDOM_INFO_END])) ? $this-&gt;_[HDOM_INFO_END] : 0;&nbsp;</div></li><li><div>      if ($end==0) {&nbsp;</div></li><li><div>          $parent = $this-&gt;parent;&nbsp;</div></li><li><div>          while (!isset($parent-&gt;_[HDOM_INFO_END]) && $parent!==null) {&nbsp;</div></li><li><div>              $end -= 1;&nbsp;</div></li><li><div>              $parent = $parent-&gt;parent;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $end += $parent-&gt;_[HDOM_INFO_END];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      for ($i=$this-&gt;_[HDOM_INFO_BEGIN]+1; $i&lt;$end; ++$i) {&nbsp;</div></li><li><div>          $node = $this-&gt;dom-&gt;nodes[$i];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $pass = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($tag==='*' && !$key) {&nbsp;</div></li><li><div>              if (in_array($node, $this-&gt;children, true))&nbsp;</div></li><li><div>                  $ret[$i] = 1;&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// compare tag</span>&nbsp;</div></li><li><div>          if ($tag && $tag!=$node-&gt;tag && $tag!=='*') {$pass=false;}&nbsp;</div></li><li><div>          <span class="comment">// compare key</span>&nbsp;</div></li><li><div>          if ($pass && $key) {&nbsp;</div></li><li><div>              if ($no_key) {&nbsp;</div></li><li><div>                  if (isset($node-&gt;attr[$key])) $pass=false;&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  if (($key != &quot;plaintext&quot;) && !isset($node-&gt;attr[$key])) $pass=false;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          <span class="comment">// compare value</span>&nbsp;</div></li><li><div>          if ($pass && $key && $val  && $val!=='*') {&nbsp;</div></li><li><div>              <span class="comment">// If they have told us that this is a &quot;plaintext&quot; search then we want the plaintext of the node - right?</span>&nbsp;</div></li><li><div>              if ($key == &quot;plaintext&quot;) {&nbsp;</div></li><li><div>                  <span class="comment">// $node-&gt;plaintext actually returns $node-&gt;text();</span>&nbsp;</div></li><li><div>                  $nodeKeyValue = $node-&gt;text();&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  <span class="comment">// this is a normal search, we want the value of that attribute of the tag.</span>&nbsp;</div></li><li><div>                  $nodeKeyValue = $node-&gt;attr[$key];&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, &quot;testing node: &quot; . $node-&gt;tag . &quot; for attribute: &quot; . $key . $exp . $val . &quot; where nodes value is: &quot; . $nodeKeyValue);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">//PaperG - If lowercase is set, do a case insensitive test of the value of the selector.</span>&nbsp;</div></li><li><div>              if ($lowercase) {&nbsp;</div></li><li><div>                  $check = $this-&gt;match($exp, strtolower($val), strtolower($nodeKeyValue));&nbsp;</div></li><li><div>              } else {&nbsp;</div></li><li><div>                  $check = $this-&gt;match($exp, $val, $nodeKeyValue);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, &quot;after match: &quot; . ($check ? &quot;true&quot; : &quot;false&quot;));}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              <span class="comment">// handle multiple class</span>&nbsp;</div></li><li><div>              if (!$check && strcasecmp($key, 'class')===0) {&nbsp;</div></li><li><div>                  foreach (explode(' ', $node-&gt;attr[$key]) as $k) {&nbsp;</div></li><li><div>                      <span class="comment">// Without this, there were cases where leading, trailing, or double spaces lead to our comparing blanks - bad form.</span>&nbsp;</div></li><li><div>                      if (!empty($k)) {&nbsp;</div></li><li><div>                          if ($lowercase) {&nbsp;</div></li><li><div>                              $check = $this-&gt;match($exp, strtolower($val), strtolower($k));&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              $check = $this-&gt;match($exp, $val, $k);&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          if ($check) break;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (!$check) $pass = false;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ($pass) $ret[$i] = 1;&nbsp;</div></li><li><div>          unset($node);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      <span class="comment">// It's passed by reference so this is actually what this function returns.</span>&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log(1, &quot;EXIT - ret: &quot;, $ret);}&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  protected function match($exp, $pattern, $value) {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log_entry(1);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      switch ($exp) {&nbsp;</div></li><li><div>          case '=':&nbsp;</div></li><li><div>              return ($value===$pattern);&nbsp;</div></li><li><div>          case '!=':&nbsp;</div></li><li><div>              return ($value!==$pattern);&nbsp;</div></li><li><div>          case '^=':&nbsp;</div></li><li><div>              return preg_match(&quot;/^&quot;.preg_quote($pattern, '/').&quot;/&quot;, $value);&nbsp;</div></li><li><div>          case '$=':&nbsp;</div></li><li><div>              return preg_match(&quot;/&quot;.preg_quote($pattern, '/').&quot;$/&quot;, $value);&nbsp;</div></li><li><div>          case '*=':&nbsp;</div></li><li><div>              if ($pattern[0]=='/') {&nbsp;</div></li><li><div>                  return preg_match($pattern, $value);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              return preg_match(&quot;/&quot;.$pattern.&quot;/i&quot;, $value);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  protected function parse_selector($selector_string) {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log_entry(1);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// pattern of CSS selectors, modified from mootools</span>&nbsp;</div></li><li><div>      <span class="comment">// Paperg: Add the colon to the attrbute, so that it properly finds &lt;tag attr:ibute=&quot;something&quot; &gt; like google does.</span>&nbsp;</div></li><li><div>      <span class="comment">// Note: if you try to look at this attribute, yo MUST use getAttribute since $dom-&gt;x:y will fail the php syntax check.</span>&nbsp;</div></li><li><div><span class="comment">// Notice the \[ starting the attbute?  and the @? following?  This implies that an attribute can begin with an @ sign that is not captured.</span>&nbsp;</div></li><li><div><span class="comment">// This implies that an html attribute specifier may start with an @ sign that is NOT captured by the expression.</span>&nbsp;</div></li><li><div><span class="comment">// farther study is required to determine of this should be documented or removed.</span>&nbsp;</div></li><li><div><span class="comment">//        $pattern = &quot;/([\w-:\*]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-]+)(?:([!*^$]?=)[\&quot;']?(.*?)[\&quot;']?)?\])?([\/, ]+)/is&quot;;</span>&nbsp;</div></li><li><div>      $pattern = &quot;/([\w-:\*]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)[\&quot;']?(.*?)[\&quot;']?)?\])?([\/, ]+)/is&quot;;&nbsp;</div></li><li><div>      preg_match_all($pattern, trim($selector_string).' ', $matches, PREG_SET_ORDER);&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, &quot;Matches Array: &quot;, $matches);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $selectors = array();&nbsp;</div></li><li><div>      $result = array();&nbsp;</div></li><li><div>      <span class="comment">//print_r($matches);</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ($matches as $m) {&nbsp;</div></li><li><div>          $m[0] = trim($m[0]);&nbsp;</div></li><li><div>          if ($m[0]==='' || $m[0]==='/' || $m[0]==='<span class="comment">//') continue;</span>&nbsp;</div></li><li><div>          <span class="comment">// for browser generated xpath</span>&nbsp;</div></li><li><div>          if ($m[1]==='tbody') continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          list($tag, $key, $val, $exp, $no_key) = array($m[1], null, null, '=', false);&nbsp;</div></li><li><div>          if (!empty($m[2])) {$key='id'; $val=$m[2];}&nbsp;</div></li><li><div>          if (!empty($m[3])) {$key='class'; $val=$m[3];}&nbsp;</div></li><li><div>          if (!empty($m[4])) {$key=$m[4];}&nbsp;</div></li><li><div>          if (!empty($m[5])) {$exp=$m[5];}&nbsp;</div></li><li><div>          if (!empty($m[6])) {$val=$m[6];}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// convert to lowercase</span>&nbsp;</div></li><li><div>          if ($this-&gt;dom-&gt;lowercase) {$tag=strtolower($tag); $key=strtolower($key);}&nbsp;</div></li><li><div>          <span class="comment">//elements that do NOT have the specified attribute</span>&nbsp;</div></li><li><div>          if (isset($key[0]) && $key[0]==='!') {$key=substr($key, 1); $no_key=true;}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $result[] = array($tag, $key, $val, $exp, $no_key);&nbsp;</div></li><li><div>          if (trim($m[7])===', ') {&nbsp;</div></li><li><div>              $selectors[] = $result;&nbsp;</div></li><li><div>              $result = array();&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (count($result)&gt;0)&nbsp;</div></li><li><div>          $selectors[] = $result;&nbsp;</div></li><li><div>      return $selectors;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __get($name)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if (isset($this-&gt;attr[$name]))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return $this-&gt;convert_text($this-&gt;attr[$name]);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      switch ($name)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          case 'outertext': return $this-&gt;outertext();&nbsp;</div></li><li><div>          case 'innertext': return $this-&gt;innertext();&nbsp;</div></li><li><div>          case 'plaintext': return $this-&gt;text();&nbsp;</div></li><li><div>          case 'xmltext': return $this-&gt;xmltext();&nbsp;</div></li><li><div>          default: return array_key_exists($name, $this-&gt;attr);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __set($name, $value)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log_entry(1);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      switch ($name)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          case 'outertext': return $this-&gt;_[HDOM_INFO_OUTER] = $value;&nbsp;</div></li><li><div>          case 'innertext':&nbsp;</div></li><li><div>              if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;_[HDOM_INFO_TEXT] = $value;&nbsp;</div></li><li><div>              return $this-&gt;_[HDOM_INFO_INNER] = $value;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (!isset($this-&gt;attr[$name]))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $this-&gt;_[HDOM_INFO_SPACE][] = array(' ', '', '');&nbsp;</div></li><li><div>          $this-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_DOUBLE;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $this-&gt;attr[$name] = $value;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __isset($name)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      switch ($name)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          case 'outertext': return true;&nbsp;</div></li><li><div>          case 'innertext': return true;&nbsp;</div></li><li><div>          case 'plaintext': return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      <span class="comment"><span class="comment"><span class="comment">//no value attr: nowrap, checked selected...</span></span></span>&nbsp;</div></li><li><div>      return (array_key_exists($name, $this-&gt;attr)) ? true : isset($this-&gt;attr[$name]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __unset($name) {&nbsp;</div></li><li><div>      if (isset($this-&gt;attr[$name]))&nbsp;</div></li><li><div>          unset($this-&gt;attr[$name]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// PaperG - Function to convert the text from one character set to another if the two sets are not the same.</span>&nbsp;</div></li><li><div>  function convert_text($text)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log_entry(1);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $converted_text = $text;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $sourceCharset = &quot;&quot;;&nbsp;</div></li><li><div>      $targetCharset = &quot;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($this-&gt;dom)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $sourceCharset = strtoupper($this-&gt;dom-&gt;_charset);&nbsp;</div></li><li><div>          $targetCharset = strtoupper($this-&gt;dom-&gt;_target_charset);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log(3, &quot;source charset: &quot; . $sourceCharset . &quot; target charaset: &quot; . $targetCharset);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (!empty($sourceCharset) && !empty($targetCharset) && (strcasecmp($sourceCharset, $targetCharset) != 0))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          <span class="comment">// Check if the reported encoding could have been incorrect and the text is actually already UTF-8</span>&nbsp;</div></li><li><div>          if ((strcasecmp($targetCharset, 'UTF-8') == 0) && ($this-&gt;is_utf8($text)))&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $converted_text = $text;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $converted_text = iconv($sourceCharset, $targetCharset, $text);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Lets make sure that we don't have that silly BOM issue with any of the utf-8 text we output.</span>&nbsp;</div></li><li><div>      if ($targetCharset == 'UTF-8')&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          if (substr($converted_text, 0, 3) == &quot;\xef\xbb\xbf&quot;)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $converted_text = substr($converted_text, 3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (substr($converted_text, -3) == &quot;\xef\xbb\xbf&quot;)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $converted_text = substr($converted_text, 0, -3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $converted_text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">  * Returns true if $string is valid UTF-8 and false otherwise.</span>&nbsp;</div></li><li><div><span class="comment">  *</span>&nbsp;</div></li><li><div><span class="comment">  * @param mixed $str String to be tested</span>&nbsp;</div></li><li><div><span class="comment">  * @return boolean</span>&nbsp;</div></li><li><div><span class="comment">  */</span>&nbsp;</div></li><li><div>  static function is_utf8($str)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $c=0; $b=0;&nbsp;</div></li><li><div>      $bits=0;&nbsp;</div></li><li><div>      $len=strlen($str);&nbsp;</div></li><li><div>      for($i=0; $i&lt;$len; $i++)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $c=ord($str[$i]);&nbsp;</div></li><li><div>          if($c &gt; 128)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              if(($c &gt;= 254)) return false;&nbsp;</div></li><li><div>              elseif($c &gt;= 252) $bits=6;&nbsp;</div></li><li><div>              elseif($c &gt;= 248) $bits=5;&nbsp;</div></li><li><div>              elseif($c &gt;= 240) $bits=4;&nbsp;</div></li><li><div>              elseif($c &gt;= 224) $bits=3;&nbsp;</div></li><li><div>              elseif($c &gt;= 192) $bits=2;&nbsp;</div></li><li><div>              else return false;&nbsp;</div></li><li><div>              if(($i+$bits) &gt; $len) return false;&nbsp;</div></li><li><div>              while($bits &gt; 1)&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $i++;&nbsp;</div></li><li><div>                  $b=ord($str[$i]);&nbsp;</div></li><li><div>                  if($b &lt; 128 || $b &gt; 191) return false;&nbsp;</div></li><li><div>                  $bits--;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">  function is_utf8($string)</span>&nbsp;</div></li><li><div><span class="comment">  {</span>&nbsp;</div></li><li><div><span class="comment">      //this is buggy</span>&nbsp;</div></li><li><div><span class="comment">      return (utf8_encode(utf8_decode($string)) == $string);</span>&nbsp;</div></li><li><div><span class="comment">  }</span>&nbsp;</div></li><li><div><span class="comment">  */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Function to try a few tricks to determine the displayed size of an img on the page.</span>&nbsp;</div></li><li><div><span class="comment">   * NOTE: This will ONLY work on an IMG tag. Returns FALSE on all other tag types.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @author John Schlick</span>&nbsp;</div></li><li><div><span class="comment">   * @version April 19 2012</span>&nbsp;</div></li><li><div><span class="comment">   * @return array an array containing the 'height' and 'width' of the image on the page or -1 if we can't figure it out.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_display_size()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $width = -1;&nbsp;</div></li><li><div>      $height = -1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($this-&gt;tag !== 'img')&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// See if there is aheight or width attribute in the tag itself.</span>&nbsp;</div></li><li><div>      if (isset($this-&gt;attr['width']))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $width = $this-&gt;attr['width'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (isset($this-&gt;attr['height']))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $height = $this-&gt;attr['height'];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Now look for an inline style.</span>&nbsp;</div></li><li><div>      if (isset($this-&gt;attr['style']))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          <span class="comment">// Thanks to user gnarf from stackoverflow for this regular expression.</span>&nbsp;</div></li><li><div>          $attributes = array();&nbsp;</div></li><li><div>          preg_match_all(&quot;/([\w-]+)\s*:\s*([^;]+)\s*;?/&quot;, $this-&gt;attr['style'], $matches, PREG_SET_ORDER);&nbsp;</div></li><li><div>          foreach ($matches as $match) {&nbsp;</div></li><li><div>            $attributes[$match[1]] = $match[2];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// If there is a width in the style attributes:</span></span>&nbsp;</div></li><li><div>          if (isset($attributes['width']) && $width == -1)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">// check that the last two characters are px (pixels)</span></span>&nbsp;</div></li><li><div>              if (strtolower(substr($attributes['width'], -2)) == 'px')&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $proposed_width = substr($attributes['width'], 0, -2);&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Now make sure that it's an integer and not something stupid.</span></span>&nbsp;</div></li><li><div>                  if (filter_var($proposed_width, FILTER_VALIDATE_INT))&nbsp;</div></li><li><div>                  {&nbsp;</div></li><li><div>                      $width = $proposed_width;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// If there is a width in the style attributes:</span></span>&nbsp;</div></li><li><div>          if (isset($attributes['height']) && $height == -1)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">// check that the last two characters are px (pixels)</span></span>&nbsp;</div></li><li><div>              if (strtolower(substr($attributes['height'], -2)) == 'px')&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $proposed_height = substr($attributes['height'], 0, -2);&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment">// Now make sure that it's an integer and not something stupid.</span></span>&nbsp;</div></li><li><div>                  if (filter_var($proposed_height, FILTER_VALIDATE_INT))&nbsp;</div></li><li><div>                  {&nbsp;</div></li><li><div>                      $height = $proposed_height;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Future enhancement:</span>&nbsp;</div></li><li><div>      <span class="comment">// Look in the tag to see if there is a class or id specified that has a height or width attribute to it.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Far future enhancement</span>&nbsp;</div></li><li><div>      <span class="comment">// Look at all the parent tags of this image to see if they specify a class or id that has an img selector that specifies a height or width</span>&nbsp;</div></li><li><div>      <span class="comment">// Note that in this case, the class or id will have the img subselector for it to apply to the image.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// ridiculously far future development</span>&nbsp;</div></li><li><div>      <span class="comment">// If the class or id is specified in a SEPARATE css file thats not on the page, go get it and do what we were just doing for the ones on the page.</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $result = array('height' =&gt; $height, &nbsp;</div></li><li><div>                      'width' =&gt; $width);&nbsp;</div></li><li><div>      return $result;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// camel naming conventions</span></span>&nbsp;</div></li><li><div>  function getAllAttributes() {return $this-&gt;attr;}&nbsp;</div></li><li><div>  function getAttribute($name) {return $this-&gt;__get($name);}&nbsp;</div></li><li><div>  function setAttribute($name, $value) {$this-&gt;__set($name, $value);}&nbsp;</div></li><li><div>  function hasAttribute($name) {return $this-&gt;__isset($name);}&nbsp;</div></li><li><div>  function removeAttribute($name) {$this-&gt;__set($name, null);}&nbsp;</div></li><li><div>  function getElementById($id) {return $this-&gt;find(&quot;#$id&quot;, 0);}&nbsp;</div></li><li><div>  function getElementsById($id, $idx=null) {return $this-&gt;find(&quot;#$id&quot;, $idx);}&nbsp;</div></li><li><div>  function getElementByTagName($name) {return $this-&gt;find($name, 0);}&nbsp;</div></li><li><div>  function getElementsByTagName($name, $idx=null) {return $this-&gt;find($name, $idx);}&nbsp;</div></li><li><div>  function parentNode() {return $this-&gt;parent();}&nbsp;</div></li><li><div>  function childNodes($idx=-1) {return $this-&gt;children($idx);}&nbsp;</div></li><li><div>  function firstChild() {return $this-&gt;first_child();}&nbsp;</div></li><li><div>  function lastChild() {return $this-&gt;last_child();}&nbsp;</div></li><li><div>  function nextSibling() {return $this-&gt;next_sibling();}&nbsp;</div></li><li><div>  function previousSibling() {return $this-&gt;prev_sibling();}&nbsp;</div></li><li><div>  function hasChildNodes() {return $this-&gt;has_child();}&nbsp;</div></li><li><div>  function nodeName() {return $this-&gt;tag;}&nbsp;</div></li><li><div>  function appendChild($node) {$node-&gt;parent($this); return $node;}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * simple html dom parser</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg - in the find routine: allow us to specify that we want case insensitive testing of the value of the selector.</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg - change $size from protected to public so we can easily access it</span>&nbsp;</div></li><li><div><span class="comment"> * Paperg - added ForceTagsClosed in the constructor which tells us whether we trust the html or not.  Default is to NOT trust it.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package PlaceLocalInclude</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>class simple_html_dom&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>  public $root = null;&nbsp;</div></li><li><div>  public $nodes = array();&nbsp;</div></li><li><div>  public $callback = null;&nbsp;</div></li><li><div>  public $lowercase = false;&nbsp;</div></li><li><div>  <span class="comment">// Used to keep track of how large the text was when we started.</span>&nbsp;</div></li><li><div>  public $original_size;&nbsp;</div></li><li><div>  public $size;&nbsp;</div></li><li><div>  protected $pos;&nbsp;</div></li><li><div>  protected $doc;&nbsp;</div></li><li><div>  protected $char;&nbsp;</div></li><li><div>  protected $cursor;&nbsp;</div></li><li><div>  protected $parent;&nbsp;</div></li><li><div>  protected $noise = array();&nbsp;</div></li><li><div>  protected $token_blank = &quot; \t\r\n&quot;;&nbsp;</div></li><li><div>  protected $token_equal = ' =/&gt;';&nbsp;</div></li><li><div>  protected $token_slash = &quot; /&gt;\r\n\t&quot;;&nbsp;</div></li><li><div>  protected $token_attr = ' &gt;';&nbsp;</div></li><li><div>  <span class="comment">// Note that this is referenced by a child node, and so it needs to be public for that node to see this information.</span>&nbsp;</div></li><li><div>  public $_charset = '';&nbsp;</div></li><li><div>  public $_target_charset = '';&nbsp;</div></li><li><div>  protected $default_br_text = &quot;&quot;;&nbsp;</div></li><li><div>  public $default_span_text = &quot;&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// use isset instead of in_array, performance boost about 30%...</span>&nbsp;</div></li><li><div>  protected $self_closing_tags = array('img'=&gt;1, 'br'=&gt;1, 'input'=&gt;1, 'meta'=&gt;1, 'link'=&gt;1, 'hr'=&gt;1, 'base'=&gt;1, 'embed'=&gt;1, 'spacer'=&gt;1);&nbsp;</div></li><li><div>  protected $block_tags = array('root'=&gt;1, 'body'=&gt;1, 'form'=&gt;1, 'div'=&gt;1, 'span'=&gt;1, 'table'=&gt;1);&nbsp;</div></li><li><div>  <span class="comment">// Known sourceforge issue #2977341</span>&nbsp;</div></li><li><div>  <span class="comment">// B tags that are not closed cause us to return everything to the end of the document.</span>&nbsp;</div></li><li><div>  protected $optional_closing_tags = array(&nbsp;</div></li><li><div>      'tr'=&gt;array('tr'=&gt;1, 'td'=&gt;1, 'th'=&gt;1), &nbsp;</div></li><li><div>      'th'=&gt;array('th'=&gt;1), &nbsp;</div></li><li><div>      'td'=&gt;array('td'=&gt;1), &nbsp;</div></li><li><div>      'li'=&gt;array('li'=&gt;1), &nbsp;</div></li><li><div>      'dt'=&gt;array('dt'=&gt;1, 'dd'=&gt;1), &nbsp;</div></li><li><div>      'dd'=&gt;array('dd'=&gt;1, 'dt'=&gt;1), &nbsp;</div></li><li><div>      'dl'=&gt;array('dd'=&gt;1, 'dt'=&gt;1), &nbsp;</div></li><li><div>      'p'=&gt;array('p'=&gt;1), &nbsp;</div></li><li><div>      'nobr'=&gt;array('nobr'=&gt;1), &nbsp;</div></li><li><div>      'b'=&gt;array('b'=&gt;1), &nbsp;</div></li><li><div>      'option'=&gt;array('option'=&gt;1), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __construct($str=null, $lowercase=true, $forceTagsClosed=true, $target_charset=DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if ($str)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          if (preg_match(&quot;/^http:\/\<span class="comment">//i&quot;, $str) || is_file($str))</span>&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $this-&gt;load_file($str);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $this-&gt;load($str, $lowercase, $stripRN, $defaultBRText, $defaultSpanText);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      <span class="comment">// Forcing tags to be closed implies that we don't trust the html, but it can lead to parsing errors if we SHOULD trust the html.</span>&nbsp;</div></li><li><div>      if (!$forceTagsClosed) {&nbsp;</div></li><li><div>          $this-&gt;optional_closing_array=array();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $this-&gt;_target_charset = $target_charset;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __destruct()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;clear();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// load html from string</span>&nbsp;</div></li><li><div>  function load($str, $lowercase=true, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// prepare</span>&nbsp;</div></li><li><div>      $this-&gt;prepare($str, $lowercase, $stripRN, $defaultBRText, $defaultSpanText);&nbsp;</div></li><li><div>      <span class="comment">// strip out cdata</span>&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'&lt;!\[CDATA\[(.*?)\]\]&gt;'is&quot;, true);&nbsp;</div></li><li><div>      <span class="comment">// strip out comments</span>&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'&lt;!--(.*?)--&gt;'is&quot;);&nbsp;</div></li><li><div>      <span class="comment">// Per sourceforge http://sourceforge.net/tracker/?func=detail&aid=2949097&group_id=218559&atid=1044037</span>&nbsp;</div></li><li><div>      <span class="comment">// Script tags removal now preceeds style tag removal.</span>&nbsp;</div></li><li><div>      <span class="comment">// strip out &lt;script&gt; tags</span>&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'&lt;\s*script[^&gt;]*[^/]&gt;(.*?)&lt;\s*/\s*script\s*&gt;'is&quot;);&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'&lt;\s*script\s*&gt;(.*?)&lt;\s*/\s*script\s*&gt;'is&quot;);&nbsp;</div></li><li><div>      <span class="comment">// strip out &lt;style&gt; tags</span>&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'&lt;\s*style[^&gt;]*[^/]&gt;(.*?)&lt;\s*/\s*style\s*&gt;'is&quot;);&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'&lt;\s*style\s*&gt;(.*?)&lt;\s*/\s*style\s*&gt;'is&quot;);&nbsp;</div></li><li><div>      <span class="comment">// strip out preformatted tags</span>&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'&lt;\s*(?:code)[^&gt;]*&gt;(.*?)&lt;\s*/\s*(?:code)\s*&gt;'is&quot;);&nbsp;</div></li><li><div>      <span class="comment">// strip out server side scripts</span>&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'(&lt;\?)(.*?)(\?&gt;)'s&quot;, true);&nbsp;</div></li><li><div>      <span class="comment">// strip smarty scripts</span>&nbsp;</div></li><li><div>      $this-&gt;remove_noise(&quot;'(\{\w)(.*?)(\})'s&quot;, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// parsing</span>&nbsp;</div></li><li><div>      while ($this-&gt;parse());&nbsp;</div></li><li><div>      <span class="comment">// end</span>&nbsp;</div></li><li><div>      $this-&gt;root-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;&nbsp;</div></li><li><div>      $this-&gt;parse_charset();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// make load function chainable</span>&nbsp;</div></li><li><div>      return $this;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// load html from file</span>&nbsp;</div></li><li><div>  function load_file()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $args = func_get_args();&nbsp;</div></li><li><div>      $this-&gt;load(call_user_func_array('file_get_contents', $args), true);&nbsp;</div></li><li><div>      <span class="comment">// Throw an error if we can't properly load the dom.</span>&nbsp;</div></li><li><div>      if (($error=error_get_last())!==null) {&nbsp;</div></li><li><div>          $this-&gt;clear();&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// set callback function</span>&nbsp;</div></li><li><div>  function set_callback($function_name)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;callback = $function_name;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// remove callback function</span>&nbsp;</div></li><li><div>  function remove_callback()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;callback = null;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// save dom as string</span>&nbsp;</div></li><li><div>  function save($filepath='')&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $ret = $this-&gt;root-&gt;innertext();&nbsp;</div></li><li><div>      if ($filepath!=='') file_put_contents($filepath, $ret, LOCK_EX);&nbsp;</div></li><li><div>      return $ret;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// find dom node by css selector</span>&nbsp;</div></li><li><div>  <span class="comment">// Paperg - allow us to specify that we want case insensitive testing of the value of the selector.</span>&nbsp;</div></li><li><div>  function find($selector, $idx=null, $lowercase=false)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      return $this-&gt;root-&gt;find($selector, $idx, $lowercase);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// clean up memory due to php5 circular references memory leak...</span></span>&nbsp;</div></li><li><div>  function clear()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      foreach ($this-&gt;nodes as $n) {$n-&gt;clear(); $n = null;}&nbsp;</div></li><li><div>      <span class="comment">// This add next line is documented in the sourceforge repository. 2977248 as a fix for ongoing memory leaks that occur even with the use of clear.</span>&nbsp;</div></li><li><div>      if (isset($this-&gt;children)) foreach ($this-&gt;children as $n) {$n-&gt;clear(); $n = null;}&nbsp;</div></li><li><div>      if (isset($this-&gt;parent)) {$this-&gt;parent-&gt;clear(); unset($this-&gt;parent);}&nbsp;</div></li><li><div>      if (isset($this-&gt;root)) {$this-&gt;root-&gt;clear(); unset($this-&gt;root);}&nbsp;</div></li><li><div>      unset($this-&gt;doc);&nbsp;</div></li><li><div>      unset($this-&gt;noise);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function dump($show_attr=true)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;root-&gt;dump($show_attr);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// prepare</span> HTML data and init everything&nbsp;</div></li><li><div>  protected function prepare($str, $lowercase=true, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT, $defaultSpanText=DEFAULT_SPAN_TEXT)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;clear();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// set the length of content before we do anything to it.</span>&nbsp;</div></li><li><div>      $this-&gt;size = strlen($str);&nbsp;</div></li><li><div>      <span class="comment">// Save the original size of the html that we got in.  It might be useful to someone.</span>&nbsp;</div></li><li><div>      $this-&gt;original_size = $this-&gt;size;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">//before we save the string as the doc...  strip out the \r \n's if we are told to.</span>&nbsp;</div></li><li><div>      if ($stripRN) {&nbsp;</div></li><li><div>          $str = str_replace(&quot;\r&quot;, &quot; &quot;, $str);&nbsp;</div></li><li><div>          $str = str_replace(&quot;\n&quot;, &quot; &quot;, $str);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// set the length of content since we have changed it.</span>&nbsp;</div></li><li><div>          $this-&gt;size = strlen($str);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;doc = $str;&nbsp;</div></li><li><div>      $this-&gt;pos = 0;&nbsp;</div></li><li><div>      $this-&gt;cursor = 1;&nbsp;</div></li><li><div>      $this-&gt;noise = array();&nbsp;</div></li><li><div>      $this-&gt;nodes = array();&nbsp;</div></li><li><div>      $this-&gt;lowercase = $lowercase;&nbsp;</div></li><li><div>      $this-&gt;default_br_text = $defaultBRText;&nbsp;</div></li><li><div>      $this-&gt;default_span_text = $defaultSpanText;&nbsp;</div></li><li><div>      $this-&gt;root = new simple_html_dom_node($this);&nbsp;</div></li><li><div>      $this-&gt;root-&gt;tag = 'root';&nbsp;</div></li><li><div>      $this-&gt;root-&gt;_[HDOM_INFO_BEGIN] = -1;&nbsp;</div></li><li><div>      $this-&gt;root-&gt;nodetype = HDOM_TYPE_ROOT;&nbsp;</div></li><li><div>      $this-&gt;parent = $this-&gt;root;&nbsp;</div></li><li><div>      if ($this-&gt;size&gt;0) $this-&gt;char = $this-&gt;doc[0];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// parse html content</span>&nbsp;</div></li><li><div>  protected function parse()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if (($s = $this-&gt;copy_until_char('&lt;'))==='')&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return $this-&gt;read_tag();&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// text</span></span>&nbsp;</div></li><li><div>      $node = new simple_html_dom_node($this);&nbsp;</div></li><li><div>      ++$this-&gt;cursor;&nbsp;</div></li><li><div>      $node-&gt;_[HDOM_INFO_TEXT] = $s;&nbsp;</div></li><li><div>      $this-&gt;link_nodes($node, false);&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// PAPERG - dkchou - added this to try to identify the character set of the page we have just parsed so we know better how to spit it out later.</span>&nbsp;</div></li><li><div>  <span class="comment">// NOTE:  IF you provide a routine called get_last_retrieve_url_contents_content_type which returns the CURLINFO_CONTENT_TYPE from the last curl_exec</span>&nbsp;</div></li><li><div>  <span class="comment">// (or the content_type header from the last transfer), we will parse THAT, and if a charset is specified, we will use it over any other mechanism.</span>&nbsp;</div></li><li><div>  protected function parse_charset()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $charset = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (function_exists('get_last_retrieve_url_contents_content_type'))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $contentTypeHeader = get_last_retrieve_url_contents_content_type();&nbsp;</div></li><li><div>          $success = preg_match('/charset=(.+)/', $contentTypeHeader, $matches);&nbsp;</div></li><li><div>          if ($success)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $charset = $matches[1];&nbsp;</div></li><li><div>              if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, 'header content-type found charset of: ' . $charset);}&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (empty($charset))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $el = $this-&gt;root-&gt;find('meta[http-equiv=Content-Type]', 0);&nbsp;</div></li><li><div>          if (!empty($el))&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $fullvalue = $el-&gt;content;&nbsp;</div></li><li><div>              if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, 'meta content-type tag found' . $fullvalue);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if (!empty($fullvalue))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $success = preg_match('/charset=(.+)/', $fullvalue, $matches);&nbsp;</div></li><li><div>                  if ($success)&nbsp;</div></li><li><div>                  {&nbsp;</div></li><li><div>                      $charset = $matches[1];&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  else&nbsp;</div></li><li><div>                  {&nbsp;</div></li><li><div>                      <span class="comment">// If there is a meta tag, and they don't specify the character set, research says that it's typically ISO-8859-1</span>&nbsp;</div></li><li><div>                      if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, 'meta content-type tag couldn\'t be parsed. using iso-8859 default.');}&nbsp;</div></li><li><div>                      $charset = 'ISO-8859-1';&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If we couldn't find a charset above, then lets try to detect one based on the text we got...</span>&nbsp;</div></li><li><div>      if (empty($charset))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          <span class="comment">// Use this in case mb_detect_charset isn't installed/loaded on this machine.</span>&nbsp;</div></li><li><div>          $charset = false;&nbsp;</div></li><li><div>          if (function_exists('mb_detect_encoding'))&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              <span class="comment">// Have php try to detect the encoding from the text given to us.</span>&nbsp;</div></li><li><div>              $charset = mb_detect_encoding($this-&gt;root-&gt;plaintext . &quot;ascii&quot;, $encoding_list = array( &quot;UTF-8&quot;, &quot;CP1252&quot; ) );&nbsp;</div></li><li><div>              if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, 'mb_detect found: ' . $charset);}&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// and if this doesn't work...  then we need to just wrongheadedly assume it's UTF-8 so that we can move on - cause this will usually give us most of what we need...</span>&nbsp;</div></li><li><div>          if ($charset === false)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, 'since mb_detect failed - using default of utf-8');}&nbsp;</div></li><li><div>              $charset = 'UTF-8';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Since CP1252 is a superset, if we get one of it's subsets, we want it instead.</span>&nbsp;</div></li><li><div>      if ((strtolower($charset) == strtolower('ISO-8859-1')) || (strtolower($charset) == strtolower('Latin1')) || (strtolower($charset) == strtolower('Latin-1')))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          if (is_object($debug_object)) {$debug_object-&gt;debug_log(2, 'replacing ' . $charset . ' with CP1252 as its a superset');}&nbsp;</div></li><li><div>          $charset = 'CP1252';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (is_object($debug_object)) {$debug_object-&gt;debug_log(1, 'EXIT - ' . $charset);}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;_charset = $charset;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// read tag info</span>&nbsp;</div></li><li><div>  protected function read_tag()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if ($this-&gt;char!=='&lt;')&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $this-&gt;root-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $begin_tag_pos = $this-&gt;pos;&nbsp;</div></li><li><div>      $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// end</span> tag&nbsp;</div></li><li><div>      if ($this-&gt;char==='/')&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>          <span class="comment">// This represents the change in the simple_html_dom trunk from revision 180 to 181.</span>&nbsp;</div></li><li><div>          <span class="comment">// $this-&gt;skip($this-&gt;token_blank_t);</span>&nbsp;</div></li><li><div>          $this-&gt;skip($this-&gt;token_blank);&nbsp;</div></li><li><div>          $tag = $this-&gt;copy_until_char('&gt;');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// skip attributes in end tag</span>&nbsp;</div></li><li><div>          if (($pos = strpos($tag, ' '))!==false)&nbsp;</div></li><li><div>              $tag = substr($tag, 0, $pos);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $parent_lower = strtolower($this-&gt;parent-&gt;tag);&nbsp;</div></li><li><div>          $tag_lower = strtolower($tag);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($parent_lower!==$tag_lower)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              if (isset($this-&gt;optional_closing_tags[$parent_lower]) && isset($this-&gt;block_tags[$tag_lower]))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;&nbsp;</div></li><li><div>                  $org_parent = $this-&gt;parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  while (($this-&gt;parent-&gt;parent) && strtolower($this-&gt;parent-&gt;tag)!==$tag_lower)&nbsp;</div></li><li><div>                      $this-&gt;parent = $this-&gt;parent-&gt;parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  if (strtolower($this-&gt;parent-&gt;tag)!==$tag_lower) {&nbsp;</div></li><li><div>                      $this-&gt;parent = $org_parent; <span class="comment"><span class="comment">// restore origonal parent</span></span>&nbsp;</div></li><li><div>                      if ($this-&gt;parent-&gt;parent) $this-&gt;parent = $this-&gt;parent-&gt;parent;&nbsp;</div></li><li><div>                      $this-&gt;parent-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;&nbsp;</div></li><li><div>                      return $this-&gt;as_text_node($tag);&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else if (($this-&gt;parent-&gt;parent) && isset($this-&gt;block_tags[$tag_lower]))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;&nbsp;</div></li><li><div>                  $org_parent = $this-&gt;parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  while (($this-&gt;parent-&gt;parent) && strtolower($this-&gt;parent-&gt;tag)!==$tag_lower)&nbsp;</div></li><li><div>                      $this-&gt;parent = $this-&gt;parent-&gt;parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  if (strtolower($this-&gt;parent-&gt;tag)!==$tag_lower)&nbsp;</div></li><li><div>                  {&nbsp;</div></li><li><div>                      $this-&gt;parent = $org_parent; <span class="comment"><span class="comment">// restore origonal parent</span></span>&nbsp;</div></li><li><div>                      $this-&gt;parent-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;&nbsp;</div></li><li><div>                      return $this-&gt;as_text_node($tag);&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else if (($this-&gt;parent-&gt;parent) && strtolower($this-&gt;parent-&gt;parent-&gt;tag)===$tag_lower)&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;&nbsp;</div></li><li><div>                  $this-&gt;parent = $this-&gt;parent-&gt;parent;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else&nbsp;</div></li><li><div>                  return $this-&gt;as_text_node($tag);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $this-&gt;parent-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;&nbsp;</div></li><li><div>          if ($this-&gt;parent-&gt;parent) $this-&gt;parent = $this-&gt;parent-&gt;parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $node = new simple_html_dom_node($this);&nbsp;</div></li><li><div>      $node-&gt;_[HDOM_INFO_BEGIN] = $this-&gt;cursor;&nbsp;</div></li><li><div>      ++$this-&gt;cursor;&nbsp;</div></li><li><div>      $tag = $this-&gt;copy_until($this-&gt;token_slash);&nbsp;</div></li><li><div>      $node-&gt;tag_start = $begin_tag_pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// doctype, cdata & comments...</span>&nbsp;</div></li><li><div>      if (isset($tag[0]) && $tag[0]==='!') {&nbsp;</div></li><li><div>          $node-&gt;_[HDOM_INFO_TEXT] = '&lt;' . $tag . $this-&gt;copy_until_char('&gt;');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if (isset($tag[2]) && $tag[1]==='-' && $tag[2]==='-') {&nbsp;</div></li><li><div>              $node-&gt;nodetype = HDOM_TYPE_COMMENT;&nbsp;</div></li><li><div>              $node-&gt;tag = 'comment';&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $node-&gt;nodetype = HDOM_TYPE_UNKNOWN;&nbsp;</div></li><li><div>              $node-&gt;tag = 'unknown';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ($this-&gt;char==='&gt;') $node-&gt;_[HDOM_INFO_TEXT].='&gt;';&nbsp;</div></li><li><div>          $this-&gt;link_nodes($node, true);&nbsp;</div></li><li><div>          $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// text</span></span>&nbsp;</div></li><li><div>      if ($pos=strpos($tag, '&lt;')!==false) {&nbsp;</div></li><li><div>          $tag = '&lt;' . substr($tag, 0, -1);&nbsp;</div></li><li><div>          $node-&gt;_[HDOM_INFO_TEXT] = $tag;&nbsp;</div></li><li><div>          $this-&gt;link_nodes($node, false);&nbsp;</div></li><li><div>          $this-&gt;char = $this-&gt;doc[--$this-&gt;pos]; <span class="comment"><span class="comment">// prev</span></span>&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (!preg_match(&quot;/^[\w-:]+$/&quot;, $tag)) {&nbsp;</div></li><li><div>          $node-&gt;_[HDOM_INFO_TEXT] = '&lt;' . $tag . $this-&gt;copy_until('&lt;&gt;');&nbsp;</div></li><li><div>          if ($this-&gt;char==='&lt;') {&nbsp;</div></li><li><div>              $this-&gt;link_nodes($node, false);&nbsp;</div></li><li><div>              return true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($this-&gt;char==='&gt;') $node-&gt;_[HDOM_INFO_TEXT].='&gt;';&nbsp;</div></li><li><div>          $this-&gt;link_nodes($node, false);&nbsp;</div></li><li><div>          $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// begin tag</span>&nbsp;</div></li><li><div>      $node-&gt;nodetype = HDOM_TYPE_ELEMENT;&nbsp;</div></li><li><div>      $tag_lower = strtolower($tag);&nbsp;</div></li><li><div>      $node-&gt;tag = ($this-&gt;lowercase) ? $tag_lower : $tag;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// handle optional closing tags</span>&nbsp;</div></li><li><div>      if (isset($this-&gt;optional_closing_tags[$tag_lower]) )&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          while (isset($this-&gt;optional_closing_tags[$tag_lower][strtolower($this-&gt;parent-&gt;tag)]))&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;&nbsp;</div></li><li><div>              $this-&gt;parent = $this-&gt;parent-&gt;parent;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $node-&gt;parent = $this-&gt;parent;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $guard = 0; <span class="comment"><span class="comment">// prev</span></span>ent infinity loop&nbsp;</div></li><li><div>      $space = array($this-&gt;copy_skip($this-&gt;token_blank), '', '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// attributes</span>&nbsp;</div></li><li><div>      do&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          if ($this-&gt;char!==null && $space[0]==='')&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $name = $this-&gt;copy_until($this-&gt;token_equal);&nbsp;</div></li><li><div>          if ($guard===$this-&gt;pos)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $guard = $this-&gt;pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// handle endless '&lt;'</span>&nbsp;</div></li><li><div>          if ($this-&gt;pos&gt;=$this-&gt;size-1 && $this-&gt;char!=='&gt;') {&nbsp;</div></li><li><div>              $node-&gt;nodetype = HDOM_TYPE_TEXT;&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_END] = 0;&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_TEXT] = '&lt;'.$tag . $space[0] . $name;&nbsp;</div></li><li><div>              $node-&gt;tag = 'text';&nbsp;</div></li><li><div>              $this-&gt;link_nodes($node, false);&nbsp;</div></li><li><div>              return true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          <span class="comment">// handle mismatch '&lt;'</span>&nbsp;</div></li><li><div>          if ($this-&gt;doc[$this-&gt;pos-1]=='&lt;') {&nbsp;</div></li><li><div>              $node-&gt;nodetype = HDOM_TYPE_TEXT;&nbsp;</div></li><li><div>              $node-&gt;tag = 'text';&nbsp;</div></li><li><div>              $node-&gt;attr = array();&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_END] = 0;&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_TEXT] = substr($this-&gt;doc, $begin_tag_pos, $this-&gt;pos-$begin_tag_pos-1);&nbsp;</div></li><li><div>              $this-&gt;pos -= 2;&nbsp;</div></li><li><div>              $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>              $this-&gt;link_nodes($node, false);&nbsp;</div></li><li><div>              return true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($name!=='/' && $name!=='') {&nbsp;</div></li><li><div>              $space[1] = $this-&gt;copy_skip($this-&gt;token_blank);&nbsp;</div></li><li><div>              $name = $this-&gt;restore_noise($name);&nbsp;</div></li><li><div>              if ($this-&gt;lowercase) $name = strtolower($name);&nbsp;</div></li><li><div>              if ($this-&gt;char==='=') {&nbsp;</div></li><li><div>                  $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>                  $this-&gt;parse_attr($node, $name, $space);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else {&nbsp;</div></li><li><div>                  <span class="comment"><span class="comment"><span class="comment">//no value attr: nowrap, checked selected...</span></span></span>&nbsp;</div></li><li><div>                  $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_NO;&nbsp;</div></li><li><div>                  $node-&gt;attr[$name] = true;&nbsp;</div></li><li><div>                  if ($this-&gt;char!='&gt;') $this-&gt;char = $this-&gt;doc[--$this-&gt;pos]; <span class="comment"><span class="comment">// prev</span></span>&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_SPACE][] = $space;&nbsp;</div></li><li><div>              $space = array($this-&gt;copy_skip($this-&gt;token_blank), '', '');&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>      } while ($this-&gt;char!=='&gt;' && $this-&gt;char!=='/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;link_nodes($node, true);&nbsp;</div></li><li><div>      $node-&gt;_[HDOM_INFO_ENDSPACE] = $space[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// check self closing</span>&nbsp;</div></li><li><div>      if ($this-&gt;copy_until_char_escape('&gt;')==='/')&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $node-&gt;_[HDOM_INFO_ENDSPACE] .= '/';&nbsp;</div></li><li><div>          $node-&gt;_[HDOM_INFO_END] = 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          <span class="comment">// reset parent</span>&nbsp;</div></li><li><div>          if (!isset($this-&gt;self_closing_tags[strtolower($node-&gt;tag)])) $this-&gt;parent = $node;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If it's a BR tag, we need to set it's text to the default text.</span>&nbsp;</div></li><li><div>      <span class="comment">// This way when we see it in plaintext, we can generate formatting that the user wants.</span>&nbsp;</div></li><li><div>      <span class="comment">// since a br tag never has sub nodes, this works well.</span>&nbsp;</div></li><li><div>      if ($node-&gt;tag == &quot;br&quot;)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $node-&gt;_[HDOM_INFO_INNER] = $this-&gt;default_br_text;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// parse attributes</span>&nbsp;</div></li><li><div>  protected function parse_attr($node, $name, &$space)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      <span class="comment">// Per sourceforge: http://sourceforge.net/tracker/?func=detail&aid=3061408&group_id=218559&atid=1044037</span>&nbsp;</div></li><li><div>      <span class="comment">// If the attribute is already defined inside a tag, only pay atetntion to the first one as opposed to the last one.</span>&nbsp;</div></li><li><div>      if (isset($node-&gt;attr[$name]))&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $space[2] = $this-&gt;copy_skip($this-&gt;token_blank);&nbsp;</div></li><li><div>      switch ($this-&gt;char) {&nbsp;</div></li><li><div>          case '&quot;':&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_DOUBLE;&nbsp;</div></li><li><div>              $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>              $node-&gt;attr[$name] = $this-&gt;restore_noise($this-&gt;copy_until_char_escape('&quot;'));&nbsp;</div></li><li><div>              $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          case '\'':&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_SINGLE;&nbsp;</div></li><li><div>              $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>              $node-&gt;attr[$name] = $this-&gt;restore_noise($this-&gt;copy_until_char_escape('\''));&nbsp;</div></li><li><div>              $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          default:&nbsp;</div></li><li><div>              $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_NO;&nbsp;</div></li><li><div>              $node-&gt;attr[$name] = $this-&gt;restore_noise($this-&gt;copy_until($this-&gt;token_attr));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      <span class="comment">// PaperG: Attributes should not have \r or \n in them, that counts as html whitespace.</span>&nbsp;</div></li><li><div>      $node-&gt;attr[$name] = str_replace(&quot;\r&quot;, &quot;&quot;, $node-&gt;attr[$name]);&nbsp;</div></li><li><div>      $node-&gt;attr[$name] = str_replace(&quot;\n&quot;, &quot;&quot;, $node-&gt;attr[$name]);&nbsp;</div></li><li><div>      <span class="comment">// PaperG: If this is a &quot;class&quot; selector, lets get rid of the preceeding and trailing space since some people leave it in the multi class case.</span>&nbsp;</div></li><li><div>      if ($name == &quot;class&quot;) {&nbsp;</div></li><li><div>          $node-&gt;attr[$name] = trim($node-&gt;attr[$name]);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// link node's parent</span>&nbsp;</div></li><li><div>  protected function link_nodes(&$node, $is_child)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $node-&gt;parent = $this-&gt;parent;&nbsp;</div></li><li><div>      $this-&gt;parent-&gt;nodes[] = $node;&nbsp;</div></li><li><div>      if ($is_child)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $this-&gt;parent-&gt;children[] = $node;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// as a text node</span>&nbsp;</div></li><li><div>  protected function as_text_node($tag)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $node = new simple_html_dom_node($this);&nbsp;</div></li><li><div>      ++$this-&gt;cursor;&nbsp;</div></li><li><div>      $node-&gt;_[HDOM_INFO_TEXT] = '&lt;/' . $tag . '&gt;';&nbsp;</div></li><li><div>      $this-&gt;link_nodes($node, false);&nbsp;</div></li><li><div>      $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  protected function skip($chars)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $this-&gt;pos += strspn($this-&gt;doc, $chars, $this-&gt;pos);&nbsp;</div></li><li><div>      $this-&gt;char = ($this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  protected function copy_skip($chars)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $pos = $this-&gt;pos;&nbsp;</div></li><li><div>      $len = strspn($this-&gt;doc, $chars, $pos);&nbsp;</div></li><li><div>      $this-&gt;pos += $len;&nbsp;</div></li><li><div>      $this-&gt;char = ($this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      if ($len===0) return '';&nbsp;</div></li><li><div>      return substr($this-&gt;doc, $pos, $len);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  protected function copy_until($chars)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      $pos = $this-&gt;pos;&nbsp;</div></li><li><div>      $len = strcspn($this-&gt;doc, $chars, $pos);&nbsp;</div></li><li><div>      $this-&gt;pos += $len;&nbsp;</div></li><li><div>      $this-&gt;char = ($this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; <span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment"><span class="comment">// next</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;</div></li><li><div>      return substr($this-&gt;doc, $pos, $len);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  protected function copy_until_char($char)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if ($this-&gt;char===null) return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if (($pos = strpos($this-&gt;doc, $char, $this-&gt;pos))===false) {&nbsp;</div></li><li><div>          $ret = substr($this-&gt;doc, $this-&gt;pos, $this-&gt;size-$this-&gt;pos);&nbsp;</div></li><li><div>          $this-&gt;char = null;&nbsp;</div></li><li><div>          $this-&gt;pos = $this-&gt;size;&nbsp;</div></li><li><div>          return $ret;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ($pos===$this-&gt;pos) return '';&nbsp;</div></li><li><div>      $pos_old = $this-&gt;pos;&nbsp;</div></li><li><div>      $this-&gt;char = $this-&gt;doc[$pos];&nbsp;</div></li><li><div>      $this-&gt;pos = $pos;&nbsp;</div></li><li><div>      return substr($this-&gt;doc, $pos_old, $pos-$pos_old);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  protected function copy_until_char_escape($char)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      if ($this-&gt;char===null) return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $start = $this-&gt;pos;&nbsp;</div></li><li><div>      while (1)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          if (($pos = strpos($this-&gt;doc, $char, $start))===false)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $ret = substr($this-&gt;doc, $this-&gt;pos, $this-&gt;size-$this-&gt;pos);&nbsp;</div></li><li><div>              $this-&gt;char = null;&nbsp;</div></li><li><div>              $this-&gt;pos = $this-&gt;size;&nbsp;</div></li><li><div>              return $ret;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($pos===$this-&gt;pos) return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ($this-&gt;doc[$pos-1]==='\\') {&nbsp;</div></li><li><div>              $start = $pos+1;&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $pos_old = $this-&gt;pos;&nbsp;</div></li><li><div>          $this-&gt;char = $this-&gt;doc[$pos];&nbsp;</div></li><li><div>          $this-&gt;pos = $pos;&nbsp;</div></li><li><div>          return substr($this-&gt;doc, $pos_old, $pos-$pos_old);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// remove noise from html content</span>&nbsp;</div></li><li><div>  <span class="comment">// save the noise in the $this-&gt;noise array.</span>&nbsp;</div></li><li><div>  protected function remove_noise($pattern, $remove_tag=false)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) { $debug_object-&gt;debug_log_entry(1); }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $count = preg_match_all($pattern, $this-&gt;doc, $matches, PREG_SET_ORDER|PREG_OFFSET_CAPTURE);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      for ($i=$count-1; $i&gt;-1; --$i)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $key = '___noise___'.sprintf('% 5d', count($this-&gt;noise)+1000);&nbsp;</div></li><li><div>          if (is_object($debug_object)) { $debug_object-&gt;debug_log(2, 'key is: ' . $key); }&nbsp;</div></li><li><div>          $idx = ($remove_tag) ? 0 : 1;&nbsp;</div></li><li><div>          $this-&gt;noise[$key] = $matches[$i][$idx][0];&nbsp;</div></li><li><div>          $this-&gt;doc = substr_replace($this-&gt;doc, $key, $matches[$i][$idx][1], strlen($matches[$i][$idx][0]));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// reset the length of content</span>&nbsp;</div></li><li><div>      $this-&gt;size = strlen($this-&gt;doc);&nbsp;</div></li><li><div>      if ($this-&gt;size&gt;0)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          $this-&gt;char = $this-&gt;doc[0];&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// restore noise to html content</span>&nbsp;</div></li><li><div>  function restore_noise($text)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) { $debug_object-&gt;debug_log_entry(1); }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      while (($pos=strpos($text, '___noise___'))!==false)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          <span class="comment">// Sometimes there is a broken piece of markup, and we don't GET the pos+11 etc... token which indicates a problem outside of us...</span>&nbsp;</div></li><li><div>          if (strlen($text) &gt; $pos+15)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              $key = '___noise___'.$text[$pos+11].$text[$pos+12].$text[$pos+13].$text[$pos+14].$text[$pos+15];&nbsp;</div></li><li><div>              if (is_object($debug_object)) { $debug_object-&gt;debug_log(2, 'located key of: ' . $key); }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if (isset($this-&gt;noise[$key]))&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  $text = substr($text, 0, $pos).$this-&gt;noise[$key].substr($text, $pos+16);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              else&nbsp;</div></li><li><div>              {&nbsp;</div></li><li><div>                  <span class="comment">// do this to prevent an infinite loop.</span>&nbsp;</div></li><li><div>                  $text = substr($text, 0, $pos).'UNDEFINED NOISE FOR KEY: '.$key . substr($text, $pos+16);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              <span class="comment">// There is no valid key being given back to us... We must get rid of the ___noise___ or we will have a problem.</span>&nbsp;</div></li><li><div>              $text = substr($text, 0, $pos).'NO NUMERIC NOISE KEY' . substr($text, $pos+11);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $text;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">// Sometimes we NEED one of the noise elements.</span>&nbsp;</div></li><li><div>  function search_noise($text)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      global $debug_object;&nbsp;</div></li><li><div>      if (is_object($debug_object)) { $debug_object-&gt;debug_log_entry(1); }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach($this-&gt;noise as $noiseElement)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          if (strpos($noiseElement, $text)!==false)&nbsp;</div></li><li><div>          {&nbsp;</div></li><li><div>              return $noiseElement;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>  function __toString()&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      return $this-&gt;root-&gt;innertext();&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function __get($name)&nbsp;</div></li><li><div>  {&nbsp;</div></li><li><div>      switch ($name)&nbsp;</div></li><li><div>      {&nbsp;</div></li><li><div>          case 'outertext':&nbsp;</div></li><li><div>              return $this-&gt;root-&gt;innertext();&nbsp;</div></li><li><div>          case 'innertext':&nbsp;</div></li><li><div>              return $this-&gt;root-&gt;innertext();&nbsp;</div></li><li><div>          case 'plaintext':&nbsp;</div></li><li><div>              return $this-&gt;root-&gt;text();&nbsp;</div></li><li><div>          case 'charset':&nbsp;</div></li><li><div>              return $this-&gt;_charset;&nbsp;</div></li><li><div>          case 'target_charset':&nbsp;</div></li><li><div>              return $this-&gt;_target_charset;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment"><span class="comment">// camel naming conventions</span></span>&nbsp;</div></li><li><div>  function childNodes($idx=-1) {return $this-&gt;root-&gt;childNodes($idx);}&nbsp;</div></li><li><div>  function firstChild() {return $this-&gt;root-&gt;first_child();}&nbsp;</div></li><li><div>  function lastChild() {return $this-&gt;root-&gt;last_child();}&nbsp;</div></li><li><div>  function createElement($name, $value=null) {return @str_get_html(&quot;&lt;$name&gt;$value&lt;/$name&gt;&quot;)-&gt;first_child();}&nbsp;</div></li><li><div>  function createTextNode($value) {return @end(str_get_html($value)-&gt;nodes);}&nbsp;</div></li><li><div>  function getElementById($id) {return $this-&gt;find(&quot;#$id&quot;, 0);}&nbsp;</div></li><li><div>  function getElementsById($id, $idx=null) {return $this-&gt;find(&quot;#$id&quot;, $idx);}&nbsp;</div></li><li><div>  function getElementByTagName($name) {return $this-&gt;find($name, 0);}&nbsp;</div></li><li><div>  function getElementsByTagName($name, $idx=-1) {return $this-&gt;find($name, $idx);}&nbsp;</div></li><li><div>  function loadFile() {$args = func_get_args();$this-&gt;load_file($args);}&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>?&gt;&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>file</li><li><span></span></li><li><span></span>rtMedia for WordPress, BuddyPress and bbPress</li><li><span></span>4.3.1</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>