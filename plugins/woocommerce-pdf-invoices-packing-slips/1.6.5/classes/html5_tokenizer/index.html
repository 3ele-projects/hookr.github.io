<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="1.6.5" data-slug="woocommerce-pdf-invoices-packing-slips" data-type="class" data-id="76917"><head xmlns="http://www.w3.org/1999/xhtml"><title> html5_tokenizer | class | Woocommerce Pdf Invoices Packing Slips | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="HTML5_Tokenizer, class, plugin, woocommerce-pdf-invoices-packing-slips, 1.6.5" /><meta name="description" content="The WooCommerce PDF Invoices &amp; Packing Slips HTML5 Tokenizer class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.17"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=9892f23bfc6325438aecc608c33c5764' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.17' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/html5_tokenizer/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fhtml5_tokenizer%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fhtml5_tokenizer%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-woocommerce-pdf-invoices-packing-slips-1.6.5-class-html5_tokenizer","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="html5_tokenizer" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to woocommerce-pdf-invoices-pack&hellip;." href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/" class="plugin"><span property="name">woocommerce-pdf-invoices-pack&hellip;</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 1.6.5." href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/" class="H_VERSION"><span property="name">1.6.5</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">html5_tokenizer</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="269"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/all/" title="All">All <span class="count badge">269</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="132"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/hooks/" title="Hooks">Hooks <span class="count badge">132</span></a></li><li class="" data-id="action" data-count="38"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/actions/" title="Actions">Actions <span class="count badge">38</span></a></li><li class="" data-id="filter" data-count="94"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/filters/" title="Filters">Filters <span class="count badge">94</span></a></li><li class="active" data-id="class" data-count="121"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/classes/" title="Classes">Classes <span class="count badge">121</span></a></li><li class="" data-id="constant" data-count="9"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/constants/" title="Constants">Constants <span class="count badge">9</span></a></li><li class="" data-id="function" data-count="7"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/functions/" title="Functions">Functions <span class="count badge">7</span></a></li><li class="" data-id="shortcode" data-count="0"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">0</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>HTML5_Tokenizer</strong></h1><p>The WooCommerce PDF Invoices &amp; Packing Slips <strong>HTML5 Tokenizer</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/files/lib-dompdf-lib-html5lib-tokenizer/" class="file">/lib/dompdf/lib/html5lib/Tokenizer.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="36" class="block" start="36"><li><div>class HTML5_Tokenizer {&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Points to an InputStream object.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $stream;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Tree builder that the tokenizer emits token to.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private $tree;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Current content model we are parsing as.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $content_model;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Current token that is being built, but not yet emitted. Also&nbsp;</div></li><li><div>     * is the last token emitted, if applicable.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected $token;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // These are constants describing the content model&nbsp;</div></li><li><div>    const PCDATA = 0;&nbsp;</div></li><li><div>    const RCDATA = 1;&nbsp;</div></li><li><div>    const CDATA = 2;&nbsp;</div></li><li><div>    const PLAINTEXT = 3;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // These are constants describing tokens&nbsp;</div></li><li><div>    // XXX should probably be moved somewhere else, probably the&nbsp;</div></li><li><div>    // HTML5 class.&nbsp;</div></li><li><div>    const DOCTYPE = 0;&nbsp;</div></li><li><div>    const STARTTAG = 1;&nbsp;</div></li><li><div>    const ENDTAG = 2;&nbsp;</div></li><li><div>    const COMMENT = 3;&nbsp;</div></li><li><div>    const CHARACTER = 4;&nbsp;</div></li><li><div>    const SPACECHARACTER = 5;&nbsp;</div></li><li><div>    const EOF = 6;&nbsp;</div></li><li><div>    const PARSEERROR = 7;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // These are constants representing bunches of characters.&nbsp;</div></li><li><div>    const ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';&nbsp;</div></li><li><div>    const UPPER_ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';&nbsp;</div></li><li><div>    const LOWER_ALPHA = 'abcdefghijklmnopqrstuvwxyz';&nbsp;</div></li><li><div>    const DIGIT = '0123456789';&nbsp;</div></li><li><div>    const HEX = '0123456789ABCDEFabcdef';&nbsp;</div></li><li><div>    const WHITESPACE = &quot;\t\n\x0c &quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param $data Data to parse&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function __construct($data, $builder = null) {&nbsp;</div></li><li><div>        $this-&gt;stream = new HTML5_InputStream($data);&nbsp;</div></li><li><div>        if (!$builder) $this-&gt;tree = new HTML5_TreeBuilder;&nbsp;</div></li><li><div>        else $this-&gt;tree = $builder;&nbsp;</div></li><li><div>        $this-&gt;content_model = self::PCDATA;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function parseFragment($context = null) {&nbsp;</div></li><li><div>        $this-&gt;tree-&gt;setupContext($context);&nbsp;</div></li><li><div>        if ($this-&gt;tree-&gt;content_model) {&nbsp;</div></li><li><div>            $this-&gt;content_model = $this-&gt;tree-&gt;content_model;&nbsp;</div></li><li><div>            $this-&gt;tree-&gt;content_model = null;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $this-&gt;parse();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // XXX maybe convert this into an iterator? regardless, this function&nbsp;</div></li><li><div>    // and the save function should go into a Parser facade of some sort&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Performs the actual parsing of the document.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function parse() {&nbsp;</div></li><li><div>        // Current state&nbsp;</div></li><li><div>        $state = 'data';&nbsp;</div></li><li><div>        // This is used to avoid having to have look-behind in the data state.&nbsp;</div></li><li><div>        $lastFourChars = '';&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Escape flag as specified by the HTML5 specification: &quot;used to&nbsp;</div></li><li><div>         * control the behavior of the tokeniser. It is either true or&nbsp;</div></li><li><div>         * false, and initially must be set to the false state.&quot;&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $escape = false;&nbsp;</div></li><li><div>        //echo &quot;\n\n&quot;;&nbsp;</div></li><li><div>        while($state !== null) {&nbsp;</div></li><li><div>            &nbsp;</div></li><li><div>            /**echo $state . ' ';&nbsp;</div></li><li><div>            switch ($this-&gt;content_model) {&nbsp;</div></li><li><div>                case self::PCDATA: echo 'PCDATA'; break;&nbsp;</div></li><li><div>                case self::RCDATA: echo 'RCDATA'; break;&nbsp;</div></li><li><div>                case self::CDATA: echo 'CDATA'; break;&nbsp;</div></li><li><div>                case self::PLAINTEXT: echo 'PLAINTEXT'; break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($escape) echo &quot; escape&quot;;&nbsp;</div></li><li><div>            echo &quot;\n&quot;;*/&nbsp;</div></li><li><div>            &nbsp;</div></li><li><div>            switch($state) {&nbsp;</div></li><li><div>                case 'data':&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** Consume the next input character */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>                    $lastFourChars .= $char;&nbsp;</div></li><li><div>                    if (strlen($lastFourChars) &gt; 4) $lastFourChars = substr($lastFourChars, -4);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // see below for meaning&nbsp;</div></li><li><div>                    $hyp_cond = &nbsp;</div></li><li><div>                        !$escape &&&nbsp;</div></li><li><div>                        (&nbsp;</div></li><li><div>                            $this-&gt;content_model === self::RCDATA ||&nbsp;</div></li><li><div>                            $this-&gt;content_model === self::CDATA&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                    $amp_cond =&nbsp;</div></li><li><div>                        !$escape &&&nbsp;</div></li><li><div>                        (&nbsp;</div></li><li><div>                            $this-&gt;content_model === self::PCDATA ||&nbsp;</div></li><li><div>                            $this-&gt;content_model === self::RCDATA&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                    $lt_cond =&nbsp;</div></li><li><div>                        $this-&gt;content_model === self::PCDATA ||&nbsp;</div></li><li><div>                        (&nbsp;</div></li><li><div>                            (&nbsp;</div></li><li><div>                                $this-&gt;content_model === self::RCDATA ||&nbsp;</div></li><li><div>                                $this-&gt;content_model === self::CDATA&nbsp;</div></li><li><div> ) &&&nbsp;</div></li><li><div>                             !$escape&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                    $gt_cond = &nbsp;</div></li><li><div>                        $escape &&&nbsp;</div></li><li><div>                        (&nbsp;</div></li><li><div>                            $this-&gt;content_model === self::RCDATA ||&nbsp;</div></li><li><div>                            $this-&gt;content_model === self::CDATA&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === '&' && $amp_cond) {&nbsp;</div></li><li><div>                        /** U+0026 AMPERSAND (&)&nbsp;</div></li><li><div>                        When the content model flag is set to one of the PCDATA or RCDATA&nbsp;</div></li><li><div>                        states and the escape flag is false: switch to the&nbsp;</div></li><li><div>                        character reference data state. Otherwise: treat it as per&nbsp;</div></li><li><div>                        the &quot;anything else&quot; entry below. */&nbsp;</div></li><li><div>                        $state = 'character reference data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif(&nbsp;</div></li><li><div>                        $char === '-' &&&nbsp;</div></li><li><div>                        $hyp_cond &&&nbsp;</div></li><li><div>                        $lastFourChars === '&lt;!--'&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                        /**&nbsp;</div></li><li><div>                        U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                        If the content model flag is set to either the RCDATA state or&nbsp;</div></li><li><div>                        the CDATA state, and the escape flag is false, and there are at&nbsp;</div></li><li><div>                        least three characters before this one in the input stream, and the&nbsp;</div></li><li><div>                        last four characters in the input stream, including this one, are&nbsp;</div></li><li><div>                        U+003C LESS-THAN SIGN, U+0021 EXCLAMATION MARK, U+002D HYPHEN-MINUS, &nbsp;</div></li><li><div>                        and U+002D HYPHEN-MINUS (&quot;&lt;!--&quot;), then set the escape flag to true. */&nbsp;</div></li><li><div>                        $escape = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** In any case, emit the input character as a character token. Stay&nbsp;</div></li><li><div>                        in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                            'data' =&gt; '-'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        // We do the &quot;any case&quot; part as part of &quot;anything else&quot;.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** U+003C LESS-THAN SIGN (&lt;) */&nbsp;</div></li><li><div>                    } elseif($char === '&lt;' && $lt_cond) {&nbsp;</div></li><li><div>                        /** When the content model flag is set to the PCDATA state: switch&nbsp;</div></li><li><div>                        to the tag open state.&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>                        When the content model flag is set to either the RCDATA state or&nbsp;</div></li><li><div>                        the CDATA state and the escape flag is false: switch to the tag&nbsp;</div></li><li><div>                        open state.&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>                        Otherwise: treat it as per the &quot;anything else&quot; entry below. */&nbsp;</div></li><li><div>                        $state = 'tag open';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** U+003E GREATER-THAN SIGN (&gt;) */&nbsp;</div></li><li><div>                    } elseif(&nbsp;</div></li><li><div>                        $char === '&gt;' &&&nbsp;</div></li><li><div>                        $gt_cond &&&nbsp;</div></li><li><div>                        substr($lastFourChars, 1) === '--&gt;'&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                        /** If the content model flag is set to either the RCDATA state or&nbsp;</div></li><li><div>                        the CDATA state, and the escape flag is true, and the last three&nbsp;</div></li><li><div>                        characters in the input stream including this one are U+002D&nbsp;</div></li><li><div>                        HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN (&quot;--&gt;&quot;), &nbsp;</div></li><li><div>                        set the escape flag to false. */&nbsp;</div></li><li><div>                        $escape = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** In any case, emit the input character as a character token.&nbsp;</div></li><li><div>                        Stay in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                            'data' =&gt; '&gt;'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        // We do the &quot;any case&quot; part as part of &quot;anything else&quot;.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Emit an end-of-file token. */&nbsp;</div></li><li><div>                        $state = null;&nbsp;</div></li><li><div>                        $this-&gt;tree-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::EOF&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                    &nbsp;</div></li><li><div>                    } elseif($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        // Directly after emitting a token you switch back to the &quot;data&nbsp;</div></li><li><div>                        // state&quot;. At that point spaceCharacters are important so they are&nbsp;</div></li><li><div>                        // emitted separately.&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsWhile(self::WHITESPACE);&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::SPACECHARACTER, &nbsp;</div></li><li><div>                            'data' =&gt; $char . $chars&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $lastFourChars .= $chars;&nbsp;</div></li><li><div>                        if (strlen($lastFourChars) &gt; 4) $lastFourChars = substr($lastFourChars, -4);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        THIS IS AN OPTIMIZATION: Get as many character that&nbsp;</div></li><li><div>                        otherwise would also be treated as a character token and emit it&nbsp;</div></li><li><div>                        as a single character token. Stay in the data state. */&nbsp;</div></li><li><div>                        &nbsp;</div></li><li><div>                        $mask = '';&nbsp;</div></li><li><div>                        if ($hyp_cond) $mask .= '-';&nbsp;</div></li><li><div>                        if ($amp_cond) $mask .= '&';&nbsp;</div></li><li><div>                        if ($lt_cond)  $mask .= '&lt;';&nbsp;</div></li><li><div>                        if ($gt_cond)  $mask .= '&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ($mask === '') {&nbsp;</div></li><li><div>                            $chars = $this-&gt;stream-&gt;remainingChars();&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $chars = $this-&gt;stream-&gt;charsUntil($mask);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                            'data' =&gt; $char . $chars&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $lastFourChars .= $chars;&nbsp;</div></li><li><div>                        if (strlen($lastFourChars) &gt; 4) $lastFourChars = substr($lastFourChars, -4);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'character reference data':&nbsp;</div></li><li><div>                    /** (This cannot happen if the content model flag&nbsp;</div></li><li><div>                    is set to the CDATA state.) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** Attempt to consume a character reference, with no&nbsp;</div></li><li><div>                    additional allowed character. */&nbsp;</div></li><li><div>                    $entity = $this-&gt;consumeCharacterReference();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** If nothing is returned, emit a U+0026 AMPERSAND&nbsp;</div></li><li><div>                    character token. Otherwise, emit the character token that&nbsp;</div></li><li><div>                    was returned. */&nbsp;</div></li><li><div>                    // This is all done when consuming the character reference.&nbsp;</div></li><li><div>                    $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                        'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                        'data' =&gt; $entity&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** Finally, switch to the data state. */&nbsp;</div></li><li><div>                    $state = 'data';&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'tag open':&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    switch($this-&gt;content_model) {&nbsp;</div></li><li><div>                        case self::RCDATA:&nbsp;</div></li><li><div>                        case self::CDATA:&nbsp;</div></li><li><div>                            /** Consume the next input character. If it is a&nbsp;</div></li><li><div>                            U+002F SOLIDUS (/) character, switch to the close&nbsp;</div></li><li><div>                            tag open state. Otherwise, emit a U+003C LESS-THAN&nbsp;</div></li><li><div>                            SIGN character token and reconsume the current input&nbsp;</div></li><li><div>                            character in the data state. */&nbsp;</div></li><li><div>                            // We consumed above.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if($char === '/') {&nbsp;</div></li><li><div>                                $state = 'close tag open';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                    'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                                    'data' =&gt; '&lt;'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $state = 'data';&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        case self::PCDATA:&nbsp;</div></li><li><div>                            /** If the content model flag is set to the PCDATA state&nbsp;</div></li><li><div>                            Consume the next input character: */&nbsp;</div></li><li><div>                            // We consumed above.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if($char === '!') {&nbsp;</div></li><li><div>                                /** U+0021 EXCLAMATION MARK (!)&nbsp;</div></li><li><div>                                Switch to the markup declaration open state. */&nbsp;</div></li><li><div>                                $state = 'markup declaration open';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } elseif($char === '/') {&nbsp;</div></li><li><div>                                /** U+002F SOLIDUS (/)&nbsp;</div></li><li><div>                                Switch to the close tag open state. */&nbsp;</div></li><li><div>                                $state = 'close tag open';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } elseif('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                                /** U+0041 LATIN LETTER A through to U+005A LATIN LETTER Z&nbsp;</div></li><li><div>                                Create a new start tag token, set its tag name to the lowercase&nbsp;</div></li><li><div>                                version of the input character (add 0x0020 to the character's code&nbsp;</div></li><li><div>                                point), then switch to the tag name state. (Don't emit the token&nbsp;</div></li><li><div>                                yet; further details will be filled in before it is emitted.) */&nbsp;</div></li><li><div>                                $this-&gt;token = array(&nbsp;</div></li><li><div>                                    'name' =&gt; strtolower($char), &nbsp;</div></li><li><div>                                    'type' =&gt; self::STARTTAG, &nbsp;</div></li><li><div>                                    'attr' =&gt; array()&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $state = 'tag name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } elseif('a' &lt;= $char && $char &lt;= 'z') {&nbsp;</div></li><li><div>                                /** U+0061 LATIN SMALL LETTER A through to U+007A LATIN SMALL LETTER Z&nbsp;</div></li><li><div>                                Create a new start tag token, set its tag name to the input&nbsp;</div></li><li><div>                                character, then switch to the tag name state. (Don't emit&nbsp;</div></li><li><div>                                the token yet; further details will be filled in before it&nbsp;</div></li><li><div>                                is emitted.) */&nbsp;</div></li><li><div>                                $this-&gt;token = array(&nbsp;</div></li><li><div>                                    'name' =&gt; $char, &nbsp;</div></li><li><div>                                    'type' =&gt; self::STARTTAG, &nbsp;</div></li><li><div>                                    'attr' =&gt; array()&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $state = 'tag name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                                /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                                Parse error. Emit a U+003C LESS-THAN SIGN character token and a&nbsp;</div></li><li><div>                                U+003E GREATER-THAN SIGN character token. Switch to the data state. */&nbsp;</div></li><li><div>                                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                    'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                    'data' =&gt; 'expected-tag-name-but-got-right-bracket'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                    'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                                    'data' =&gt; '&lt;&gt;'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } elseif($char === '?') {&nbsp;</div></li><li><div>                                /** U+003F QUESTION MARK (?)&nbsp;</div></li><li><div>                                Parse error. Switch to the bogus comment state. */&nbsp;</div></li><li><div>                                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                    'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                    'data' =&gt; 'expected-tag-name-but-got-question-mark'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                                $this-&gt;token = array(&nbsp;</div></li><li><div>                                    'data' =&gt; '?', &nbsp;</div></li><li><div>                                    'type' =&gt; self::COMMENT&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                                $state = 'bogus comment';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                /** Anything else&nbsp;</div></li><li><div>                                Parse error. Emit a U+003C LESS-THAN SIGN character token and&nbsp;</div></li><li><div>                                reconsume the current input character in the data state. */&nbsp;</div></li><li><div>                                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                    'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                    'data' =&gt; 'expected-tag-name'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                    'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                                    'data' =&gt; '&lt;'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $state = 'data';&nbsp;</div></li><li><div>                                $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'close tag open':&nbsp;</div></li><li><div>                    if (&nbsp;</div></li><li><div>                        $this-&gt;content_model === self::RCDATA ||&nbsp;</div></li><li><div>                        $this-&gt;content_model === self::CDATA&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                        /** If the content model flag is set to the RCDATA or CDATA&nbsp;</div></li><li><div>                        states... */&nbsp;</div></li><li><div>                        $name = strtolower($this-&gt;stream-&gt;charsWhile(self::ALPHA));&nbsp;</div></li><li><div>                        $following = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        if (&nbsp;</div></li><li><div>                            !$this-&gt;token ||&nbsp;</div></li><li><div>                            $this-&gt;token['name'] !== $name ||&nbsp;</div></li><li><div>                            $this-&gt;token['name'] === $name && !in_array($following, array(&quot;\x09&quot;, &quot;\x0A&quot;, &quot;\x0C&quot;, &quot;\x20&quot;, &quot;\x3E&quot;, &quot;\x2F&quot;, false))&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                            /** if no start tag token has ever been emitted by this instance&nbsp;</div></li><li><div>                            of the tokenizer (fragment case), or, if the next few&nbsp;</div></li><li><div>                            characters do not match the tag name of the last start tag&nbsp;</div></li><li><div>                            token emitted (compared in an ASCII case-insensitive manner), &nbsp;</div></li><li><div>                            or if they do but they are not immediately followed by one of&nbsp;</div></li><li><div>                            the following characters:&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>                                * U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                                * U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                                * U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                                * U+0020 SPACE&nbsp;</div></li><li><div>                                * U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                                * U+002F SOLIDUS (/)&nbsp;</div></li><li><div>                                * EOF&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>                            ...then emit a U+003C LESS-THAN SIGN character token, a&nbsp;</div></li><li><div>                            U+002F SOLIDUS character token, and switch to the data&nbsp;</div></li><li><div>                            state to process the next input character. */&nbsp;</div></li><li><div>                            // XXX: Probably ought to replace in_array with $following === x ||...&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // We also need to emit $name now we've consumed that, as we&nbsp;</div></li><li><div>                            // know it'll just be emitted as a character token.&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                                'data' =&gt; '&lt;/' . $name&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $state = 'data';&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            // This matches what would happen if we actually did the&nbsp;</div></li><li><div>                            // otherwise below (but we can't because we've consumed too&nbsp;</div></li><li><div>                            // much).&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Start the end tag token with the name we already have.&nbsp;</div></li><li><div>                            $this-&gt;token = array(&nbsp;</div></li><li><div>                                'name' =&gt; $name, &nbsp;</div></li><li><div>                                'type' =&gt; self::ENDTAG&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Change to tag name state.&nbsp;</div></li><li><div>                            $state = 'tag name';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    } elseif ($this-&gt;content_model === self::PCDATA) {&nbsp;</div></li><li><div>                        /** Otherwise, if the content model flag is set to the PCDATA&nbsp;</div></li><li><div>                        state [...]: */&nbsp;</div></li><li><div>                        $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                            /** U+0041 LATIN LETTER A through to U+005A LATIN LETTER Z&nbsp;</div></li><li><div>                            Create a new end tag token, set its tag name to the lowercase version&nbsp;</div></li><li><div>                            of the input character (add 0x0020 to the character's code point), then&nbsp;</div></li><li><div>                            switch to the tag name state. (Don't emit the token yet; further details&nbsp;</div></li><li><div>                            will be filled in before it is emitted.) */&nbsp;</div></li><li><div>                            $this-&gt;token = array(&nbsp;</div></li><li><div>                                'name' =&gt; strtolower($char), &nbsp;</div></li><li><div>                                'type' =&gt; self::ENDTAG&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $state = 'tag name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        } elseif ('a' &lt;= $char && $char &lt;= 'z') {&nbsp;</div></li><li><div>                            /** U+0061 LATIN SMALL LETTER A through to U+007A LATIN SMALL LETTER Z&nbsp;</div></li><li><div>                            Create a new end tag token, set its tag name to the&nbsp;</div></li><li><div>                            input character, then switch to the tag name state.&nbsp;</div></li><li><div>                            (Don't emit the token yet; further details will be&nbsp;</div></li><li><div>                            filled in before it is emitted.) */&nbsp;</div></li><li><div>                            $this-&gt;token = array(&nbsp;</div></li><li><div>                                'name' =&gt; $char, &nbsp;</div></li><li><div>                                'type' =&gt; self::ENDTAG&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $state = 'tag name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                            /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                            Parse error. Switch to the data state. */&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'expected-closing-tag-but-got-right-bracket'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                            $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        } elseif($char === false) {&nbsp;</div></li><li><div>                            /** EOF&nbsp;</div></li><li><div>                            Parse error. Emit a U+003C LESS-THAN SIGN character token and a U+002F&nbsp;</div></li><li><div>                            SOLIDUS character token. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'expected-closing-tag-but-got-eof'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::CHARACTER, &nbsp;</div></li><li><div>                                'data' =&gt; '&lt;/'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                            $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            /** Parse error. Switch to the bogus comment state. */&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'expected-closing-tag-but-got-char'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                            $this-&gt;token = array(&nbsp;</div></li><li><div>                                'data' =&gt; $char, &nbsp;</div></li><li><div>                                'type' =&gt; self::COMMENT&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                            $state = 'bogus comment';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'tag name':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                        U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                        U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                        U+0020 SPACE&nbsp;</div></li><li><div>                        Switch to the before attribute name state. */&nbsp;</div></li><li><div>                        $state = 'before attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '/') {&nbsp;</div></li><li><div>                        /** U+002F SOLIDUS (/)&nbsp;</div></li><li><div>                        Switch to the self-closing start tag state. */&nbsp;</div></li><li><div>                        $state = 'self-closing start tag';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                        /** U+0041 LATIN CAPITAL LETTER A through to U+005A LATIN CAPITAL LETTER Z&nbsp;</div></li><li><div>                        Append the lowercase version of the current input&nbsp;</div></li><li><div>                        character (add 0x0020 to the character's code point) to&nbsp;</div></li><li><div>                        the current tag token's tag name. Stay in the tag name state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsWhile(self::UPPER_ALPHA);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;token['name'] .= strtolower($char . $chars);&nbsp;</div></li><li><div>                        $state = 'tag name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-tag-name'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current tag token's tag name.&nbsp;</div></li><li><div>                        Stay in the tag name state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsUntil(&quot;\t\n\x0C /&gt;&quot; . self::UPPER_ALPHA);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;token['name'] .= $char . $chars;&nbsp;</div></li><li><div>                        $state = 'tag name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'before attribute name':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // this conditional is optimized, check bottom&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                        U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                        U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                        U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the before attribute name state. */&nbsp;</div></li><li><div>                        $state = 'before attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '/') {&nbsp;</div></li><li><div>                        /** U+002F SOLIDUS (/)&nbsp;</div></li><li><div>                        Switch to the self-closing start tag state. */&nbsp;</div></li><li><div>                        $state = 'self-closing start tag';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                        /** U+0041 LATIN CAPITAL LETTER A through to U+005A LATIN CAPITAL LETTER Z&nbsp;</div></li><li><div>                        Start a new attribute in the current tag token. Set that&nbsp;</div></li><li><div>                        attribute's name to the lowercase version of the current&nbsp;</div></li><li><div>                        input character (add 0x0020 to the character's code&nbsp;</div></li><li><div>                        point), and its value to the empty string. Switch to the&nbsp;</div></li><li><div>                        attribute name state.*/&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][] = array(&nbsp;</div></li><li><div>                            'name' =&gt; strtolower($char), &nbsp;</div></li><li><div>                            'value' =&gt; ''&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'expected-attribute-name-but-got-eof'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                           U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                           U+003C LESS-THAN SIGN (&lt;)&nbsp;</div></li><li><div>                           U+003D EQUALS SIGN (=)&nbsp;</div></li><li><div>                        Parse error. Treat it as per the &quot;anything else&quot; entry&nbsp;</div></li><li><div>                        below. */&nbsp;</div></li><li><div>                        if($char === '&quot;' || $char === &quot;'&quot; || $char === '&lt;' || $char === '=') {&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'invalid-character-in-attribute-name'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Start a new attribute in the current tag token. Set that attribute's&nbsp;</div></li><li><div>                        name to the current input character, and its value to the empty string.&nbsp;</div></li><li><div>                        Switch to the attribute name state. */&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][] = array(&nbsp;</div></li><li><div>                            'name' =&gt; $char, &nbsp;</div></li><li><div>                            'value' =&gt; ''&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'attribute name':&nbsp;</div></li><li><div>                    // Consume the next input character:&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // this conditional is optimized, check bottom&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                        U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                        U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                        U+0020 SPACE&nbsp;</div></li><li><div>                        Switch to the after attribute name state. */&nbsp;</div></li><li><div>                        $state = 'after attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '/') {&nbsp;</div></li><li><div>                        /** U+002F SOLIDUS (/)&nbsp;</div></li><li><div>                        Switch to the self-closing start tag state. */&nbsp;</div></li><li><div>                        $state = 'self-closing start tag';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '=') {&nbsp;</div></li><li><div>                        /** U+003D EQUALS SIGN (=)&nbsp;</div></li><li><div>                        Switch to the before attribute value state. */&nbsp;</div></li><li><div>                        $state = 'before attribute value';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                        /** U+0041 LATIN CAPITAL LETTER A through to U+005A LATIN CAPITAL LETTER Z&nbsp;</div></li><li><div>                        Append the lowercase version of the current input&nbsp;</div></li><li><div>                        character (add 0x0020 to the character's code point) to&nbsp;</div></li><li><div>                        the current attribute's name. Stay in the attribute name&nbsp;</div></li><li><div>                        state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsWhile(self::UPPER_ALPHA);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $last = count($this-&gt;token['attr']) - 1;&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][$last]['name'] .= strtolower($char . $chars);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-attribute-name'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                           U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                           U+003C LESS-THAN SIGN (&lt;)&nbsp;</div></li><li><div>                        Parse error. Treat it as per the &quot;anything else&quot;&nbsp;</div></li><li><div>                        entry below. */&nbsp;</div></li><li><div>                        if($char === '&quot;' || $char === &quot;'&quot; || $char === '&lt;') {&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'invalid-character-in-attribute-name'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current attribute's name.&nbsp;</div></li><li><div>                        Stay in the attribute name state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsUntil(&quot;\t\n\x0C /=&gt;\&quot;'&quot; . self::UPPER_ALPHA);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $last = count($this-&gt;token['attr']) - 1;&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][$last]['name'] .= $char . $chars;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** When the user agent leaves the attribute name state&nbsp;</div></li><li><div>                    (and before emitting the tag token, if appropriate), the&nbsp;</div></li><li><div>                    complete attribute's name must be compared to the other&nbsp;</div></li><li><div>                    attributes on the same token; if there is already an&nbsp;</div></li><li><div>                    attribute on the token with the exact same name, then this&nbsp;</div></li><li><div>                    is a parse error and the new attribute must be dropped, along&nbsp;</div></li><li><div>                    with the value that gets associated with it (if any). */&nbsp;</div></li><li><div>                    // this might be implemented in the emitToken method&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'after attribute name':&nbsp;</div></li><li><div>                    // Consume the next input character:&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // this is an optimized conditional, check the bottom&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                        U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                        U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                        U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the after attribute name state. */&nbsp;</div></li><li><div>                        $state = 'after attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '/') {&nbsp;</div></li><li><div>                        /** U+002F SOLIDUS (/)&nbsp;</div></li><li><div>                        Switch to the self-closing start tag state. */&nbsp;</div></li><li><div>                        $state = 'self-closing start tag';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '=') {&nbsp;</div></li><li><div>                        /** U+003D EQUALS SIGN (=)&nbsp;</div></li><li><div>                        Switch to the before attribute value state. */&nbsp;</div></li><li><div>                        $state = 'before attribute value';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                        /** U+0041 LATIN CAPITAL LETTER A through to U+005A LATIN CAPITAL LETTER Z&nbsp;</div></li><li><div>                        Start a new attribute in the current tag token. Set that&nbsp;</div></li><li><div>                        attribute's name to the lowercase version of the current&nbsp;</div></li><li><div>                        input character (add 0x0020 to the character's code&nbsp;</div></li><li><div>                        point), and its value to the empty string. Switch to the&nbsp;</div></li><li><div>                        attribute name state. */&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][] = array(&nbsp;</div></li><li><div>                            'name' =&gt; strtolower($char), &nbsp;</div></li><li><div>                            'value' =&gt; ''&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'expected-end-of-tag-but-got-eof'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                           U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                           U+003C LESS-THAN SIGN(&lt;)&nbsp;</div></li><li><div>                        Parse error. Treat it as per the &quot;anything else&quot;&nbsp;</div></li><li><div>                        entry below. */&nbsp;</div></li><li><div>                        if($char === '&quot;' || $char === &quot;'&quot; || $char === &quot;&lt;&quot;) {&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'invalid-character-after-attribute-name'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Start a new attribute in the current tag token. Set that attribute's&nbsp;</div></li><li><div>                        name to the current input character, and its value to the empty string.&nbsp;</div></li><li><div>                        Switch to the attribute name state. */&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][] = array(&nbsp;</div></li><li><div>                            'name' =&gt; $char, &nbsp;</div></li><li><div>                            'value' =&gt; ''&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'before attribute value':&nbsp;</div></li><li><div>                    // Consume the next input character:&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // this is an optimized conditional&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                        U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                        U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                        U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the before attribute value state. */&nbsp;</div></li><li><div>                        $state = 'before attribute value';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&quot;') {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                        Switch to the attribute value (double-quoted) state. */&nbsp;</div></li><li><div>                        $state = 'attribute value (double-quoted)';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&') {&nbsp;</div></li><li><div>                        /** U+0026 AMPERSAND (&)&nbsp;</div></li><li><div>                        Switch to the attribute value (unquoted) state and reconsume&nbsp;</div></li><li><div>                        this input character. */&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'attribute value (unquoted)';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '\'') {&nbsp;</div></li><li><div>                        /** U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                        Switch to the attribute value (single-quoted) state. */&nbsp;</div></li><li><div>                        $state = 'attribute value (single-quoted)';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'expected-attribute-value-but-got-right-bracket'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'expected-attribute-value-but-got-eof'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** U+003D EQUALS SIGN (=)&nbsp;</div></li><li><div>                         * U+003C LESS-THAN SIGN (&lt;)&nbsp;</div></li><li><div>                        Parse error. Treat it as per the &quot;anything else&quot; entry below. */&nbsp;</div></li><li><div>                        if($char === '=' || $char === '&lt;') {&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'equals-in-unquoted-attribute-value'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current attribute's value.&nbsp;</div></li><li><div>                        Switch to the attribute value (unquoted) state. */&nbsp;</div></li><li><div>                        $last = count($this-&gt;token['attr']) - 1;&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][$last]['value'] .= $char;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute value (unquoted)';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'attribute value (double-quoted)':&nbsp;</div></li><li><div>                    // Consume the next input character:&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === '&quot;') {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                        Switch to the after attribute value (quoted) state. */&nbsp;</div></li><li><div>                        $state = 'after attribute value (quoted)';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&') {&nbsp;</div></li><li><div>                        /** U+0026 AMPERSAND (&)&nbsp;</div></li><li><div>                        Switch to the character reference in attribute value&nbsp;</div></li><li><div>                        state, with the additional allowed character&nbsp;</div></li><li><div>                        being U+0022 QUOTATION MARK (&quot;). */&nbsp;</div></li><li><div>                        $this-&gt;characterReferenceInAttributeValue('&quot;');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-attribute-value-double-quote'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current attribute's value.&nbsp;</div></li><li><div>                        Stay in the attribute value (double-quoted) state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsUntil('&quot;&');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $last = count($this-&gt;token['attr']) - 1;&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][$last]['value'] .= $char . $chars;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute value (double-quoted)';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'attribute value (single-quoted)':&nbsp;</div></li><li><div>                    // Consume the next input character:&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;'&quot;) {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (')&nbsp;</div></li><li><div>                        Switch to the after attribute value state. */&nbsp;</div></li><li><div>                        $state = 'after attribute value (quoted)';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&') {&nbsp;</div></li><li><div>                        /** U+0026 AMPERSAND (&)&nbsp;</div></li><li><div>                        Switch to the entity in attribute value state. */&nbsp;</div></li><li><div>                        $this-&gt;characterReferenceInAttributeValue(&quot;'&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-attribute-value-single-quote'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current attribute's value.&nbsp;</div></li><li><div>                        Stay in the attribute value (single-quoted) state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsUntil(&quot;'&&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $last = count($this-&gt;token['attr']) - 1;&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][$last]['value'] .= $char . $chars;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute value (single-quoted)';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'attribute value (unquoted)':&nbsp;</div></li><li><div>                    // Consume the next input character:&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                        U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                        U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                        U+0020 SPACE&nbsp;</div></li><li><div>                        Switch to the before attribute name state. */&nbsp;</div></li><li><div>                        $state = 'before attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&') {&nbsp;</div></li><li><div>                        /** U+0026 AMPERSAND (&)&nbsp;</div></li><li><div>                        Switch to the entity in attribute value state, with the &nbsp;</div></li><li><div>                        additional allowed character  being U+003E &nbsp;</div></li><li><div>                        GREATER-THAN SIGN (&gt;). */&nbsp;</div></li><li><div>                        $this-&gt;characterReferenceInAttributeValue('&gt;');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-attribute-value-no-quotes'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                           U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                           U+003C LESS-THAN SIGN (&lt;)&nbsp;</div></li><li><div>                           U+003D EQUALS SIGN (=)&nbsp;</div></li><li><div>                        Parse error. Treat it as per the &quot;anything else&quot;&nbsp;</div></li><li><div>                        entry below. */&nbsp;</div></li><li><div>                        if($char === '&quot;' || $char === &quot;'&quot; || $char === '=' || $char == '&lt;') {&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'unexpected-character-in-unquoted-attribute-value'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current attribute's value.&nbsp;</div></li><li><div>                        Stay in the attribute value (unquoted) state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsUntil(&quot;\t\n\x0c &&gt;\&quot;'=&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $last = count($this-&gt;token['attr']) - 1;&nbsp;</div></li><li><div>                        $this-&gt;token['attr'][$last]['value'] .= $char . $chars;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'attribute value (unquoted)';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'after attribute value (quoted)':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Switch to the before attribute name state. */&nbsp;</div></li><li><div>                        $state = 'before attribute name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif ($char === '/') {&nbsp;</div></li><li><div>                        /** U+002F SOLIDUS (/)&nbsp;</div></li><li><div>                        Switch to the self-closing start tag state. */&nbsp;</div></li><li><div>                        $state = 'self-closing start tag';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-EOF-after-attribute-value'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Parse error. Reconsume the character in the before attribute&nbsp;</div></li><li><div>                        name state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-character-after-attribute-value'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'before attribute name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'self-closing start tag':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Set the self-closing flag of the current tag token.&nbsp;</div></li><li><div>                        Emit the current tag token. Switch to the data state. */&nbsp;</div></li><li><div>                        // not sure if this is the name we want&nbsp;</div></li><li><div>                        $this-&gt;token['self-closing'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Reconsume the EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-eof-after-self-closing'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Parse error. Reconsume the character in the before attribute name state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-character-after-self-closing'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'before attribute name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'bogus comment':&nbsp;</div></li><li><div>                    /** (This can only happen if the content model flag is set to the PCDATA state.) */&nbsp;</div></li><li><div>                    /** Consume every character up to the first U+003E GREATER-THAN SIGN&nbsp;</div></li><li><div>                    character (&gt;) or the end of the file (EOF), whichever comes first. Emit&nbsp;</div></li><li><div>                    a comment token whose data is the concatenation of all the characters&nbsp;</div></li><li><div>                    starting from and including the character that caused the state machine&nbsp;</div></li><li><div>                    to switch into the bogus comment state, up to and including the last&nbsp;</div></li><li><div>                    consumed character before the U+003E character, if any, or up to the&nbsp;</div></li><li><div>                    end of the file otherwise. (If the comment was started by the end of&nbsp;</div></li><li><div>                    the file (EOF), the token is empty.) */&nbsp;</div></li><li><div>                    $this-&gt;token['data'] .= (string) $this-&gt;stream-&gt;charsUntil('&gt;');&nbsp;</div></li><li><div>                    $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** Switch to the data state. */&nbsp;</div></li><li><div>                    $state = 'data';&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'markup declaration open':&nbsp;</div></li><li><div>                    // Consume for below&nbsp;</div></li><li><div>                    $hyphens = $this-&gt;stream-&gt;charsWhile('-', 2);&nbsp;</div></li><li><div>                    if ($hyphens === '-') {&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($hyphens !== '--') {&nbsp;</div></li><li><div>                        $alpha = $this-&gt;stream-&gt;charsWhile(self::ALPHA, 7);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** If the next two characters are both U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                    characters, consume those two characters, create a comment token whose&nbsp;</div></li><li><div>                    data is the empty string, and switch to the comment state. */&nbsp;</div></li><li><div>                    if($hyphens === '--') {&nbsp;</div></li><li><div>                        $state = 'comment start';&nbsp;</div></li><li><div>                        $this-&gt;token = array(&nbsp;</div></li><li><div>                            'data' =&gt; '', &nbsp;</div></li><li><div>                            'type' =&gt; self::COMMENT&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** Otherwise if the next seven characters are a case-insensitive match&nbsp;</div></li><li><div>                    for the word &quot;DOCTYPE&quot;, then consume those characters and switch to the&nbsp;</div></li><li><div>                    DOCTYPE state. */&nbsp;</div></li><li><div>                    } elseif(strtoupper($alpha) === 'DOCTYPE') {&nbsp;</div></li><li><div>                        $state = 'DOCTYPE';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // XXX not implemented&nbsp;</div></li><li><div>                    /** Otherwise, if the insertion mode is &quot;in foreign content&quot;&nbsp;</div></li><li><div>                    and the current node is not an element in the HTML namespace&nbsp;</div></li><li><div>                    and the next seven characters are an ASCII case-sensitive&nbsp;</div></li><li><div>                    match for the string &quot;[CDATA[&quot; (the five uppercase letters&nbsp;</div></li><li><div>                    &quot;CDATA&quot; with a U+005B LEFT SQUARE BRACKET character before&nbsp;</div></li><li><div>                    and after), then consume those characters and switch to the&nbsp;</div></li><li><div>                    CDATA section state (which is unrelated to the content model&nbsp;</div></li><li><div>                    flag's CDATA state). */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** Otherwise, is is a parse error. Switch to the bogus comment state.&nbsp;</div></li><li><div>                    The next character that is consumed, if any, is the first character&nbsp;</div></li><li><div>                    that will be in the comment. */&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'expected-dashes-or-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token = array(&nbsp;</div></li><li><div>                            'data' =&gt; (string) $alpha, &nbsp;</div></li><li><div>                            'type' =&gt; self::COMMENT&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                        $state = 'bogus comment';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'comment start':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($char === '-') {&nbsp;</div></li><li><div>                        /** U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                        Switch to the comment start dash state. */&nbsp;</div></li><li><div>                        $state = 'comment start dash';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Emit the comment token. Switch to the&nbsp;</div></li><li><div>                        data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'incorrect-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Emit the comment token. Reconsume the&nbsp;</div></li><li><div>                        EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the input character to the comment token's&nbsp;</div></li><li><div>                        data. Switch to the comment state. */&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= $char;&nbsp;</div></li><li><div>                        $state = 'comment';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'comment start dash':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>                    if ($char === '-') {&nbsp;</div></li><li><div>                        /** U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                        Switch to the comment end state */&nbsp;</div></li><li><div>                        $state = 'comment end';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Emit the comment token. Switch to the&nbsp;</div></li><li><div>                        data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'incorrect-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** Parse error. Emit the comment token. Reconsume the&nbsp;</div></li><li><div>                        EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= '-' . $char;&nbsp;</div></li><li><div>                        $state = 'comment';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'comment':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === '-') {&nbsp;</div></li><li><div>                        /** U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                        Switch to the comment end dash state */&nbsp;</div></li><li><div>                        $state = 'comment end dash';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Emit the comment token. Reconsume the EOF character&nbsp;</div></li><li><div>                        in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the input character to the comment token's data. Stay in&nbsp;</div></li><li><div>                        the comment state. */&nbsp;</div></li><li><div>                        $chars = $this-&gt;stream-&gt;charsUntil('-');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= $char . $chars;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'comment end dash':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === '-') {&nbsp;</div></li><li><div>                        /** U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                        Switch to the comment end state  */&nbsp;</div></li><li><div>                        $state = 'comment end';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Emit the comment token. Reconsume the EOF character&nbsp;</div></li><li><div>                        in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-comment-end-dash'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append a U+002D HYPHEN-MINUS (-) character and the input&nbsp;</div></li><li><div>                        character to the comment token's data. Switch to the comment state. */&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= '-'.$char;&nbsp;</div></li><li><div>                        $state = 'comment';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'comment end':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the comment token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '-') {&nbsp;</div></li><li><div>                        /** U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                        Parse error. Append a U+002D HYPHEN-MINUS (-) character&nbsp;</div></li><li><div>                        to the comment token's data. Stay in the comment end&nbsp;</div></li><li><div>                        state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-dash-after-double-dash-in-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= '-';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0a&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-space-after-double-dash-in-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= '--' . $char;&nbsp;</div></li><li><div>                        $state = 'comment end space';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '!') {&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-bang-after-double-dash-in-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $state = 'comment end bang';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Emit the comment token. Reconsume the&nbsp;</div></li><li><div>                        EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-comment-double-dash'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Parse error. Append two U+002D HYPHEN-MINUS (-)&nbsp;</div></li><li><div>                        characters and the input character to the comment token's&nbsp;</div></li><li><div>                        data. Switch to the comment state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-char-in-comment'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= '--'.$char;&nbsp;</div></li><li><div>                        $state = 'comment';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'comment end bang':&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>                    if ($char === '&gt;') {&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === &quot;-&quot;) {&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= '--!';&nbsp;</div></li><li><div>                        $state = 'comment end dash';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-comment-end-bang'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= '--!' . $char;&nbsp;</div></li><li><div>                        $state = 'comment';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'comment end space':&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>                    if ($char === '&gt;') {&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === '-') {&nbsp;</div></li><li><div>                        $state = 'comment end dash';&nbsp;</div></li><li><div>                    } elseif ($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= $char;&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-eof-in-comment-end-space', &nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $this-&gt;token['data'] .= $char;&nbsp;</div></li><li><div>                        $state = 'comment';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'DOCTYPE':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Switch to the before DOCTYPE name state. */&nbsp;</div></li><li><div>                        $state = 'before DOCTYPE name';&nbsp;</div></li><li><div>                    &nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Create a new DOCTYPE token. Set its&nbsp;</div></li><li><div>                        force-quirks flag to on. Emit the token. Reconsume the&nbsp;</div></li><li><div>                        EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'need-space-after-doctype-but-got-eof'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'name' =&gt; '', &nbsp;</div></li><li><div>                            'type' =&gt; self::DOCTYPE, &nbsp;</div></li><li><div>                            'force-quirks' =&gt; true, &nbsp;</div></li><li><div>                            'error' =&gt; true&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Parse error. Reconsume the current character in the&nbsp;</div></li><li><div>                        before DOCTYPE name state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'need-space-after-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'before DOCTYPE name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'before DOCTYPE name':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the before DOCTYPE name state. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Create a new DOCTYPE token. Set its&nbsp;</div></li><li><div>                        force-quirks flag to on. Emit the token. Switch to the&nbsp;</div></li><li><div>                        data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'expected-doctype-name-but-got-right-bracket'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'name' =&gt; '', &nbsp;</div></li><li><div>                            'type' =&gt; self::DOCTYPE, &nbsp;</div></li><li><div>                            'force-quirks' =&gt; true, &nbsp;</div></li><li><div>                            'error' =&gt; true&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                        /** U+0041 LATIN CAPITAL LETTER A through to U+005A LATIN CAPITAL LETTER Z&nbsp;</div></li><li><div>                        Create a new DOCTYPE token. Set the token's name to the&nbsp;</div></li><li><div>                        lowercase version of the input character (add 0x0020 to&nbsp;</div></li><li><div>                        the character's code point). Switch to the DOCTYPE name&nbsp;</div></li><li><div>                        state. */&nbsp;</div></li><li><div>                        $this-&gt;token = array(&nbsp;</div></li><li><div>                            'name' =&gt; strtolower($char), &nbsp;</div></li><li><div>                            'type' =&gt; self::DOCTYPE, &nbsp;</div></li><li><div>                            'error' =&gt; true&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'DOCTYPE name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Create a new DOCTYPE token. Set its&nbsp;</div></li><li><div>                        force-quirks flag to on. Emit the token. Reconsume the&nbsp;</div></li><li><div>                        EOF character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'expected-doctype-name-but-got-eof'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'name' =&gt; '', &nbsp;</div></li><li><div>                            'type' =&gt; self::DOCTYPE, &nbsp;</div></li><li><div>                            'force-quirks' =&gt; true, &nbsp;</div></li><li><div>                            'error' =&gt; true&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Create a new DOCTYPE token. Set the token's name to the&nbsp;</div></li><li><div>                        current input character. Switch to the DOCTYPE name state. */&nbsp;</div></li><li><div>                        $this-&gt;token = array(&nbsp;</div></li><li><div>                            'name' =&gt; $char, &nbsp;</div></li><li><div>                            'type' =&gt; self::DOCTYPE, &nbsp;</div></li><li><div>                            'error' =&gt; true&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $state = 'DOCTYPE name';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'DOCTYPE name':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Switch to the after DOCTYPE name state. */&nbsp;</div></li><li><div>                        $state = 'after DOCTYPE name';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif('A' &lt;= $char && $char &lt;= 'Z') {&nbsp;</div></li><li><div>                        /** U+0041 LATIN CAPITAL LETTER A through to U+005A LATIN CAPITAL LETTER Z&nbsp;</div></li><li><div>                        Append the lowercase version of the input character&nbsp;</div></li><li><div>                        (add 0x0020 to the character's code point) to the current&nbsp;</div></li><li><div>                        DOCTYPE token's name. Stay in the DOCTYPE name state. */&nbsp;</div></li><li><div>                        $this-&gt;token['name'] .= strtolower($char);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype-name'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current&nbsp;</div></li><li><div>                        DOCTYPE token's name. Stay in the DOCTYPE name state. */&nbsp;</div></li><li><div>                        $this-&gt;token['name'] .= $char;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // XXX this is probably some sort of quirks mode designation, &nbsp;</div></li><li><div>                    // check tree-builder to be sure. In general 'error' needs&nbsp;</div></li><li><div>                    // to be specc'ified, this probably means removing it at the end&nbsp;</div></li><li><div>                    $this-&gt;token['error'] = ($this-&gt;token['name'] === 'HTML')&nbsp;</div></li><li><div>                        ? false&nbsp;</div></li><li><div>                        : true;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'after DOCTYPE name':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the after DOCTYPE name state. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $nextSix = strtoupper($char . $this-&gt;stream-&gt;charsWhile(self::ALPHA, 5));&nbsp;</div></li><li><div>                        if ($nextSix === 'PUBLIC') {&nbsp;</div></li><li><div>                            /** If the next six characters are an ASCII&nbsp;</div></li><li><div>                            case-insensitive match for the word &quot;PUBLIC&quot;, then&nbsp;</div></li><li><div>                            consume those characters and switch to the before&nbsp;</div></li><li><div>                            DOCTYPE public identifier state. */&nbsp;</div></li><li><div>                            $state = 'before DOCTYPE public identifier';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        } elseif ($nextSix === 'SYSTEM') {&nbsp;</div></li><li><div>                            /** Otherwise, if the next six characters are an ASCII&nbsp;</div></li><li><div>                            case-insensitive match for the word &quot;SYSTEM&quot;, then&nbsp;</div></li><li><div>                            consume those characters and switch to the before&nbsp;</div></li><li><div>                            DOCTYPE system identifier state. */&nbsp;</div></li><li><div>                            $state = 'before DOCTYPE system identifier';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            /** Otherwise, this is the parse error. Set the DOCTYPE&nbsp;</div></li><li><div>                            token's force-quirks flag to on. Switch to the bogus&nbsp;</div></li><li><div>                            DOCTYPE state. */&nbsp;</div></li><li><div>                            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                                'data' =&gt; 'expected-space-or-right-bracket-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                            $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                            $this-&gt;token['error'] = true;&nbsp;</div></li><li><div>                            $state = 'bogus DOCTYPE';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'before DOCTYPE public identifier':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the before DOCTYPE public identifier state. */&nbsp;</div></li><li><div>                    } elseif ($char === '&quot;') {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                        Set the DOCTYPE token's public identifier to the empty&nbsp;</div></li><li><div>                        string (not missing), then switch to the DOCTYPE public&nbsp;</div></li><li><div>                        identifier (double-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['public'] = '';&nbsp;</div></li><li><div>                        $state = 'DOCTYPE public identifier (double-quoted)';&nbsp;</div></li><li><div>                    } elseif ($char === &quot;'&quot;) {&nbsp;</div></li><li><div>                        /** U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                        Set the DOCTYPE token's public identifier to the empty&nbsp;</div></li><li><div>                        string (not missing), then switch to the DOCTYPE public&nbsp;</div></li><li><div>                        identifier (single-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['public'] = '';&nbsp;</div></li><li><div>                        $state = 'DOCTYPE public identifier (single-quoted)';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-end-of-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks&nbsp;</div></li><li><div>                        flag to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Switch to the bogus DOCTYPE state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-char-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $state = 'bogus DOCTYPE';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'DOCTYPE public identifier (double-quoted)':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($char === '&quot;') {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                        Switch to the after DOCTYPE public identifier state. */&nbsp;</div></li><li><div>                        $state = 'after DOCTYPE public identifier';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-end-of-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current&nbsp;</div></li><li><div>                        DOCTYPE token's public identifier. Stay in the DOCTYPE&nbsp;</div></li><li><div>                        public identifier (double-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['public'] .= $char;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'DOCTYPE public identifier (single-quoted)':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($char === &quot;'&quot;) {&nbsp;</div></li><li><div>                        /** U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                        Switch to the after DOCTYPE public identifier state. */&nbsp;</div></li><li><div>                        $state = 'after DOCTYPE public identifier';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-end-of-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current&nbsp;</div></li><li><div>                        DOCTYPE token's public identifier. Stay in the DOCTYPE&nbsp;</div></li><li><div>                        public identifier (double-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['public'] .= $char;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'after DOCTYPE public identifier':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the after DOCTYPE public identifier state. */&nbsp;</div></li><li><div>                    } elseif ($char === '&quot;') {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                        Set the DOCTYPE token's system identifier to the&nbsp;</div></li><li><div>                        empty string (not missing), then switch to the DOCTYPE&nbsp;</div></li><li><div>                        system identifier (double-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['system'] = '';&nbsp;</div></li><li><div>                        $state = 'DOCTYPE system identifier (double-quoted)';&nbsp;</div></li><li><div>                    } elseif ($char === &quot;'&quot;) {&nbsp;</div></li><li><div>                        /** U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                        Set the DOCTYPE token's system identifier to the&nbsp;</div></li><li><div>                        empty string (not missing), then switch to the DOCTYPE&nbsp;</div></li><li><div>                        system identifier (single-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['system'] = '';&nbsp;</div></li><li><div>                        $state = 'DOCTYPE system identifier (single-quoted)';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks&nbsp;</div></li><li><div>                        flag to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Switch to the bogus DOCTYPE state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-char-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $state = 'bogus DOCTYPE';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'before DOCTYPE system identifier':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the before DOCTYPE system identifier state. */&nbsp;</div></li><li><div>                    } elseif ($char === '&quot;') {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                        Set the DOCTYPE token's system identifier to the empty&nbsp;</div></li><li><div>                        string (not missing), then switch to the DOCTYPE system&nbsp;</div></li><li><div>                        identifier (double-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['system'] = '';&nbsp;</div></li><li><div>                        $state = 'DOCTYPE system identifier (double-quoted)';&nbsp;</div></li><li><div>                    } elseif ($char === &quot;'&quot;) {&nbsp;</div></li><li><div>                        /** U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                        Set the DOCTYPE token's system identifier to the empty&nbsp;</div></li><li><div>                        string (not missing), then switch to the DOCTYPE system&nbsp;</div></li><li><div>                        identifier (single-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['system'] = '';&nbsp;</div></li><li><div>                        $state = 'DOCTYPE system identifier (single-quoted)';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-char-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks&nbsp;</div></li><li><div>                        flag to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Switch to the bogus DOCTYPE state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-char-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $state = 'bogus DOCTYPE';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'DOCTYPE system identifier (double-quoted)':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($char === '&quot;') {&nbsp;</div></li><li><div>                        /** U+0022 QUOTATION MARK (&quot;)&nbsp;</div></li><li><div>                        Switch to the after DOCTYPE system identifier state. */&nbsp;</div></li><li><div>                        $state = 'after DOCTYPE system identifier';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-end-of-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current&nbsp;</div></li><li><div>                        DOCTYPE token's system identifier. Stay in the DOCTYPE&nbsp;</div></li><li><div>                        system identifier (double-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['system'] .= $char;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'DOCTYPE system identifier (single-quoted)':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($char === &quot;'&quot;) {&nbsp;</div></li><li><div>                        /** U+0027 APOSTROPHE (')&nbsp;</div></li><li><div>                        Switch to the after DOCTYPE system identifier state. */&nbsp;</div></li><li><div>                        $state = 'after DOCTYPE system identifier';&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-end-of-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Parse error. Set the DOCTYPE token's force-quirks flag&nbsp;</div></li><li><div>                        to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Append the current input character to the current&nbsp;</div></li><li><div>                        DOCTYPE token's system identifier. Stay in the DOCTYPE&nbsp;</div></li><li><div>                        system identifier (double-quoted) state. */&nbsp;</div></li><li><div>                        $this-&gt;token['system'] .= $char;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'after DOCTYPE system identifier':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if($char === &quot;\t&quot; || $char === &quot;\n&quot; || $char === &quot;\x0c&quot; || $char === ' ') {&nbsp;</div></li><li><div>                        /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>                           U+000A LINE FEED (LF)&nbsp;</div></li><li><div>                           U+000C FORM FEED (FF)&nbsp;</div></li><li><div>                           U+0020 SPACE&nbsp;</div></li><li><div>                        Stay in the after DOCTYPE system identifier state. */&nbsp;</div></li><li><div>                    } elseif ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the current DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } elseif ($char === false) {&nbsp;</div></li><li><div>                        /** Parse error. Set the DOCTYPE token's force-quirks&nbsp;</div></li><li><div>                        flag to on. Emit that DOCTYPE token. Reconsume the EOF&nbsp;</div></li><li><div>                        character in the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'eof-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $this-&gt;token['force-quirks'] = true;&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Parse error. Switch to the bogus DOCTYPE state.&nbsp;</div></li><li><div>                        (This does not set the DOCTYPE token's force-quirks&nbsp;</div></li><li><div>                        flag to on.) */&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'unexpected-char-in-doctype'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        $state = 'bogus DOCTYPE';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                case 'bogus DOCTYPE':&nbsp;</div></li><li><div>                    /** Consume the next input character: */&nbsp;</div></li><li><div>                    $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($char === '&gt;') {&nbsp;</div></li><li><div>                        /** U+003E GREATER-THAN SIGN (&gt;)&nbsp;</div></li><li><div>                        Emit the DOCTYPE token. Switch to the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } elseif($char === false) {&nbsp;</div></li><li><div>                        /** EOF&nbsp;</div></li><li><div>                        Emit the DOCTYPE token. Reconsume the EOF character in&nbsp;</div></li><li><div>                        the data state. */&nbsp;</div></li><li><div>                        $this-&gt;emitToken($this-&gt;token);&nbsp;</div></li><li><div>                        $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                        $state = 'data';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        /** Anything else&nbsp;</div></li><li><div>                        Stay in the bogus DOCTYPE state. */&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // case 'cdataSection':&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Returns a serialized representation of the tree.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function save() {&nbsp;</div></li><li><div>        return $this-&gt;tree-&gt;save();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>        &nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * @return HTML5_TreeBuilder The tree&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        public function getTree() {&nbsp;</div></li><li><div>            return $this-&gt;tree;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Returns the input stream.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function stream() {&nbsp;</div></li><li><div>        return $this-&gt;stream;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function consumeCharacterReference($allowed = false, $inattr = false) {&nbsp;</div></li><li><div>        // This goes quite far against spec, and is far closer to the Python&nbsp;</div></li><li><div>        // impl., mainly because we don't do the large unconsuming the spec&nbsp;</div></li><li><div>        // requires.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // All consumed characters.&nbsp;</div></li><li><div>        $chars = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** This section defines how to consume a character&nbsp;</div></li><li><div>        reference. This definition is used when parsing character&nbsp;</div></li><li><div>        references in text and in attributes.&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        The behavior depends on the identity of the next character&nbsp;</div></li><li><div>        (the one immediately after the U+0026 AMPERSAND character): */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (&nbsp;</div></li><li><div>            $chars[0] === &quot;\x09&quot; ||&nbsp;</div></li><li><div>            $chars[0] === &quot;\x0A&quot; ||&nbsp;</div></li><li><div>            $chars[0] === &quot;\x0C&quot; ||&nbsp;</div></li><li><div>            $chars[0] === &quot;\x20&quot; ||&nbsp;</div></li><li><div>            $chars[0] === '&lt;' ||&nbsp;</div></li><li><div>            $chars[0] === '&' ||&nbsp;</div></li><li><div>            $chars === false ||&nbsp;</div></li><li><div>            $chars[0] === $allowed&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>            /** U+0009 CHARACTER TABULATION&nbsp;</div></li><li><div>               U+000A LINE FEED (LF)&nbsp;</div></li><li><div>               U+000C FORM FEED (FF)&nbsp;</div></li><li><div>               U+0020 SPACE&nbsp;</div></li><li><div>               U+003C LESS-THAN SIGN&nbsp;</div></li><li><div>               U+0026 AMPERSAND&nbsp;</div></li><li><div>               EOF&nbsp;</div></li><li><div>               The additional allowed character, if there is one&nbsp;</div></li><li><div>            Not a character reference. No characters are consumed, &nbsp;</div></li><li><div>            and nothing is returned. (This is not an error, either.) */&nbsp;</div></li><li><div>            // We already consumed, so unconsume.&nbsp;</div></li><li><div>            $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>            return '&';&nbsp;</div></li><li><div>        } elseif ($chars[0] === '#') {&nbsp;</div></li><li><div>            /** Consume the U+0023 NUMBER SIGN. */&nbsp;</div></li><li><div>            // Um, yeah, we already did that.&nbsp;</div></li><li><div>            /** The behavior further depends on the character after&nbsp;</div></li><li><div>            the U+0023 NUMBER SIGN: */&nbsp;</div></li><li><div>            $chars .= $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>            if (isset($chars[1]) && ($chars[1] === 'x' || $chars[1] === 'X')) {&nbsp;</div></li><li><div>                /** U+0078 LATIN SMALL LETTER X&nbsp;</div></li><li><div>                   U+0058 LATIN CAPITAL LETTER X */&nbsp;</div></li><li><div>                /** Consume the X. */&nbsp;</div></li><li><div>                // Um, yeah, we already did that.&nbsp;</div></li><li><div>                /** Follow the steps below, but using the range of&nbsp;</div></li><li><div>                characters U+0030 DIGIT ZERO through to U+0039 DIGIT&nbsp;</div></li><li><div>                NINE, U+0061 LATIN SMALL LETTER A through to U+0066&nbsp;</div></li><li><div>                LATIN SMALL LETTER F, and U+0041 LATIN CAPITAL LETTER&nbsp;</div></li><li><div>                A, through to U+0046 LATIN CAPITAL LETTER F (in other&nbsp;</div></li><li><div>                words, 0123456789, ABCDEF, abcdef). */&nbsp;</div></li><li><div>                $char_class = self::HEX;&nbsp;</div></li><li><div>                /** When it comes to interpreting the&nbsp;</div></li><li><div>                number, interpret it as a hexadecimal number. */&nbsp;</div></li><li><div>                $hex = true;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                /** Anything else */&nbsp;</div></li><li><div>                // Unconsume because we shouldn't have consumed this.&nbsp;</div></li><li><div>                $chars = $chars[0];&nbsp;</div></li><li><div>                $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                /** Follow the steps below, but using the range of&nbsp;</div></li><li><div>                characters U+0030 DIGIT ZERO through to U+0039 DIGIT&nbsp;</div></li><li><div>                NINE (i.e. just 0123456789). */&nbsp;</div></li><li><div>                $char_class = self::DIGIT;&nbsp;</div></li><li><div>                /** When it comes to interpreting the number, &nbsp;</div></li><li><div>                interpret it as a decimal number. */&nbsp;</div></li><li><div>                $hex = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** Consume as many characters as match the range of characters given above. */&nbsp;</div></li><li><div>            $consumed = $this-&gt;stream-&gt;charsWhile($char_class);&nbsp;</div></li><li><div>            if ($consumed === '' || $consumed === false) {&nbsp;</div></li><li><div>                /** If no characters match the range, then don't consume&nbsp;</div></li><li><div>                any characters (and unconsume the U+0023 NUMBER SIGN&nbsp;</div></li><li><div>                character and, if appropriate, the X character). This&nbsp;</div></li><li><div>                is a parse error; nothing is returned. */&nbsp;</div></li><li><div>                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                    'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                    'data' =&gt; 'expected-numeric-entity'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                return '&' . $chars;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                /** Otherwise, if the next character is a U+003B SEMICOLON, &nbsp;</div></li><li><div>                consume that too. If it isn't, there is a parse error. */&nbsp;</div></li><li><div>                if ($this-&gt;stream-&gt;char() !== ';') {&nbsp;</div></li><li><div>                    $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                    $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                        'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                        'data' =&gt; 'numeric-entity-without-semicolon'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /** If one or more characters match the range, then take&nbsp;</div></li><li><div>                them all and interpret the string of characters as a number&nbsp;</div></li><li><div>                (either hexadecimal or decimal as appropriate). */&nbsp;</div></li><li><div>                $codepoint = $hex ? hexdec($consumed) : (int) $consumed;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /** If that number is one of the numbers in the first column&nbsp;</div></li><li><div>                of the following table, then this is a parse error. Find the&nbsp;</div></li><li><div>                row with that number in the first column, and return a&nbsp;</div></li><li><div>                character token for the Unicode character given in the&nbsp;</div></li><li><div>                second column of that row. */&nbsp;</div></li><li><div>                $new_codepoint = HTML5_Data::getRealCodepoint($codepoint);&nbsp;</div></li><li><div>                if ($new_codepoint) {&nbsp;</div></li><li><div>                    $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                        'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                        'data' =&gt; 'illegal-windows-1252-entity'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                    return HTML5_Data::utf8chr($new_codepoint);&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    /** Otherwise, if the number is greater than 0x10FFFF, then &nbsp;</div></li><li><div>                     * this is a parse error. Return a U+FFFD REPLACEMENT &nbsp;</div></li><li><div>                     * CHARACTER. */&nbsp;</div></li><li><div>                    if ($codepoint &gt; 0x10FFFF) {&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'overlong-character-entity' // XXX probably not correct&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                        return &quot;\xEF\xBF\xBD&quot;;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    /** Otherwise, return a character token for the Unicode &nbsp;</div></li><li><div>                     * character whose code point is that number.  If the &nbsp;</div></li><li><div>                     * number is in the range 0x0001 to 0x0008, 0x000E to &nbsp;</div></li><li><div>                     * 0x001F, 0x007F  to 0x009F, 0xD800 to 0xDFFF, 0xFDD0 to &nbsp;</div></li><li><div>                     * 0xFDEF, or is one of 0x000B, 0xFFFE, 0xFFFF, 0x1FFFE, &nbsp;</div></li><li><div>                     * 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE, 0x3FFFF, 0x4FFFE, &nbsp;</div></li><li><div>                     * 0x4FFFF, 0x5FFFE, 0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE, &nbsp;</div></li><li><div>                     * 0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE, 0x9FFFF, 0xAFFFE, &nbsp;</div></li><li><div>                     * 0xAFFFF, 0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE, &nbsp;</div></li><li><div>                     * 0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 0xFFFFF, 0x10FFFE, &nbsp;</div></li><li><div>                     * or 0x10FFFF, then this is a parse error. */&nbsp;</div></li><li><div>                    // && has higher precedence than ||&nbsp;</div></li><li><div>                    if (&nbsp;</div></li><li><div>                        $codepoint &gt;= 0x0000 && $codepoint &lt;= 0x0008 ||&nbsp;</div></li><li><div>                        $codepoint === 0x000B ||&nbsp;</div></li><li><div>                        $codepoint &gt;= 0x000E && $codepoint &lt;= 0x001F ||&nbsp;</div></li><li><div>                        $codepoint &gt;= 0x007F && $codepoint &lt;= 0x009F ||&nbsp;</div></li><li><div>                        $codepoint &gt;= 0xD800 && $codepoint &lt;= 0xDFFF ||&nbsp;</div></li><li><div>                        $codepoint &gt;= 0xFDD0 && $codepoint &lt;= 0xFDEF ||&nbsp;</div></li><li><div>                        ($codepoint & 0xFFFE) === 0xFFFE ||&nbsp;</div></li><li><div>                        $codepoint == 0x10FFFF || $codepoint == 0x10FFFE&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                        $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                            'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                            'data' =&gt; 'illegal-codepoint-for-numeric-entity'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    return HTML5_Data::utf8chr($codepoint);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            /** Anything else */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** Consume the maximum number of characters possible, &nbsp;</div></li><li><div>            with the consumed characters matching one of the&nbsp;</div></li><li><div>            identifiers in the first column of the named character&nbsp;</div></li><li><div>            references table (in a case-sensitive manner). */&nbsp;</div></li><li><div>            // What we actually do here is consume as much as we can while it&nbsp;</div></li><li><div>            // matches the start of one of the identifiers in the first column.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $refs = HTML5_Data::getNamedCharacterReferences();&nbsp;</div></li><li><div>            &nbsp;</div></li><li><div>            // Get the longest string which is the start of an identifier&nbsp;</div></li><li><div>            // ($chars) as well as the longest identifier which matches ($id)&nbsp;</div></li><li><div>            // and its codepoint ($codepoint).&nbsp;</div></li><li><div>            $codepoint = false;&nbsp;</div></li><li><div>            $char = $chars;&nbsp;</div></li><li><div>            while ($char !== false && isset($refs[$char])) {&nbsp;</div></li><li><div>                $refs = $refs[$char];&nbsp;</div></li><li><div>                if (isset($refs['codepoint'])) {&nbsp;</div></li><li><div>                    $id = $chars;&nbsp;</div></li><li><div>                    $codepoint = $refs['codepoint'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $chars .= $char = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            &nbsp;</div></li><li><div>            // Unconsume the one character we just took which caused the while&nbsp;</div></li><li><div>            // statement to fail. This could be anything and could cause state&nbsp;</div></li><li><div>            // changes (as if it matches the while loop it must be&nbsp;</div></li><li><div>            // alphanumeric so we can just concat it to whatever we get later).&nbsp;</div></li><li><div>            $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>            if ($char !== false) {&nbsp;</div></li><li><div>                $chars = substr($chars, 0, -1);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** If no match can be made, then this is a parse error.&nbsp;</div></li><li><div>            No characters are consumed, and nothing is returned. */&nbsp;</div></li><li><div>            if (!$codepoint) {&nbsp;</div></li><li><div>                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                    'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                    'data' =&gt; 'expected-named-entity'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                return '&' . $chars;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** If the last character matched is not a U+003B SEMICOLON&nbsp;</div></li><li><div>            (;), there is a parse error. */&nbsp;</div></li><li><div>            $semicolon = true;&nbsp;</div></li><li><div>            if (substr($id, -1) !== ';') {&nbsp;</div></li><li><div>                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                    'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                    'data' =&gt; 'named-entity-without-semicolon'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                $semicolon = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** If the character reference is being consumed as part of&nbsp;</div></li><li><div>            an attribute, and the last character matched is not a&nbsp;</div></li><li><div>            U+003B SEMICOLON (;), and the next character is in the&nbsp;</div></li><li><div>            range U+0030 DIGIT ZERO to U+0039 DIGIT NINE, U+0041&nbsp;</div></li><li><div>            LATIN CAPITAL LETTER A to U+005A LATIN CAPITAL LETTER Z, &nbsp;</div></li><li><div>            or U+0061 LATIN SMALL LETTER A to U+007A LATIN SMALL LETTER Z, &nbsp;</div></li><li><div>            then, for historical reasons, all the characters that were&nbsp;</div></li><li><div>            matched after the U+0026 AMPERSAND (&) must be unconsumed, &nbsp;</div></li><li><div>            and nothing is returned. */&nbsp;</div></li><li><div>            if ($inattr && !$semicolon) {&nbsp;</div></li><li><div>                // The next character is either the next character in $chars or in the stream.&nbsp;</div></li><li><div>                if (strlen($chars) &gt; strlen($id)) {&nbsp;</div></li><li><div>                    $next = substr($chars, strlen($id), 1);&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $next = $this-&gt;stream-&gt;char();&nbsp;</div></li><li><div>                    $this-&gt;stream-&gt;unget();&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (&nbsp;</div></li><li><div>                    '0' &lt;= $next && $next &lt;= '9' ||&nbsp;</div></li><li><div>                    'A' &lt;= $next && $next &lt;= 'Z' ||&nbsp;</div></li><li><div>                    'a' &lt;= $next && $next &lt;= 'z'&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                    return '&' . $chars;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** Otherwise, return a character token for the character&nbsp;</div></li><li><div>            corresponding to the character reference name (as given&nbsp;</div></li><li><div>            by the second column of the named character references table). */&nbsp;</div></li><li><div>            return HTML5_Data::utf8chr($codepoint) . substr($chars, strlen($id));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function characterReferenceInAttributeValue($allowed = false) {&nbsp;</div></li><li><div>        /** Attempt to consume a character reference. */&nbsp;</div></li><li><div>        $entity = $this-&gt;consumeCharacterReference($allowed, true);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** If nothing is returned, append a U+0026 AMPERSAND&nbsp;</div></li><li><div>        character to the current attribute's value.&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        Otherwise, append the returned character token to the&nbsp;</div></li><li><div>        current attribute's value. */&nbsp;</div></li><li><div>        $char = (!$entity)&nbsp;</div></li><li><div>            ? '&'&nbsp;</div></li><li><div>            : $entity;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $last = count($this-&gt;token['attr']) - 1;&nbsp;</div></li><li><div>        $this-&gt;token['attr'][$last]['value'] .= $char;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Finally, switch back to the attribute value state that you&nbsp;</div></li><li><div>        were in when were switched into this state. */&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Emits a token, passing it on to the tree builder.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected function emitToken($token, $checkStream = true, $dry = false) {&nbsp;</div></li><li><div>        if ($checkStream) {&nbsp;</div></li><li><div>            // Emit errors from input stream.&nbsp;</div></li><li><div>            while ($this-&gt;stream-&gt;errors) {&nbsp;</div></li><li><div>                $this-&gt;emitToken(array_shift($this-&gt;stream-&gt;errors), false);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if($token['type'] === self::ENDTAG && !empty($token['attr'])) {&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; count($token['attr']); $i++) {&nbsp;</div></li><li><div>                $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                    'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                    'data' =&gt; 'attributes-in-end-tag'&nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if($token['type'] === self::ENDTAG && !empty($token['self-closing'])) {&nbsp;</div></li><li><div>            $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                'data' =&gt; 'self-closing-flag-on-end-tag', &nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if($token['type'] === self::STARTTAG) {&nbsp;</div></li><li><div>            // This could be changed to actually pass the tree-builder a hash&nbsp;</div></li><li><div>            $hash = array();&nbsp;</div></li><li><div>            foreach ($token['attr'] as $keypair) {&nbsp;</div></li><li><div>                if (isset($hash[$keypair['name']])) {&nbsp;</div></li><li><div>                    $this-&gt;emitToken(array(&nbsp;</div></li><li><div>                        'type' =&gt; self::PARSEERROR, &nbsp;</div></li><li><div>                        'data' =&gt; 'duplicate-attribute', &nbsp;</div></li><li><div> ));&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $hash[$keypair['name']] = $keypair['value'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if(!$dry) {&nbsp;</div></li><li><div>            // the current structure of attributes is not a terribly good one&nbsp;</div></li><li><div>            $this-&gt;tree-&gt;emitToken($token);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if(!$dry && is_int($this-&gt;tree-&gt;content_model)) {&nbsp;</div></li><li><div>            $this-&gt;content_model = $this-&gt;tree-&gt;content_model;&nbsp;</div></li><li><div>            $this-&gt;tree-&gt;content_model = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        } elseif($token['type'] === self::ENDTAG) {&nbsp;</div></li><li><div>            $this-&gt;content_model = self::PCDATA;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 1.6.1</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.5/classes/html5_tokenizer/" class="active">1.6.5</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.4/classes/html5_tokenizer/" class="">1.6.4</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.3/classes/html5_tokenizer/" class="">1.6.3</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.2/classes/html5_tokenizer/" class="">1.6.2</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices-packing-slips/1.6.1/classes/html5_tokenizer/" class="">1.6.1</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>HTML5_Tokenizer</li><li><span></span>WooCommerce PDF Invoices &amp; Packing Slips</li><li><span></span>1.6.5</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>