<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="3.3.50" data-slug="wordpress-twitter-bootstrap-css" data-type="class" data-id="31889"><head xmlns="http://www.w3.org/1999/xhtml"><title> less_parser | class | WordPress Twitter Bootstrap Css | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="Less_Parser, class, plugin, wordpress-twitter-bootstrap-css, 3.3.50" /><meta name="description" content="Class for parsing and compiling less files into css" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.10"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=2c635a5536fa4c8381d9b3970275796e' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.10' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/less_parser/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fless_parser%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fless_parser%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-wordpress-twitter-bootstrap-css-3.3.50-class-less_parser","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="less_parser" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to wordpress-twitter-bootstrap-c&hellip;." href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/" class="plugin"><span property="name">wordpress-twitter-bootstrap-c&hellip;</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 3.3.50." href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/" class="H_VERSION"><span property="name">3.3.50</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">less_parser</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="115"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/all/" title="All">All <span class="count badge">115</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="16"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/hooks/" title="Hooks">Hooks <span class="count badge">16</span></a></li><li class="" data-id="action" data-count="4"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/actions/" title="Actions">Actions <span class="count badge">4</span></a></li><li class="" data-id="filter" data-count="12"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/filters/" title="Filters">Filters <span class="count badge">12</span></a></li><li class="active" data-id="class" data-count="88"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/classes/" title="Classes">Classes <span class="count badge">88</span></a></li><li class="" data-id="constant" data-count="1"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/constants/" title="Constants">Constants <span class="count badge">1</span></a></li><li class="" data-id="function" data-count="8"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/functions/" title="Functions">Functions <span class="count badge">8</span></a></li><li class="" data-id="shortcode" data-count="2"><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">2</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>Less_Parser</strong></h1><p>Class for parsing and compiling less files into css.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/files/inc-less-php-parser/" class="file">/inc/Less.php/Parser.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="12" class="block" start="12"><li><div>class Less_Parser{&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Default parser options&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static $default_options = array(&nbsp;</div></li><li><div>        'compress' =&gt; false, // option - whether to compress&nbsp;</div></li><li><div>        'strictUnits' =&gt; false, // whether units need to evaluate correctly&nbsp;</div></li><li><div>        'strictMath' =&gt; false, // whether math has to be within parenthesis&nbsp;</div></li><li><div>        'relativeUrls' =&gt; true, // option - whether to adjust URL's to be relative&nbsp;</div></li><li><div>        'urlArgs' =&gt; array(), // whether to add args into url tokens&nbsp;</div></li><li><div>        'numPrecision' =&gt; 8, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        'import_dirs' =&gt; array(), &nbsp;</div></li><li><div>        'import_callback' =&gt; null, &nbsp;</div></li><li><div>        'cache_dir' =&gt; null, &nbsp;</div></li><li><div>        'cache_method' =&gt; 'php', // false, 'serialize', 'php', 'var_export', 'callback';&nbsp;</div></li><li><div>        'cache_callback_get' =&gt; null, &nbsp;</div></li><li><div>        'cache_callback_set' =&gt; null, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        'sourceMap' =&gt; false, // whether to output a source map&nbsp;</div></li><li><div>        'sourceMapBasepath' =&gt; null, &nbsp;</div></li><li><div>        'sourceMapWriteTo' =&gt; null, &nbsp;</div></li><li><div>        'sourceMapURL' =&gt; null, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        'plugins' =&gt; array(), &nbsp;</div></li><li><div>&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static $options = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private $input;                    // Less input string&nbsp;</div></li><li><div>    private $input_len;                // input string length&nbsp;</div></li><li><div>    private $pos;                    // current index in `input`&nbsp;</div></li><li><div>    private $saveStack = array();    // holds state for backtracking&nbsp;</div></li><li><div>    private $furthest;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @var Less_Environment&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private $env;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private $rules = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private static $imports = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static $has_extends = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static $next_id = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Filename to contents of all parsed the files&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @var array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static $contentsMap = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param Less_Environment|array|null $env&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function __construct( $env = null ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Top parser on an import tree must be sure there is one &quot;env&quot;&nbsp;</div></li><li><div>        // which will then be passed around by reference.&nbsp;</div></li><li><div>        if( $env instanceof Less_Environment ) {&nbsp;</div></li><li><div>            $this-&gt;env = $env;&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $this-&gt;SetOptions(Less_Parser::$default_options);&nbsp;</div></li><li><div>            $this-&gt;Reset( $env );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Reset the parser state completely&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function Reset( $options = null ) {&nbsp;</div></li><li><div>        $this-&gt;rules = array();&nbsp;</div></li><li><div>        self::$imports = array();&nbsp;</div></li><li><div>        self::$has_extends = false;&nbsp;</div></li><li><div>        self::$imports = array();&nbsp;</div></li><li><div>        self::$contentsMap = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;env = new Less_Environment($options);&nbsp;</div></li><li><div>        $this-&gt;env-&gt;Init();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //set new options&nbsp;</div></li><li><div>        if( is_array($options) ) {&nbsp;</div></li><li><div>            $this-&gt;SetOptions(Less_Parser::$default_options);&nbsp;</div></li><li><div>            $this-&gt;SetOptions($options);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set one or more compiler options&nbsp;</div></li><li><div>     *  options: import_dirs, cache_dir, cache_method&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function SetOptions( $options ) {&nbsp;</div></li><li><div>        foreach($options as $option =&gt; $value) {&nbsp;</div></li><li><div>            $this-&gt;SetOption($option, $value);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set one compiler option&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function SetOption($option, $value) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        switch($option) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'import_dirs':&nbsp;</div></li><li><div>                $this-&gt;SetImportDirs($value);&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'cache_dir':&nbsp;</div></li><li><div>                if( is_string($value) ) {&nbsp;</div></li><li><div>                    Less_Cache::SetCacheDir($value);&nbsp;</div></li><li><div>                    Less_Cache::CheckCacheDir();&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        Less_Parser::$options[$option] = $value;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Registers a new custom function&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param  string   $name     function name&nbsp;</div></li><li><div>     * @param  callable $callback callback&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function registerFunction($name, $callback) {&nbsp;</div></li><li><div>        $this-&gt;env-&gt;functions[$name] = $callback;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Removed an already registered function&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param  string $name function name&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function unregisterFunction($name) {&nbsp;</div></li><li><div>        if( isset($this-&gt;env-&gt;functions[$name]) )&nbsp;</div></li><li><div>            unset($this-&gt;env-&gt;functions[$name]);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Get the current css buffer&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function getCss() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $precision = ini_get('precision');&nbsp;</div></li><li><div>        @ini_set('precision', 16);&nbsp;</div></li><li><div>        $locale = setlocale(LC_NUMERIC, 0);&nbsp;</div></li><li><div>        setlocale(LC_NUMERIC, &quot;C&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        try {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>             $root = new Less_Tree_Ruleset(array(), $this-&gt;rules );&nbsp;</div></li><li><div>            $root-&gt;root = true;&nbsp;</div></li><li><div>            $root-&gt;firstRoot = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;PreVisitors($root);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            self::$has_extends = false;&nbsp;</div></li><li><div>            $evaldRoot = $root-&gt;compile($this-&gt;env);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;PostVisitors($evaldRoot);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( Less_Parser::$options['sourceMap'] ) {&nbsp;</div></li><li><div>                $generator = new Less_SourceMap_Generator($evaldRoot, Less_Parser::$contentsMap, Less_Parser::$options );&nbsp;</div></li><li><div>                // will also save file&nbsp;</div></li><li><div>                // FIXME: should happen somewhere else?&nbsp;</div></li><li><div>                $css = $generator-&gt;generateCSS();&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                $css = $evaldRoot-&gt;toCSS();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( Less_Parser::$options['compress'] ) {&nbsp;</div></li><li><div>                $css = preg_replace('/(^(\s)+)|((\s)+$)/', '', $css);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        } catch (Exception $exc) {&nbsp;</div></li><li><div>               // Intentional fall-through so we can reset environment&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //reset php settings&nbsp;</div></li><li><div>        @ini_set('precision', $precision);&nbsp;</div></li><li><div>        setlocale(LC_NUMERIC, $locale);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Rethrow exception after we handled resetting the environment&nbsp;</div></li><li><div>        if (!empty($exc)) {&nbsp;</div></li><li><div>                    throw $exc;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $css;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Run pre-compile visitors&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function PreVisitors($root) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( Less_Parser::$options['plugins'] ) {&nbsp;</div></li><li><div>            foreach(Less_Parser::$options['plugins'] as $plugin) {&nbsp;</div></li><li><div>                if( !empty($plugin-&gt;isPreEvalVisitor) ) {&nbsp;</div></li><li><div>                    $plugin-&gt;run($root);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Run post-compile visitors&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function PostVisitors($evaldRoot) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $visitors = array();&nbsp;</div></li><li><div>        $visitors[] = new Less_Visitor_joinSelector();&nbsp;</div></li><li><div>        if( self::$has_extends ) {&nbsp;</div></li><li><div>            $visitors[] = new Less_Visitor_processExtends();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $visitors[] = new Less_Visitor_toCSS();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( Less_Parser::$options['plugins'] ) {&nbsp;</div></li><li><div>            foreach(Less_Parser::$options['plugins'] as $plugin) {&nbsp;</div></li><li><div>                if( property_exists($plugin, 'isPreEvalVisitor') && $plugin-&gt;isPreEvalVisitor ) {&nbsp;</div></li><li><div>                    continue;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if( property_exists($plugin, 'isPreVisitor') && $plugin-&gt;isPreVisitor ) {&nbsp;</div></li><li><div>                    array_unshift( $visitors, $plugin);&nbsp;</div></li><li><div>                }else{&nbsp;</div></li><li><div>                    $visitors[] = $plugin;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for($i = 0; $i &lt; count($visitors); $i++ ) {&nbsp;</div></li><li><div>            $visitors[$i]-&gt;run($evaldRoot);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parse a Less string into css&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $str The string to convert&nbsp;</div></li><li><div>     * @param string $uri_root The url of the file&nbsp;</div></li><li><div>     * @return Less_Tree_Ruleset|Less_Parser&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function parse( $str, $file_uri = null ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !$file_uri ) {&nbsp;</div></li><li><div>            $uri_root = '';&nbsp;</div></li><li><div>            $filename = 'anonymous-file-'.Less_Parser::$next_id++.'.less';&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $file_uri = self::WinPath($file_uri);&nbsp;</div></li><li><div>            $filename = basename($file_uri);&nbsp;</div></li><li><div>            $uri_root = dirname($file_uri);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $previousFileInfo = $this-&gt;env-&gt;currentFileInfo;&nbsp;</div></li><li><div>        $uri_root = self::WinPath($uri_root);&nbsp;</div></li><li><div>        $this-&gt;SetFileInfo($filename, $uri_root);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;input = $str;&nbsp;</div></li><li><div>        $this-&gt;_parse();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $previousFileInfo ) {&nbsp;</div></li><li><div>            $this-&gt;env-&gt;currentFileInfo = $previousFileInfo;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parse a Less string from a given file&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @throws Less_Exception_Parser&nbsp;</div></li><li><div>     * @param string $filename The file to parse&nbsp;</div></li><li><div>     * @param string $uri_root The url of the file&nbsp;</div></li><li><div>     * @param bool $returnRoot Indicates whether the return value should be a css string a root node&nbsp;</div></li><li><div>     * @return Less_Tree_Ruleset|Less_Parser&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function parseFile( $filename, $uri_root = '', $returnRoot = false) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !file_exists($filename) ) {&nbsp;</div></li><li><div>            $this-&gt;Error(sprintf('File `%s` not found.', $filename));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // fix uri_root?&nbsp;</div></li><li><div>        // Instead of The mixture of file path for the first argument and directory path for the second argument has bee&nbsp;</div></li><li><div>        if( !$returnRoot && !empty($uri_root) && basename($uri_root) == basename($filename) ) {&nbsp;</div></li><li><div>            $uri_root = dirname($uri_root);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $previousFileInfo = $this-&gt;env-&gt;currentFileInfo;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $filename ) {&nbsp;</div></li><li><div>            $filename = self::WinPath(realpath($filename));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $uri_root = self::WinPath($uri_root);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;SetFileInfo($filename, $uri_root);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        self::AddParsedFile($filename);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $returnRoot ) {&nbsp;</div></li><li><div>            $rules = $this-&gt;GetRules( $filename );&nbsp;</div></li><li><div>            $return = new Less_Tree_Ruleset(array(), $rules );&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $this-&gt;_parse( $filename );&nbsp;</div></li><li><div>            $return = $this;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $previousFileInfo ) {&nbsp;</div></li><li><div>            $this-&gt;env-&gt;currentFileInfo = $previousFileInfo;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $return;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Allows a user to set variables values&nbsp;</div></li><li><div>     * @param array $vars&nbsp;</div></li><li><div>     * @return Less_Parser&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function ModifyVars( $vars ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;input = Less_Parser::serializeVars( $vars );&nbsp;</div></li><li><div>        $this-&gt;_parse();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param string $filename&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function SetFileInfo( $filename, $uri_root = '') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $filename = Less_Environment::normalizePath($filename);&nbsp;</div></li><li><div>        $dirname = preg_replace('/[^\/\\\\]*$/', '', $filename);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !empty($uri_root) ) {&nbsp;</div></li><li><div>            $uri_root = rtrim($uri_root, '/').'/';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $currentFileInfo = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //entry info&nbsp;</div></li><li><div>        if( isset($this-&gt;env-&gt;currentFileInfo) ) {&nbsp;</div></li><li><div>            $currentFileInfo['entryPath'] = $this-&gt;env-&gt;currentFileInfo['entryPath'];&nbsp;</div></li><li><div>            $currentFileInfo['entryUri'] = $this-&gt;env-&gt;currentFileInfo['entryUri'];&nbsp;</div></li><li><div>            $currentFileInfo['rootpath'] = $this-&gt;env-&gt;currentFileInfo['rootpath'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $currentFileInfo['entryPath'] = $dirname;&nbsp;</div></li><li><div>            $currentFileInfo['entryUri'] = $uri_root;&nbsp;</div></li><li><div>            $currentFileInfo['rootpath'] = $dirname;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $currentFileInfo['currentDirectory'] = $dirname;&nbsp;</div></li><li><div>        $currentFileInfo['currentUri'] = $uri_root.basename($filename);&nbsp;</div></li><li><div>        $currentFileInfo['filename'] = $filename;&nbsp;</div></li><li><div>        $currentFileInfo['uri_root'] = $uri_root;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //inherit reference&nbsp;</div></li><li><div>        if( isset($this-&gt;env-&gt;currentFileInfo['reference']) && $this-&gt;env-&gt;currentFileInfo['reference'] ) {&nbsp;</div></li><li><div>            $currentFileInfo['reference'] = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;env-&gt;currentFileInfo = $currentFileInfo;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @deprecated 1.5.1.2&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function SetCacheDir( $dir ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !file_exists($dir) ) {&nbsp;</div></li><li><div>            if( mkdir($dir) ) {&nbsp;</div></li><li><div>                return true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            throw new Less_Exception_Parser('Less.php cache directory couldn\'t be created: '.$dir);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }elseif( !is_dir($dir) ) {&nbsp;</div></li><li><div>            throw new Less_Exception_Parser('Less.php cache directory doesn\'t exist: '.$dir);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }elseif( !is_writable($dir) ) {&nbsp;</div></li><li><div>            throw new Less_Exception_Parser('Less.php cache directory isn\'t writable: '.$dir);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $dir = self::WinPath($dir);&nbsp;</div></li><li><div>            Less_Cache::$cache_dir = rtrim($dir, '/').'/';&nbsp;</div></li><li><div>            return true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set a list of directories or callbacks the parser should use for determining import paths&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param array $dirs&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function SetImportDirs( $dirs ) {&nbsp;</div></li><li><div>        Less_Parser::$options['import_dirs'] = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach($dirs as $path =&gt; $uri_root) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $path = self::WinPath($path);&nbsp;</div></li><li><div>            if( !empty($path) ) {&nbsp;</div></li><li><div>                $path = rtrim($path, '/').'/';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( !is_callable($uri_root) ) {&nbsp;</div></li><li><div>                $uri_root = self::WinPath($uri_root);&nbsp;</div></li><li><div>                if( !empty($uri_root) ) {&nbsp;</div></li><li><div>                    $uri_root = rtrim($uri_root, '/').'/';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            Less_Parser::$options['import_dirs'][$path] = $uri_root;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param string $file_path&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function _parse( $file_path = null ) {&nbsp;</div></li><li><div>        if (ini_get(&quot;mbstring.func_overload&quot;)) {&nbsp;</div></li><li><div>            $mb_internal_encoding = ini_get(&quot;mbstring.internal_encoding&quot;);&nbsp;</div></li><li><div>            @ini_set(&quot;mbstring.internal_encoding&quot;, &quot;ascii&quot;);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;rules = array_merge($this-&gt;rules, $this-&gt;GetRules( $file_path ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //reset php settings&nbsp;</div></li><li><div>        if (isset($mb_internal_encoding)) {&nbsp;</div></li><li><div>            @ini_set(&quot;mbstring.internal_encoding&quot;, $mb_internal_encoding);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Return the results of parsePrimary for $file_path&nbsp;</div></li><li><div>     * Use cache and save cached results if possible&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string|null $file_path&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function GetRules( $file_path ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;SetInput($file_path);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $cache_file = $this-&gt;CacheFile( $file_path );&nbsp;</div></li><li><div>        if( $cache_file ) {&nbsp;</div></li><li><div>            if( Less_Parser::$options['cache_method'] == 'callback' ) {&nbsp;</div></li><li><div>                if( is_callable(Less_Parser::$options['cache_callback_get']) ) {&nbsp;</div></li><li><div>                    $cache = call_user_func_array(&nbsp;</div></li><li><div>                        Less_Parser::$options['cache_callback_get'], &nbsp;</div></li><li><div>                        array($this, $file_path, $cache_file)&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if( $cache ) {&nbsp;</div></li><li><div>                        $this-&gt;UnsetInput();&nbsp;</div></li><li><div>                        return $cache;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }elseif( file_exists($cache_file) ) {&nbsp;</div></li><li><div>                switch(Less_Parser::$options['cache_method']) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Using serialize&nbsp;</div></li><li><div>                    // Faster but uses more memory&nbsp;</div></li><li><div>                    case 'serialize':&nbsp;</div></li><li><div>                        $cache = unserialize(file_get_contents($cache_file));&nbsp;</div></li><li><div>                        if( $cache ) {&nbsp;</div></li><li><div>                            touch($cache_file);&nbsp;</div></li><li><div>                            $this-&gt;UnsetInput();&nbsp;</div></li><li><div>                            return $cache;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Using generated php code&nbsp;</div></li><li><div>                    case 'var_export':&nbsp;</div></li><li><div>                    case 'php':&nbsp;</div></li><li><div>                    $this-&gt;UnsetInput();&nbsp;</div></li><li><div>                    return include($cache_file);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $rules = $this-&gt;parsePrimary();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;pos &lt; $this-&gt;input_len ) {&nbsp;</div></li><li><div>            throw new Less_Exception_Chunk($this-&gt;input, null, $this-&gt;furthest, $this-&gt;env-&gt;currentFileInfo);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;UnsetInput();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //save the cache&nbsp;</div></li><li><div>        if( $cache_file ) {&nbsp;</div></li><li><div>            if( Less_Parser::$options['cache_method'] == 'callback' ) {&nbsp;</div></li><li><div>                if( is_callable(Less_Parser::$options['cache_callback_set']) ) {&nbsp;</div></li><li><div>                    call_user_func_array(&nbsp;</div></li><li><div>                        Less_Parser::$options['cache_callback_set'], &nbsp;</div></li><li><div>                        array($this, $file_path, $cache_file, $rules)&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                //msg('write cache file');&nbsp;</div></li><li><div>                switch(Less_Parser::$options['cache_method']) {&nbsp;</div></li><li><div>                    case 'serialize':&nbsp;</div></li><li><div>                        file_put_contents( $cache_file, serialize($rules) );&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                    case 'php':&nbsp;</div></li><li><div>                        file_put_contents( $cache_file, '&lt;?php return '.self::ArgString($rules).'; ?&gt;' );&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                    case 'var_export':&nbsp;</div></li><li><div>                        //Requires __set_state()&nbsp;</div></li><li><div>                        file_put_contents( $cache_file, '&lt;?php return '.var_export($rules, true).'; ?&gt;' );&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                Less_Cache::CleanCache();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $rules;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Set up the input buffer&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function SetInput( $file_path ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $file_path ) {&nbsp;</div></li><li><div>            $this-&gt;input = file_get_contents( $file_path );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;pos = $this-&gt;furthest = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Remove potential UTF Byte Order Mark&nbsp;</div></li><li><div>        $this-&gt;input = preg_replace('/\\G\xEF\xBB\xBF/', '', $this-&gt;input);&nbsp;</div></li><li><div>        $this-&gt;input_len = strlen($this-&gt;input);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( Less_Parser::$options['sourceMap'] && $this-&gt;env-&gt;currentFileInfo ) {&nbsp;</div></li><li><div>            $uri = $this-&gt;env-&gt;currentFileInfo['currentUri'];&nbsp;</div></li><li><div>            Less_Parser::$contentsMap[$uri] = $this-&gt;input;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Free up some memory&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function UnsetInput() {&nbsp;</div></li><li><div>        unset($this-&gt;input, $this-&gt;pos, $this-&gt;input_len, $this-&gt;furthest);&nbsp;</div></li><li><div>        $this-&gt;saveStack = array();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function CacheFile( $file_path ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $file_path && $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $env = get_object_vars($this-&gt;env);&nbsp;</div></li><li><div>            unset($env['frames']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $parts = array();&nbsp;</div></li><li><div>            $parts[] = $file_path;&nbsp;</div></li><li><div>            $parts[] = filesize( $file_path );&nbsp;</div></li><li><div>            $parts[] = filemtime( $file_path );&nbsp;</div></li><li><div>            $parts[] = $env;&nbsp;</div></li><li><div>            $parts[] = Less_Version::cache_version;&nbsp;</div></li><li><div>            $parts[] = Less_Parser::$options['cache_method'];&nbsp;</div></li><li><div>            return Less_Cache::$cache_dir . Less_Cache::$prefix . base_convert( sha1(json_encode($parts) ), 16, 36) . '.lesscache';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    static function AddParsedFile($file) {&nbsp;</div></li><li><div>        self::$imports[] = $file;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    static function AllParsedFiles() {&nbsp;</div></li><li><div>        return self::$imports;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param string $file&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    static function FileParsed($file) {&nbsp;</div></li><li><div>        return in_array($file, self::$imports);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function save() {&nbsp;</div></li><li><div>        $this-&gt;saveStack[] = $this-&gt;pos;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function restore() {&nbsp;</div></li><li><div>        $this-&gt;pos = array_pop($this-&gt;saveStack);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function forget() {&nbsp;</div></li><li><div>        array_pop($this-&gt;saveStack);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function isWhitespace($offset = 0) {&nbsp;</div></li><li><div>        return preg_match('/\s/', $this-&gt;input[ $this-&gt;pos + $offset]);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parse from a token, regexp or string, and move forward if match&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param array $toks&nbsp;</div></li><li><div>     * @return array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function match($toks) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // The match is confirmed, add the match length to `this::pos`, &nbsp;</div></li><li><div>        // and consume any extra white-space characters (' ' || '\n')&nbsp;</div></li><li><div>        // which come after that. The reason for this is that LeSS's&nbsp;</div></li><li><div>        // grammar is mostly white-space insensitive.&nbsp;</div></li><li><div>        //&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        foreach($toks as $tok) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $char = $tok[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $char === '/' ) {&nbsp;</div></li><li><div>                $match = $this-&gt;MatchReg($tok);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if( $match ) {&nbsp;</div></li><li><div>                    return count($match) === 1 ? $match[0] : $match;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }elseif( $char === '#' ) {&nbsp;</div></li><li><div>                $match = $this-&gt;MatchChar($tok[1]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                // Non-terminal, match using a function call&nbsp;</div></li><li><div>                $match = $this-&gt;$tok();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $match ) {&nbsp;</div></li><li><div>                return $match;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param string[] $toks&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function MatchFuncs($toks) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;pos &lt; $this-&gt;input_len ) {&nbsp;</div></li><li><div>            foreach($toks as $tok) {&nbsp;</div></li><li><div>                $match = $this-&gt;$tok();&nbsp;</div></li><li><div>                if( $match ) {&nbsp;</div></li><li><div>                    return $match;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // Match a single character in the input, &nbsp;</div></li><li><div>    private function MatchChar($tok) {&nbsp;</div></li><li><div>        if( ($this-&gt;pos &lt; $this-&gt;input_len) && ($this-&gt;input[$this-&gt;pos] === $tok) ) {&nbsp;</div></li><li><div>            $this-&gt;skipWhitespace(1);&nbsp;</div></li><li><div>            return $tok;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // Match a regexp from the current start point&nbsp;</div></li><li><div>    private function MatchReg($tok) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( preg_match($tok, $this-&gt;input, $match, 0, $this-&gt;pos) ) {&nbsp;</div></li><li><div>            $this-&gt;skipWhitespace(strlen($match[0]));&nbsp;</div></li><li><div>            return $match;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Same as match(), but don't change the state of the parser, &nbsp;</div></li><li><div>     * just return the match.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $tok&nbsp;</div></li><li><div>     * @return integer&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function PeekReg($tok) {&nbsp;</div></li><li><div>        return preg_match($tok, $this-&gt;input, $match, 0, $this-&gt;pos);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param string $tok&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function PeekChar($tok) {&nbsp;</div></li><li><div>        //return ($this-&gt;input[$this-&gt;pos] === $tok );&nbsp;</div></li><li><div>        return ($this-&gt;pos &lt; $this-&gt;input_len) && ($this-&gt;input[$this-&gt;pos] === $tok );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param integer $length&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function skipWhitespace($length) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;pos += $length;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for(; $this-&gt;pos &lt; $this-&gt;input_len; $this-&gt;pos++ ) {&nbsp;</div></li><li><div>            $c = $this-&gt;input[$this-&gt;pos];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( ($c !== &quot;\n&quot;) && ($c !== &quot;\r&quot;) && ($c !== &quot;\t&quot;) && ($c !== ' ') ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param string $tok&nbsp;</div></li><li><div>     * @param string|null $msg&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function expect($tok, $msg = NULL) {&nbsp;</div></li><li><div>        $result = $this-&gt;match( array($tok) );&nbsp;</div></li><li><div>        if (!$result) {&nbsp;</div></li><li><div>            $this-&gt;Error( $msg    ? &quot;Expected '&quot; . $tok . &quot;' got '&quot; . $this-&gt;input[$this-&gt;pos] . &quot;'&quot; : $msg );&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            return $result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param string $tok&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function expectChar($tok, $msg = null ) {&nbsp;</div></li><li><div>        $result = $this-&gt;MatchChar($tok);&nbsp;</div></li><li><div>        if( !$result ) {&nbsp;</div></li><li><div>            $this-&gt;Error( $msg ? &quot;Expected '&quot; . $tok . &quot;' got '&quot; . $this-&gt;input[$this-&gt;pos] . &quot;'&quot; : $msg );&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            return $result;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Here in, the parsing rules/functions&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The basic structure of the syntax tree generated is as follows:&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //   Ruleset -&gt;  Rule -&gt; Value -&gt; Expression -&gt; Entity&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Here's some LESS code:&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //    .class {&nbsp;</div></li><li><div>    //      color: #fff;&nbsp;</div></li><li><div>    //      border: 1px solid #000;&nbsp;</div></li><li><div>    //      width: @w + 4px;&nbsp;</div></li><li><div>    //      &gt; .child {...}&nbsp;</div></li><li><div>    //    }&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // And here's what the parse tree might look like:&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     Ruleset (Selector '.class', [&nbsp;</div></li><li><div>    //         Rule (&quot;color&quot;, Value ([Expression [Color #fff]]))&nbsp;</div></li><li><div>    //         Rule (&quot;border&quot;, Value ([Expression [Dimension 1px][Keyword &quot;solid&quot;][Color #000]]))&nbsp;</div></li><li><div>    //         Rule (&quot;width&quot;, Value ([Expression [Operation &quot;+&quot; [Variable &quot;@w&quot;][Dimension 4px]]]))&nbsp;</div></li><li><div>    //         Ruleset (Selector [Element '&gt;', '.child'], [...])&nbsp;</div></li><li><div>    // ])&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //  In general, most rules will try to parse a token with the `$()` function, and if the return&nbsp;</div></li><li><div>    //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check&nbsp;</div></li><li><div>    //  first, before parsing, that's when we use `peek()`.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The `primary` rule is the *entry* and *exit* point of the parser.&nbsp;</div></li><li><div>    // The rules here can appear at any level of the parse tree.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The recursive nature of the grammar is an interplay between the `block`&nbsp;</div></li><li><div>    // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule, &nbsp;</div></li><li><div>    // as represented by this simplified grammar:&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     primary  *  (ruleset | rule)+&nbsp;</div></li><li><div>    //     ruleset  *  selector+ block&nbsp;</div></li><li><div>    //     block    *  '{' primary '}'&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Only at one point is the primary rule not called from the&nbsp;</div></li><li><div>    // block rule: at the root level.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parsePrimary() {&nbsp;</div></li><li><div>        $root = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while( true ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $this-&gt;pos &gt;= $this-&gt;input_len ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $node = $this-&gt;parseExtend(true);&nbsp;</div></li><li><div>            if( $node ) {&nbsp;</div></li><li><div>                $root = array_merge($root, $node);&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //$node = $this-&gt;MatchFuncs( array( 'parseMixinDefinition', 'parseRule', 'parseRuleset', 'parseMixinCall', 'parseComment', 'parseDirective'));&nbsp;</div></li><li><div>            $node = $this-&gt;MatchFuncs( array( 'parseMixinDefinition', 'parseNameValue', 'parseRule', 'parseRuleset', 'parseMixinCall', 'parseComment', 'parseRulesetCall', 'parseDirective'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $node ) {&nbsp;</div></li><li><div>                $root[] = $node;&nbsp;</div></li><li><div>            }elseif( !$this-&gt;MatchReg('/\\G[\s\n;]+/') ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $this-&gt;PeekChar('}') ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $root;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // We create a Comment node for CSS comments `/* */`, &nbsp;</div></li><li><div>    // but keep the LeSS comments `//` silent, by just skipping&nbsp;</div></li><li><div>    // over them.&nbsp;</div></li><li><div>    private function parseComment() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;input[$this-&gt;pos] !== '/' ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;input[$this-&gt;pos+1] === '/' ) {&nbsp;</div></li><li><div>            $match = $this-&gt;MatchReg('/\\G\/\/.*/');&nbsp;</div></li><li><div>            return $this-&gt;NewObj4('Less_Tree_Comment', array($match[0], true, $this-&gt;pos, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //$comment = $this-&gt;MatchReg('/\\G\/\*(?:[^*]|\*+[^\/*])*\*+\/\n?/');&nbsp;</div></li><li><div>        $comment = $this-&gt;MatchReg('/\\G\/\*(?s).*?\*+\/\n?/');//not the same as less.js to prevent fatal errors&nbsp;</div></li><li><div>        if( $comment ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj4('Less_Tree_Comment', array($comment[0], false, $this-&gt;pos, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseComments() {&nbsp;</div></li><li><div>        $comments = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while( $this-&gt;pos &lt; $this-&gt;input_len ) {&nbsp;</div></li><li><div>            $comment = $this-&gt;parseComment();&nbsp;</div></li><li><div>            if( !$comment ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $comments[] = $comment;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $comments;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A string, which supports escaping &quot; and '&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     &quot;milky way&quot; 'he\'s the one!'&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesQuoted() {&nbsp;</div></li><li><div>        $j = $this-&gt;pos;&nbsp;</div></li><li><div>        $e = false;&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;input[$this-&gt;pos] === '~' ) {&nbsp;</div></li><li><div>            $j++;&nbsp;</div></li><li><div>            $e = true; // Escaped strings&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;input[$j] != '&quot;' && $this-&gt;input[$j] !== &quot;'&quot; ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($e) {&nbsp;</div></li><li><div>            $this-&gt;MatchChar('~');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Fix for #124: match escaped newlines&nbsp;</div></li><li><div>                //$str = $this-&gt;MatchReg('/\\G&quot;((?:[^&quot;\\\\\r\n]|\\\\.)*)&quot;|\'((?:[^\'\\\\\r\n]|\\\\.)*)\'/');&nbsp;</div></li><li><div>        $str = $this-&gt;MatchReg('/\\G&quot;((?:[^&quot;\\\\\r\n]|\\\\.|\\\\\r\n|\\\\[\n\r\f])*)&quot;|\'((?:[^\'\\\\\r\n]|\\\\.|\\\\\r\n|\\\\[\n\r\f])*)\'/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $str ) {&nbsp;</div></li><li><div>            $result = $str[0][0] == '&quot;' ? $str[1] : $str[2];&nbsp;</div></li><li><div>            return $this-&gt;NewObj5('Less_Tree_Quoted', array($str[0], $result, $e, $index, $this-&gt;env-&gt;currentFileInfo) );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A catch-all word, such as:&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     black border-collapse&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesKeyword() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //$k = $this-&gt;MatchReg('/\\G[_A-Za-z-][_A-Za-z0-9-]*/');&nbsp;</div></li><li><div>        $k = $this-&gt;MatchReg('/\\G%|\\G[_A-Za-z-][_A-Za-z0-9-]*/');&nbsp;</div></li><li><div>        if( $k ) {&nbsp;</div></li><li><div>            $k = $k[0];&nbsp;</div></li><li><div>            $color = $this-&gt;fromKeyword($k);&nbsp;</div></li><li><div>            if( $color ) {&nbsp;</div></li><li><div>                return $color;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Keyword', $k);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // duplicate of Less_Tree_Color::FromKeyword&nbsp;</div></li><li><div>    private function FromKeyword( $keyword ) {&nbsp;</div></li><li><div>        $keyword = strtolower($keyword);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( Less_Colors::hasOwnProperty($keyword) ) {&nbsp;</div></li><li><div>            // detect named color&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Color', substr(Less_Colors::color($keyword), 1));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $keyword === 'transparent' ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj3('Less_Tree_Color', array( array(0, 0, 0), 0, true));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A function call&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     rgb(255, 0, 255)&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // We also try to catch IE's `alpha()`, but let the `alpha` parser&nbsp;</div></li><li><div>    // deal with the details.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The arguments are parsed with the `entities.arguments` parser.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesCall() {&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !preg_match('/\\G([\w-]+|%|progid:[\w\.]+)\(/', $this-&gt;input, $name, 0, $this-&gt;pos) ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $name = $name[1];&nbsp;</div></li><li><div>        $nameLC = strtolower($name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($nameLC === 'url') {&nbsp;</div></li><li><div>            return null;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;pos += strlen($name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $nameLC === 'alpha' ) {&nbsp;</div></li><li><div>            $alpha_ret = $this-&gt;parseAlpha();&nbsp;</div></li><li><div>            if( $alpha_ret ) {&nbsp;</div></li><li><div>                return $alpha_ret;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;MatchChar('('); // Parse the '(' and consume whitespace.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $args = $this-&gt;parseEntitiesArguments();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !$this-&gt;MatchChar(')') ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($name) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj4('Less_Tree_Call', array($name, $args, $index, $this-&gt;env-&gt;currentFileInfo) );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parse a list of arguments&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return array&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseEntitiesArguments() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $args = array();&nbsp;</div></li><li><div>        while( true ) {&nbsp;</div></li><li><div>            $arg = $this-&gt;MatchFuncs( array('parseEntitiesAssignment', 'parseExpression') );&nbsp;</div></li><li><div>            if( !$arg ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $args[] = $arg;&nbsp;</div></li><li><div>            if( !$this-&gt;MatchChar(', ') ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $args;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseEntitiesLiteral() {&nbsp;</div></li><li><div>        return $this-&gt;MatchFuncs( array('parseEntitiesDimension', 'parseEntitiesColor', 'parseEntitiesQuoted', 'parseUnicodeDescriptor') );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // Assignments are argument entities for calls.&nbsp;</div></li><li><div>    // They are present in ie filter properties as shown below.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesAssignment() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $key = $this-&gt;MatchReg('/\\G\w+(?=\s?=)/');&nbsp;</div></li><li><div>        if( !$key ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !$this-&gt;MatchChar('=') ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $value = $this-&gt;parseEntity();&nbsp;</div></li><li><div>        if( $value ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj2('Less_Tree_Assignment', array($key[0], $value));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Parse url() tokens&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // We use a specific rule for urls, because they don't really behave like&nbsp;</div></li><li><div>    // standard function calls. The difference is that the argument doesn't have&nbsp;</div></li><li><div>    // to be enclosed within a string, so it can't be parsed as an Expression.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesUrl() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;input[$this-&gt;pos] !== 'u' || !$this-&gt;matchReg('/\\Gurl\(/') ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $value = $this-&gt;match( array('parseEntitiesQuoted', 'parseEntitiesVariable', '/\\Gdata\:.*?[^\)]+/', '/\\G(?:(?:\\\\[\(\)\'&quot;])|[^\(\)\'&quot;])+/') );&nbsp;</div></li><li><div>        if( !$value ) {&nbsp;</div></li><li><div>            $value = '';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;expectChar(')');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( isset($value-&gt;value) || $value instanceof Less_Tree_Variable ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj2('Less_Tree_Url', array($value, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;NewObj2('Less_Tree_Url', array( $this-&gt;NewObj1('Less_Tree_Anonymous', $value), $this-&gt;env-&gt;currentFileInfo) );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Variable entity, such as `@fink`, in&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     width: @fink + 2px&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // We use a different parser for variable definitions, &nbsp;</div></li><li><div>    // see `parsers.variable`.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesVariable() {&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>        if ($this-&gt;PeekChar('@') && ($name = $this-&gt;MatchReg('/\\G@@?[\w-]+/'))) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj3('Less_Tree_Variable', array( $name[0], $index, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // A variable entity useing the protective {} e.g. @{var}&nbsp;</div></li><li><div>    private function parseEntitiesVariableCurly() {&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;input_len &gt; ($this-&gt;pos+1) && $this-&gt;input[$this-&gt;pos] === '@' && ($curly = $this-&gt;MatchReg('/\\G@\{([\w-]+)\}/')) ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj3('Less_Tree_Variable', array('@'.$curly[1], $index, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Hexadecimal color&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     #4F3C2F&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // `rgb` and `hsl` colors are parsed through the `entities.call` parser.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesColor() {&nbsp;</div></li><li><div>        if ($this-&gt;PeekChar('#') && ($rgb = $this-&gt;MatchReg('/\\G#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/'))) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Color', $rgb[1]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Dimension, that is, a number and a unit&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     0.5em 95%&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesDimension() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $c = @ord($this-&gt;input[$this-&gt;pos]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //Is the first char of the dimension 0-9, '.', '+' or '-'&nbsp;</div></li><li><div>        if (($c &gt; 57 || $c &lt; 43) || $c === 47 || $c == 44) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $value = $this-&gt;MatchReg('/\\G([+-]?\d*\.?\d+)(%|[a-z]+)?/');&nbsp;</div></li><li><div>        if( $value ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( isset($value[2]) ) {&nbsp;</div></li><li><div>                return $this-&gt;NewObj2('Less_Tree_Dimension', array($value[1], $value[2]));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Dimension', $value[1]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A unicode descriptor, as is used in unicode-range&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // U+0?? or U+00A1-00A9&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    function parseUnicodeDescriptor() {&nbsp;</div></li><li><div>        $ud = $this-&gt;MatchReg('/\\G(U\+[0-9a-fA-F?]+)(\-[0-9a-fA-F?]+)?/');&nbsp;</div></li><li><div>        if( $ud ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_UnicodeDescriptor', $ud[0]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // JavaScript code to be evaluated&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     `window.location.href`&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntitiesJavascript() {&nbsp;</div></li><li><div>        $e = false;&nbsp;</div></li><li><div>        $j = $this-&gt;pos;&nbsp;</div></li><li><div>        if( $this-&gt;input[$j] === '~' ) {&nbsp;</div></li><li><div>            $j++;&nbsp;</div></li><li><div>            $e = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if( $this-&gt;input[$j] !== '`' ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if( $e ) {&nbsp;</div></li><li><div>            $this-&gt;MatchChar('~');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $str = $this-&gt;MatchReg('/\\G`([^`]*)`/');&nbsp;</div></li><li><div>        if( $str ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj3('Less_Tree_Javascript', array($str[1], $this-&gt;pos, $e));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The variable part of a variable definition. Used in the `rule` parser&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     @fink:&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseVariable() {&nbsp;</div></li><li><div>        if ($this-&gt;PeekChar('@') && ($name = $this-&gt;MatchReg('/\\G(@[\w-]+)\s*:/'))) {&nbsp;</div></li><li><div>            return $name[1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The variable part of a variable definition. Used in the `rule` parser&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // @fink();&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseRulesetCall() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;input[$this-&gt;pos] === '@' && ($name = $this-&gt;MatchReg('/\\G(@[\w-]+)\s*\(\s*\)\s*;/')) ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_RulesetCall', $name[1] );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // extend syntax - used to extend selectors&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    function parseExtend($isRule = false) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>        $extendList = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !$this-&gt;MatchReg( $isRule ? '/\\G&:extend\(/' : '/\\G:extend\(/' ) ) { return; }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        do{&nbsp;</div></li><li><div>            $option = null;&nbsp;</div></li><li><div>            $elements = array();&nbsp;</div></li><li><div>            while( true ) {&nbsp;</div></li><li><div>                $option = $this-&gt;MatchReg('/\\G(all)(?=\s*(\)|, ))/');&nbsp;</div></li><li><div>                if( $option ) { break; }&nbsp;</div></li><li><div>                $e = $this-&gt;parseElement();&nbsp;</div></li><li><div>                if( !$e ) { break; }&nbsp;</div></li><li><div>                $elements[] = $e;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $option ) {&nbsp;</div></li><li><div>                $option = $option[1];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $extendList[] = $this-&gt;NewObj3('Less_Tree_Extend', array( $this-&gt;NewObj1('Less_Tree_Selector', $elements), $option, $index ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }while( $this-&gt;MatchChar(&quot;, &quot;) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;expect('/\\G\)/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $isRule ) {&nbsp;</div></li><li><div>            $this-&gt;expect('/\\G;/');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $extendList;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Mixin call, with an optional argument list&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     #mixins &gt; .square(#fff);&nbsp;</div></li><li><div>    //     .rounded(4px, black);&nbsp;</div></li><li><div>    //     .button;&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The `while` loop is there because mixins can be&nbsp;</div></li><li><div>    // namespaced, but we only support the child and descendant&nbsp;</div></li><li><div>    // selector for now.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseMixinCall() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $char = $this-&gt;input[$this-&gt;pos];&nbsp;</div></li><li><div>        if( $char !== '.' && $char !== '#' ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>        $this-&gt;save(); // stop us absorbing part of an invalid selector&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $elements = $this-&gt;parseMixinCallElements();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $elements ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $this-&gt;MatchChar('(') ) {&nbsp;</div></li><li><div>                $returned = $this-&gt;parseMixinArgs(true);&nbsp;</div></li><li><div>                $args = $returned['args'];&nbsp;</div></li><li><div>                $this-&gt;expectChar(')');&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                $args = array();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $important = $this-&gt;parseImportant();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $this-&gt;parseEnd() ) {&nbsp;</div></li><li><div>                $this-&gt;forget();&nbsp;</div></li><li><div>                return $this-&gt;NewObj5('Less_Tree_Mixin_Call', array( $elements, $args, $index, $this-&gt;env-&gt;currentFileInfo, $important));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;restore();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseMixinCallElements() {&nbsp;</div></li><li><div>        $elements = array();&nbsp;</div></li><li><div>        $c = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while( true ) {&nbsp;</div></li><li><div>            $elemIndex = $this-&gt;pos;&nbsp;</div></li><li><div>            $e = $this-&gt;MatchReg('/\\G[#.](?:[\w-]|\\\\(?:[A-Fa-f0-9]{1, 6} ?|[^A-Fa-f0-9]))+/');&nbsp;</div></li><li><div>            if( !$e ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $elements[] = $this-&gt;NewObj4('Less_Tree_Element', array($c, $e[0], $elemIndex, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>            $c = $this-&gt;MatchChar('&gt;');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $elements;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * @param boolean $isCall&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseMixinArgs( $isCall ) {&nbsp;</div></li><li><div>        $expressions = array();&nbsp;</div></li><li><div>        $argsSemiColon = array();&nbsp;</div></li><li><div>        $isSemiColonSeperated = null;&nbsp;</div></li><li><div>        $argsComma = array();&nbsp;</div></li><li><div>        $expressionContainsNamed = null;&nbsp;</div></li><li><div>        $name = null;&nbsp;</div></li><li><div>        $returner = array('args'=&gt;array(), 'variadic'=&gt; false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;save();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while( true ) {&nbsp;</div></li><li><div>            if( $isCall ) {&nbsp;</div></li><li><div>                $arg = $this-&gt;MatchFuncs( array( 'parseDetachedRuleset', 'parseExpression' ) );&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $this-&gt;parseComments();&nbsp;</div></li><li><div>                if( $this-&gt;input[ $this-&gt;pos ] === '.' && $this-&gt;MatchReg('/\\G\.{3}/') ) {&nbsp;</div></li><li><div>                    $returner['variadic'] = true;&nbsp;</div></li><li><div>                    if( $this-&gt;MatchChar(&quot;;&quot;) && !$isSemiColonSeperated ) {&nbsp;</div></li><li><div>                        $isSemiColonSeperated = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if( $isSemiColonSeperated ) {&nbsp;</div></li><li><div>                        $argsSemiColon[] = array('variadic'=&gt;true);&nbsp;</div></li><li><div>                    }else{&nbsp;</div></li><li><div>                        $argsComma[] = array('variadic'=&gt;true);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $arg = $this-&gt;MatchFuncs( array('parseEntitiesVariable', 'parseEntitiesLiteral', 'parseEntitiesKeyword') );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( !$arg ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $nameLoop = null;&nbsp;</div></li><li><div>            if( $arg instanceof Less_Tree_Expression ) {&nbsp;</div></li><li><div>                $arg-&gt;throwAwayComments();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $value = $arg;&nbsp;</div></li><li><div>            $val = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $isCall ) {&nbsp;</div></li><li><div>                // Variable&nbsp;</div></li><li><div>                if( property_exists($arg, 'value') && count($arg-&gt;value) == 1 ) {&nbsp;</div></li><li><div>                    $val = $arg-&gt;value[0];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $val = $arg;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $val instanceof Less_Tree_Variable ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if( $this-&gt;MatchChar(':') ) {&nbsp;</div></li><li><div>                    if( $expressions ) {&nbsp;</div></li><li><div>                        if( $isSemiColonSeperated ) {&nbsp;</div></li><li><div>                            $this-&gt;Error('Cannot mix ; and , as delimiter types');&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $expressionContainsNamed = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // we do not support setting a ruleset as a default variable - it doesn't make sense&nbsp;</div></li><li><div>                    // However if we do want to add it, there is nothing blocking it, just don't error&nbsp;</div></li><li><div>                    // and remove isCall dependency below&nbsp;</div></li><li><div>                    $value = null;&nbsp;</div></li><li><div>                    if( $isCall ) {&nbsp;</div></li><li><div>                        $value = $this-&gt;parseDetachedRuleset();&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if( !$value ) {&nbsp;</div></li><li><div>                        $value = $this-&gt;parseExpression();&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if( !$value ) {&nbsp;</div></li><li><div>                        if( $isCall ) {&nbsp;</div></li><li><div>                            $this-&gt;Error('could not understand value for named argument');&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $this-&gt;restore();&nbsp;</div></li><li><div>                            $returner['args'] = array();&nbsp;</div></li><li><div>                            return $returner;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $nameLoop = ($name = $val-&gt;name);&nbsp;</div></li><li><div>                }elseif( !$isCall && $this-&gt;MatchReg('/\\G\.{3}/') ) {&nbsp;</div></li><li><div>                    $returner['variadic'] = true;&nbsp;</div></li><li><div>                    if( $this-&gt;MatchChar(&quot;;&quot;) && !$isSemiColonSeperated ) {&nbsp;</div></li><li><div>                        $isSemiColonSeperated = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if( $isSemiColonSeperated ) {&nbsp;</div></li><li><div>                        $argsSemiColon[] = array('name'=&gt; $arg-&gt;name, 'variadic' =&gt; true);&nbsp;</div></li><li><div>                    }else{&nbsp;</div></li><li><div>                        $argsComma[] = array('name'=&gt; $arg-&gt;name, 'variadic' =&gt; true);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }elseif( !$isCall ) {&nbsp;</div></li><li><div>                    $name = $nameLoop = $val-&gt;name;&nbsp;</div></li><li><div>                    $value = null;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $value ) {&nbsp;</div></li><li><div>                $expressions[] = $value;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $argsComma[] = array('name'=&gt;$nameLoop, 'value'=&gt;$value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $this-&gt;MatchChar(', ') ) {&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $this-&gt;MatchChar(';') || $isSemiColonSeperated ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if( $expressionContainsNamed ) {&nbsp;</div></li><li><div>                    $this-&gt;Error('Cannot mix ; and , as delimiter types');&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $isSemiColonSeperated = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if( count($expressions) &gt; 1 ) {&nbsp;</div></li><li><div>                    $value = $this-&gt;NewObj1('Less_Tree_Value', $expressions);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $argsSemiColon[] = array('name'=&gt;$name, 'value'=&gt;$value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $name = null;&nbsp;</div></li><li><div>                $expressions = array();&nbsp;</div></li><li><div>                $expressionContainsNamed = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;forget();&nbsp;</div></li><li><div>        $returner['args'] = ($isSemiColonSeperated ? $argsSemiColon : $argsComma);&nbsp;</div></li><li><div>        return $returner;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Mixin definition, with a list of parameters&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     .rounded (@radius: 2px, @color) {&nbsp;</div></li><li><div>    //        ...&nbsp;</div></li><li><div>    //     }&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Until we have a finer grained state-machine, we have to&nbsp;</div></li><li><div>    // do a look-ahead, to make sure we don't have a mixin call.&nbsp;</div></li><li><div>    // See the `rule` function for more information.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // We start by matching `.rounded (`, and then proceed on to&nbsp;</div></li><li><div>    // the argument list, which has optional default values.&nbsp;</div></li><li><div>    // We store the parameters in `params`, with a `value` key, &nbsp;</div></li><li><div>    // if there is a value, such as in the case of `@radius`.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Once we've got our params list, and a closing `)`, we parse&nbsp;</div></li><li><div>    // the `{...}` block.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseMixinDefinition() {&nbsp;</div></li><li><div>        $cond = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $char = $this-&gt;input[$this-&gt;pos];&nbsp;</div></li><li><div>        if( ($char !== '.' && $char !== '#') || ($char === '{' && $this-&gt;PeekReg('/\\G[^{]*\}/')) ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;save();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $match = $this-&gt;MatchReg('/\\G([#.](?:[\w-]|\\\(?:[A-Fa-f0-9]{1, 6} ?|[^A-Fa-f0-9]))+)\s*\(/');&nbsp;</div></li><li><div>        if( $match ) {&nbsp;</div></li><li><div>            $name = $match[1];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $argInfo = $this-&gt;parseMixinArgs( false );&nbsp;</div></li><li><div>            $params = $argInfo['args'];&nbsp;</div></li><li><div>            $variadic = $argInfo['variadic'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // .mixincall(&quot;@{a}&quot;);&nbsp;</div></li><li><div>            // looks a bit like a mixin definition..&nbsp;</div></li><li><div>            // also&nbsp;</div></li><li><div>            // .mixincall(@a: {rule: set;});&nbsp;</div></li><li><div>            // so we have to be nice and restore&nbsp;</div></li><li><div>            if( !$this-&gt;MatchChar(')') ) {&nbsp;</div></li><li><div>                $this-&gt;furthest = $this-&gt;pos;&nbsp;</div></li><li><div>                $this-&gt;restore();&nbsp;</div></li><li><div>                return;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;parseComments();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($this-&gt;MatchReg('/\\Gwhen/')) { // Guard&nbsp;</div></li><li><div>                $cond = $this-&gt;expect('parseConditions', 'Expected conditions');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $ruleset = $this-&gt;parseBlock();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( is_array($ruleset) ) {&nbsp;</div></li><li><div>                $this-&gt;forget();&nbsp;</div></li><li><div>                return $this-&gt;NewObj5('Less_Tree_Mixin_Definition', array( $name, $params, $ruleset, $cond, $variadic));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;restore();&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $this-&gt;forget();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Entities are the smallest recognized token, &nbsp;</div></li><li><div>    // and can be found inside a rule's value.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEntity() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;MatchFuncs( array('parseEntitiesLiteral', 'parseEntitiesVariable', 'parseEntitiesUrl', 'parseEntitiesCall', 'parseEntitiesKeyword', 'parseEntitiesJavascript', 'parseComment') );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Rule terminator. Note that we use `peek()` to check for '}', &nbsp;</div></li><li><div>    // because the `block` rule will be expecting it, but we still need to make sure&nbsp;</div></li><li><div>    // it's there, if ';' was ommitted.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseEnd() {&nbsp;</div></li><li><div>        return $this-&gt;MatchChar(';') || $this-&gt;PeekChar('}');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // IE's alpha function&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     alpha(opacity=88)&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseAlpha() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( ! $this-&gt;MatchReg('/\\G\(opacity=/i')) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $value = $this-&gt;MatchReg('/\\G[0-9]+/');&nbsp;</div></li><li><div>        if( $value ) {&nbsp;</div></li><li><div>            $value = $value[0];&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $value = $this-&gt;parseEntitiesVariable();&nbsp;</div></li><li><div>            if( !$value ) {&nbsp;</div></li><li><div>                return;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;expectChar(')');&nbsp;</div></li><li><div>        return $this-&gt;NewObj1('Less_Tree_Alpha', $value);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Selector Element&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     div&nbsp;</div></li><li><div>    //     + h1&nbsp;</div></li><li><div>    //     #socks&nbsp;</div></li><li><div>    //     input[type=&quot;text&quot;]&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Elements are the building blocks for Selectors, &nbsp;</div></li><li><div>    // they are made out of a `Combinator` (see combinator rule), &nbsp;</div></li><li><div>    // and an element name, such as a tag a class, or `*`.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseElement() {&nbsp;</div></li><li><div>        $c = $this-&gt;parseCombinator();&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $e = $this-&gt;match( array('/\\G(?:\d+\.\d+|\d+)%/', '/\\G(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\\\(?:[A-Fa-f0-9]{1, 6} ?|[^A-Fa-f0-9]))+/', &nbsp;</div></li><li><div>            '#*', '#&', 'parseAttribute', '/\\G\([^()@]+\)/', '/\\G[\.#](?=@)/', 'parseEntitiesVariableCurly') );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( is_null($e) ) {&nbsp;</div></li><li><div>            $this-&gt;save();&nbsp;</div></li><li><div>            if( $this-&gt;MatchChar('(') ) {&nbsp;</div></li><li><div>                if( ($v = $this-&gt;parseSelector()) && $this-&gt;MatchChar(')') ) {&nbsp;</div></li><li><div>                    $e = $this-&gt;NewObj1('Less_Tree_Paren', $v);&nbsp;</div></li><li><div>                    $this-&gt;forget();&nbsp;</div></li><li><div>                }else{&nbsp;</div></li><li><div>                    $this-&gt;restore();&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                $this-&gt;forget();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !is_null($e) ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj4('Less_Tree_Element', array( $c, $e, $index, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Combinators combine elements together, in a Selector.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Because our parser isn't white-space sensitive, special care&nbsp;</div></li><li><div>    // has to be taken, when parsing the descendant combinator, ` `, &nbsp;</div></li><li><div>    // as it's an empty space. We have to check the previous character&nbsp;</div></li><li><div>    // in the input, to see if it's a ` ` character.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseCombinator() {&nbsp;</div></li><li><div>        if( $this-&gt;pos &lt; $this-&gt;input_len ) {&nbsp;</div></li><li><div>            $c = $this-&gt;input[$this-&gt;pos];&nbsp;</div></li><li><div>            if ($c === '&gt;' || $c === '+' || $c === '~' || $c === '|' || $c === '^' ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $this-&gt;pos++;&nbsp;</div></li><li><div>                if( $this-&gt;input[$this-&gt;pos] === '^' ) {&nbsp;</div></li><li><div>                    $c = '^^';&nbsp;</div></li><li><div>                    $this-&gt;pos++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $this-&gt;skipWhitespace(0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                return $c;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $this-&gt;pos &gt; 0 && $this-&gt;isWhitespace(-1) ) {&nbsp;</div></li><li><div>                return ' ';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A CSS selector (see selector below)&nbsp;</div></li><li><div>    // with less extensions e.g. the ability to extend and guard&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseLessSelector() {&nbsp;</div></li><li><div>        return $this-&gt;parseSelector(true);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A CSS Selector&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     .class &gt; div + h1&nbsp;</div></li><li><div>    //     li a:hover&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Selectors are made out of one or more Elements, see above.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseSelector( $isLess = false ) {&nbsp;</div></li><li><div>        $elements = array();&nbsp;</div></li><li><div>        $extendList = array();&nbsp;</div></li><li><div>        $condition = null;&nbsp;</div></li><li><div>        $when = false;&nbsp;</div></li><li><div>        $extend = false;&nbsp;</div></li><li><div>        $e = null;&nbsp;</div></li><li><div>        $c = null;&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while( ($isLess && ($extend = $this-&gt;parseExtend())) || ($isLess && ($when = $this-&gt;MatchReg('/\\Gwhen/') )) || ($e = $this-&gt;parseElement()) ) {&nbsp;</div></li><li><div>            if( $when ) {&nbsp;</div></li><li><div>                $condition = $this-&gt;expect('parseConditions', 'expected condition');&nbsp;</div></li><li><div>            }elseif( $condition ) {&nbsp;</div></li><li><div>                //error(&quot;CSS guard can only be used at the end of selector&quot;);&nbsp;</div></li><li><div>            }elseif( $extend ) {&nbsp;</div></li><li><div>                $extendList = array_merge($extendList, $extend);&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                //if( count($extendList) ) {&nbsp;</div></li><li><div>                    //error(&quot;Extend can only be used at the end of selector&quot;);&nbsp;</div></li><li><div>                //}&nbsp;</div></li><li><div>                if( $this-&gt;pos &lt; $this-&gt;input_len ) {&nbsp;</div></li><li><div>                    $c = $this-&gt;input[ $this-&gt;pos ];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $elements[] = $e;&nbsp;</div></li><li><div>                $e = null;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $c === '{' || $c === '}' || $c === ';' || $c === ', ' || $c === ')') { break; }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $elements ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj5('Less_Tree_Selector', array($elements, $extendList, $condition, $index, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if( $extendList ) {&nbsp;</div></li><li><div>            $this-&gt;Error('Extend must be used to extend a selector, it cannot be used on its own');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseTag() {&nbsp;</div></li><li><div>        return ( $tag = $this-&gt;MatchReg('/\\G[A-Za-z][A-Za-z-]*[0-9]?/') ) ? $tag : $this-&gt;MatchChar('*');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseAttribute() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $val = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !$this-&gt;MatchChar('[') ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $key = $this-&gt;parseEntitiesVariableCurly();&nbsp;</div></li><li><div>        if( !$key ) {&nbsp;</div></li><li><div>            $key = $this-&gt;expect('/\\G(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\\\.)+/');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $op = $this-&gt;MatchReg('/\\G[|~*$^]?=/');&nbsp;</div></li><li><div>        if( $op ) {&nbsp;</div></li><li><div>            $val = $this-&gt;match( array('parseEntitiesQuoted', '/\\G[0-9]+%/', '/\\G[\w-]+/', 'parseEntitiesVariableCurly') );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;expectChar(']');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $this-&gt;NewObj3('Less_Tree_Attribute', array( $key, $op[0], $val));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // The `block` rule is used by `ruleset` and `mixin.definition`.&nbsp;</div></li><li><div>    // It's a wrapper around the `primary` rule, with added `{}`.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseBlock() {&nbsp;</div></li><li><div>        if( $this-&gt;MatchChar('{') ) {&nbsp;</div></li><li><div>            $content = $this-&gt;parsePrimary();&nbsp;</div></li><li><div>            if( $this-&gt;MatchChar('}') ) {&nbsp;</div></li><li><div>                return $content;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseBlockRuleset() {&nbsp;</div></li><li><div>        $block = $this-&gt;parseBlock();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $block ) {&nbsp;</div></li><li><div>            $block = $this-&gt;NewObj2('Less_Tree_Ruleset', array( null, $block));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $block;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseDetachedRuleset() {&nbsp;</div></li><li><div>        $blockRuleset = $this-&gt;parseBlockRuleset();&nbsp;</div></li><li><div>        if( $blockRuleset ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_DetachedRuleset', $blockRuleset);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // div, .class, body &gt; p {...}&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseRuleset() {&nbsp;</div></li><li><div>        $selectors = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;save();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while( true ) {&nbsp;</div></li><li><div>            $s = $this-&gt;parseLessSelector();&nbsp;</div></li><li><div>            if( !$s ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $selectors[] = $s;&nbsp;</div></li><li><div>            $this-&gt;parseComments();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $s-&gt;condition && count($selectors) &gt; 1 ) {&nbsp;</div></li><li><div>                $this-&gt;Error('Guards are only currently allowed on a single selector.');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( !$this-&gt;MatchChar(', ') ) {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if( $s-&gt;condition ) {&nbsp;</div></li><li><div>                $this-&gt;Error('Guards are only currently allowed on a single selector.');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $this-&gt;parseComments();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $selectors ) {&nbsp;</div></li><li><div>            $rules = $this-&gt;parseBlock();&nbsp;</div></li><li><div>            if( is_array($rules) ) {&nbsp;</div></li><li><div>                $this-&gt;forget();&nbsp;</div></li><li><div>                return $this-&gt;NewObj2('Less_Tree_Ruleset', array( $selectors, $rules)); //Less_Environment::$strictImports&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Backtrack&nbsp;</div></li><li><div>        $this-&gt;furthest = $this-&gt;pos;&nbsp;</div></li><li><div>        $this-&gt;restore();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Custom less.php parse function for finding simple name-value css pairs&nbsp;</div></li><li><div>     * ex: width:100px;&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseNameValue() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>        $this-&gt;save();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //$match = $this-&gt;MatchReg('/\\G([a-zA-Z\-]+)\s*:\s*((?:\'&quot;)?[a-zA-Z0-9\-% \., !]+?(?:\'&quot;)?)\s*([;}])/');&nbsp;</div></li><li><div>        $match = $this-&gt;MatchReg('/\\G([a-zA-Z\-]+)\s*:\s*([\'&quot;]?[#a-zA-Z0-9\-%\., ]+?[\'&quot;]?) *(! *important)?\s*([;}])/');&nbsp;</div></li><li><div>        if( $match ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $match[4] == '}' ) {&nbsp;</div></li><li><div>                $this-&gt;pos = $index + strlen($match[0])-1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $match[3] ) {&nbsp;</div></li><li><div>                $match[2] .= ' !important';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            return $this-&gt;NewObj4('Less_Tree_NameValue', array( $match[1], $match[2], $index, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;restore();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseRule( $tryAnonymous = null ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $merge = false;&nbsp;</div></li><li><div>        $startOfRule = $this-&gt;pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $c = $this-&gt;input[$this-&gt;pos];&nbsp;</div></li><li><div>        if( $c === '.' || $c === '#' || $c === '&' ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;save();&nbsp;</div></li><li><div>        $name = $this-&gt;MatchFuncs( array('parseVariable', 'parseRuleProperty'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $name ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $isVariable = is_string($name);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $value = null;&nbsp;</div></li><li><div>            if( $isVariable ) {&nbsp;</div></li><li><div>                $value = $this-&gt;parseDetachedRuleset();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $important = null;&nbsp;</div></li><li><div>            if( !$value ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // prefer to try to parse first if its a variable or we are compressing&nbsp;</div></li><li><div>                // but always fallback on the other one&nbsp;</div></li><li><div>                //if( !$tryAnonymous && is_string($name) && $name[0] === '@' ) {&nbsp;</div></li><li><div>                if( !$tryAnonymous && (Less_Parser::$options['compress'] || $isVariable) ) {&nbsp;</div></li><li><div>                    $value = $this-&gt;MatchFuncs( array('parseValue', 'parseAnonymousValue'));&nbsp;</div></li><li><div>                }else{&nbsp;</div></li><li><div>                    $value = $this-&gt;MatchFuncs( array('parseAnonymousValue', 'parseValue'));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $important = $this-&gt;parseImportant();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // a name returned by this.ruleProperty() is always an array of the form:&nbsp;</div></li><li><div>                // [string-1, ..., string-n, &quot;&quot;] or [string-1, ..., string-n, &quot;+&quot;]&nbsp;</div></li><li><div>                // where each item is a tree.Keyword or tree.Variable&nbsp;</div></li><li><div>                if( !$isVariable && is_array($name) ) {&nbsp;</div></li><li><div>                    $nm = array_pop($name);&nbsp;</div></li><li><div>                    if( $nm-&gt;value ) {&nbsp;</div></li><li><div>                        $merge = $nm-&gt;value;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $value && $this-&gt;parseEnd() ) {&nbsp;</div></li><li><div>                $this-&gt;forget();&nbsp;</div></li><li><div>                return $this-&gt;NewObj6('Less_Tree_Rule', array( $name, $value, $important, $merge, $startOfRule, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                $this-&gt;furthest = $this-&gt;pos;&nbsp;</div></li><li><div>                $this-&gt;restore();&nbsp;</div></li><li><div>                if( $value && !$tryAnonymous ) {&nbsp;</div></li><li><div>                    return $this-&gt;parseRule(true);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            $this-&gt;forget();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function parseAnonymousValue() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( preg_match('/\\G([^@+\/\'&quot;*`(;{}-]*);/', $this-&gt;input, $match, 0, $this-&gt;pos) ) {&nbsp;</div></li><li><div>            $this-&gt;pos += strlen($match[1]);&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Anonymous', $match[1]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // An @import directive&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     @import &quot;lib&quot;;&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // Depending on our environment, importing is done differently:&nbsp;</div></li><li><div>    // In the browser, it's an XHR request, in Node, it would be a&nbsp;</div></li><li><div>    // file-system operation. The function used for importing is&nbsp;</div></li><li><div>    // stored in `import`, which we pass to the Import constructor.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseImport() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;save();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $dir = $this-&gt;MatchReg('/\\G@import?\s+/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $dir ) {&nbsp;</div></li><li><div>            $options = $this-&gt;parseImportOptions();&nbsp;</div></li><li><div>            $path = $this-&gt;MatchFuncs( array('parseEntitiesQuoted', 'parseEntitiesUrl'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $path ) {&nbsp;</div></li><li><div>                $features = $this-&gt;parseMediaFeatures();&nbsp;</div></li><li><div>                if( $this-&gt;MatchChar(';') ) {&nbsp;</div></li><li><div>                    if( $features ) {&nbsp;</div></li><li><div>                        $features = $this-&gt;NewObj1('Less_Tree_Value', $features);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;forget();&nbsp;</div></li><li><div>                    return $this-&gt;NewObj5('Less_Tree_Import', array( $path, $features, $options, $this-&gt;pos, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;restore();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseImportOptions() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $options = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // list of options, surrounded by parens&nbsp;</div></li><li><div>        if( !$this-&gt;MatchChar('(') ) {&nbsp;</div></li><li><div>            return $options;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        do{&nbsp;</div></li><li><div>            $optionName = $this-&gt;parseImportOption();&nbsp;</div></li><li><div>            if( $optionName ) {&nbsp;</div></li><li><div>                $value = true;&nbsp;</div></li><li><div>                switch( $optionName ) {&nbsp;</div></li><li><div>                    case &quot;css&quot;:&nbsp;</div></li><li><div>                        $optionName = &quot;less&quot;;&nbsp;</div></li><li><div>                        $value = false;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                    case &quot;once&quot;:&nbsp;</div></li><li><div>                        $optionName = &quot;multiple&quot;;&nbsp;</div></li><li><div>                        $value = false;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $options[$optionName] = $value;&nbsp;</div></li><li><div>                if( !$this-&gt;MatchChar(', ') ) { break; }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }while( $optionName );&nbsp;</div></li><li><div>        $this-&gt;expectChar(')');&nbsp;</div></li><li><div>        return $options;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseImportOption() {&nbsp;</div></li><li><div>        $opt = $this-&gt;MatchReg('/\\G(less|css|multiple|once|inline|reference)/');&nbsp;</div></li><li><div>        if( $opt ) {&nbsp;</div></li><li><div>            return $opt[1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseMediaFeature() {&nbsp;</div></li><li><div>        $nodes = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        do{&nbsp;</div></li><li><div>            $e = $this-&gt;MatchFuncs(array('parseEntitiesKeyword', 'parseEntitiesVariable'));&nbsp;</div></li><li><div>            if( $e ) {&nbsp;</div></li><li><div>                $nodes[] = $e;&nbsp;</div></li><li><div>            } elseif ($this-&gt;MatchChar('(')) {&nbsp;</div></li><li><div>                $p = $this-&gt;parseProperty();&nbsp;</div></li><li><div>                $e = $this-&gt;parseValue();&nbsp;</div></li><li><div>                if ($this-&gt;MatchChar(')')) {&nbsp;</div></li><li><div>                    if ($p && $e) {&nbsp;</div></li><li><div>                        $r = $this-&gt;NewObj7('Less_Tree_Rule', array( $p, $e, null, null, $this-&gt;pos, $this-&gt;env-&gt;currentFileInfo, true));&nbsp;</div></li><li><div>                        $nodes[] = $this-&gt;NewObj1('Less_Tree_Paren', $r);&nbsp;</div></li><li><div>                    } elseif ($e) {&nbsp;</div></li><li><div>                        $nodes[] = $this-&gt;NewObj1('Less_Tree_Paren', $e);&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        return null;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else&nbsp;</div></li><li><div>                    return null;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } while ($e);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($nodes) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Expression', $nodes);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseMediaFeatures() {&nbsp;</div></li><li><div>        $features = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        do{&nbsp;</div></li><li><div>            $e = $this-&gt;parseMediaFeature();&nbsp;</div></li><li><div>            if( $e ) {&nbsp;</div></li><li><div>                $features[] = $e;&nbsp;</div></li><li><div>                if (!$this-&gt;MatchChar(', ')) break;&nbsp;</div></li><li><div>            }else{&nbsp;</div></li><li><div>                $e = $this-&gt;parseEntitiesVariable();&nbsp;</div></li><li><div>                if( $e ) {&nbsp;</div></li><li><div>                    $features[] = $e;&nbsp;</div></li><li><div>                    if (!$this-&gt;MatchChar(', ')) break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } while ($e);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $features ? $features : null;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseMedia() {&nbsp;</div></li><li><div>        if( $this-&gt;MatchReg('/\\G@media/') ) {&nbsp;</div></li><li><div>            $features = $this-&gt;parseMediaFeatures();&nbsp;</div></li><li><div>            $rules = $this-&gt;parseBlock();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( is_array($rules) ) {&nbsp;</div></li><li><div>                return $this-&gt;NewObj4('Less_Tree_Media', array( $rules, $features, $this-&gt;pos, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A CSS Directive&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // @charset &quot;utf-8&quot;;&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseDirective() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !$this-&gt;PeekChar('@') ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $rules = null;&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>        $hasBlock = true;&nbsp;</div></li><li><div>        $hasIdentifier = false;&nbsp;</div></li><li><div>        $hasExpression = false;&nbsp;</div></li><li><div>        $hasUnknown = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $value = $this-&gt;MatchFuncs(array('parseImport', 'parseMedia'));&nbsp;</div></li><li><div>        if( $value ) {&nbsp;</div></li><li><div>            return $value;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;save();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $name = $this-&gt;MatchReg('/\\G@[a-z-]+/');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( !$name ) return;&nbsp;</div></li><li><div>        $name = $name[0];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $nonVendorSpecificName = $name;&nbsp;</div></li><li><div>        $pos = strpos($name, '-', 2);&nbsp;</div></li><li><div>        if( $name[1] == '-' && $pos &gt; 0 ) {&nbsp;</div></li><li><div>            $nonVendorSpecificName = &quot;@&quot; . substr($name, $pos + 1);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        switch( $nonVendorSpecificName ) {&nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>            case &quot;@font-face&quot;:&nbsp;</div></li><li><div>            case &quot;@viewport&quot;:&nbsp;</div></li><li><div>            case &quot;@top-left&quot;:&nbsp;</div></li><li><div>            case &quot;@top-left-corner&quot;:&nbsp;</div></li><li><div>            case &quot;@top-center&quot;:&nbsp;</div></li><li><div>            case &quot;@top-right&quot;:&nbsp;</div></li><li><div>            case &quot;@top-right-corner&quot;:&nbsp;</div></li><li><div>            case &quot;@bottom-left&quot;:&nbsp;</div></li><li><div>            case &quot;@bottom-left-corner&quot;:&nbsp;</div></li><li><div>            case &quot;@bottom-center&quot;:&nbsp;</div></li><li><div>            case &quot;@bottom-right&quot;:&nbsp;</div></li><li><div>            case &quot;@bottom-right-corner&quot;:&nbsp;</div></li><li><div>            case &quot;@left-top&quot;:&nbsp;</div></li><li><div>            case &quot;@left-middle&quot;:&nbsp;</div></li><li><div>            case &quot;@left-bottom&quot;:&nbsp;</div></li><li><div>            case &quot;@right-top&quot;:&nbsp;</div></li><li><div>            case &quot;@right-middle&quot;:&nbsp;</div></li><li><div>            case &quot;@right-bottom&quot;:&nbsp;</div></li><li><div>            hasBlock = true;&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>            */&nbsp;</div></li><li><div>            case &quot;@charset&quot;:&nbsp;</div></li><li><div>                $hasIdentifier = true;&nbsp;</div></li><li><div>                $hasBlock = false;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            case &quot;@namespace&quot;:&nbsp;</div></li><li><div>                $hasExpression = true;&nbsp;</div></li><li><div>                $hasBlock = false;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            case &quot;@keyframes&quot;:&nbsp;</div></li><li><div>                $hasIdentifier = true;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            case &quot;@host&quot;:&nbsp;</div></li><li><div>            case &quot;@page&quot;:&nbsp;</div></li><li><div>            case &quot;@document&quot;:&nbsp;</div></li><li><div>            case &quot;@supports&quot;:&nbsp;</div></li><li><div>                $hasUnknown = true;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $hasIdentifier ) {&nbsp;</div></li><li><div>            $value = $this-&gt;parseEntity();&nbsp;</div></li><li><div>            if( !$value ) {&nbsp;</div></li><li><div>                $this-&gt;error(&quot;expected &quot; . $name . &quot; identifier&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else if( $hasExpression ) {&nbsp;</div></li><li><div>            $value = $this-&gt;parseExpression();&nbsp;</div></li><li><div>            if( !$value ) {&nbsp;</div></li><li><div>                $this-&gt;error(&quot;expected &quot; . $name. &quot; expression&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else if ($hasUnknown) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $value = $this-&gt;MatchReg('/\\G[^{;]+/');&nbsp;</div></li><li><div>            if( $value ) {&nbsp;</div></li><li><div>                $value = $this-&gt;NewObj1('Less_Tree_Anonymous', trim($value[0]));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $hasBlock ) {&nbsp;</div></li><li><div>            $rules = $this-&gt;parseBlockRuleset();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $rules || (!$hasBlock && $value && $this-&gt;MatchChar(';'))) {&nbsp;</div></li><li><div>            $this-&gt;forget();&nbsp;</div></li><li><div>            return $this-&gt;NewObj5('Less_Tree_Directive', array($name, $value, $rules, $index, $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;restore();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // A Value is a comma-delimited list of Expressions&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    //     font-family: Baskerville, Georgia, serif;&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    // In a Rule, a Value represents everything after the `:`, &nbsp;</div></li><li><div>    // and before the `;`.&nbsp;</div></li><li><div>    //&nbsp;</div></li><li><div>&nbsp;    private function parseValue() {&nbsp;</div></li><li><div>        $expressions = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        do{&nbsp;</div></li><li><div>            $e = $this-&gt;parseExpression();&nbsp;</div></li><li><div>            if( $e ) {&nbsp;</div></li><li><div>                $expressions[] = $e;&nbsp;</div></li><li><div>                if (! $this-&gt;MatchChar(', ')) {&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }while($e);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $expressions ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Value', $expressions);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseImportant () {&nbsp;</div></li><li><div>        if( $this-&gt;PeekChar('!') && $this-&gt;MatchReg('/\\G! *important/') ) {&nbsp;</div></li><li><div>            return ' !important';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseSub () {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $this-&gt;MatchChar('(') ) {&nbsp;</div></li><li><div>            $a = $this-&gt;parseAddition();&nbsp;</div></li><li><div>            if( $a ) {&nbsp;</div></li><li><div>                $this-&gt;expectChar(')');&nbsp;</div></li><li><div>                return $this-&gt;NewObj2('Less_Tree_Expression', array( array($a), true) ); //instead of $e-&gt;parens = true so the value is cached&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parses multiplication operation&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return Less_Tree_Operation|null&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    function parseMultiplication() {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $return = $m = $this-&gt;parseOperand();&nbsp;</div></li><li><div>        if( $return ) {&nbsp;</div></li><li><div>            while( true ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $isSpaced = $this-&gt;isWhitespace( -1 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if( $this-&gt;PeekReg('/\\G\/[*\/]/') ) {&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $op = $this-&gt;MatchChar('/');&nbsp;</div></li><li><div>                if( !$op ) {&nbsp;</div></li><li><div>                    $op = $this-&gt;MatchChar('*');&nbsp;</div></li><li><div>                    if( !$op ) {&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $a = $this-&gt;parseOperand();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if(!$a) { break; }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $m-&gt;parensInOp = true;&nbsp;</div></li><li><div>                $a-&gt;parensInOp = true;&nbsp;</div></li><li><div>                $return = $this-&gt;NewObj3('Less_Tree_Operation', array( $op, array( $return, $a ), $isSpaced) );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parses an addition operation&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return Less_Tree_Operation|null&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseAddition () {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $return = $m = $this-&gt;parseMultiplication();&nbsp;</div></li><li><div>        if( $return ) {&nbsp;</div></li><li><div>            while( true ) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $isSpaced = $this-&gt;isWhitespace( -1 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $op = $this-&gt;MatchReg('/\\G[-+]\s+/');&nbsp;</div></li><li><div>                if( $op ) {&nbsp;</div></li><li><div>                    $op = $op[0];&nbsp;</div></li><li><div>                }else{&nbsp;</div></li><li><div>                    if( !$isSpaced ) {&nbsp;</div></li><li><div>                        $op = $this-&gt;match(array('#+', '#-'));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if( !$op ) {&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $a = $this-&gt;parseMultiplication();&nbsp;</div></li><li><div>                if( !$a ) {&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $m-&gt;parensInOp = true;&nbsp;</div></li><li><div>                $a-&gt;parensInOp = true;&nbsp;</div></li><li><div>                $return = $this-&gt;NewObj3('Less_Tree_Operation', array($op, array($return, $a), $isSpaced));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $return;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parses the conditions&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return Less_Tree_Condition|null&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseConditions() {&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>        $return = $a = $this-&gt;parseCondition();&nbsp;</div></li><li><div>        if( $a ) {&nbsp;</div></li><li><div>            while( true ) {&nbsp;</div></li><li><div>                if( !$this-&gt;PeekReg('/\\G, \s*(not\s*)?\(/') ||  !$this-&gt;MatchChar(', ') ) {&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $b = $this-&gt;parseCondition();&nbsp;</div></li><li><div>                if( !$b ) {&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $return = $this-&gt;NewObj4('Less_Tree_Condition', array('or', $return, $b, $index));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return $return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function parseCondition() {&nbsp;</div></li><li><div>        $index = $this-&gt;pos;&nbsp;</div></li><li><div>        $negate = false;&nbsp;</div></li><li><div>        $c = null;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($this-&gt;MatchReg('/\\Gnot/')) $negate = true;&nbsp;</div></li><li><div>        $this-&gt;expectChar('(');&nbsp;</div></li><li><div>        $a = $this-&gt;MatchFuncs(array('parseAddition', 'parseEntitiesKeyword', 'parseEntitiesQuoted'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $a ) {&nbsp;</div></li><li><div>            $op = $this-&gt;MatchReg('/\\G(?:&gt;=|&lt;=|=&lt;|[&lt;=&gt;])/');&nbsp;</div></li><li><div>            if( $op ) {&nbsp;</div></li><li><div>                $b = $this-&gt;MatchFuncs(array('parseAddition', 'parseEntitiesKeyword', 'parseEntitiesQuoted'));&nbsp;</div></li><li><div>                if( $b ) {&nbsp;</div></li><li><div>                    $c = $this-&gt;NewObj5('Less_Tree_Condition', array($op[0], $a, $b, $index, $negate));&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $this-&gt;Error('Unexpected expression');&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $k = $this-&gt;NewObj1('Less_Tree_Keyword', 'true');&nbsp;</div></li><li><div>                $c = $this-&gt;NewObj5('Less_Tree_Condition', array('=', $a, $k, $index, $negate));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $this-&gt;expectChar(')');&nbsp;</div></li><li><div>            return $this-&gt;MatchReg('/\\Gand/') ? $this-&gt;NewObj3('Less_Tree_Condition', array('and', $c, $this-&gt;parseCondition())) : $c;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * An operand is anything that can be part of an operation, &nbsp;</div></li><li><div>     * such as a Color, or a Variable&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseOperand () {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $negate = false;&nbsp;</div></li><li><div>        $offset = $this-&gt;pos+1;&nbsp;</div></li><li><div>        if( $offset &gt;= $this-&gt;input_len ) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $char = $this-&gt;input[$offset];&nbsp;</div></li><li><div>        if( $char === '@' || $char === '(' ) {&nbsp;</div></li><li><div>            $negate = $this-&gt;MatchChar('-');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $o = $this-&gt;MatchFuncs(array('parseSub', 'parseEntitiesDimension', 'parseEntitiesColor', 'parseEntitiesVariable', 'parseEntitiesCall'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $negate ) {&nbsp;</div></li><li><div>            $o-&gt;parensInOp = true;&nbsp;</div></li><li><div>            $o = $this-&gt;NewObj1('Less_Tree_Negative', $o);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $o;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Expressions either represent mathematical operations, &nbsp;</div></li><li><div>     * or white-space delimited Entities.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     *     1px solid black&nbsp;</div></li><li><div>     *     @var * 2&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return Less_Tree_Expression|null&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseExpression () {&nbsp;</div></li><li><div>        $entities = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        do{&nbsp;</div></li><li><div>            $e = $this-&gt;MatchFuncs(array('parseAddition', 'parseEntity'));&nbsp;</div></li><li><div>            if( $e ) {&nbsp;</div></li><li><div>                $entities[] = $e;&nbsp;</div></li><li><div>                // operations do not allow keyword &quot;/&quot; dimension (e.g. small/20px) so we support that here&nbsp;</div></li><li><div>                if( !$this-&gt;PeekReg('/\\G\/[\/*]/') ) {&nbsp;</div></li><li><div>                    $delim = $this-&gt;MatchChar('/');&nbsp;</div></li><li><div>                    if( $delim ) {&nbsp;</div></li><li><div>                        $entities[] = $this-&gt;NewObj1('Less_Tree_Anonymous', $delim);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }while($e);&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>        if( $entities ) {&nbsp;</div></li><li><div>            return $this-&gt;NewObj1('Less_Tree_Expression', $entities);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parse a property&nbsp;</div></li><li><div>     * eg: 'min-width', 'orientation', etc&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseProperty () {&nbsp;</div></li><li><div>        $name = $this-&gt;MatchReg('/\\G(\*?-?[_a-zA-Z0-9-]+)\s*:/');&nbsp;</div></li><li><div>        if( $name ) {&nbsp;</div></li><li><div>            return $name[1];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parse a rule property&nbsp;</div></li><li><div>     * eg: 'color', 'width', 'height', etc&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function parseRuleProperty() {&nbsp;</div></li><li><div>        $offset = $this-&gt;pos;&nbsp;</div></li><li><div>        $name = array();&nbsp;</div></li><li><div>        $index = array();&nbsp;</div></li><li><div>        $length = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;rulePropertyMatch('/\\G(\*?)/', $offset, $length, $index, $name );&nbsp;</div></li><li><div>        while( $this-&gt;rulePropertyMatch('/\\G((?:[\w-]+)|(?:@\{[\w-]+\}))/', $offset, $length, $index, $name )); // !&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( (count($name) &gt; 1) && $this-&gt;rulePropertyMatch('/\\G\s*((?:\+_|\+)?)\s*:/', $offset, $length, $index, $name) ) {&nbsp;</div></li><li><div>            // at last, we have the complete match now. move forward, &nbsp;</div></li><li><div>            // convert name particles to tree objects and return:&nbsp;</div></li><li><div>            $this-&gt;skipWhitespace($length);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if( $name[0] === '' ) {&nbsp;</div></li><li><div>                array_shift($name);&nbsp;</div></li><li><div>                array_shift($index);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            foreach($name as $k =&gt; $s ) {&nbsp;</div></li><li><div>                if( !$s || $s[0] !== '@' ) {&nbsp;</div></li><li><div>                    $name[$k] = $this-&gt;NewObj1('Less_Tree_Keyword', $s);&nbsp;</div></li><li><div>                }else{&nbsp;</div></li><li><div>                    $name[$k] = $this-&gt;NewObj3('Less_Tree_Variable', array('@' . substr($s, 2, -1), $index[$k], $this-&gt;env-&gt;currentFileInfo));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return $name;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    private function rulePropertyMatch( $re, &$offset, &$length, &$index, &$name ) {&nbsp;</div></li><li><div>        preg_match($re, $this-&gt;input, $a, 0, $offset);&nbsp;</div></li><li><div>        if( $a ) {&nbsp;</div></li><li><div>            $index[] = $this-&gt;pos + $length;&nbsp;</div></li><li><div>            $length += strlen($a[0]);&nbsp;</div></li><li><div>            $offset += strlen($a[0]);&nbsp;</div></li><li><div>            $name[] = $a[1];&nbsp;</div></li><li><div>            return true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function serializeVars( $vars ) {&nbsp;</div></li><li><div>        $s = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach($vars as $name =&gt; $value) {&nbsp;</div></li><li><div>            $s .= (($name[0] === '@') ? '' : '@') . $name .': '. $value . ((substr($value, -1) === ';') ? '' : ';');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $s;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Some versions of php have trouble with method_exists($a, $b) if $a is not an object&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $b&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function is_method($a, $b) {&nbsp;</div></li><li><div>        return is_object($a) && method_exists($a, $b);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Round numbers similarly to javascript&nbsp;</div></li><li><div>     * eg: 1.499999 to 1 instead of 2&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function round($i, $precision = 0) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $precision = pow(10, $precision);&nbsp;</div></li><li><div>        $i = $i*$precision;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $ceil = ceil($i);&nbsp;</div></li><li><div>        $floor = floor($i);&nbsp;</div></li><li><div>        if( ($ceil - $i) &lt;= ($i - $floor) ) {&nbsp;</div></li><li><div>            return $ceil/$precision;&nbsp;</div></li><li><div>        }else{&nbsp;</div></li><li><div>            return $floor/$precision;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Create Less_Tree_* objects and optionally generate a cache string&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return mixed&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function NewObj0($class) {&nbsp;</div></li><li><div>        $obj = new $class();&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $obj-&gt;cache_string = ' new '.$class.'()';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function NewObj1($class, $arg) {&nbsp;</div></li><li><div>        $obj = new $class( $arg );&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $obj-&gt;cache_string = ' new '.$class.'('.Less_Parser::ArgString($arg).')';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function NewObj2($class, $args) {&nbsp;</div></li><li><div>        $obj = new $class( $args[0], $args[1] );&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $this-&gt;ObjCache( $obj, $class, $args);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function NewObj3($class, $args) {&nbsp;</div></li><li><div>        $obj = new $class( $args[0], $args[1], $args[2] );&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $this-&gt;ObjCache( $obj, $class, $args);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function NewObj4($class, $args) {&nbsp;</div></li><li><div>        $obj = new $class( $args[0], $args[1], $args[2], $args[3] );&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $this-&gt;ObjCache( $obj, $class, $args);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function NewObj5($class, $args) {&nbsp;</div></li><li><div>        $obj = new $class( $args[0], $args[1], $args[2], $args[3], $args[4] );&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $this-&gt;ObjCache( $obj, $class, $args);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function NewObj6($class, $args) {&nbsp;</div></li><li><div>        $obj = new $class( $args[0], $args[1], $args[2], $args[3], $args[4], $args[5] );&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $this-&gt;ObjCache( $obj, $class, $args);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function NewObj7($class, $args) {&nbsp;</div></li><li><div>        $obj = new $class( $args[0], $args[1], $args[2], $args[3], $args[4], $args[5], $args[6] );&nbsp;</div></li><li><div>        if( $this-&gt;CacheEnabled() ) {&nbsp;</div></li><li><div>            $this-&gt;ObjCache( $obj, $class, $args);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $obj;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //caching&nbsp;</div></li><li><div>    public function ObjCache($obj, $class, $args=array()) {&nbsp;</div></li><li><div>        $obj-&gt;cache_string = ' new '.$class.'('. self::ArgCache($args).')';&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function ArgCache($args) {&nbsp;</div></li><li><div>        return implode(', ', array_map( array('Less_Parser', 'ArgString'), $args));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Convert an argument to a string for use in the parser cache&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function ArgString($arg) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $type = gettype($arg);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if( $type === 'object') {&nbsp;</div></li><li><div>            $string = $arg-&gt;cache_string;&nbsp;</div></li><li><div>            unset($arg-&gt;cache_string);&nbsp;</div></li><li><div>            return $string;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }elseif( $type === 'array' ) {&nbsp;</div></li><li><div>            $string = ' Array(';&nbsp;</div></li><li><div>            foreach($arg as $k =&gt; $a) {&nbsp;</div></li><li><div>                $string .= var_export($k, true).' =&gt; '.self::ArgString($a).', ';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return $string . ')';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return var_export($arg, true);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function Error($msg) {&nbsp;</div></li><li><div>        throw new Less_Exception_Parser($msg, null, $this-&gt;furthest, $this-&gt;env-&gt;currentFileInfo);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function WinPath($path) {&nbsp;</div></li><li><div>        return str_replace('\\', '/', $path);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function CacheEnabled() {&nbsp;</div></li><li><div>        return (Less_Parser::$options['cache_method'] && (Less_Cache::$cache_dir || (Less_Parser::$options['cache_method'] == 'callback')));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 3.3.50</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.7-1/classes/less_parser/" class="">3.3.7-1</a></li><li><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.7-0/classes/less_parser/" class="">3.3.7-0</a></li><li><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.60/classes/less_parser/" class="">3.3.60</a></li><li><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.6-1/classes/less_parser/" class="">3.3.6-1</a></li><li><a href="http://hookr.io/plugins/wordpress-twitter-bootstrap-css/3.3.50/classes/less_parser/" class="active">3.3.50</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>Less_Parser</li><li><span></span>WordPress Twitter Bootstrap CSS</li><li><span></span>3.3.7-1</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2017 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer> <script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>