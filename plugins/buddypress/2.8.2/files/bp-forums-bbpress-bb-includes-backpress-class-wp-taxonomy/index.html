<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr file lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr file lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr file lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr file ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr file gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr file" data-site="plugin" data-version="2.8.2" data-slug="buddypress" data-type="file" data-id="49156"><head xmlns="http://www.w3.org/1999/xhtml"><title> bp-forums-bbpress-bb-includes-backpress-class-wp-taxonomy | file | Buddypress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="file, plugin, buddypress, 2.8.2" /><meta name="description" content="The WordPress Hook/API Index" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.24"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=cacf5c985ddb808677dbe1c53f409783' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.24' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/files/bp-forums-bbpress-bb-includes-backpress-class-wp-taxonomy/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fbp-forums-bbpress-bb-includes-backpress-class-wp-taxonomy%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Ffiles%2Fbp-forums-bbpress-bb-includes-backpress-class-wp-taxonomy%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-buddypress-2.8.2-file-bp-forums-bbpress-bb-includes-backpress-class-wp-taxonomy","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="bp-forums-bbpress-bb-includes-backpress-class-wp-taxonomy" class="single single-file"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to buddypress." href="http://hookr.io/plugins/buddypress/" class="plugin"><span property="name">buddypress</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 2.8.2." href="http://hookr.io/plugins/buddypress/2.8.2/" class="H_VERSION"><span property="name">2.8.2</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to files." href="http://hookr.io/plugins/buddypress/2.8.2/files/" class=""><span property="name">files</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">bp-forums-bbpress-bb-includes&hellip;</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="file"><ul role="navigation"><li class="" data-id="all" data-count="7837"><a href="http://hookr.io/plugins/buddypress/2.8.2/all/" title="All">All <span class="count badge">7837</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/plugins/buddypress/2.8.2/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="3621"><a href="http://hookr.io/plugins/buddypress/2.8.2/hooks/" title="Hooks">Hooks <span class="count badge">3621</span></a></li><li class="" data-id="action" data-count="1727"><a href="http://hookr.io/plugins/buddypress/2.8.2/actions/" title="Actions">Actions <span class="count badge">1727</span></a></li><li class="" data-id="filter" data-count="1894"><a href="http://hookr.io/plugins/buddypress/2.8.2/filters/" title="Filters">Filters <span class="count badge">1894</span></a></li><li class="" data-id="class" data-count="181"><a href="http://hookr.io/plugins/buddypress/2.8.2/classes/" title="Classes">Classes <span class="count badge">181</span></a></li><li class="" data-id="constant" data-count="161"><a href="http://hookr.io/plugins/buddypress/2.8.2/constants/" title="Constants">Constants <span class="count badge">161</span></a></li><li class="" data-id="function" data-count="3874"><a href="http://hookr.io/plugins/buddypress/2.8.2/functions/" title="Functions">Functions <span class="count badge">3874</span></a></li><li class="" data-id="shortcode" data-count="0"><a href="http://hookr.io/plugins/buddypress/2.8.2/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">0</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article> <section><h1>/bp-forums/bbpress/bb-includes/backpress/class.wp-taxonomy.php</h1><p><pre><ol  class="block" start="1"><li><div>&lt;?php&nbsp;</div></li><li><div><span class="comment">// Last sync [WP11537] - Refactored into a class based on wp-includes/taxonomy.php</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * Taxonomy API</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment"> * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div><span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment"> * WordPress Taxonomy based off of WordPress revision 8782.</span>&nbsp;</div></li><li><div><span class="comment"> *</span>&nbsp;</div></li><li><div><span class="comment"> * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment"> */</span>&nbsp;</div></li><li><div>class WP_Taxonomy {&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Stores the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @var unknown_type</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  var $db;&nbsp;</div></li><li><div>  var $taxonomies = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function WP_Taxonomy( &$db ) {&nbsp;</div></li><li><div>      $this-&gt;__construct( $db );&nbsp;</div></li><li><div>      register_shutdown_function( array(&$this, '__destruct') );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * PHP5 constructor - Assigns the database to an attribute of the class.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param unknown_type $db</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function __construct( &$db ) {&nbsp;</div></li><li><div>      $this-&gt;db =& $db;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Does nothing.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package BackPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function __destruct() {&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Return all of the taxonomy names that are of $object_type.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * It appears that this function can be used to find all of the names inside of</span>&nbsp;</div></li><li><div><span class="comment">   * $this-&gt;taxonomies variable.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * &lt;code&gt;&lt;?php $taxonomies = $this-&gt;get_object_taxonomies('post'); ?&gt;&lt;/code&gt; Should</span>&nbsp;</div></li><li><div><span class="comment">   * result in &lt;code&gt;Array('category', 'post_tag')&lt;/code&gt;</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;taxonomies</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string|object $object_type Name of the type of taxonomy object, or an object (row from posts)</span>&nbsp;</div></li><li><div><span class="comment">   * @return array The names of all taxonomy of $object_type.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_object_taxonomies($object_type) {&nbsp;</div></li><li><div>      $object_type = (array) $object_type;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// WP DIFF</span></span>&nbsp;</div></li><li><div>      $taxonomies = array();&nbsp;</div></li><li><div>      foreach ( (array) $this-&gt;taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          if ( array_intersect($object_type, (array) $taxonomy-&gt;object_type) )&nbsp;</div></li><li><div>              $taxonomies[] = $taxonomy-&gt;name;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $taxonomies;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the taxonomy object of $taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The get_taxonomy function will first check that the parameter string given</span>&nbsp;</div></li><li><div><span class="comment">   * is a taxonomy object and if it is, it will return it.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;taxonomies</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;is_taxonomy() Checks whether taxonomy exists</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Name of taxonomy object to return</span>&nbsp;</div></li><li><div><span class="comment">   * @return object|bool The Taxonomy Object or false if $taxonomy doesn't exist</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_taxonomy( $taxonomy ) {&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;taxonomies[$taxonomy];&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Checks that the taxonomy name exists.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * </span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;taxonomies</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Name of taxonomy object</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool Whether the taxonomy exists or not.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function is_taxonomy( $taxonomy ) {&nbsp;</div></li><li><div>      return isset($this-&gt;taxonomies[$taxonomy]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Whether the taxonomy object is hierarchical.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Checks to make sure that the taxonomy is an object first. Then Gets the</span>&nbsp;</div></li><li><div><span class="comment">   * object, and finally returns the hierarchical value in the object.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * A false return value might also mean that the taxonomy does not exist.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;is_taxonomy() Checks whether taxonomy exists</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;get_taxonomy() Used to get the taxonomy object</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Name of taxonomy object</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool Whether the taxonomy is hierarchical</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function is_taxonomy_hierarchical($taxonomy) {&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $taxonomy = $this-&gt;get_taxonomy($taxonomy);&nbsp;</div></li><li><div>      return $taxonomy-&gt;hierarchical;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Create or modify a taxonomy object. Do not use before init.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * A simple function for creating or modifying a taxonomy object based on the</span>&nbsp;</div></li><li><div><span class="comment">   * parameters given. The function will accept an array (third optional</span>&nbsp;</div></li><li><div><span class="comment">   * parameter), along with strings for the taxonomy name and another string for</span>&nbsp;</div></li><li><div><span class="comment">   * the object type.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The function keeps a default set, allowing for the $args to be optional but</span>&nbsp;</div></li><li><div><span class="comment">   * allow the other functions to still work. It is possible to overwrite the</span>&nbsp;</div></li><li><div><span class="comment">   * default set, which contains two keys: hierarchical and update_count_callback.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Nothing is returned, so expect error maybe or use is_taxonomy() to check</span>&nbsp;</div></li><li><div><span class="comment">   * whether taxonomy exists.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Optional $args contents:</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * hierarachical - has some defined purpose at other parts of the API and is a</span>&nbsp;</div></li><li><div><span class="comment">   * boolean value.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * update_count_callback - works much like a hook, in that it will be called</span>&nbsp;</div></li><li><div><span class="comment">   * when the count is updated.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;taxonomies Inserts new taxonomy object into the list</span>&nbsp;</div></li><li><div><span class="comment">   * </span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Name of taxonomy object</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $object_type Name of the object type for the taxonomy object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $args See above description for the two keys values.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function register_taxonomy( $taxonomy, $object_type, $args = array() ) {&nbsp;</div></li><li><div>      $defaults = array('hierarchical' =&gt; false, 'update_count_callback' =&gt; '');&nbsp;</div></li><li><div>      $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $args['name'] = $taxonomy;&nbsp;</div></li><li><div>      $args['object_type'] = $object_type;&nbsp;</div></li><li><div>      $this-&gt;taxonomies[$taxonomy] = (object) $args;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">  // Term API</span>&nbsp;</div></li><li><div>  <span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieve object_ids of valid taxonomy and term.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The strings of $taxonomies must exist before this function will continue. On</span>&nbsp;</div></li><li><div><span class="comment">   * failure of finding a valid taxonomy, it will return an WP_Error class, kind</span>&nbsp;</div></li><li><div><span class="comment">   * of like Exceptions in PHP 5, except you can't catch them. Even so, you can</span>&nbsp;</div></li><li><div><span class="comment">   * still test for the WP_Error class and get the error message.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The $terms aren't checked the same as $taxonomies, but still need to exist</span>&nbsp;</div></li><li><div><span class="comment">   * for $object_ids to be returned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * It is possible to change the order that object_ids is returned by either</span>&nbsp;</div></li><li><div><span class="comment">   * using PHP sort family functions or using the database by using $args with</span>&nbsp;</div></li><li><div><span class="comment">   * either ASC or DESC array. The value should be in the key named 'order'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses wp_parse_args() Creates an array from string $args.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $terms String of term or array of string values of terms that will be used</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $taxonomies String of taxonomy name or Array of string values of taxonomy names</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $args Change the order of the object_ids, either ASC or DESC</span>&nbsp;</div></li><li><div><span class="comment">   * @return WP_Error|array If the taxonomy does not exist, then WP_Error will be returned. On success</span>&nbsp;</div></li><li><div><span class="comment">   *    the array can be empty meaning that there are no $object_ids found or it will return the $object_ids found.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_objects_in_term( $terms, $taxonomies, $args = null ) {&nbsp;</div></li><li><div>      if ( !is_array($terms) )&nbsp;</div></li><li><div>          $terms = array($terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($taxonomies) )&nbsp;</div></li><li><div>          $taxonomies = array($taxonomies);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>              return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array('order' =&gt; 'ASC', 'field' =&gt; 'term_id');&nbsp;</div></li><li><div>      $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>      extract($args, EXTR_SKIP);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'tt_id' == $field )&nbsp;</div></li><li><div>          $field = 'tt.term_taxonomy_id';&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $field = 'tt.term_id';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $order = ( 'desc' == strtolower($order) ) ? 'DESC' : 'ASC';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = array_map('intval', $terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $taxonomies = &quot;'&quot; . implode(&quot;', '&quot;, $taxonomies) . &quot;'&quot;;&nbsp;</div></li><li><div>      $terms = &quot;'&quot; . implode(&quot;', '&quot;, $terms) . &quot;'&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $object_ids = $this-&gt;db-&gt;get_col(&quot;SELECT tr.object_id FROM {$this-&gt;db-&gt;term_relationships} AS tr INNER JOIN {$this-&gt;db-&gt;term_taxonomy} AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND $field IN ($terms) ORDER BY tr.object_id $order&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $object_ids )&nbsp;</div></li><li><div>          return array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $object_ids;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Get all Term data from database by Term ID.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The usage of the get_term function is to apply filters to a term object. It</span>&nbsp;</div></li><li><div><span class="comment">   * is possible to get a term object from the database before applying the</span>&nbsp;</div></li><li><div><span class="comment">   * filters.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * $term ID must be part of $taxonomy, to get from the database. Failure, might</span>&nbsp;</div></li><li><div><span class="comment">   * be able to be captured by the hooks. Failure would be the same value as $this-&gt;db</span>&nbsp;</div></li><li><div><span class="comment">   * returns for the get_row method.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * There are two hooks, one is specifically for each term, named 'get_term', and</span>&nbsp;</div></li><li><div><span class="comment">   * the second is for the taxonomy name, 'term_$taxonomy'. Both hooks gets the</span>&nbsp;</div></li><li><div><span class="comment">   * term object, and the taxonomy name as parameters. Both hooks are expected to</span>&nbsp;</div></li><li><div><span class="comment">   * return a Term object.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * 'get_term' hook - Takes two parameters the term Object and the taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment">   * Must return term object. Used in get_term() as a catch-all filter for every</span>&nbsp;</div></li><li><div><span class="comment">   * $term.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * 'get_$taxonomy' hook - Takes two parameters the term Object and the taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * name. Must return term object. $taxonomy will be the taxonomy name, so for</span>&nbsp;</div></li><li><div><span class="comment">   * example, if 'category', it would be 'get_category' as the filter name. Useful</span>&nbsp;</div></li><li><div><span class="comment">   * for custom taxonomies or plugging into default taxonomies.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;sanitize_term() Cleanses the term based on $filter context before returning.</span>&nbsp;</div></li><li><div><span class="comment">   * @see $this-&gt;sanitize_term_field() The $context param lists the available values for get_term_by() $filter param.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|object $term If integer, will get from database. If object will apply filters and return $term.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy name that $term is part of.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $filter Optional, default is raw or no WordPress defined filter will applied.</span>&nbsp;</div></li><li><div><span class="comment">   * @return mixed|null|WP_Error Term Row from database. Will return null if $term is empty. If taxonomy does not</span>&nbsp;</div></li><li><div><span class="comment">   * exist then WP_Error will be returned.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function &get_term($term, $taxonomy, $output = OBJECT, $filter = 'raw') {&nbsp;</div></li><li><div>      if ( empty($term) ) {&nbsp;</div></li><li><div>          $error = new WP_Error('invalid_term', __('Empty Term'));&nbsp;</div></li><li><div>          return $error;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) ) {&nbsp;</div></li><li><div>          $error = new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));&nbsp;</div></li><li><div>          return $error;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_object($term) ) {&nbsp;</div></li><li><div>          wp_cache_add($term-&gt;term_id, $term, $taxonomy);&nbsp;</div></li><li><div>          wp_cache_add($term-&gt;term_taxonomy_id, $term-&gt;term_id, &quot;$taxonomy:tt_id&quot; );&nbsp;</div></li><li><div>          $_term = $term;&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $term = (int) $term;&nbsp;</div></li><li><div>          if ( ! $_term = wp_cache_get($term, $taxonomy) ) {&nbsp;</div></li><li><div>              $_term = $this-&gt;db-&gt;get_row( $this-&gt;db-&gt;prepare( &quot;SELECT t.*, tt.* FROM {$this-&gt;db-&gt;terms} AS t INNER JOIN {$this-&gt;db-&gt;term_taxonomy} AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND t.term_id = %s LIMIT 1&quot;, $taxonomy, $term) );&nbsp;</div></li><li><div>              wp_cache_add($term, $_term, $taxonomy);&nbsp;</div></li><li><div>              wp_cache_add($_term-&gt;term_taxonomy_id, $_term-&gt;term_id, &quot;$taxonomy:tt_id&quot; );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $_term = apply_filters('get_term', $_term, $taxonomy);&nbsp;</div></li><li><div>      $_term = apply_filters(&quot;get_$taxonomy&quot;, $_term, $taxonomy);&nbsp;</div></li><li><div>      $_term = $this-&gt;sanitize_term($_term, $taxonomy, $filter);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      backpress_convert_object( $_term, $output );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $_term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Get all Term data from database by Term field and data.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Warning: $value is not escaped for 'name' $field. You must do it yourself, if</span>&nbsp;</div></li><li><div><span class="comment">   * required.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The default $field is 'id', therefore it is possible to also use null for</span>&nbsp;</div></li><li><div><span class="comment">   * field, but not recommended that you do so.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If $value does not exist, the return value will be false. If $taxonomy exists</span>&nbsp;</div></li><li><div><span class="comment">   * and $field and $value combinations exist, the Term will be returned.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;sanitize_term() Cleanses the term based on $filter context before returning.</span>&nbsp;</div></li><li><div><span class="comment">   * @see $this-&gt;sanitize_term_field() The $context param lists the available values for get_term_by() $filter param.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $field Either 'slug', 'name', 'id', or 'tt_id'</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|int $value Search for this term value</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $filter Optional, default is raw or no WordPress defined filter will applied.</span>&nbsp;</div></li><li><div><span class="comment">   * @return mixed Term Row from database. Will return false if $taxonomy does not exist or $term was not found.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_term_by($field, $value, $taxonomy, $output = OBJECT, $filter = 'raw') {&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'slug' == $field ) {&nbsp;</div></li><li><div>          $field = 't.slug';&nbsp;</div></li><li><div>          $value = $this-&gt;sanitize_term_slug($value, $taxonomy);&nbsp;</div></li><li><div>          if ( empty($value) )&nbsp;</div></li><li><div>              return false;&nbsp;</div></li><li><div>      } else if ( 'name' == $field ) {&nbsp;</div></li><li><div>          <span class="comment">// Assume already escaped</span>&nbsp;</div></li><li><div>          $field = 't.name';&nbsp;</div></li><li><div>      } else if ( 'tt_id' == $field ) {&nbsp;</div></li><li><div>          $field = 'tt.term_taxonomy_id';&nbsp;</div></li><li><div>          $value = (int) $value;&nbsp;</div></li><li><div>          if ( $_term_id = wp_cache_get( $value, &quot;$taxonomy:tt_id&quot; ) )&nbsp;</div></li><li><div>              return $this-&gt;get_term( $_term_id, $taxonomy, $output, $filter );&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $field = 't.term_id';&nbsp;</div></li><li><div>          $value = (int) $value;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term = $this-&gt;db-&gt;get_row( $this-&gt;db-&gt;prepare( &quot;SELECT t.*, tt.* FROM {$this-&gt;db-&gt;terms} AS t INNER JOIN {$this-&gt;db-&gt;term_taxonomy} AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND $field = %s LIMIT 1&quot;, $taxonomy, $value) );&nbsp;</div></li><li><div>      if ( !$term )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_cache_add($term-&gt;term_id, $term, $taxonomy);&nbsp;</div></li><li><div>      wp_cache_add($term-&gt;term_taxonomy_id, $term-&gt;term_id, &quot;$taxonomy:tt_id&quot; );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term = $this-&gt;sanitize_term($term, $taxonomy, $filter);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      backpress_convert_object( $term, $output );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Merge all term children into a single array of their IDs.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * This recursive function will merge all of the children of $term into the same</span>&nbsp;</div></li><li><div><span class="comment">   * array of term IDs. Only useful for taxonomies which are hierarchical.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will return an empty array if $term does not exist in $taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   * </span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;_get_term_hierarchy()</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;get_term_children() Used to get the children of both $taxonomy and the parent $term</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $term ID of Term to get children</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error List of Term Objects. WP_Error returned if $taxonomy does not exist</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_term_children( $term_id, $taxonomy ) {&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>          return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_id = intval( $term_id );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = $this-&gt;_get_term_hierarchy($taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! isset($terms[$term_id]) )&nbsp;</div></li><li><div>          return array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $children = $terms[$term_id];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $terms[$term_id] as $child ) {&nbsp;</div></li><li><div>          if ( isset($terms[$child]) )&nbsp;</div></li><li><div>              $children = array_merge($children, $this-&gt;get_term_children($child, $taxonomy));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $children;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Get sanitized Term field.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Does checks for $term, based on the $taxonomy. The function is for contextual</span>&nbsp;</div></li><li><div><span class="comment">   * reasons and for simplicity of usage. See sanitize_term_field() for more</span>&nbsp;</div></li><li><div><span class="comment">   * information.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;sanitize_term_field() Passes the return value in sanitize_term_field on success.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $field Term field to fetch</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term Term ID</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $context Optional, default is display. Look at sanitize_term_field() for available options.</span>&nbsp;</div></li><li><div><span class="comment">   * @return mixed Will return an empty string if $term is not an object or if $field is not set in $term.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_term_field( $field, $term, $taxonomy, $context = 'display' ) {&nbsp;</div></li><li><div>      $term = (int) $term;&nbsp;</div></li><li><div>      $term = $this-&gt;get_term( $term, $taxonomy );&nbsp;</div></li><li><div>      if ( is_wp_error($term) )&nbsp;</div></li><li><div>          return $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_object($term) )&nbsp;</div></li><li><div>          return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !isset($term-&gt;$field) )&nbsp;</div></li><li><div>          return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;sanitize_term_field($field, $term-&gt;$field, $term-&gt;term_id, $taxonomy, $context);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Sanitizes Term for editing.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Return value is sanitize_term() and usage is for sanitizing the term for</span>&nbsp;</div></li><li><div><span class="comment">   * editing. Function is for contextual and simplicity.</span>&nbsp;</div></li><li><div><span class="comment">   * </span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;sanitize_term() Passes the return value on success</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|object $id Term ID or Object</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @return mixed|null|WP_Error Will return empty string if $term is not an object.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_term_to_edit( $id, $taxonomy ) {&nbsp;</div></li><li><div>      $term = $this-&gt;get_term( $id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_wp_error($term) )&nbsp;</div></li><li><div>          return $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_object($term) )&nbsp;</div></li><li><div>          return '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;sanitize_term($term, $taxonomy, 'edit');&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieve the terms in a given taxonomy or list of taxonomies.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * You can fully inject any customizations to the query before it is sent, as</span>&nbsp;</div></li><li><div><span class="comment">   * well as control the output with a filter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'get_terms' filter will be called when the cache has the term and will</span>&nbsp;</div></li><li><div><span class="comment">   * pass the found term along with the array of $taxonomies and array of $args.</span>&nbsp;</div></li><li><div><span class="comment">   * This filter is also called before the array of terms is passed and will pass</span>&nbsp;</div></li><li><div><span class="comment">   * the array of terms, along with the $taxonomies and $args.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'list_terms_exclusions' filter passes the compiled exclusions along with</span>&nbsp;</div></li><li><div><span class="comment">   * the $args.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'get_terms_orderby' filter passes the ORDER BY clause for the query</span>&nbsp;</div></li><li><div><span class="comment">   * along with the $args array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'get_terms_fields' filter passes the fields for the SELECT query</span>&nbsp;</div></li><li><div><span class="comment">   * along with the $args array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The list of arguments that $args can contain, which will overwrite the defaults:</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * orderby - Default is 'name'. Can be name, count, term_group, slug or nothing</span>&nbsp;</div></li><li><div><span class="comment">   * (will use term_id), Passing a custom value other than these will cause it to</span>&nbsp;</div></li><li><div><span class="comment">   * order based on the custom value.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * order - Default is ASC. Can use DESC.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * hide_empty - Default is true. Will not return empty terms, which means</span>&nbsp;</div></li><li><div><span class="comment">   * terms whose count is 0 according to the given taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * exclude - Default is an empty string.  A comma- or space-delimited string</span>&nbsp;</div></li><li><div><span class="comment">   * of term ids to exclude from the return array.  If 'include' is non-empty, </span>&nbsp;</div></li><li><div><span class="comment">   * 'exclude' is ignored.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * include - Default is an empty string.  A comma- or space-delimited string</span>&nbsp;</div></li><li><div><span class="comment">   * of term ids to include in the return array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * number - The maximum number of terms to return.  Default is empty.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * offset - The number by which to offset the terms query.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * fields - Default is 'all', which returns an array of term objects.</span>&nbsp;</div></li><li><div><span class="comment">   * If 'fields' is 'ids' or 'names', returns an array of</span>&nbsp;</div></li><li><div><span class="comment">   * integers or strings, respectively.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * slug - Returns terms whose &quot;slug&quot; matches this value. Default is empty string.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * hierarchical - Whether to include terms that have non-empty descendants</span>&nbsp;</div></li><li><div><span class="comment">   * (even if 'hide_empty' is set to true).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * search - Returned terms' names will contain the value of 'search', </span>&nbsp;</div></li><li><div><span class="comment">   * case-insensitive.  Default is an empty string.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * name__like - Returned terms' names will begin with the value of 'name__like', </span>&nbsp;</div></li><li><div><span class="comment">   * case-insensitive. Default is empty string.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The argument 'pad_counts', if set to true will include the quantity of a term's</span>&nbsp;</div></li><li><div><span class="comment">   * children in the quantity of each term's &quot;count&quot; object variable.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'get' argument, if set to 'all' instead of its default empty string, </span>&nbsp;</div></li><li><div><span class="comment">   * returns terms regardless of ancestry or whether the terms are empty.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'child_of' argument, when used, should be set to the integer of a term ID.  Its default</span>&nbsp;</div></li><li><div><span class="comment">   * is 0.  If set to a non-zero value, all returned terms will be descendants</span>&nbsp;</div></li><li><div><span class="comment">   * of that term according to the given taxonomy.  Hence 'child_of' is set to 0</span>&nbsp;</div></li><li><div><span class="comment">   * if more than one taxonomy is passed in $taxonomies, because multiple taxonomies</span>&nbsp;</div></li><li><div><span class="comment">   * make term ancestry ambiguous.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The 'parent' argument, when used, should be set to the integer of a term ID.  Its default is</span>&nbsp;</div></li><li><div><span class="comment">   * the empty string '', which has a different meaning from the integer 0.</span>&nbsp;</div></li><li><div><span class="comment">   * If set to an integer value, all returned terms will have as an immediate</span>&nbsp;</div></li><li><div><span class="comment">   * ancestor the term whose ID is specified by that integer according to the given taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   * The 'parent' argument is different from 'child_of' in that a term X is considered a 'parent'</span>&nbsp;</div></li><li><div><span class="comment">   * of term Y only if term X is the father of term Y, not its grandfather or great-grandfather, etc.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses wp_parse_args() Merges the defaults with those defined by $args and allows for strings.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array Taxonomy name or list of Taxonomy names</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $args The values of what to search for when returning terms</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error List of Term Objects and their children. Will return WP_Error, if any of $taxonomies do not exist.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function &get_terms($taxonomies, $args = '') {&nbsp;</div></li><li><div>      $empty_array = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $single_taxonomy = false;&nbsp;</div></li><li><div>      if ( !is_array($taxonomies) ) {&nbsp;</div></li><li><div>          $single_taxonomy = true;&nbsp;</div></li><li><div>          $taxonomies = array($taxonomies);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          if ( ! $this-&gt;is_taxonomy($taxonomy) ) {&nbsp;</div></li><li><div>              $error = new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));&nbsp;</div></li><li><div>              return $error;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $in_taxonomies = &quot;'&quot; . implode(&quot;', '&quot;, $taxonomies) . &quot;'&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array('orderby' =&gt; 'name', 'order' =&gt; 'ASC', &nbsp;</div></li><li><div>          'hide_empty' =&gt; true, 'exclude' =&gt; '', 'exclude_tree' =&gt; '', 'include' =&gt; '', &nbsp;</div></li><li><div>          'number' =&gt; '', 'fields' =&gt; 'all', 'slug' =&gt; '', 'parent' =&gt; '', &nbsp;</div></li><li><div>          'hierarchical' =&gt; true, 'child_of' =&gt; 0, 'get' =&gt; '', 'name__like' =&gt; '', &nbsp;</div></li><li><div>          'pad_counts' =&gt; false, 'offset' =&gt; '', 'search' =&gt; '');&nbsp;</div></li><li><div>      $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>      $args['number'] = absint( $args['number'] );&nbsp;</div></li><li><div>      $args['offset'] = absint( $args['offset'] );&nbsp;</div></li><li><div>      if ( !$single_taxonomy || !$this-&gt;is_taxonomy_hierarchical($taxonomies[0]) ||&nbsp;</div></li><li><div>          '' !== $args['parent'] ) {&nbsp;</div></li><li><div>          $args['child_of'] = 0;&nbsp;</div></li><li><div>          $args['hierarchical'] = false;&nbsp;</div></li><li><div>          $args['pad_counts'] = false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'all' == $args['get'] ) {&nbsp;</div></li><li><div>          $args['child_of'] = 0;&nbsp;</div></li><li><div>          $args['hide_empty'] = 0;&nbsp;</div></li><li><div>          $args['hierarchical'] = false;&nbsp;</div></li><li><div>          $args['pad_counts'] = false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      extract($args, EXTR_SKIP);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $child_of ) {&nbsp;</div></li><li><div>          $hierarchy = $this-&gt;_get_term_hierarchy($taxonomies[0]);&nbsp;</div></li><li><div>          if ( !isset($hierarchy[$child_of]) )&nbsp;</div></li><li><div>              return $empty_array;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $parent ) {&nbsp;</div></li><li><div>          $hierarchy = $this-&gt;_get_term_hierarchy($taxonomies[0]);&nbsp;</div></li><li><div>          if ( !isset($hierarchy[$parent]) )&nbsp;</div></li><li><div>              return $empty_array;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// $args can be whatever, only use the args defined in defaults to compute the key</span>&nbsp;</div></li><li><div>      $filter_key = ( has_filter('list_terms_exclusions') ) ? serialize($GLOBALS['wp_filter']['list_terms_exclusions']) : '';&nbsp;</div></li><li><div>      $key = md5( serialize( compact(array_keys($defaults)) ) . serialize( $taxonomies ) . $filter_key );&nbsp;</div></li><li><div>      $last_changed = wp_cache_get('last_changed', 'terms');&nbsp;</div></li><li><div>      if ( !$last_changed ) {&nbsp;</div></li><li><div>          $last_changed = time();&nbsp;</div></li><li><div>          wp_cache_set('last_changed', $last_changed, 'terms');&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $cache_key = &quot;get_terms:$key:$last_changed&quot;;&nbsp;</div></li><li><div>      $cache = wp_cache_get( $cache_key, 'terms' );&nbsp;</div></li><li><div>      if ( false !== $cache ) {&nbsp;</div></li><li><div>          $cache = apply_filters('get_terms', $cache, $taxonomies, $args);&nbsp;</div></li><li><div>          return $cache;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $_orderby = strtolower($orderby);&nbsp;</div></li><li><div>      if ( 'count' == $_orderby )&nbsp;</div></li><li><div>          $orderby = 'tt.count';&nbsp;</div></li><li><div>      else if ( 'name' == $_orderby )&nbsp;</div></li><li><div>          $orderby = 't.name';&nbsp;</div></li><li><div>      else if ( 'slug' == $_orderby )&nbsp;</div></li><li><div>          $orderby = 't.slug';&nbsp;</div></li><li><div>      else if ( 'term_group' == $_orderby )&nbsp;</div></li><li><div>          $orderby = 't.term_group';&nbsp;</div></li><li><div>      elseif ( empty($_orderby) || 'id' == $_orderby )&nbsp;</div></li><li><div>          $orderby = 't.term_id';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $orderby = apply_filters( 'get_terms_orderby', $orderby, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $where = '';&nbsp;</div></li><li><div>      $inclusions = '';&nbsp;</div></li><li><div>      if ( !empty($include) ) {&nbsp;</div></li><li><div>          $exclude = '';&nbsp;</div></li><li><div>          $exclude_tree = '';&nbsp;</div></li><li><div>          $interms = preg_split('/[\s, ]+/', $include);&nbsp;</div></li><li><div>          if ( count($interms) ) {&nbsp;</div></li><li><div>              foreach ( (array) $interms as $interm ) {&nbsp;</div></li><li><div>                  if (empty($inclusions))&nbsp;</div></li><li><div>                      $inclusions = ' AND ( t.term_id = ' . intval($interm) . ' ';&nbsp;</div></li><li><div>                  else&nbsp;</div></li><li><div>                      $inclusions .= ' OR t.term_id = ' . intval($interm) . ' ';&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($inclusions) )&nbsp;</div></li><li><div>          $inclusions .= ')';&nbsp;</div></li><li><div>      $where .= $inclusions;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $exclusions = '';&nbsp;</div></li><li><div>      if ( ! empty( $exclude_tree ) ) {&nbsp;</div></li><li><div>          $excluded_trunks = preg_split('/[\s, ]+/', $exclude_tree);&nbsp;</div></li><li><div>          foreach( (array) $excluded_trunks as $extrunk ) {&nbsp;</div></li><li><div>              $excluded_children = (array) $this-&gt;get_terms($taxonomies[0], array('child_of' =&gt; intval($extrunk), 'fields' =&gt; 'ids'));&nbsp;</div></li><li><div>              $excluded_children[] = $extrunk;&nbsp;</div></li><li><div>              foreach( (array) $excluded_children as $exterm ) {&nbsp;</div></li><li><div>                  if ( empty($exclusions) )&nbsp;</div></li><li><div>                      $exclusions = ' AND ( t.term_id &lt;&gt; ' . intval($exterm) . ' ';&nbsp;</div></li><li><div>                  else&nbsp;</div></li><li><div>                      $exclusions .= ' AND t.term_id &lt;&gt; ' . intval($exterm) . ' ';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ( !empty($exclude) ) {&nbsp;</div></li><li><div>          $exterms = preg_split('/[\s, ]+/', $exclude);&nbsp;</div></li><li><div>          if ( count($exterms) ) {&nbsp;</div></li><li><div>              foreach ( (array) $exterms as $exterm ) {&nbsp;</div></li><li><div>                  if ( empty($exclusions) )&nbsp;</div></li><li><div>                      $exclusions = ' AND ( t.term_id &lt;&gt; ' . intval($exterm) . ' ';&nbsp;</div></li><li><div>                  else&nbsp;</div></li><li><div>                      $exclusions .= ' AND t.term_id &lt;&gt; ' . intval($exterm) . ' ';&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($exclusions) )&nbsp;</div></li><li><div>          $exclusions .= ')';&nbsp;</div></li><li><div>      $exclusions = apply_filters('list_terms_exclusions', $exclusions, $args );&nbsp;</div></li><li><div>      $where .= $exclusions;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($slug) ) {&nbsp;</div></li><li><div>          $slug =  $this-&gt;sanitize_term_slug($slug);&nbsp;</div></li><li><div>          $where .= &quot; AND t.slug = '$slug'&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($name__like) )&nbsp;</div></li><li><div>          $where .= &quot; AND t.name LIKE '{$name__like}%'&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( '' !== $parent ) {&nbsp;</div></li><li><div>          $parent = (int) $parent;&nbsp;</div></li><li><div>          $where .= &quot; AND tt.parent = '$parent'&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $hide_empty && !$hierarchical )&nbsp;</div></li><li><div>          $where .= ' AND tt.count &gt; 0';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// don't limit the query results when we have to descend the family tree</span>&nbsp;</div></li><li><div>      if ( ! empty($number) && ! $hierarchical && empty( $child_of ) && '' === $parent ) {&nbsp;</div></li><li><div>          if( $offset )&nbsp;</div></li><li><div>              $limit = 'LIMIT ' . $offset . ', ' . $number;&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $limit = 'LIMIT ' . $number;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      } else&nbsp;</div></li><li><div>          $limit = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($search) ) {&nbsp;</div></li><li><div>          $search = like_escape($search);&nbsp;</div></li><li><div>          $where .= &quot; AND (t.name LIKE '%$search%')&quot;;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !in_array( $fields, array( 'all', 'ids', 'names', 'tt_ids' ) ) )&nbsp;</div></li><li><div>          $fields = 'all';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $selects = array();&nbsp;</div></li><li><div>      if ( 'all' == $fields )&nbsp;</div></li><li><div>          $selects = array('t.*', 'tt.*');&nbsp;</div></li><li><div>      else if ( 'ids' == $fields )&nbsp;</div></li><li><div>          $selects = array('t.term_id', 'tt.parent', 'tt.count');&nbsp;</div></li><li><div>      else if ( 'names' == $fields )&nbsp;</div></li><li><div>          $selects = array('t.term_id', 'tt.parent', 'tt.count', 't.name');&nbsp;</div></li><li><div>          $select_this = implode(', ', apply_filters( 'get_terms_fields', $selects, $args ));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $query = &quot;SELECT $select_this FROM {$this-&gt;db-&gt;terms} AS t INNER JOIN {$this-&gt;db-&gt;term_taxonomy} AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy IN ($in_taxonomies) $where ORDER BY $orderby $order $limit&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = $this-&gt;db-&gt;get_results($query);&nbsp;</div></li><li><div>      if ( 'all' == $fields ) {&nbsp;</div></li><li><div>          $this-&gt;update_term_cache($terms);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($terms) ) {&nbsp;</div></li><li><div>          wp_cache_add( $cache_key, array(), 'terms' );&nbsp;</div></li><li><div>          $terms = apply_filters('get_terms', array(), $taxonomies, $args);&nbsp;</div></li><li><div>          return $terms;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $child_of || $hierarchical ) {&nbsp;</div></li><li><div>          $children = $this-&gt;_get_term_hierarchy($taxonomies[0]);&nbsp;</div></li><li><div>          if ( ! empty($children) )&nbsp;</div></li><li><div>              $terms = & $this-&gt;_get_term_children($child_of, $terms, $taxonomies[0]);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Update term counts to include children.</span>&nbsp;</div></li><li><div>      if ( $pad_counts )&nbsp;</div></li><li><div>          $this-&gt;_pad_term_counts($terms, $taxonomies[0]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Make sure we show empty categories that have children.</span>&nbsp;</div></li><li><div>      if ( $hierarchical && $hide_empty && is_array($terms) ) {&nbsp;</div></li><li><div>          foreach ( $terms as $k =&gt; $term ) {&nbsp;</div></li><li><div>              if ( ! $term-&gt;count ) {&nbsp;</div></li><li><div>                  $children = $this-&gt;_get_term_children($term-&gt;term_id, $terms, $taxonomies[0]);&nbsp;</div></li><li><div>                  if( is_array($children) )&nbsp;</div></li><li><div>                      foreach ( $children as $child )&nbsp;</div></li><li><div>                          if ( $child-&gt;count )&nbsp;</div></li><li><div>                              continue 2;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                  <span class="comment">// It really is empty</span>&nbsp;</div></li><li><div>                  unset($terms[$k]);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      reset ( $terms );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $_terms = array();&nbsp;</div></li><li><div>      if ( 'ids' == $fields ) {&nbsp;</div></li><li><div>          while ( $term = array_shift($terms) )&nbsp;</div></li><li><div>              $_terms[] = $term-&gt;term_id;&nbsp;</div></li><li><div>          $terms = $_terms;&nbsp;</div></li><li><div>      } elseif ( 'names' == $fields ) {&nbsp;</div></li><li><div>          while ( $term = array_shift($terms) )&nbsp;</div></li><li><div>              $_terms[] = $term-&gt;name;&nbsp;</div></li><li><div>          $terms = $_terms;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 0 &lt; $number && intval(@count($terms)) &gt; $number ) {&nbsp;</div></li><li><div>          $terms = array_slice($terms, $offset, $number);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_cache_add( $cache_key, $terms, 'terms' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = apply_filters('get_terms', $terms, $taxonomies, $args);&nbsp;</div></li><li><div>      return $terms;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Check if Term exists.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Returns the index of a defined term, or 0 (false) if the term doesn't exist.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|string $term The term to check</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy The taxonomy name to use</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $parent ID of parent term under which to confine the exists search.</span>&nbsp;</div></li><li><div><span class="comment">   * @return mixed Get the term id or Term Object, if exists.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function is_term($term, $taxonomy = '', $parent = 0) {&nbsp;</div></li><li><div>      $select = &quot;SELECT term_id FROM {$this-&gt;db-&gt;terms} as t WHERE &quot;;&nbsp;</div></li><li><div>      $tax_select = &quot;SELECT tt.term_id, tt.term_taxonomy_id FROM {$this-&gt;db-&gt;terms} AS t INNER JOIN {$this-&gt;db-&gt;term_taxonomy} as tt ON tt.term_id = t.term_id WHERE &quot;;&nbsp;</div></li><li><div>      &nbsp;</div></li><li><div>      if ( is_int($term) ) {&nbsp;</div></li><li><div>          if ( 0 == $term )&nbsp;</div></li><li><div>              return 0;&nbsp;</div></li><li><div>          $where = 't.term_id = %d';&nbsp;</div></li><li><div>          if ( !empty($taxonomy) )&nbsp;</div></li><li><div>              return $this-&gt;db-&gt;get_row( $this-&gt;db-&gt;prepare( $tax_select . $where . &quot; AND tt.taxonomy = %s&quot;, $term, $taxonomy ), ARRAY_A );&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              return $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( $select . $where, $term ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term = trim( stripslashes( $term ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( '' === $slug = $this-&gt;sanitize_term_slug($term) )&nbsp;</div></li><li><div>          return 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $where = 't.slug = %s';&nbsp;</div></li><li><div>      $else_where = 't.name = %s';&nbsp;</div></li><li><div>      $where_fields = array($slug);&nbsp;</div></li><li><div>      $else_where_fields = array($term);&nbsp;</div></li><li><div>      if ( !empty($taxonomy) ) {&nbsp;</div></li><li><div>          $parent = (int) $parent;&nbsp;</div></li><li><div>          if ( $parent &gt; 0 ) {&nbsp;</div></li><li><div>              $where_fields[] = $parent;&nbsp;</div></li><li><div>              $else_where_fields[] = $parent;&nbsp;</div></li><li><div>              $where .= ' AND tt.parent = %d';&nbsp;</div></li><li><div>              $else_where .= ' AND tt.parent = %d';&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $where_fields[] = $taxonomy;&nbsp;</div></li><li><div>          $else_where_fields[] = $taxonomy;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $result = $this-&gt;db-&gt;get_row( $this-&gt;db-&gt;prepare(&quot;SELECT tt.term_id, tt.term_taxonomy_id FROM {$this-&gt;db-&gt;terms} AS t INNER JOIN {$this-&gt;db-&gt;term_taxonomy} as tt ON tt.term_id = t.term_id WHERE $where AND tt.taxonomy = %s&quot;, $where_fields), ARRAY_A) )&nbsp;</div></li><li><div>              return $result;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          return $this-&gt;db-&gt;get_row( $this-&gt;db-&gt;prepare(&quot;SELECT tt.term_id, tt.term_taxonomy_id FROM {$this-&gt;db-&gt;terms} AS t INNER JOIN {$this-&gt;db-&gt;term_taxonomy} as tt ON tt.term_id = t.term_id WHERE $else_where AND tt.taxonomy = %s&quot;, $else_where_fields), ARRAY_A);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $result = $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare(&quot;SELECT term_id FROM {$this-&gt;db-&gt;terms} as t WHERE $where&quot;, $where_fields) ) )&nbsp;</div></li><li><div>          return $result;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare(&quot;SELECT term_id FROM {$this-&gt;db-&gt;terms} as t WHERE $else_where&quot;, $else_where_fields) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function sanitize_term_slug( $title, $taxonomy = '', $term_id = 0 ) {&nbsp;</div></li><li><div>      return apply_filters( 'pre_term_slug', $title, $taxonomy, $term_id );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function format_to_edit( $text ) {&nbsp;</div></li><li><div>      return format_to_edit( $text );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Sanitize Term all fields</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Relies on sanitize_term_field() to sanitize the term. The difference</span>&nbsp;</div></li><li><div><span class="comment">   * is that this function will sanitize &lt;strong&gt;all&lt;/strong&gt; fields. The</span>&nbsp;</div></li><li><div><span class="comment">   * context is based on sanitize_term_field().</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The $term is expected to be either an array or an object.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;sanitize_term_field Used to sanitize all fields in a term</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|object $term The term to check</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy The taxonomy name to use</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $context Default is 'display'.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|object Term with all fields sanitized</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function sanitize_term($term, $taxonomy, $context = 'display') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'raw' == $context )&nbsp;</div></li><li><div>          return $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $fields = array('term_id', 'name', 'description', 'slug', 'count', 'parent', 'term_group');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $do_object = false;&nbsp;</div></li><li><div>      if ( is_object($term) )&nbsp;</div></li><li><div>          $do_object = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_id = $do_object ? $term-&gt;term_id : (isset($term['term_id']) ? $term['term_id'] : 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $fields as $field ) {&nbsp;</div></li><li><div>          if ( $do_object ) {&nbsp;</div></li><li><div>              if ( isset($term-&gt;$field) )&nbsp;</div></li><li><div>                  $term-&gt;$field = $this-&gt;sanitize_term_field($field, $term-&gt;$field, $term_id, $taxonomy, $context);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              if ( isset($term[$field]) )&nbsp;</div></li><li><div>                  $term[$field] = $this-&gt;sanitize_term_field($field, $term[$field], $term_id, $taxonomy, $context);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $do_object )&nbsp;</div></li><li><div>          $term-&gt;filter = $context;&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $term['filter'] = $context;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $term;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Cleanse the field value in the term based on the context.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Passing a term field value through the function should be assumed to have</span>&nbsp;</div></li><li><div><span class="comment">   * cleansed the value for whatever context the term field is going to be used.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If no context or an unsupported context is given, then default filters will</span>&nbsp;</div></li><li><div><span class="comment">   * be applied.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * There are enough filters for each context to support a custom filtering</span>&nbsp;</div></li><li><div><span class="comment">   * without creating your own filter function. Simply create a function that</span>&nbsp;</div></li><li><div><span class="comment">   * hooks into the filter you need.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $field Term field to sanitize</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $value Search for this term value</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id Term ID</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $context Either edit, db, display, attribute, or js.</span>&nbsp;</div></li><li><div><span class="comment">   * @return mixed sanitized field</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function sanitize_term_field($field, $value, $term_id, $taxonomy, $context) {&nbsp;</div></li><li><div>      if ( 'parent' == $field  || 'term_id' == $field || 'count' == $field || 'term_group' == $field ) {&nbsp;</div></li><li><div>          $value = (int) $value;&nbsp;</div></li><li><div>          if ( $value &lt; 0 )&nbsp;</div></li><li><div>              $value = 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'raw' == $context )&nbsp;</div></li><li><div>          return $value;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'edit' == $context ) {&nbsp;</div></li><li><div>          $value = apply_filters(&quot;edit_term_$field&quot;, $value, $term_id, $taxonomy);&nbsp;</div></li><li><div>          $value = apply_filters(&quot;edit_${taxonomy}_$field&quot;, $value, $term_id);&nbsp;</div></li><li><div>          if ( 'description' == $field )&nbsp;</div></li><li><div>              $value = $this-&gt;format_to_edit($value);&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              $value = esc_attr($value);&nbsp;</div></li><li><div>      } else if ( 'db' == $context ) {&nbsp;</div></li><li><div>          $value = apply_filters(&quot;pre_term_$field&quot;, $value, $taxonomy);&nbsp;</div></li><li><div>          $value = apply_filters(&quot;pre_${taxonomy}_$field&quot;, $value);&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// WP DIFF</span></span>&nbsp;</div></li><li><div>      } else if ( 'rss' == $context ) {&nbsp;</div></li><li><div>          $value = apply_filters(&quot;term_${field}_rss&quot;, $value, $taxonomy);&nbsp;</div></li><li><div>          $value = apply_filters(&quot;${taxonomy}_${field}_rss&quot;, $value);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment">// Use display filters by default.</span>&nbsp;</div></li><li><div>          $value = apply_filters(&quot;term_$field&quot;, $value, $term_id, $taxonomy, $context);&nbsp;</div></li><li><div>          $value = apply_filters(&quot;${taxonomy}_$field&quot;, $value, $term_id, $context);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'attribute' == $context )&nbsp;</div></li><li><div>          $value = esc_attr($value);&nbsp;</div></li><li><div>      else if ( 'js' == $context )&nbsp;</div></li><li><div>          $value = esc_js($value);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $value;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Count how many terms are in Taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Default $args is 'ignore_empty' which can be &lt;code&gt;'ignore_empty=true'&lt;/code&gt;</span>&nbsp;</div></li><li><div><span class="comment">   * or &lt;code&gt;array('ignore_empty' =&gt; true);&lt;/code&gt;.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses wp_parse_args() Turns strings into arrays and merges defaults into an array.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy name</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $args Overwrite defaults</span>&nbsp;</div></li><li><div><span class="comment">   * @return int How many terms are in $taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function count_terms( $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>      $defaults = array('ignore_empty' =&gt; false);&nbsp;</div></li><li><div>      $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>      extract($args, EXTR_SKIP);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $where = '';&nbsp;</div></li><li><div>      if ( $ignore_empty )&nbsp;</div></li><li><div>          $where = 'AND count &gt; 0';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT COUNT(*) FROM {$this-&gt;db-&gt;term_taxonomy} WHERE taxonomy = %s $where&quot;, $taxonomy ) );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Will unlink the term from the taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will remove the term's relationship to the taxonomy, not the term or taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * itself. The term and taxonomy will still exist. Will require the term's</span>&nbsp;</div></li><li><div><span class="comment">   * object ID to perform the operation.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $object_id The term Object Id that refers to the term</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $taxonomy List of Taxonomy Names or single Taxonomy name.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function delete_object_term_relationships( $object_id, $taxonomies ) {&nbsp;</div></li><li><div>      $object_id = (int) $object_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($taxonomies) )&nbsp;</div></li><li><div>          $taxonomies = array($taxonomies);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          $terms = $this-&gt;get_object_terms($object_id, $taxonomy, array('fields' =&gt; 'tt_ids'));&nbsp;</div></li><li><div>          $in_terms = &quot;'&quot; . implode(&quot;', '&quot;, $terms) . &quot;'&quot;;&nbsp;</div></li><li><div>          $this-&gt;db-&gt;query( $this-&gt;db-&gt;prepare( &quot;DELETE FROM {$this-&gt;db-&gt;term_relationships} WHERE object_id = %d AND term_taxonomy_id IN ($in_terms)&quot;, $object_id ) );&nbsp;</div></li><li><div>          $this-&gt;update_term_count($terms, $taxonomy);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Removes a term from the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If the term is a parent of other terms, then the children will be updated to</span>&nbsp;</div></li><li><div><span class="comment">   * that term's parent.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The $args 'default' will only override the terms found, if there is only one</span>&nbsp;</div></li><li><div><span class="comment">   * term found. Any other and the found terms are used.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The $args 'force_default' will force the term supplied as default to be</span>&nbsp;</div></li><li><div><span class="comment">   * assigned even if the object was not going to be termless</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses do_action() Calls both 'delete_term' and 'delete_$taxonomy' action</span>&nbsp;</div></li><li><div><span class="comment">   *  hooks, passing term object, term id. 'delete_term' gets an additional</span>&nbsp;</div></li><li><div><span class="comment">   *  parameter with the $taxonomy parameter.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term Term ID</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $args Optional. Change 'default' term id and override found term ids.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool|WP_Error Returns false if not term; true if completes delete action.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function delete_term( $term, $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>      $term = (int) $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $ids = $this-&gt;is_term($term, $taxonomy) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      if ( is_wp_error( $ids ) )&nbsp;</div></li><li><div>          return $ids;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $tt_id = $ids['term_taxonomy_id'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array();&nbsp;</div></li><li><div>      $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>      extract($args, EXTR_SKIP);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( isset($default) ) {&nbsp;</div></li><li><div>          $default = (int) $default;&nbsp;</div></li><li><div>          if ( !$this-&gt;is_term($default, $taxonomy) )&nbsp;</div></li><li><div>              unset($default);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Update children to point to new parent</span>&nbsp;</div></li><li><div>      if ( $this-&gt;is_taxonomy_hierarchical($taxonomy) ) {&nbsp;</div></li><li><div>          $term_obj = $this-&gt;get_term($term, $taxonomy);&nbsp;</div></li><li><div>          if ( is_wp_error( $term_obj ) )&nbsp;</div></li><li><div>              return $term_obj;&nbsp;</div></li><li><div>          $parent = $term_obj-&gt;parent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          $this-&gt;db-&gt;update( $this-&gt;db-&gt;term_taxonomy, compact( 'parent' ), array( 'parent' =&gt; $term_obj-&gt;term_id ) + compact( 'taxonomy' ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $objects = $this-&gt;db-&gt;get_col( $this-&gt;db-&gt;prepare( &quot;SELECT object_id FROM {$this-&gt;db-&gt;term_relationships} WHERE term_taxonomy_id = %d&quot;, $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $objects as $object ) {&nbsp;</div></li><li><div>          $terms = $this-&gt;get_object_terms($object, $taxonomy, array('fields' =&gt; 'ids', 'orderby' =&gt; 'none'));&nbsp;</div></li><li><div>          if ( 1 == count($terms) && isset($default) ) {&nbsp;</div></li><li><div>              $terms = array($default);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $terms = array_diff($terms, array($term));&nbsp;</div></li><li><div>              if (isset($default) && isset($force_default) && $force_default)&nbsp;</div></li><li><div>                  $terms = array_merge($terms, array($default));&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $terms = array_map('intval', $terms);&nbsp;</div></li><li><div>          $this-&gt;set_object_terms($object, $terms, $taxonomy);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;db-&gt;query( $this-&gt;db-&gt;prepare( &quot;DELETE FROM {$this-&gt;db-&gt;term_taxonomy} WHERE term_taxonomy_id = %d&quot;, $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Delete the term if no taxonomies use it.</span>&nbsp;</div></li><li><div>      if ( !$this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT COUNT(*) FROM {$this-&gt;db-&gt;term_taxonomy} WHERE term_id = %d&quot;, $term) ) )&nbsp;</div></li><li><div>          $this-&gt;db-&gt;query( $this-&gt;db-&gt;prepare( &quot;DELETE FROM {$this-&gt;db-&gt;terms} WHERE term_id = %d&quot;, $term) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;clean_term_cache($term, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action('delete_term', $term, $tt_id, $taxonomy);&nbsp;</div></li><li><div>      do_action(&quot;delete_$taxonomy&quot;, $term, $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the terms associated with the given object(s), in the supplied taxonomies.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The following information has to do the $args parameter and for what can be</span>&nbsp;</div></li><li><div><span class="comment">   * contained in the string or array of that parameter, if it exists.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The first argument is called, 'orderby' and has the default value of 'name'.</span>&nbsp;</div></li><li><div><span class="comment">   * The other value that is supported is 'count'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The second argument is called, 'order' and has the default value of 'ASC'.</span>&nbsp;</div></li><li><div><span class="comment">   * The only other value that will be acceptable is 'DESC'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The final argument supported is called, 'fields' and has the default value of</span>&nbsp;</div></li><li><div><span class="comment">   * 'all'. There are multiple other options that can be used instead. Supported</span>&nbsp;</div></li><li><div><span class="comment">   * values are as follows: 'all', 'ids', 'names', and finally</span>&nbsp;</div></li><li><div><span class="comment">   * 'all_with_object_id'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The fields argument also decides what will be returned. If 'all' or</span>&nbsp;</div></li><li><div><span class="comment">   * 'all_with_object_id' is choosen or the default kept intact, then all matching</span>&nbsp;</div></li><li><div><span class="comment">   * terms objects will be returned. If either 'ids' or 'names' is used, then an</span>&nbsp;</div></li><li><div><span class="comment">   * array of all matching term ids or term names will be returned respectively.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|array $object_id The id of the object(s) to retrieve.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $taxonomies The taxonomies to retrieve terms from.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $args Change what is returned</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error The requested term data or empty array if no terms found. WP_Error if $taxonomy does not exist.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function get_object_terms($object_ids, $taxonomies, $args = array()) {&nbsp;</div></li><li><div>      if ( !is_array($taxonomies) )&nbsp;</div></li><li><div>          $taxonomies = array($taxonomies);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>              return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($object_ids) )&nbsp;</div></li><li><div>          $object_ids = array($object_ids);&nbsp;</div></li><li><div>      $object_ids = array_map('intval', $object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array('orderby' =&gt; 'name', 'order' =&gt; 'ASC', 'fields' =&gt; 'all');&nbsp;</div></li><li><div>      $args = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = array();&nbsp;</div></li><li><div>      if ( count($taxonomies) &gt; 1 ) {&nbsp;</div></li><li><div>          foreach ( $taxonomies as $index =&gt; $taxonomy ) {&nbsp;</div></li><li><div>              $t = $this-&gt;get_taxonomy($taxonomy);&nbsp;</div></li><li><div>              if ( isset($t-&gt;args) && is_array($t-&gt;args) && $args != array_merge($args, $t-&gt;args) ) {&nbsp;</div></li><li><div>                  unset($taxonomies[$index]);&nbsp;</div></li><li><div>                  $terms = array_merge($terms, $this-&gt;get_object_terms($object_ids, $taxonomy, array_merge($args, $t-&gt;args)));&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $t = $this-&gt;get_taxonomy($taxonomies[0]);&nbsp;</div></li><li><div>          if ( isset($t-&gt;args) && is_array($t-&gt;args) )&nbsp;</div></li><li><div>              $args = array_merge($args, $t-&gt;args);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      extract($args, EXTR_SKIP);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'count' == $orderby )&nbsp;</div></li><li><div>          $orderby = 'tt.count';&nbsp;</div></li><li><div>      else if ( 'name' == $orderby )&nbsp;</div></li><li><div>          $orderby = 't.name';&nbsp;</div></li><li><div>      else if ( 'slug' == $orderby )&nbsp;</div></li><li><div>          $orderby = 't.slug';&nbsp;</div></li><li><div>      else if ( 'term_group' == $orderby )&nbsp;</div></li><li><div>          $orderby = 't.term_group';&nbsp;</div></li><li><div>      else if ( 'term_order' == $orderby )&nbsp;</div></li><li><div>          $orderby = 'tr.term_order';&nbsp;</div></li><li><div>      else if ( 'none' == $orderby ) {&nbsp;</div></li><li><div>          $orderby = '';&nbsp;</div></li><li><div>          $order = '';&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $orderby = 't.term_id';&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// tt_ids queries can only be none or tr.term_taxonomy_id</span>&nbsp;</div></li><li><div>      if ( ('tt_ids' == $fields) && !empty($orderby) )&nbsp;</div></li><li><div>          $orderby = 'tr.term_taxonomy_id';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($orderby) )&nbsp;</div></li><li><div>          $orderby = &quot;ORDER BY $orderby&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $taxonomies = &quot;'&quot; . implode(&quot;', '&quot;, $taxonomies) . &quot;'&quot;;&nbsp;</div></li><li><div>      $object_ids = implode(', ', $object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $select_this = '';&nbsp;</div></li><li><div>      if ( 'all' == $fields )&nbsp;</div></li><li><div>          $select_this = 't.*, tt.*';&nbsp;</div></li><li><div>      else if ( 'ids' == $fields )&nbsp;</div></li><li><div>          $select_this = 't.term_id';&nbsp;</div></li><li><div>      else if ( 'names' == $fields )&nbsp;</div></li><li><div>          $select_this = 't.name';&nbsp;</div></li><li><div>      else if ( 'all_with_object_id' == $fields )&nbsp;</div></li><li><div>          $select_this = 't.*, tt.*, tr.object_id';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $query = &quot;SELECT $select_this FROM {$this-&gt;db-&gt;terms} AS t INNER JOIN {$this-&gt;db-&gt;term_taxonomy} AS tt ON tt.term_id = t.term_id INNER JOIN {$this-&gt;db-&gt;term_relationships} AS tr ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tr.object_id IN ($object_ids) $orderby $order&quot;;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( 'all' == $fields || 'all_with_object_id' == $fields ) {&nbsp;</div></li><li><div>          $terms = array_merge($terms, $this-&gt;db-&gt;get_results($query));&nbsp;</div></li><li><div>          $this-&gt;update_term_cache($terms);&nbsp;</div></li><li><div>      } else if ( 'ids' == $fields || 'names' == $fields ) {&nbsp;</div></li><li><div>          $terms = array_merge($terms, $this-&gt;db-&gt;get_col($query));&nbsp;</div></li><li><div>      } else if ( 'tt_ids' == $fields ) {&nbsp;</div></li><li><div>          $terms = $this-&gt;db-&gt;get_col(&quot;SELECT tr.term_taxonomy_id FROM {$this-&gt;db-&gt;term_relationships} AS tr INNER JOIN {$this-&gt;db-&gt;term_taxonomy} AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tr.object_id IN ($object_ids) AND tt.taxonomy IN ($taxonomies) $orderby $order&quot;);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $terms )&nbsp;</div></li><li><div>          $terms = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return apply_filters('wp_get_object_terms', $terms, $object_ids, $taxonomies, $args);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Adds a new term to the database. Optionally marks it as an alias of an existing term.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Error handling is assigned for the nonexistance of the $taxonomy and $term</span>&nbsp;</div></li><li><div><span class="comment">   * parameters before inserting. If both the term id and taxonomy exist</span>&nbsp;</div></li><li><div><span class="comment">   * previously, then an array will be returned that contains the term id and the</span>&nbsp;</div></li><li><div><span class="comment">   * contents of what is returned. The keys of the array are 'term_id' and</span>&nbsp;</div></li><li><div><span class="comment">   * 'term_taxonomy_id' containing numeric values.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * It is assumed that the term does not yet exist or the above will apply. The</span>&nbsp;</div></li><li><div><span class="comment">   * term will be first added to the term table and then related to the taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * if everything is well. If everything is correct, then several actions will be</span>&nbsp;</div></li><li><div><span class="comment">   * run prior to a filter and then several actions will be run after the filter</span>&nbsp;</div></li><li><div><span class="comment">   * is run.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The arguments decide how the term is handled based on the $args parameter.</span>&nbsp;</div></li><li><div><span class="comment">   * The following is a list of the available overrides and the defaults.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * 'alias_of'. There is no default, but if added, expected is the slug that the</span>&nbsp;</div></li><li><div><span class="comment">   * term will be an alias of. Expected to be a string.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * 'description'. There is no default. If exists, will be added to the database</span>&nbsp;</div></li><li><div><span class="comment">   * along with the term. Expected to be a string.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * 'parent'. Expected to be numeric and default is 0 (zero). Will assign value</span>&nbsp;</div></li><li><div><span class="comment">   * of 'parent' to the term.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * 'slug'. Expected to be a string. There is no default.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If 'slug' argument exists then the slug will be checked to see if it is not</span>&nbsp;</div></li><li><div><span class="comment">   * a valid term. If that check succeeds (it is not a valid term), then it is</span>&nbsp;</div></li><li><div><span class="comment">   * added and the term id is given. If it fails, then a check is made to whether</span>&nbsp;</div></li><li><div><span class="comment">   * the taxonomy is hierarchical and the parent argument is not empty. If the</span>&nbsp;</div></li><li><div><span class="comment">   * second check succeeds, the term will be inserted and the term id will be</span>&nbsp;</div></li><li><div><span class="comment">   * given.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses do_action() Calls 'create_term' hook with the term id and taxonomy id as parameters.</span>&nbsp;</div></li><li><div><span class="comment">   * @uses do_action() Calls 'create_$taxonomy' hook with term id and taxonomy id as parameters.</span>&nbsp;</div></li><li><div><span class="comment">   * @uses apply_filters() Calls 'term_id_filter' hook with term id and taxonomy id as parameters.</span>&nbsp;</div></li><li><div><span class="comment">   * @uses do_action() Calls 'created_term' hook with the term id and taxonomy id as parameters.</span>&nbsp;</div></li><li><div><span class="comment">   * @uses do_action() Calls 'created_$taxonomy' hook with term id and taxonomy id as parameters.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|string $term The term to add or update.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy The taxonomy to which to add the term</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $args Change the values of the inserted term</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error The Term ID and Term Taxonomy ID</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function insert_term( $term, $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>          return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_int($term) && 0 == $term )&nbsp;</div></li><li><div>          return new WP_Error('invalid_term_id', __('Invalid term ID'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( '' == trim($term) )&nbsp;</div></li><li><div>          return new WP_Error('empty_term_name', __('A name is required for this term'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array( 'alias_of' =&gt; '', 'description' =&gt; '', 'parent' =&gt; 0, 'slug' =&gt; '');&nbsp;</div></li><li><div>      $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>      $args['name'] = $term;&nbsp;</div></li><li><div>      $args['taxonomy'] = $taxonomy;&nbsp;</div></li><li><div>      $args = $this-&gt;sanitize_term($args, $taxonomy, 'db');&nbsp;</div></li><li><div>      extract($args, EXTR_SKIP);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// expected_slashed ($name)</span></span>&nbsp;</div></li><li><div>      $name = stripslashes($name);&nbsp;</div></li><li><div>      $description = stripslashes($description);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($slug) )&nbsp;</div></li><li><div>          $slug = $this-&gt;sanitize_term_slug($name, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_group = 0;&nbsp;</div></li><li><div>      if ( $alias_of ) {&nbsp;</div></li><li><div>          $alias = $this-&gt;db-&gt;get_row( $this-&gt;db-&gt;prepare( &quot;SELECT term_id, term_group FROM {$this-&gt;db-&gt;terms} WHERE slug = %s&quot;, $alias_of) );&nbsp;</div></li><li><div>          if ( $alias-&gt;term_group ) {&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">// The alias we want is already in a group, so let's use that one.</span></span>&nbsp;</div></li><li><div>              $term_group = $alias-&gt;term_group;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.</span></span>&nbsp;</div></li><li><div>              $term_group = $this-&gt;db-&gt;get_var(&quot;SELECT MAX(term_group) FROM {$this-&gt;db-&gt;terms}&quot;) + 1;&nbsp;</div></li><li><div>              $this-&gt;db-&gt;query( $this-&gt;db-&gt;prepare( &quot;UPDATE {$this-&gt;db-&gt;terms} SET term_group = %d WHERE term_id = %d&quot;, $term_group, $alias-&gt;term_id ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $term_id = $this-&gt;is_term($slug) ) {&nbsp;</div></li><li><div>          if ( false === $this-&gt;db-&gt;insert( $this-&gt;db-&gt;terms, compact( 'name', 'slug', 'term_group' ) ) )&nbsp;</div></li><li><div>              return new WP_Error('db_insert_error', __('Could not insert term into the database'), $this-&gt;db-&gt;last_error);&nbsp;</div></li><li><div>          $term_id = (int) $this-&gt;db-&gt;insert_id;&nbsp;</div></li><li><div>      } else if ( $this-&gt;is_taxonomy_hierarchical($taxonomy) && !empty($parent) ) {&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// If the taxonomy supports hierarchy and the term has a parent, make the slug unique</span></span>&nbsp;</div></li><li><div>          <span class="comment"><span class="comment">// by incorporating parent slugs.</span></span>&nbsp;</div></li><li><div>          $slug = $this-&gt;unique_term_slug($slug, (object) $args);&nbsp;</div></li><li><div>          if ( false === $this-&gt;db-&gt;insert( $this-&gt;db-&gt;terms, compact( 'name', 'slug', 'term_group' ) ) )&nbsp;</div></li><li><div>              return new WP_Error('db_insert_error', __('Could not insert term into the database'), $this-&gt;db-&gt;last_error);&nbsp;</div></li><li><div>          $term_id = (int) $this-&gt;db-&gt;insert_id;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($slug) ) {&nbsp;</div></li><li><div>          $slug = $this-&gt;sanitize_term_slug($slug, $taxonomy, $term_id);&nbsp;</div></li><li><div>          $this-&gt;db-&gt;update( $this-&gt;db-&gt;terms, compact( 'slug' ), compact( 'term_id' ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $tt_id = $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT tt.term_taxonomy_id FROM {$this-&gt;db-&gt;term_taxonomy} AS tt INNER JOIN {$this-&gt;db-&gt;terms} AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d&quot;, $taxonomy, $term_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !empty($tt_id) )&nbsp;</div></li><li><div>          return array('term_id' =&gt; $term_id, 'term_taxonomy_id' =&gt; $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;db-&gt;insert( $this-&gt;db-&gt;term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent') + array( 'count' =&gt; 0 ) );&nbsp;</div></li><li><div>      $tt_id = (int) $this-&gt;db-&gt;insert_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action(&quot;create_term&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>      do_action(&quot;create_$taxonomy&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_id = apply_filters('term_id_filter', $term_id, $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;clean_term_cache($term_id, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action(&quot;created_term&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>      do_action(&quot;created_$taxonomy&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array('term_id' =&gt; $term_id, 'term_taxonomy_id' =&gt; $tt_id);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Create Term and Taxonomy Relationships.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Relates an object (post, link etc) to a term and taxonomy type. Creates the</span>&nbsp;</div></li><li><div><span class="comment">   * term and taxonomy relationship if it doesn't already exist. Creates a term if</span>&nbsp;</div></li><li><div><span class="comment">   * it doesn't exist (using the slug).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * A relationship means that the term is grouped in or belongs to the taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   * A term has no meaning until it is given context by defining which taxonomy it</span>&nbsp;</div></li><li><div><span class="comment">   * exists under.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $object_id The object to relate to.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|int|string $term The slug or id of the term, will replace all existing</span>&nbsp;</div></li><li><div><span class="comment">   * related terms in this taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $taxonomy The context in which to relate the term to the object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool $append If false will delete difference of terms.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error Affected Term IDs</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function set_object_terms($object_id, $terms, $taxonomy, $append = false) {&nbsp;</div></li><li><div>      $object_id = (int) $object_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>          return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($terms) )&nbsp;</div></li><li><div>          $terms = array($terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $append )&nbsp;</div></li><li><div>          $old_tt_ids = $this-&gt;get_object_terms($object_id, $taxonomy, array('fields' =&gt; 'tt_ids', 'orderby' =&gt; 'none'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $tt_ids = array();&nbsp;</div></li><li><div>      $term_ids = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>          if ( !strlen(trim($term)) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( !$id = $this-&gt;is_term($term, $taxonomy) )&nbsp;</div></li><li><div>              $id = $this-&gt;insert_term($term, $taxonomy);&nbsp;</div></li><li><div>          if ( is_wp_error($id) )&nbsp;</div></li><li><div>              return $id;&nbsp;</div></li><li><div>          $term_ids[] = $id['term_id'];&nbsp;</div></li><li><div>          $id = $id['term_taxonomy_id'];&nbsp;</div></li><li><div>          $tt_ids[] = $id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT term_taxonomy_id FROM {$this-&gt;db-&gt;term_relationships} WHERE object_id = %d AND term_taxonomy_id = %d&quot;, $object_id, $id ) ) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          $this-&gt;db-&gt;insert( $this-&gt;db-&gt;term_relationships, array( 'object_id' =&gt; $object_id, 'term_taxonomy_id' =&gt; $id ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;update_term_count($tt_ids, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( ! $append ) {&nbsp;</div></li><li><div>          $delete_terms = array_diff($old_tt_ids, $tt_ids);&nbsp;</div></li><li><div>          if ( $delete_terms ) {&nbsp;</div></li><li><div>              $in_delete_terms = &quot;'&quot; . implode(&quot;', '&quot;, $delete_terms) . &quot;'&quot;;&nbsp;</div></li><li><div>              $this-&gt;db-&gt;query( $this-&gt;db-&gt;prepare(&quot;DELETE FROM {$this-&gt;db-&gt;term_relationships} WHERE object_id = %d AND term_taxonomy_id IN ($in_delete_terms)&quot;, $object_id) );&nbsp;</div></li><li><div>              $this-&gt;update_term_count($delete_terms, $taxonomy);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $t = $this-&gt;get_taxonomy($taxonomy);&nbsp;</div></li><li><div>      if ( ! $append && isset($t-&gt;sort) && $t-&gt;sort ) {&nbsp;</div></li><li><div>          $values = array();&nbsp;</div></li><li><div>          $term_order = 0;&nbsp;</div></li><li><div>          $final_tt_ids = $this-&gt;get_object_terms($object_id, $taxonomy, 'fields=tt_ids');&nbsp;</div></li><li><div>          foreach ( $tt_ids as $tt_id )&nbsp;</div></li><li><div>              if ( in_array($tt_id, $final_tt_ids) )&nbsp;</div></li><li><div>                  $values[] = $this-&gt;db-&gt;prepare( &quot;(%d, %d, %d)&quot;, $object_id, $tt_id, ++$term_order);&nbsp;</div></li><li><div>          if ( $values )&nbsp;</div></li><li><div>              $this-&gt;db-&gt;query(&quot;INSERT INTO {$this-&gt;db-&gt;term_relationships} (object_id, term_taxonomy_id, term_order) VALUES &quot; . join(', ', $values) . &quot; ON DUPLICATE KEY UPDATE term_order = VALUES(term_order)&quot;);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action('set_object_terms', $object_id, $terms, $tt_ids, $taxonomy, $append);&nbsp;</div></li><li><div>      return $tt_ids;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Will make slug unique, if it isn't already.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The $slug has to be unique global to every taxonomy, meaning that one</span>&nbsp;</div></li><li><div><span class="comment">   * taxonomy term can't have a matching slug with another taxonomy term. Each</span>&nbsp;</div></li><li><div><span class="comment">   * slug has to be globally unique for every taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The way this works is that if the taxonomy that the term belongs to is</span>&nbsp;</div></li><li><div><span class="comment">   * heirarchical and has a parent, it will append that parent to the $slug.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If that still doesn't return an unique slug, then it try to append a number</span>&nbsp;</div></li><li><div><span class="comment">   * until it finds a number that is truely unique.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The only purpose for $term is for appending a parent, if one exists.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $slug The string that will be tried for a unique slug</span>&nbsp;</div></li><li><div><span class="comment">   * @param object $term The term object that the $slug will belong too</span>&nbsp;</div></li><li><div><span class="comment">   * @return string Will return a true unique slug.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function unique_term_slug($slug, $term) {&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// If the taxonomy supports hierarchy and the term has a parent, make the slug unique</span></span>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// by incorporating parent slugs.</span></span>&nbsp;</div></li><li><div>      if ( $this-&gt;is_taxonomy_hierarchical($term-&gt;taxonomy) && !empty($term-&gt;parent) ) {&nbsp;</div></li><li><div>          $the_parent = $term-&gt;parent;&nbsp;</div></li><li><div>          while ( ! empty($the_parent) ) {&nbsp;</div></li><li><div>              $parent_term = $this-&gt;get_term($the_parent, $term-&gt;taxonomy);&nbsp;</div></li><li><div>              if ( is_wp_error($parent_term) || empty($parent_term) )&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>                  $slug .= '-' . $parent_term-&gt;slug;&nbsp;</div></li><li><div>              if ( empty($parent_term-&gt;parent) )&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              $the_parent = $parent_term-&gt;parent;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// If we didn't get a unique slug, try appending a number to make it unique.</span>&nbsp;</div></li><li><div>      if ( !empty($args['term_id']) )&nbsp;</div></li><li><div>          $query = $this-&gt;db-&gt;prepare( &quot;SELECT slug FROM {$this-&gt;db-&gt;terms} WHERE slug = %s AND term_id != %d&quot;, $slug, $args['term_id'] );&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $query = $this-&gt;db-&gt;prepare( &quot;SELECT slug FROM {$this-&gt;db-&gt;terms} WHERE slug = %s&quot;, $slug );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $this-&gt;db-&gt;get_var( $query ) ) {&nbsp;</div></li><li><div>          $num = 2;&nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              $alt_slug = $slug . &quot;-$num&quot;;&nbsp;</div></li><li><div>              $num++;&nbsp;</div></li><li><div>              $slug_check = $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT slug FROM {$this-&gt;db-&gt;terms} WHERE slug = %s&quot;, $alt_slug ) );&nbsp;</div></li><li><div>          } while ( $slug_check );&nbsp;</div></li><li><div>          $slug = $alt_slug;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $slug;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Update term based on arguments provided.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The $args will indiscriminately override all values with the same field name.</span>&nbsp;</div></li><li><div><span class="comment">   * Care must be taken to not override important information need to update or</span>&nbsp;</div></li><li><div><span class="comment">   * update will fail (or perhaps create a new term, neither would be acceptable).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Defaults will set 'alias_of', 'description', 'parent', and 'slug' if not</span>&nbsp;</div></li><li><div><span class="comment">   * defined in $args already.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * 'alias_of' will create a term group, if it doesn't already exist, and update</span>&nbsp;</div></li><li><div><span class="comment">   * it for the $term.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If the 'slug' argument in $args is missing, then the 'name' in $args will be</span>&nbsp;</div></li><li><div><span class="comment">   * used. It should also be noted that if you set 'slug' and it isn't unique then</span>&nbsp;</div></li><li><div><span class="comment">   * a WP_Error will be passed back. If you don't pass any slug, then a unique one</span>&nbsp;</div></li><li><div><span class="comment">   * will be created for you.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * For what can be overrode in $args, check the term scheme can contain and stay</span>&nbsp;</div></li><li><div><span class="comment">   * away from the term keys.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses do_action() Will call both 'edit_term' and 'edit_$taxonomy' twice.</span>&nbsp;</div></li><li><div><span class="comment">   * @uses apply_filters() Will call the 'term_id_filter' filter and pass the term</span>&nbsp;</div></li><li><div><span class="comment">   *  id and taxonomy id.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id The ID of the term</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy The context in which to relate the term to the object.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array|string $args Overwrite term field values</span>&nbsp;</div></li><li><div><span class="comment">   * @return array|WP_Error Returns Term ID and Taxonomy Term ID</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function update_term( $term_id, $taxonomy, $args = array() ) {&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy($taxonomy) )&nbsp;</div></li><li><div>          return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_id = (int) $term_id;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// First, get all of the original args</span>&nbsp;</div></li><li><div>      $term = $this-&gt;get_term($term_id, $taxonomy, ARRAY_A);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_wp_error( $term ) )&nbsp;</div></li><li><div>          return $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Merge old and new args with new args overwriting old ones.</span>&nbsp;</div></li><li><div>      $args = array_merge($term, $args);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $defaults = array( 'alias_of' =&gt; '', 'description' =&gt; '', 'parent' =&gt; 0, 'slug' =&gt; '');&nbsp;</div></li><li><div>      $args = wp_parse_args($args, $defaults);&nbsp;</div></li><li><div>      $args = $this-&gt;sanitize_term($args, $taxonomy, 'db');&nbsp;</div></li><li><div>      extract($args, EXTR_SKIP);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment"><span class="comment">// expected_slashed ($name)</span></span>&nbsp;</div></li><li><div>      $name = stripslashes($name);&nbsp;</div></li><li><div>      $description = stripslashes($description);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( '' == trim($name) )&nbsp;</div></li><li><div>          return new WP_Error('empty_term_name', __('A name is required for this term'));&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $empty_slug = false;&nbsp;</div></li><li><div>      if ( empty($slug) ) {&nbsp;</div></li><li><div>          $empty_slug = true;&nbsp;</div></li><li><div>          $slug = $this-&gt;sanitize_term_slug($name, $taxonomy, $term_id);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $alias_of ) {&nbsp;</div></li><li><div>          $alias = $this-&gt;db-&gt;get_row( $this-&gt;db-&gt;prepare( &quot;SELECT term_id, term_group FROM {$this-&gt;db-&gt;terms} WHERE slug = %s&quot;, $alias_of) );&nbsp;</div></li><li><div>          if ( $alias-&gt;term_group ) {&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">// The alias we want is already in a group, so let's use that one.</span></span>&nbsp;</div></li><li><div>              $term_group = $alias-&gt;term_group;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              <span class="comment"><span class="comment">// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.</span></span>&nbsp;</div></li><li><div>              $term_group = $this-&gt;db-&gt;get_var(&quot;SELECT MAX(term_group) FROM {$this-&gt;db-&gt;terms}&quot;) + 1;&nbsp;</div></li><li><div>              $this-&gt;db-&gt;update( $this-&gt;db-&gt;terms, compact('term_group'), array( 'term_id' =&gt; $alias-&gt;term_id ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      <span class="comment">// Check for duplicate slug</span>&nbsp;</div></li><li><div>      $id = $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT term_id FROM {$this-&gt;db-&gt;terms} WHERE slug = %s&quot;, $slug ) );&nbsp;</div></li><li><div>      if ( $id && ($id != $term_id) ) {&nbsp;</div></li><li><div>          <span class="comment">// If an empty slug was passed or the parent changed, reset the slug to something unique.</span>&nbsp;</div></li><li><div>          <span class="comment">// Otherwise, bail.</span>&nbsp;</div></li><li><div>          if ( $empty_slug || ( $parent != $term-&gt;parent) )&nbsp;</div></li><li><div>              $slug = $this-&gt;unique_term_slug($slug, (object) $args);&nbsp;</div></li><li><div>          else&nbsp;</div></li><li><div>              return new WP_Error('duplicate_term_slug', sprintf(__('The slug &#8220;%s&#8221; is already in use by another term'), $slug));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;db-&gt;update($this-&gt;db-&gt;terms, compact( 'name', 'slug', 'term_group' ), compact( 'term_id' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($slug) ) {&nbsp;</div></li><li><div>          $slug = $this-&gt;sanitize_term_slug($name, $taxonomy, $term_id);&nbsp;</div></li><li><div>          $this-&gt;db-&gt;update( $this-&gt;db-&gt;terms, compact( 'slug' ), compact( 'term_id' ) );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $tt_id = $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT tt.term_taxonomy_id FROM {$this-&gt;db-&gt;term_taxonomy} AS tt INNER JOIN {$this-&gt;db-&gt;terms} AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d&quot;, $taxonomy, $term_id) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;db-&gt;update( $this-&gt;db-&gt;term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent' ), array( 'term_taxonomy_id' =&gt; $tt_id ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action(&quot;edit_term&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>      do_action(&quot;edit_$taxonomy&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_id = apply_filters('term_id_filter', $term_id, $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;clean_term_cache($term_id, $taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action(&quot;edited_term&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>      do_action(&quot;edited_$taxonomy&quot;, $term_id, $tt_id);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return array('term_id' =&gt; $term_id, 'term_taxonomy_id' =&gt; $tt_id);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Enable or disable term counting.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param bool $defer Optional. Enable if true, disable if false.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool Whether term counting is enabled or disabled.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function defer_term_counting($defer=NULL) {&nbsp;</div></li><li><div>      static $_defer = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_bool($defer) ) {&nbsp;</div></li><li><div>          $_defer = $defer;&nbsp;</div></li><li><div>          <span class="comment">// flush any deferred counts</span>&nbsp;</div></li><li><div>          if ( !$defer )&nbsp;</div></li><li><div>              $this-&gt;update_term_count( NULL, NULL, true );&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $_defer;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Updates the amount of terms in taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If there is a taxonomy callback applied, then it will be called for updating</span>&nbsp;</div></li><li><div><span class="comment">   * the count.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The default action is to count what the amount of terms have the relationship</span>&nbsp;</div></li><li><div><span class="comment">   * of term ID. Once that is done, then update the database.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;db</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|array $terms The ID of the terms</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy The context of the term.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool If no terms will return false, and if successful will return true.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function update_term_count( $terms, $taxonomy, $do_deferred=false ) {&nbsp;</div></li><li><div>      static $_deferred = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $do_deferred ) {&nbsp;</div></li><li><div>          foreach ( (array) array_keys($_deferred) as $tax ) {&nbsp;</div></li><li><div>              $this-&gt;update_term_count_now( $_deferred[$tax], $tax );&nbsp;</div></li><li><div>              unset( $_deferred[$tax] );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty($terms) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($terms) )&nbsp;</div></li><li><div>          $terms = array($terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $this-&gt;defer_term_counting() ) {&nbsp;</div></li><li><div>          if ( !isset($_deferred[$taxonomy]) )&nbsp;</div></li><li><div>              $_deferred[$taxonomy] = array();&nbsp;</div></li><li><div>          $_deferred[$taxonomy] = array_unique( array_merge($_deferred[$taxonomy], $terms) );&nbsp;</div></li><li><div>          return true;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $this-&gt;update_term_count_now( $terms, $taxonomy );&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Perform term count update immediately.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.5.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $terms The term_taxonomy_id of terms to update.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy The context of the term.</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool Always true when complete.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function update_term_count_now( $terms, $taxonomy ) {&nbsp;</div></li><li><div>      $terms = array_map('intval', $terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $taxonomy = $this-&gt;get_taxonomy($taxonomy);&nbsp;</div></li><li><div>      if ( !empty($taxonomy-&gt;update_count_callback) ) {&nbsp;</div></li><li><div>          call_user_func($taxonomy-&gt;update_count_callback, $terms);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          <span class="comment">// Default count updater</span>&nbsp;</div></li><li><div>          foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>              $count = $this-&gt;db-&gt;get_var( $this-&gt;db-&gt;prepare( &quot;SELECT COUNT(*) FROM {$this-&gt;db-&gt;term_relationships} WHERE term_taxonomy_id = %d&quot;, $term) );&nbsp;</div></li><li><div>              $this-&gt;db-&gt;update( $this-&gt;db-&gt;term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' =&gt; $term ) );&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $this-&gt;clean_term_cache($terms);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return true;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>  // Cache&nbsp;</div></li><li><div>  <span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Removes the taxonomy relationship to terms from the cache.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will remove the entire taxonomy relationship containing term $object_id. The</span>&nbsp;</div></li><li><div><span class="comment">   * term IDs have to exist within the taxonomy $object_type for the deletion to</span>&nbsp;</div></li><li><div><span class="comment">   * take place.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @see $this-&gt;get_object_taxonomies() for more on $object_type</span>&nbsp;</div></li><li><div><span class="comment">   * @uses do_action() Will call action hook named, 'clean_object_term_cache' after completion.</span>&nbsp;</div></li><li><div><span class="comment">   *    Passes, function params in same order.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|array $object_ids Single or list of term object ID(s)</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $object_type The taxonomy object type</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function clean_object_term_cache($object_ids, $object_type) {&nbsp;</div></li><li><div>      if ( !is_array($object_ids) )&nbsp;</div></li><li><div>          $object_ids = array($object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $object_ids as $id )&nbsp;</div></li><li><div>          foreach ( $this-&gt;get_object_taxonomies($object_type) as $taxonomy )&nbsp;</div></li><li><div>              wp_cache_delete($id, &quot;{$taxonomy}_relationships&quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action('clean_object_term_cache', $object_ids, $object_type);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Will remove all of the term ids from the cache.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|array $ids Single or list of Term IDs</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Can be empty and will assume tt_ids, else will use for context.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function clean_term_cache($ids, $taxonomy = '') {&nbsp;</div></li><li><div>      static $cleaned = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($ids) )&nbsp;</div></li><li><div>          $ids = array($ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $taxonomies = array();&nbsp;</div></li><li><div>      <span class="comment">// If no taxonomy, assume tt_ids.</span>&nbsp;</div></li><li><div>      if ( empty($taxonomy) ) {&nbsp;</div></li><li><div>          $tt_ids = implode( ', ', array_map( 'intval', $ids ) );&nbsp;</div></li><li><div>          $terms = $this-&gt;db-&gt;get_results(&quot;SELECT term_id, term_taxonomy_id, taxonomy FROM {$this-&gt;db-&gt;term_taxonomy} WHERE term_taxonomy_id IN ($tt_ids)&quot;);&nbsp;</div></li><li><div>          foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>              $taxonomies[] = $term-&gt;taxonomy;&nbsp;</div></li><li><div>              wp_cache_delete($term-&gt;term_id, $term-&gt;taxonomy);&nbsp;</div></li><li><div>              wp_cache_delete($term-&gt;term_taxonomy_id, &quot;{$term-&gt;taxonomy}:tt_id&quot;);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $taxonomies = array_unique($taxonomies);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $tt_ids = implode( ', ', array_map( 'intval', $ids ) );&nbsp;</div></li><li><div>          $terms = $this-&gt;db-&gt;get_results(&quot;SELECT term_id, term_taxonomy_id FROM {$this-&gt;db-&gt;term_taxonomy} WHERE term_id IN ($tt_ids)&quot;);&nbsp;</div></li><li><div>          foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>              wp_cache_delete($term-&gt;term_id, $taxonomy);&nbsp;</div></li><li><div>              wp_cache_delete($term-&gt;term_taxonomy_id, &quot;$taxonomy:tt_id&quot;);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $taxonomies = array($taxonomy);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>          if ( isset($cleaned[$taxonomy]) )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>          $cleaned[$taxonomy] = true;&nbsp;</div></li><li><div>          wp_cache_delete('all_ids', $taxonomy);&nbsp;</div></li><li><div>          wp_cache_delete('get', $taxonomy);&nbsp;</div></li><li><div>          $this-&gt;delete_children_cache($taxonomy);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      wp_cache_delete('get_terms', 'terms');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      do_action('clean_term_cache', $ids, $taxonomy);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves the taxonomy relationship to the term object id.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses wp_cache_get() Retrieves taxonomy relationship from cache</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|array $id Term object ID</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool|array Empty array if $terms found, but not $taxonomy. False if nothing is in cache for $taxonomy and $id.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function &get_object_term_cache($id, $taxonomy) {&nbsp;</div></li><li><div>      $cache = wp_cache_get($id, &quot;{$taxonomy}_relationships&quot;);&nbsp;</div></li><li><div>      return $cache;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Updates the cache for Term ID(s).</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Will only update the cache for terms not already cached.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The $object_ids expects that the ids be separated by commas, if it is a</span>&nbsp;</div></li><li><div><span class="comment">   * string.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * It should be noted that update_object_term_cache() is very time extensive. It</span>&nbsp;</div></li><li><div><span class="comment">   * is advised that the function is not called very often or at least not for a</span>&nbsp;</div></li><li><div><span class="comment">   * lot of terms that exist in a lot of taxonomies. The amount of time increases</span>&nbsp;</div></li><li><div><span class="comment">   * for each term and it also increases for each taxonomy the term belongs to.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   * @uses $this-&gt;get_object_terms() Used to get terms from the database to update</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string|array $object_ids Single or list of term object ID(s)</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $object_type The taxonomy object type</span>&nbsp;</div></li><li><div><span class="comment">   * @return null|bool Null value is given with empty $object_ids. False if </span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function update_object_term_cache($object_ids, $object_type) {&nbsp;</div></li><li><div>      if ( empty($object_ids) )&nbsp;</div></li><li><div>          return;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( !is_array($object_ids) )&nbsp;</div></li><li><div>          $object_ids = explode(', ', $object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $object_ids = array_map('intval', $object_ids);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $taxonomies = $this-&gt;get_object_taxonomies($object_type);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $ids = array();&nbsp;</div></li><li><div>      foreach ( (array) $object_ids as $id ) {&nbsp;</div></li><li><div>          foreach ( $taxonomies as $taxonomy ) {&nbsp;</div></li><li><div>              if ( false === wp_cache_get($id, &quot;{$taxonomy}_relationships&quot;) ) {&nbsp;</div></li><li><div>                  $ids[] = $id;&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( empty( $ids ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = $this-&gt;get_object_terms($ids, $taxonomies, 'fields=all_with_object_id');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $object_terms = array();&nbsp;</div></li><li><div>      foreach ( (array) $terms as $term )&nbsp;</div></li><li><div>          $object_terms[$term-&gt;object_id][$term-&gt;taxonomy][$term-&gt;term_id] = $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $ids as $id ) {&nbsp;</div></li><li><div>          foreach ( $taxonomies  as $taxonomy ) {&nbsp;</div></li><li><div>              if ( ! isset($object_terms[$id][$taxonomy]) ) {&nbsp;</div></li><li><div>                  if ( !isset($object_terms[$id]) )&nbsp;</div></li><li><div>                      $object_terms[$id] = array();&nbsp;</div></li><li><div>                  $object_terms[$id][$taxonomy] = array();&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $object_terms as $id =&gt; $value ) {&nbsp;</div></li><li><div>          foreach ( $value as $taxonomy =&gt; $terms ) {&nbsp;</div></li><li><div>              wp_cache_set($id, $terms, &quot;{$taxonomy}_relationships&quot;);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Updates Terms to Taxonomy in cache.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $terms List of Term objects to change</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Optional. Update Term to this taxonomy in cache</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function update_term_cache($terms, $taxonomy = '') {&nbsp;</div></li><li><div>      foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>          $term_taxonomy = $taxonomy;&nbsp;</div></li><li><div>          if ( empty($term_taxonomy) )&nbsp;</div></li><li><div>              $term_taxonomy = $term-&gt;taxonomy;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          wp_cache_add($term-&gt;term_id, $term, $term_taxonomy);&nbsp;</div></li><li><div>          wp_cache_add($term-&gt;term_taxonomy_id, $term-&gt;term_id, &quot;$term_taxonomy:tt_id&quot;);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>  // Private&nbsp;</div></li><li><div>  <span class="comment">//</span>&nbsp;</div></li><li><div><span class="comment">&nbsp;</span>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Retrieves children of taxonomy as Term IDs.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @uses backpress_update_option() Stores all of the children in &quot;$taxonomy_children&quot;</span>&nbsp;</div></li><li><div><span class="comment">   *  option. That is the name of the taxonomy, immediately followed by '_children'.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Taxonomy Name</span>&nbsp;</div></li><li><div><span class="comment">   * @return array Empty if $taxonomy isn't hierarachical or returns children as Term IDs.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function _get_term_hierarchy($taxonomy) {&nbsp;</div></li><li><div>      if ( !$this-&gt;is_taxonomy_hierarchical($taxonomy) )&nbsp;</div></li><li><div>          return array();&nbsp;</div></li><li><div>      $children = $this-&gt;get_children_cache($taxonomy);&nbsp;</div></li><li><div>      if ( is_array($children) )&nbsp;</div></li><li><div>          return $children;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $children = array();&nbsp;</div></li><li><div>      $terms = $this-&gt;get_terms($taxonomy, 'get=all');&nbsp;</div></li><li><div>      foreach ( $terms as $term ) {&nbsp;</div></li><li><div>          if ( $term-&gt;parent &gt; 0 )&nbsp;</div></li><li><div>              $children[$term-&gt;parent][] = $term-&gt;term_id;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $this-&gt;set_children_cache($taxonomy, $children);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $children;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Get the subset of $terms that are descendants of $term_id.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * If $terms is an array of objects, then _get_term_children returns an array of objects.</span>&nbsp;</div></li><li><div><span class="comment">   * If $terms is an array of IDs, then _get_term_children returns an array of IDs.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3.0</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $term_id The ancestor term: all returned terms should be descendants of $term_id.</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $terms The set of terms---either an array of term objects or term IDs---from which those that are descendants of $term_id will be chosen.</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy The taxonomy which determines the hierarchy of the terms.</span>&nbsp;</div></li><li><div><span class="comment">   * @return array The subset of $terms that are descendants of $term_id.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function &_get_term_children($term_id, $terms, $taxonomy) {&nbsp;</div></li><li><div>      $empty_array = array();&nbsp;</div></li><li><div>      if ( empty($terms) )&nbsp;</div></li><li><div>          return $empty_array;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $term_list = array();&nbsp;</div></li><li><div>      $has_children = $this-&gt;_get_term_hierarchy($taxonomy);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if  ( ( 0 != $term_id ) && ! isset($has_children[$term_id]) )&nbsp;</div></li><li><div>          return $empty_array;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( (array) $terms as $term ) {&nbsp;</div></li><li><div>          $use_id = false;&nbsp;</div></li><li><div>          if ( !is_object($term) ) {&nbsp;</div></li><li><div>              $term = $this-&gt;get_term($term, $taxonomy);&nbsp;</div></li><li><div>              if ( is_wp_error( $term ) )&nbsp;</div></li><li><div>                  return $term;&nbsp;</div></li><li><div>              $use_id = true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $term-&gt;term_id == $term_id )&nbsp;</div></li><li><div>              continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>          if ( $term-&gt;parent == $term_id ) {&nbsp;</div></li><li><div>              if ( $use_id )&nbsp;</div></li><li><div>                  $term_list[] = $term-&gt;term_id;&nbsp;</div></li><li><div>              else&nbsp;</div></li><li><div>                  $term_list[] = $term;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( !isset($has_children[$term-&gt;term_id]) )&nbsp;</div></li><li><div>                  continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>              if ( $children = $this-&gt;_get_term_children($term-&gt;term_id, $terms, $taxonomy) )&nbsp;</div></li><li><div>                  $term_list = array_merge($term_list, $children);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return $term_list;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Add count of children to parent count.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * Recalculates term counts by including items from child terms. Assumes all</span>&nbsp;</div></li><li><div><span class="comment">   * relevant children are already in the $terms argument.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @package WordPress</span>&nbsp;</div></li><li><div><span class="comment">   * @subpackage Taxonomy</span>&nbsp;</div></li><li><div><span class="comment">   * @access private</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.3</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param array $terms List of Term IDs</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy Term Context</span>&nbsp;</div></li><li><div><span class="comment">   * @return null Will break from function if conditions are not met.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function _pad_term_counts(&$terms, $taxonomy) {&nbsp;</div></li><li><div>      return;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  <span class="comment">/**</span>&nbsp;</div></li><li><div><span class="comment">   * Determine if the given object is associated with any of the given terms.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * The given terms are checked against the object's terms' term_ids, names and slugs.</span>&nbsp;</div></li><li><div><span class="comment">   * Terms given as integers will only be checked against the object's terms' term_ids.</span>&nbsp;</div></li><li><div><span class="comment">   * If no terms are given, determines if object is associated with any terms in the given taxonomy.</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @since 2.7.0</span>&nbsp;</div></li><li><div><span class="comment">   * @uses WP_Taxonomy::get_object_term_cache()</span>&nbsp;</div></li><li><div><span class="comment">   * @uses WP_Taxonomy::get_object_terms()</span>&nbsp;</div></li><li><div><span class="comment">   *</span>&nbsp;</div></li><li><div><span class="comment">   * @param int $object_id.  ID of the object (post ID, link ID, ...)</span>&nbsp;</div></li><li><div><span class="comment">   * @param string $taxonomy.  Single taxonomy name</span>&nbsp;</div></li><li><div><span class="comment">   * @param int|string|array $terms Optional.  Term term_id, name, slug or array of said</span>&nbsp;</div></li><li><div><span class="comment">   * @return bool|WP_Error. WP_Error on input error.</span>&nbsp;</div></li><li><div><span class="comment">   */</span>&nbsp;</div></li><li><div>  function is_object_in_term( $object_id, $taxonomy, $terms = null ) {&nbsp;</div></li><li><div>      if ( !$object_id = (int) $object_id )&nbsp;</div></li><li><div>          return new WP_Error( 'invalid_object', __( 'Invalid object ID' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $object_terms = $this-&gt;get_object_term_cache( $object_id, $taxonomy );&nbsp;</div></li><li><div>      if ( empty( $object_terms ) )&nbsp;</div></li><li><div>           $object_terms = $this-&gt;get_object_terms( $object_id, $taxonomy );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( is_wp_error( $object_terms ) )&nbsp;</div></li><li><div>          return $object_terms;&nbsp;</div></li><li><div>      if ( empty( $object_terms ) )&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      if ( empty( $terms ) )&nbsp;</div></li><li><div>          return ( !empty( $object_terms ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      $terms = (array) $terms;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      if ( $ints = array_filter( $terms, 'is_int' ) )&nbsp;</div></li><li><div>          $strs = array_diff( $terms, $ints );&nbsp;</div></li><li><div>      else&nbsp;</div></li><li><div>          $strs =& $terms;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      foreach ( $object_terms as $object_term ) {&nbsp;</div></li><li><div>          if ( $ints && in_array( $object_term-&gt;term_id, $ints ) ) return true; <span class="comment">// If int, check against term_id</span>&nbsp;</div></li><li><div>          if ( $strs ) {&nbsp;</div></li><li><div>              if ( in_array( $object_term-&gt;term_id, $strs ) ) return true;&nbsp;</div></li><li><div>              if ( in_array( $object_term-&gt;name, $strs ) )    return true;&nbsp;</div></li><li><div>              if ( in_array( $object_term-&gt;slug, $strs ) )    return true;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>      return false;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  function get_children_cache( $taxonomy ) { return false; }&nbsp;</div></li><li><div>  function set_children_cache( $taxonomy, $children ) {}&nbsp;</div></li><li><div>  function delete_children_cache( $taxonomy ) {}&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre>.</p> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>file</li><li><span></span></li><li><span></span>BuddyPress</li><li><span></span>2.8.2</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2021 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>