<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="2.8.1" data-slug="woocommerce-pdf-invoices" data-type="class" data-id="20856"><head xmlns="http://www.w3.org/1999/xhtml"><title> otl | class | Woocommerce Pdf Invoices | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="otl, class, plugin, woocommerce-pdf-invoices, 2.8.1" /><meta name="description" content="The WooCommerce PDF Invoices otl class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.17"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=9cfad535a7d57ffcaac23ac28d621f89' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.17' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/otl/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fotl%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fotl%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-woocommerce-pdf-invoices-2.8.1-class-otl","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="otl" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to woocommerce-pdf-invoices." href="http://hookr.io/plugins/woocommerce-pdf-invoices/" class="plugin"><span property="name">woocommerce-pdf-invoices</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 2.8.1." href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/" class="H_VERSION"><span property="name">2.8.1</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">otl</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="211"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/all/" title="All">All <span class="count badge">211</span></a></li><li class="" data-id="new" data-count="24"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/new/" title="New">New <span class="count badge">24</span></a></li><li class="" data-id="hooks" data-count="41"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/hooks/" title="Hooks">Hooks <span class="count badge">41</span></a></li><li class="" data-id="action" data-count="13"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/actions/" title="Actions">Actions <span class="count badge">13</span></a></li><li class="" data-id="filter" data-count="28"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/filters/" title="Filters">Filters <span class="count badge">28</span></a></li><li class="active" data-id="class" data-count="63"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/classes/" title="Classes">Classes <span class="count badge">63</span></a></li><li class="" data-id="constant" data-count="66"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/constants/" title="Constants">Constants <span class="count badge">66</span></a></li><li class="" data-id="function" data-count="40"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/functions/" title="Functions">Functions <span class="count badge">40</span></a></li><li class="" data-id="shortcode" data-count="1"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">1</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>otl</strong></h1><p>The WooCommerce PDF Invoices <strong>otl</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/files/vendor-mpdf-mpdf-classes-otl/" class="file">/vendor/mpdf/mpdf/classes/otl.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="12" class="block" start="12"><li><div>class otl&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $mpdf;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $arabLeftJoining;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $arabRightJoining;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $arabTransparentJoin;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $arabTransparent;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GSUBdata;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GPOSdata;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GSUBfont;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $fontkey;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $ttfOTLdata;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $glyphIDtoUni;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $_pos;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GSUB_offset;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GPOS_offset;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $MarkAttachmentType;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $MarkGlyphSets;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GlyphClassMarks;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GlyphClassLigatures;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GlyphClassBases;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $GlyphClassComponents;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $Ignores;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $LuCoverage;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $OTLdata;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $assocLigs;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $assocMarks;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $shaper;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $restrictToSyllable;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $lbdicts; // Line-breaking dictionaries&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $LuDataCache;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    var $debugOTL = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public function __construct(mPDF $mpdf)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;mpdf = $mpdf;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;arabic_initialise();&nbsp;</div></li><li><div>        $this-&gt;current_fh = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;lbdicts = array();&nbsp;</div></li><li><div>        $this-&gt;LuDataCache = array();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function applyOTL($str, $useOTL)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;OTLdata = array();&nbsp;</div></li><li><div>        if (trim($str) == '') {&nbsp;</div></li><li><div>            return $str;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (!$useOTL) {&nbsp;</div></li><li><div>            return $str;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // 1. Load GDEF data&nbsp;</div></li><li><div>        //==============================&nbsp;</div></li><li><div>        $this-&gt;fontkey = $this-&gt;mpdf-&gt;CurrentFont['fontkey'];&nbsp;</div></li><li><div>        $this-&gt;glyphIDtoUni = $this-&gt;mpdf-&gt;CurrentFont['glyphIDtoUni'];&nbsp;</div></li><li><div>        if (!isset($this-&gt;GDEFdata[$this-&gt;fontkey])) {&nbsp;</div></li><li><div>            include(_MPDF_TTFONTDATAPATH . $this-&gt;fontkey . '.GDEFdata.php');&nbsp;</div></li><li><div>            $this-&gt;GSUB_offset = $this-&gt;GDEFdata[$this-&gt;fontkey]['GSUB_offset'] = $GSUB_offset;&nbsp;</div></li><li><div>            $this-&gt;GPOS_offset = $this-&gt;GDEFdata[$this-&gt;fontkey]['GPOS_offset'] = $GPOS_offset;&nbsp;</div></li><li><div>            $this-&gt;GSUB_length = $this-&gt;GDEFdata[$this-&gt;fontkey]['GSUB_length'] = $GSUB_length;&nbsp;</div></li><li><div>            $this-&gt;MarkAttachmentType = $this-&gt;GDEFdata[$this-&gt;fontkey]['MarkAttachmentType'] = $MarkAttachmentType;&nbsp;</div></li><li><div>            $this-&gt;MarkGlyphSets = $this-&gt;GDEFdata[$this-&gt;fontkey]['MarkGlyphSets'] = $MarkGlyphSets;&nbsp;</div></li><li><div>            $this-&gt;GlyphClassMarks = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassMarks'] = $GlyphClassMarks;&nbsp;</div></li><li><div>            $this-&gt;GlyphClassLigatures = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassLigatures'] = $GlyphClassLigatures;&nbsp;</div></li><li><div>            $this-&gt;GlyphClassComponents = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassComponents'] = $GlyphClassComponents;&nbsp;</div></li><li><div>            $this-&gt;GlyphClassBases = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassBases'] = $GlyphClassBases;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $this-&gt;GSUB_offset = $this-&gt;GDEFdata[$this-&gt;fontkey]['GSUB_offset'];&nbsp;</div></li><li><div>            $this-&gt;GPOS_offset = $this-&gt;GDEFdata[$this-&gt;fontkey]['GPOS_offset'];&nbsp;</div></li><li><div>            $this-&gt;GSUB_length = $this-&gt;GDEFdata[$this-&gt;fontkey]['GSUB_length'];&nbsp;</div></li><li><div>            $this-&gt;MarkAttachmentType = $this-&gt;GDEFdata[$this-&gt;fontkey]['MarkAttachmentType'];&nbsp;</div></li><li><div>            $this-&gt;MarkGlyphSets = $this-&gt;GDEFdata[$this-&gt;fontkey]['MarkGlyphSets'];&nbsp;</div></li><li><div>            $this-&gt;GlyphClassMarks = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassMarks'];&nbsp;</div></li><li><div>            $this-&gt;GlyphClassLigatures = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassLigatures'];&nbsp;</div></li><li><div>            $this-&gt;GlyphClassComponents = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassComponents'];&nbsp;</div></li><li><div>            $this-&gt;GlyphClassBases = $this-&gt;GDEFdata[$this-&gt;fontkey]['GlyphClassBases'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // 2. Prepare string as HEX string and Analyse character properties&nbsp;</div></li><li><div>        //=================================================================&nbsp;</div></li><li><div>        $earr = $this-&gt;mpdf-&gt;UTF8StringToArray($str, false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $scriptblock = 0;&nbsp;</div></li><li><div>        $scriptblocks = array();&nbsp;</div></li><li><div>        $scriptblocks[0] = 0;&nbsp;</div></li><li><div>        $vstr = '';&nbsp;</div></li><li><div>        $OTLdata = array();&nbsp;</div></li><li><div>        $subchunk = 0;&nbsp;</div></li><li><div>        $charctr = 0;&nbsp;</div></li><li><div>        foreach ($earr as $char) {&nbsp;</div></li><li><div>            $ucd_record = UCDN::get_ucd_record($char);&nbsp;</div></li><li><div>            $sbl = $ucd_record[6];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Special case - Arabic End of Ayah&nbsp;</div></li><li><div>            if ($char == 1757) {&nbsp;</div></li><li><div>                $sbl = UCDN::SCRIPT_ARABIC;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($sbl && $sbl != 40 && $sbl != 102) {&nbsp;</div></li><li><div>                if ($scriptblock == 0) {&nbsp;</div></li><li><div>                    $scriptblock = $sbl;&nbsp;</div></li><li><div>                    $scriptblocks[$subchunk] = $scriptblock;&nbsp;</div></li><li><div>                } else if ($scriptblock &gt; 0 && $scriptblock != $sbl) {&nbsp;</div></li><li><div>                    // *************************************************&nbsp;</div></li><li><div>                    // NEW (non-common) Script encountered in this chunk. Start a new subchunk&nbsp;</div></li><li><div>                    $subchunk++;&nbsp;</div></li><li><div>                    $scriptblock = $sbl;&nbsp;</div></li><li><div>                    $charctr = 0;&nbsp;</div></li><li><div>                    $scriptblocks[$subchunk] = $scriptblock;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $OTLdata[$subchunk][$charctr]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>            $OTLdata[$subchunk][$charctr]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //$OTLdata[$subchunk][$charctr]['combining_class'] = $ucd_record[1];&nbsp;</div></li><li><div>            //$OTLdata[$subchunk][$charctr]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>            //$OTLdata[$subchunk][$charctr]['mirrored'] = $ucd_record[3];&nbsp;</div></li><li><div>            //$OTLdata[$subchunk][$charctr]['east_asian_width'] = $ucd_record[4];&nbsp;</div></li><li><div>            //$OTLdata[$subchunk][$charctr]['normalization_check'] = $ucd_record[5];&nbsp;</div></li><li><div>            //$OTLdata[$subchunk][$charctr]['script'] = $ucd_record[6];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $charasstr = $this-&gt;unicode_hex($char);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (strpos($this-&gt;GlyphClassMarks, $charasstr) !== false) {&nbsp;</div></li><li><div>                $OTLdata[$subchunk][$charctr]['group'] = 'M';&nbsp;</div></li><li><div>            } else if ($char == 32 || $char == 12288) {&nbsp;</div></li><li><div>                $OTLdata[$subchunk][$charctr]['group'] = 'S';&nbsp;</div></li><li><div>            } // 12288 = 0x3000 = CJK space&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                $OTLdata[$subchunk][$charctr]['group'] = 'C';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $OTLdata[$subchunk][$charctr]['uni'] = $char;&nbsp;</div></li><li><div>            $OTLdata[$subchunk][$charctr]['hex'] = $charasstr;&nbsp;</div></li><li><div>            $charctr++;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** PROCESS EACH SUBCHUNK WITH DIFFERENT SCRIPTS */&nbsp;</div></li><li><div>        for ($sch = 0; $sch &lt;= $subchunk; $sch++) {&nbsp;</div></li><li><div>            $this-&gt;OTLdata = $OTLdata[$sch];&nbsp;</div></li><li><div>            $scriptblock = $scriptblocks[$sch];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // 3. Get Appropriate Scripts, and Shaper engine from analysing text and list of available scripts/langsys in font&nbsp;</div></li><li><div>            //==============================&nbsp;</div></li><li><div>            // Based on actual script block of text, select shaper (and line-breaking dictionaries)&nbsp;</div></li><li><div>            if (UCDN::SCRIPT_DEVANAGARI &lt;= $scriptblock && $scriptblock &lt;= UCDN::SCRIPT_MALAYALAM) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;I&quot;;&nbsp;</div></li><li><div>            } // INDIC shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_ARABIC || $scriptblock == UCDN::SCRIPT_SYRIAC) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;A&quot;;&nbsp;</div></li><li><div>            } // ARABIC shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_NKO || $scriptblock == UCDN::SCRIPT_MANDAIC) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;A&quot;;&nbsp;</div></li><li><div>            } // ARABIC shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;K&quot;;&nbsp;</div></li><li><div>            } // KHMER shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_THAI) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;T&quot;;&nbsp;</div></li><li><div>            } // THAI shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_LAO) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;L&quot;;&nbsp;</div></li><li><div>            } // LAO shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_SINHALA) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;S&quot;;&nbsp;</div></li><li><div>            } // SINHALA shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_MYANMAR) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;M&quot;;&nbsp;</div></li><li><div>            } // MYANMAR shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_NEW_TAI_LUE) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;E&quot;;&nbsp;</div></li><li><div>            } // SEA South East Asian shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_CHAM) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;E&quot;;&nbsp;</div></li><li><div>            }  // SEA South East Asian shaper&nbsp;</div></li><li><div>            else if ($scriptblock == UCDN::SCRIPT_TAI_THAM) {&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;E&quot;;&nbsp;</div></li><li><div>            } // SEA South East Asian shaper&nbsp;</div></li><li><div>            else&nbsp;</div></li><li><div>                $this-&gt;shaper = &quot;&quot;;&nbsp;</div></li><li><div>            // Get scripttag based on actual text script&nbsp;</div></li><li><div>            $scripttag = UCDN::$uni_scriptblock[$scriptblock];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $GSUBscriptTag = '';&nbsp;</div></li><li><div>            $GSUBlangsys = '';&nbsp;</div></li><li><div>            $GPOSscriptTag = '';&nbsp;</div></li><li><div>            $GPOSlangsys = '';&nbsp;</div></li><li><div>            $is_old_spec = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $ScriptLang = $this-&gt;mpdf-&gt;CurrentFont['GSUBScriptLang'];&nbsp;</div></li><li><div>            if (count($ScriptLang)) {&nbsp;</div></li><li><div>                list($GSUBscriptTag, $is_old_spec) = $this-&gt;_getOTLscriptTag($ScriptLang, $scripttag, $scriptblock, $this-&gt;shaper, $useOTL, 'GSUB');&nbsp;</div></li><li><div>                if ($this-&gt;mpdf-&gt;fontLanguageOverride && strpos($ScriptLang[$GSUBscriptTag], $this-&gt;mpdf-&gt;fontLanguageOverride) !== false) {&nbsp;</div></li><li><div>                    $GSUBlangsys = str_pad($this-&gt;mpdf-&gt;fontLanguageOverride, 4);&nbsp;</div></li><li><div>                } else if ($GSUBscriptTag && isset($ScriptLang[$GSUBscriptTag]) && $ScriptLang[$GSUBscriptTag] != '') {&nbsp;</div></li><li><div>                    $GSUBlangsys = $this-&gt;_getOTLLangTag($this-&gt;mpdf-&gt;currentLang, $ScriptLang[$GSUBscriptTag]);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $ScriptLang = $this-&gt;mpdf-&gt;CurrentFont['GPOSScriptLang'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // NB If after GSUB, the same script/lang exist for GPOS, just use these...&nbsp;</div></li><li><div>            if ($GSUBscriptTag && $GSUBlangsys && isset($ScriptLang[$GSUBscriptTag]) && strpos($ScriptLang[$GSUBscriptTag], $GSUBlangsys) !== false) {&nbsp;</div></li><li><div>                $GPOSlangsys = $GSUBlangsys;&nbsp;</div></li><li><div>                $GPOSscriptTag = $GSUBscriptTag;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // else repeat for GPOS&nbsp;</div></li><li><div>            // [Font XBRiyaz has GSUB tables for latn, but not GPOS for latn]&nbsp;</div></li><li><div>            else if (count($ScriptLang)) {&nbsp;</div></li><li><div>                list($GPOSscriptTag, $dummy) = $this-&gt;_getOTLscriptTag($ScriptLang, $scripttag, $scriptblock, $this-&gt;shaper, $useOTL, 'GPOS');&nbsp;</div></li><li><div>                if ($GPOSscriptTag && $this-&gt;mpdf-&gt;fontLanguageOverride && strpos($ScriptLang[$GPOSscriptTag], $this-&gt;mpdf-&gt;fontLanguageOverride) !== false) {&nbsp;</div></li><li><div>                    $GPOSlangsys = str_pad($this-&gt;mpdf-&gt;fontLanguageOverride, 4);&nbsp;</div></li><li><div>                } else if ($GPOSscriptTag && isset($ScriptLang[$GPOSscriptTag]) && $ScriptLang[$GPOSscriptTag] != '') {&nbsp;</div></li><li><div>                    $GPOSlangsys = $this-&gt;_getOTLLangTag($this-&gt;mpdf-&gt;currentLang, $ScriptLang[$GPOSscriptTag]);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            ////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>            // This is just for the font_dump_OTL utility to set script and langsys override&nbsp;</div></li><li><div>            if (isset($this-&gt;mpdf-&gt;overrideOTLsettings) && isset($this-&gt;mpdf-&gt;overrideOTLsettings[$this-&gt;fontkey])) {&nbsp;</div></li><li><div>                $GSUBscriptTag = $GPOSscriptTag = $this-&gt;mpdf-&gt;overrideOTLsettings[$this-&gt;fontkey]['script'];&nbsp;</div></li><li><div>                $GSUBlangsys = $GPOSlangsys = $this-&gt;mpdf-&gt;overrideOTLsettings[$this-&gt;fontkey]['lang'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (!$GSUBscriptTag && !$GSUBlangsys && !$GPOSscriptTag && !$GPOSlangsys) {&nbsp;</div></li><li><div>                // Remove ZWJ and ZWNJ&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>                    if ($this-&gt;OTLdata[$i]['uni'] == 8204 || $this-&gt;OTLdata[$i]['uni'] == 8205) {&nbsp;</div></li><li><div>                        array_splice($this-&gt;OTLdata, $i, 1);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $this-&gt;schOTLdata[$sch] = $this-&gt;OTLdata;&nbsp;</div></li><li><div>                $this-&gt;OTLdata = array();&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Don't use MYANMAR shaper unless using v2 scripttag&nbsp;</div></li><li><div>            if ($this-&gt;shaper == 'M' && $GSUBscriptTag != 'mym2') {&nbsp;</div></li><li><div>                $this-&gt;shaper = '';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $GSUBFeatures = (isset($this-&gt;mpdf-&gt;CurrentFont['GSUBFeatures'][$GSUBscriptTag][$GSUBlangsys]) ? $this-&gt;mpdf-&gt;CurrentFont['GSUBFeatures'][$GSUBscriptTag][$GSUBlangsys] : false);&nbsp;</div></li><li><div>            $GPOSFeatures = (isset($this-&gt;mpdf-&gt;CurrentFont['GPOSFeatures'][$GPOSscriptTag][$GPOSlangsys]) ? $this-&gt;mpdf-&gt;CurrentFont['GPOSFeatures'][$GPOSscriptTag][$GPOSlangsys] : false);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;assocLigs = array(); // Ligatures[$posarr lpos] =&gt; nc&nbsp;</div></li><li><div>            $this-&gt;assocMarks = array();  // assocMarks[$posarr mpos] =&gt; array(compID, ligPos)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (!isset($this-&gt;GDEFdata[$this-&gt;fontkey]['GSUBGPOStables'])) {&nbsp;</div></li><li><div>                $this-&gt;ttfOTLdata = $this-&gt;GDEFdata[$this-&gt;fontkey]['GSUBGPOStables'] = file_get_contents(_MPDF_TTFONTDATAPATH . $this-&gt;fontkey . '.GSUBGPOStables.dat', 'rb');&nbsp;</div></li><li><div>                if (!$this-&gt;ttfOTLdata) {&nbsp;</div></li><li><div>                    throw new MpdfException('Can\'t open file ' . _MPDF_TTFONTDATAPATH . $this-&gt;fontkey . '.GSUBGPOStables.dat');&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $this-&gt;ttfOTLdata = $this-&gt;GDEFdata[$this-&gt;fontkey]['GSUBGPOStables'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                $this-&gt;_dumpproc('BEGIN', '-', '-', '-', '-', -1, '-', 0);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>/////////  LINE BREAKING FOR KHMER, THAI + LAO /////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>            // Insert U+200B at word boundaries using dictionaries&nbsp;</div></li><li><div>            if ($this-&gt;mpdf-&gt;useDictionaryLBR && ($this-&gt;shaper == &quot;K&quot; || $this-&gt;shaper == &quot;T&quot; || $this-&gt;shaper == &quot;L&quot;)) {&nbsp;</div></li><li><div>                // Sets $this-&gt;OTLdata[$i]['wordend']=true at possible end of word boundaries&nbsp;</div></li><li><div>                $this-&gt;SEAlineBreaking();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Insert U+200B at word boundaries for Tibetan&nbsp;</div></li><li><div>            else if ($this-&gt;mpdf-&gt;useTibetanLBR && $scriptblock == UCDN::SCRIPT_TIBETAN) {&nbsp;</div></li><li><div>                // Sets $this-&gt;OTLdata[$i]['wordend']=true at possible end of word boundaries&nbsp;</div></li><li><div>                $this-&gt;TibetanlineBreaking();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>//////////       GSUB          /////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>            if (($useOTL & 0xFF) && $GSUBscriptTag && $GSUBlangsys && $GSUBFeatures) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 4. Load GSUB data, Coverage & Lookups&nbsp;</div></li><li><div>                //=================================================================&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $this-&gt;GSUBfont = $this-&gt;fontkey . '.GSUB.' . $GSUBscriptTag . '.' . $GSUBlangsys;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!isset($this-&gt;GSUBdata[$this-&gt;GSUBfont])) {&nbsp;</div></li><li><div>                    if (file_exists(_MPDF_TTFONTDATAPATH . $this-&gt;mpdf-&gt;CurrentFont['fontkey'] . '.GSUB.' . $GSUBscriptTag . '.' . $GSUBlangsys . '.php')) {&nbsp;</div></li><li><div>                        include_once(_MPDF_TTFONTDATAPATH . $this-&gt;mpdf-&gt;CurrentFont['fontkey'] . '.GSUB.' . $GSUBscriptTag . '.' . $GSUBlangsys . '.php');&nbsp;</div></li><li><div>                        $this-&gt;GSUBdata[$this-&gt;GSUBfont]['rtlSUB'] = $rtlSUB;&nbsp;</div></li><li><div>                        $this-&gt;GSUBdata[$this-&gt;GSUBfont]['finals'] = $finals;&nbsp;</div></li><li><div>                        if ($this-&gt;shaper == 'I') {&nbsp;</div></li><li><div>                            $this-&gt;GSUBdata[$this-&gt;GSUBfont]['rphf'] = $rphf;&nbsp;</div></li><li><div>                            $this-&gt;GSUBdata[$this-&gt;GSUBfont]['half'] = $half;&nbsp;</div></li><li><div>                            $this-&gt;GSUBdata[$this-&gt;GSUBfont]['pref'] = $pref;&nbsp;</div></li><li><div>                            $this-&gt;GSUBdata[$this-&gt;GSUBfont]['blwf'] = $blwf;&nbsp;</div></li><li><div>                            $this-&gt;GSUBdata[$this-&gt;GSUBfont]['pstf'] = $pstf;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $this-&gt;GSUBdata[$this-&gt;GSUBfont] = array('rtlSUB' =&gt; array(), 'rphf' =&gt; array(), 'rphf' =&gt; array(), &nbsp;</div></li><li><div>                            'pref' =&gt; array(), 'blwf' =&gt; array(), 'pstf' =&gt; array(), 'finals' =&gt; ''&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!isset($this-&gt;GSUBdata[$this-&gt;fontkey])) {&nbsp;</div></li><li><div>                    include(_MPDF_TTFONTDATAPATH . $this-&gt;fontkey . '.GSUBdata.php');&nbsp;</div></li><li><div>                    $this-&gt;GSLuCoverage = $this-&gt;GSUBdata[$this-&gt;fontkey]['GSLuCoverage'] = $GSLuCoverage;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $this-&gt;GSLuCoverage = $this-&gt;GSUBdata[$this-&gt;fontkey]['GSLuCoverage'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $this-&gt;GSUBLookups = $this-&gt;mpdf-&gt;CurrentFont['GSUBLookups'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 5(A). GSUB - Shaper - ARABIC&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                if ($this-&gt;shaper == 'A') {&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // a. Apply initial GSUB Lookups (in order specified in lookup list but only selecting from certain tags)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'locl ccmp';&nbsp;</div></li><li><div>                    $omittags = '';&nbsp;</div></li><li><div>                    $usetags = $tags;&nbsp;</div></li><li><div>                    if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                        $usetags = $this-&gt;_applyTagSettings($tags, $GSUBFeatures, $omittags, true);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $this-&gt;_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // b. Apply context-specific forms GSUB Lookups (initial, isolated, medial, final)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // Arab and Syriac are the only scripts requiring the special joining - which takes the place of&nbsp;</div></li><li><div>                    // isol fina medi init rules in GSUB (+ fin2 fin3 med2 in Syriac syrc)&nbsp;</div></li><li><div>                    $tags = 'isol fina fin2 fin3 medi med2 init';&nbsp;</div></li><li><div>                    $omittags = '';&nbsp;</div></li><li><div>                    $usetags = $tags;&nbsp;</div></li><li><div>                    if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                        $usetags = $this-&gt;_applyTagSettings($tags, $GSUBFeatures, $omittags, true);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;arabGlyphs = $this-&gt;GSUBdata[$this-&gt;GSUBfont]['rtlSUB'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $gcms = explode(&quot;| &quot;, $this-&gt;GlyphClassMarks);&nbsp;</div></li><li><div>                    $gcm = array();&nbsp;</div></li><li><div>                    foreach ($gcms AS $g) {&nbsp;</div></li><li><div>                        $gcm[hexdec($g)] = 1;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $this-&gt;arabTransparentJoin = $this-&gt;arabTransparent + $gcm;&nbsp;</div></li><li><div>                    $this-&gt;arabic_shaper($usetags, $GSUBscriptTag);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // c. Set Kashida points (after joining occurred - medi, fina, init) but before other substitutions&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    //if ($scriptblock == UCDN::SCRIPT_ARABIC ) {&nbsp;</div></li><li><div>                    for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>                        // Put the kashida marker on the character BEFORE which is inserted the kashida&nbsp;</div></li><li><div>                        // Kashida marker is inverse of priority i.e. Priority 1 =&gt; 7, Priority 7 =&gt; 1.&nbsp;</div></li><li><div>                        // Priority 1   User-inserted Kashida 0640 = Tatweel&nbsp;</div></li><li><div>                        // The user entered a Kashida in a position&nbsp;</div></li><li><div>                        // Position: Before the user-inserted kashida&nbsp;</div></li><li><div>                        if ($this-&gt;OTLdata[$i]['uni'] == 0x0640) {&nbsp;</div></li><li><div>                            $this-&gt;OTLdata[$i]['GPOSinfo']['kashida'] = 8; // Put before the next character&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Priority 2   Seen (0633)  FEB3, FEB4; Sad (0635)  FEBB, FEBC&nbsp;</div></li><li><div>                        // Initial or medial form&nbsp;</div></li><li><div>                        // Connecting to the next character&nbsp;</div></li><li><div>                        // Position: After the character&nbsp;</div></li><li><div>                        else if ($this-&gt;OTLdata[$i]['uni'] == 0xFEB3 || $this-&gt;OTLdata[$i]['uni'] == 0xFEB4 || $this-&gt;OTLdata[$i]['uni'] == 0xFEBB || $this-&gt;OTLdata[$i]['uni'] == 0xFEBC) {&nbsp;</div></li><li><div>                            $checkpos = $i + 1;&nbsp;</div></li><li><div>                            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                                $checkpos++;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if (isset($this-&gt;OTLdata[$checkpos])) {&nbsp;</div></li><li><div>                                $this-&gt;OTLdata[$checkpos]['GPOSinfo']['kashida'] = 7; // Put after marks on next character&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Priority 3   Taa Marbutah (0629) FE94; Haa (062D) FEA2; Dal (062F) FEAA&nbsp;</div></li><li><div>                        // Final form&nbsp;</div></li><li><div>                        // Connecting to previous character&nbsp;</div></li><li><div>                        // Position: Before the character&nbsp;</div></li><li><div>                        else if ($this-&gt;OTLdata[$i]['uni'] == 0xFE94 || $this-&gt;OTLdata[$i]['uni'] == 0xFEA2 || $this-&gt;OTLdata[$i]['uni'] == 0xFEAA) {&nbsp;</div></li><li><div>                            $this-&gt;OTLdata[$i]['GPOSinfo']['kashida'] = 6;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Priority 4   Alef (0627) FE8E; Tah (0637) FEC2; Lam (0644) FEDE; Kaf (0643)  FEDA; Gaf (06AF) FB93&nbsp;</div></li><li><div>                        // Final form&nbsp;</div></li><li><div>                        // Connecting to previous character&nbsp;</div></li><li><div>                        // Position: Before the character&nbsp;</div></li><li><div>                        else if ($this-&gt;OTLdata[$i]['uni'] == 0xFE8E || $this-&gt;OTLdata[$i]['uni'] == 0xFEC2 || $this-&gt;OTLdata[$i]['uni'] == 0xFEDE || $this-&gt;OTLdata[$i]['uni'] == 0xFEDA || $this-&gt;OTLdata[$i]['uni'] == 0xFB93) {&nbsp;</div></li><li><div>                            $this-&gt;OTLdata[$i]['GPOSinfo']['kashida'] = 5;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Priority 5   RA (0631) FEAE; Ya (064A)  FEF2 FEF4; Alef Maqsurah (0649) FEF0 FBE9&nbsp;</div></li><li><div>                        // Final or Medial form&nbsp;</div></li><li><div>                        // Connected to preceding medial BAA (0628) = FE92&nbsp;</div></li><li><div>                        // Position: Before preceding medial Baa&nbsp;</div></li><li><div>                        // Although not mentioned in spec, added Farsi Yeh (06CC) FBFD FBFF; equivalent to 064A or 0649&nbsp;</div></li><li><div>                        else if ($this-&gt;OTLdata[$i]['uni'] == 0xFEAE || $this-&gt;OTLdata[$i]['uni'] == 0xFEF2 || $this-&gt;OTLdata[$i]['uni'] == 0xFEF0 || $this-&gt;OTLdata[$i]['uni'] == 0xFEF4 || $this-&gt;OTLdata[$i]['uni'] == 0xFBE9 || $this-&gt;OTLdata[$i]['uni'] == 0xFBFD || $this-&gt;OTLdata[$i]['uni'] == 0xFBFF&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                            $checkpos = $i - 1;&nbsp;</div></li><li><div>                            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                                $checkpos--;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if (isset($this-&gt;OTLdata[$checkpos]) && $this-&gt;OTLdata[$checkpos]['uni'] == 0xFE92) {&nbsp;</div></li><li><div>                                $this-&gt;OTLdata[$checkpos]['GPOSinfo']['kashida'] = 4; // ******* Before preceding BAA&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Priority 6   WAW (0648) FEEE; Ain (0639) FECA; Qaf (0642) FED6; Fa (0641) FED2&nbsp;</div></li><li><div>                        // Final form&nbsp;</div></li><li><div>                        // Connecting to previous character&nbsp;</div></li><li><div>                        // Position: Before the character&nbsp;</div></li><li><div>                        else if ($this-&gt;OTLdata[$i]['uni'] == 0xFEEE || $this-&gt;OTLdata[$i]['uni'] == 0xFECA || $this-&gt;OTLdata[$i]['uni'] == 0xFED6 || $this-&gt;OTLdata[$i]['uni'] == 0xFED2) {&nbsp;</div></li><li><div>                            $this-&gt;OTLdata[$i]['GPOSinfo']['kashida'] = 3;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Priority 7   Other connecting characters&nbsp;</div></li><li><div>                        // Final form&nbsp;</div></li><li><div>                        // Connecting to previous character&nbsp;</div></li><li><div>                        // Position: Before the character&nbsp;</div></li><li><div>                        /** This isn't in the spec, but using MS WORD as a basis, give a lower priority to the 3 characters already checked&nbsp;</div></li><li><div>                          in (5) above. Test case:&nbsp;</div></li><li><div>                          &#x62e;&#x652;&#x631;&#x64e;&#x649;&#x670;&nbsp;</div></li><li><div>                          &#x641;&#x64e;&#x62a;&#x64f;&#x630;&#x64e;&#x643;&#x651;&#x650;&#x631;&nbsp;</div></li><li><div>                         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if (!isset($this-&gt;OTLdata[$i]['GPOSinfo']['kashida'])) {&nbsp;</div></li><li><div>                            if (strpos($this-&gt;GSUBdata[$this-&gt;GSUBfont]['finals'], $this-&gt;OTLdata[$i]['hex']) !== false) { // ANY OTHER FINAL FORM&nbsp;</div></li><li><div>                                $this-&gt;OTLdata[$i]['GPOSinfo']['kashida'] = 2;&nbsp;</div></li><li><div>                            } else if (strpos('0FEAE 0FEF0 0FEF2', $this-&gt;OTLdata[$i]['hex']) !== false) { // not already included in 5 above&nbsp;</div></li><li><div>                                $this-&gt;OTLdata[$i]['GPOSinfo']['kashida'] = 1;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // d. Apply Presentation Forms GSUB Lookups (+ any discretionary) - Apply one at a time in Feature order&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'rlig calt liga clig mset';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';&nbsp;</div></li><li><div>                    $usetags = $tags;&nbsp;</div></li><li><div>                    if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                        $usetags = $this-&gt;_applyTagSettings($tags, $GSUBFeatures, $omittags, false);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $ts = explode(' ', $usetags);&nbsp;</div></li><li><div>                    foreach ($ts AS $ut) { //  - Apply one at a time in Feature order&nbsp;</div></li><li><div>                        $this-&gt;_applyGSUBrules($ut, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // e. NOT IN SPEC&nbsp;</div></li><li><div>                    // If space precedes a mark -&gt; substitute a &nbsp; before the Mark, to prevent line breaking Test:&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    for ($ptr = 1; $ptr &lt; count($this-&gt;OTLdata); $ptr++) {&nbsp;</div></li><li><div>                        if ($this-&gt;OTLdata[$ptr]['general_category'] == UCDN::UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK && $this-&gt;OTLdata[$ptr - 1]['uni'] == 32) {&nbsp;</div></li><li><div>                            $this-&gt;OTLdata[$ptr - 1]['uni'] = 0xa0;&nbsp;</div></li><li><div>                            $this-&gt;OTLdata[$ptr - 1]['hex'] = '000A0';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 5(I). GSUB - Shaper - INDIC and SINHALA and KHMER&nbsp;</div></li><li><div>                //===================================&nbsp;</div></li><li><div>                else if ($this-&gt;shaper == 'I' || $this-&gt;shaper == 'K' || $this-&gt;shaper == 'S') {&nbsp;</div></li><li><div>                    $this-&gt;restrictToSyllable = true;&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // a. First decompose/compose split mattras&nbsp;</div></li><li><div>                    // (normalize) ??????? Nukta/Halant order etc ??????????????????????????????????????????????????????????????????????????&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    for ($ptr = 0; $ptr &lt; count($this-&gt;OTLdata); $ptr++) {&nbsp;</div></li><li><div>                        $char = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                        $sub = INDIC::decompose_indic($char);&nbsp;</div></li><li><div>                        if ($sub) {&nbsp;</div></li><li><div>                            $newinfo = array();&nbsp;</div></li><li><div>                            for ($i = 0; $i &lt; count($sub); $i++) {&nbsp;</div></li><li><div>                                $newinfo[$i] = array();&nbsp;</div></li><li><div>                                $ucd_record = UCDN::get_ucd_record($sub[$i]);&nbsp;</div></li><li><div>                                $newinfo[$i]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                                $newinfo[$i]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                                $charasstr = $this-&gt;unicode_hex($sub[$i]);&nbsp;</div></li><li><div>                                if (strpos($this-&gt;GlyphClassMarks, $charasstr) !== false) {&nbsp;</div></li><li><div>                                    $newinfo[$i]['group'] = 'M';&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $newinfo[$i]['group'] = 'C';&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $newinfo[$i]['uni'] = $sub[$i];&nbsp;</div></li><li><div>                                $newinfo[$i]['hex'] = $charasstr;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            array_splice($this-&gt;OTLdata, $ptr, 1, $newinfo);&nbsp;</div></li><li><div>                            $ptr += count($sub) - 1;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        /** Only Composition-exclusion exceptions that we want to recompose. */&nbsp;</div></li><li><div>                        if ($this-&gt;shaper == 'I') {&nbsp;</div></li><li><div>                            if ($char == 0x09AF && isset($this-&gt;OTLdata[$ptr + 1]) && $this-&gt;OTLdata[$ptr + 1]['uni'] == 0x09BC) {&nbsp;</div></li><li><div>                                $sub = 0x09DF;&nbsp;</div></li><li><div>                                $newinfo = array();&nbsp;</div></li><li><div>                                $newinfo[0] = array();&nbsp;</div></li><li><div>                                $ucd_record = UCDN::get_ucd_record($sub);&nbsp;</div></li><li><div>                                $newinfo[0]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                                $newinfo[0]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                                $newinfo[0]['group'] = 'C';&nbsp;</div></li><li><div>                                $newinfo[0]['uni'] = $sub;&nbsp;</div></li><li><div>                                $newinfo[0]['hex'] = $this-&gt;unicode_hex($sub);&nbsp;</div></li><li><div>                                array_splice($this-&gt;OTLdata, $ptr, 2, $newinfo);&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // b. Analyse characters - group as syllables/clusters (Indic); invalid diacritics; add dotted circle&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $indic_category_string = '';&nbsp;</div></li><li><div>                    foreach ($this-&gt;OTLdata AS $eid =&gt; $c) {&nbsp;</div></li><li><div>                        INDIC::set_indic_properties($this-&gt;OTLdata[$eid], $scriptblock); // sets ['indic_category'] and ['indic_position']&nbsp;</div></li><li><div>                        //$c['general_category']&nbsp;</div></li><li><div>                        //$c['combining_class']&nbsp;</div></li><li><div>                        //$c['uni'] =  $char;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $indic_category_string .= INDIC::$indic_category_char[$this-&gt;OTLdata[$eid]['indic_category']];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $broken_syllables = false;&nbsp;</div></li><li><div>                    if ($this-&gt;shaper == 'I') {&nbsp;</div></li><li><div>                        INDIC::set_syllables($this-&gt;OTLdata, $indic_category_string, $broken_syllables);&nbsp;</div></li><li><div>                    } else if ($this-&gt;shaper == 'S') {&nbsp;</div></li><li><div>                        INDIC::set_syllables_sinhala($this-&gt;OTLdata, $indic_category_string, $broken_syllables);&nbsp;</div></li><li><div>                    } else if ($this-&gt;shaper == 'K') {&nbsp;</div></li><li><div>                        INDIC::set_syllables_khmer($this-&gt;OTLdata, $indic_category_string, $broken_syllables);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $indic_category_string = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // c. Initial Re-ordering (Indic / Khmer / Sinhala)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // Find base consonant&nbsp;</div></li><li><div>                    // Decompose/compose and reorder Matras&nbsp;</div></li><li><div>                    // Reorder marks to canonical order&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $indic_config = INDIC::$indic_configs[$scriptblock];&nbsp;</div></li><li><div>                    $dottedcircle = false;&nbsp;</div></li><li><div>                    if ($broken_syllables) {&nbsp;</div></li><li><div>                        if ($this-&gt;mpdf-&gt;_charDefined($this-&gt;mpdf-&gt;fonts[$this-&gt;fontkey]['cw'], 0x25CC)) {&nbsp;</div></li><li><div>                            $dottedcircle = array();&nbsp;</div></li><li><div>                            $ucd_record = UCDN::get_ucd_record(0x25CC);&nbsp;</div></li><li><div>                            $dottedcircle[0]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                            $dottedcircle[0]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                            $dottedcircle[0]['group'] = 'C';&nbsp;</div></li><li><div>                            $dottedcircle[0]['uni'] = 0x25CC;&nbsp;</div></li><li><div>                            $dottedcircle[0]['indic_category'] = INDIC::OT_DOTTEDCIRCLE;&nbsp;</div></li><li><div>                            $dottedcircle[0]['indic_position'] = INDIC::POS_BASE_C;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $dottedcircle[0]['hex'] = '025CC';  // TEMPORARY *****&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    INDIC::initial_reordering($this-&gt;OTLdata, $this-&gt;GSUBdata[$this-&gt;GSUBfont], $broken_syllables, $indic_config, $scriptblock, $is_old_spec, $dottedcircle);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // d. Apply initial and basic shaping forms GSUB Lookups (one at a time)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    if ($this-&gt;shaper == 'I' || $this-&gt;shaper == 'S') {&nbsp;</div></li><li><div>                        $tags = 'locl ccmp nukt akhn rphf rkrf pref blwf half pstf vatu cjct';&nbsp;</div></li><li><div>                    } else if ($this-&gt;shaper == 'K') {&nbsp;</div></li><li><div>                        $tags = 'locl ccmp pref blwf abvf pstf cfar';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $this-&gt;_applyGSUBrulesIndic($tags, $GSUBscriptTag, $GSUBlangsys, $is_old_spec);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // e. Final Re-ordering (Indic / Khmer / Sinhala)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // Reorder matras&nbsp;</div></li><li><div>                    // Reorder reph&nbsp;</div></li><li><div>                    // Reorder pre-base reordering consonants:&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    INDIC::final_reordering($this-&gt;OTLdata, $this-&gt;GSUBdata[$this-&gt;GSUBfont], $indic_config, $scriptblock, $is_old_spec);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // f. Apply 'init' feature to first syllable in word (indicated by ['mask']) INDIC::FLAG(INDIC::INIT);&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    if ($this-&gt;shaper == 'I' || $this-&gt;shaper == 'S') {&nbsp;</div></li><li><div>                        $tags = 'init';&nbsp;</div></li><li><div>                        $this-&gt;_applyGSUBrulesIndic($tags, $GSUBscriptTag, $GSUBlangsys, $is_old_spec);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // g. Apply Presentation Forms GSUB Lookups (+ any discretionary)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'pres abvs blws psts haln rlig calt liga clig mset';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';&nbsp;</div></li><li><div>                    $usetags = $tags;&nbsp;</div></li><li><div>                    if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                        $usetags = $this-&gt;_applyTagSettings($tags, $GSUBFeatures, $omittags, false);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($this-&gt;shaper == 'K') {  // Features are applied one at a time, working through each codepoint&nbsp;</div></li><li><div>                        $this-&gt;_applyGSUBrulesSingly($usetags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $this-&gt;_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $this-&gt;restrictToSyllable = false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 5(M). GSUB - Shaper - MYANMAR (ONLY mym2)&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                // NB Old style 'mymr' is left to go through the default shaper&nbsp;</div></li><li><div>                else if ($this-&gt;shaper == 'M') {&nbsp;</div></li><li><div>                    $this-&gt;restrictToSyllable = true;&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // a. Analyse characters - group as syllables/clusters (Myanmar); invalid diacritics; add dotted circle&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $myanmar_category_string = '';&nbsp;</div></li><li><div>                    foreach ($this-&gt;OTLdata AS $eid =&gt; $c) {&nbsp;</div></li><li><div>                        MYANMAR::set_myanmar_properties($this-&gt;OTLdata[$eid]); // sets ['myanmar_category'] and ['myanmar_position']&nbsp;</div></li><li><div>                        $myanmar_category_string .= MYANMAR::$myanmar_category_char[$this-&gt;OTLdata[$eid]['myanmar_category']];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $broken_syllables = false;&nbsp;</div></li><li><div>                    MYANMAR::set_syllables($this-&gt;OTLdata, $myanmar_category_string, $broken_syllables);&nbsp;</div></li><li><div>                    $myanmar_category_string = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // b. Re-ordering (Myanmar mym2)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $dottedcircle = false;&nbsp;</div></li><li><div>                    if ($broken_syllables) {&nbsp;</div></li><li><div>                        if ($this-&gt;mpdf-&gt;_charDefined($this-&gt;mpdf-&gt;fonts[$this-&gt;fontkey]['cw'], 0x25CC)) {&nbsp;</div></li><li><div>                            $dottedcircle = array();&nbsp;</div></li><li><div>                            $ucd_record = UCDN::get_ucd_record(0x25CC);&nbsp;</div></li><li><div>                            $dottedcircle[0]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                            $dottedcircle[0]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                            $dottedcircle[0]['group'] = 'C';&nbsp;</div></li><li><div>                            $dottedcircle[0]['uni'] = 0x25CC;&nbsp;</div></li><li><div>                            $dottedcircle[0]['myanmar_category'] = MYANMAR::OT_DOTTEDCIRCLE;&nbsp;</div></li><li><div>                            $dottedcircle[0]['myanmar_position'] = MYANMAR::POS_BASE_C;&nbsp;</div></li><li><div>                            $dottedcircle[0]['hex'] = '025CC';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    MYANMAR::reordering($this-&gt;OTLdata, $this-&gt;GSUBdata[$this-&gt;GSUBfont], $broken_syllables, $dottedcircle);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // c. Apply initial and basic shaping forms GSUB Lookups (one at a time)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $tags = 'locl ccmp rphf pref blwf pstf';&nbsp;</div></li><li><div>                    $this-&gt;_applyGSUBrulesMyanmar($tags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // d. Apply Presentation Forms GSUB Lookups (+ any discretionary)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'pres abvs blws psts haln rlig calt liga clig mset';&nbsp;</div></li><li><div>                    $omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';&nbsp;</div></li><li><div>                    $usetags = $tags;&nbsp;</div></li><li><div>                    if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                        $usetags = $this-&gt;_applyTagSettings($tags, $GSUBFeatures, $omittags, false);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $this-&gt;_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>                    $this-&gt;restrictToSyllable = false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 5(E). GSUB - Shaper - SEA South East Asian (New Tai Lue, Cham, Tai Tam)&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                else if ($this-&gt;shaper == 'E') {&nbsp;</div></li><li><div>                    /** HarfBuzz says: If the designer designed the font for the 'DFLT' script, &nbsp;</div></li><li><div>                     * use the default shaper.  Otherwise, use the SEA shaper.&nbsp;</div></li><li><div>                     * Note that for some simple scripts, there may not be *any*&nbsp;</div></li><li><div>                     * GSUB/GPOS needed, so there may be no scripts found! */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;restrictToSyllable = true;&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // a. Analyse characters - group as syllables/clusters (Indic); invalid diacritics; add dotted circle&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $sea_category_string = '';&nbsp;</div></li><li><div>                    foreach ($this-&gt;OTLdata AS $eid =&gt; $c) {&nbsp;</div></li><li><div>                        SEA::set_sea_properties($this-&gt;OTLdata[$eid], $scriptblock); // sets ['sea_category'] and ['sea_position']&nbsp;</div></li><li><div>                        //$c['general_category']&nbsp;</div></li><li><div>                        //$c['combining_class']&nbsp;</div></li><li><div>                        //$c['uni'] =  $char;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $sea_category_string .= SEA::$sea_category_char[$this-&gt;OTLdata[$eid]['sea_category']];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $broken_syllables = false;&nbsp;</div></li><li><div>                    SEA::set_syllables($this-&gt;OTLdata, $sea_category_string, $broken_syllables);&nbsp;</div></li><li><div>                    $sea_category_string = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // b. Apply locl and ccmp shaping forms - before initial re-ordering; GSUB Lookups (one at a time)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'locl ccmp';&nbsp;</div></li><li><div>                    $this-&gt;_applyGSUBrulesSingly($tags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // c. Initial Re-ordering&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // Find base consonant&nbsp;</div></li><li><div>                    // Decompose/compose and reorder Matras&nbsp;</div></li><li><div>                    // Reorder marks to canonical order&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $dottedcircle = false;&nbsp;</div></li><li><div>                    if ($broken_syllables) {&nbsp;</div></li><li><div>                        if ($this-&gt;mpdf-&gt;_charDefined($this-&gt;mpdf-&gt;fonts[$this-&gt;fontkey]['cw'], 0x25CC)) {&nbsp;</div></li><li><div>                            $dottedcircle = array();&nbsp;</div></li><li><div>                            $ucd_record = UCDN::get_ucd_record(0x25CC);&nbsp;</div></li><li><div>                            $dottedcircle[0]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                            $dottedcircle[0]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                            $dottedcircle[0]['group'] = 'C';&nbsp;</div></li><li><div>                            $dottedcircle[0]['uni'] = 0x25CC;&nbsp;</div></li><li><div>                            $dottedcircle[0]['sea_category'] = SEA::OT_GB;&nbsp;</div></li><li><div>                            $dottedcircle[0]['sea_position'] = SEA::POS_BASE_C;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $dottedcircle[0]['hex'] = '025CC';  // TEMPORARY *****&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    SEA::initial_reordering($this-&gt;OTLdata, $this-&gt;GSUBdata[$this-&gt;GSUBfont], $broken_syllables, $scriptblock, $dottedcircle);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // d. Apply basic shaping forms GSUB Lookups (one at a time)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'pref abvf blwf pstf';&nbsp;</div></li><li><div>                    $this-&gt;_applyGSUBrulesSingly($tags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // e. Final Re-ordering&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    SEA::final_reordering($this-&gt;OTLdata, $this-&gt;GSUBdata[$this-&gt;GSUBfont], $scriptblock);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // f. Apply Presentation Forms GSUB Lookups (+ any discretionary)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'pres abvs blws psts';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $omittags = 'locl ccmp nukt akhn rphf rkrf pref blwf abvf half pstf cfar vatu cjct init medi fina isol med2 fin2 fin3 ljmo vjmo tjmo';&nbsp;</div></li><li><div>                    $usetags = $tags;&nbsp;</div></li><li><div>                    if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                        $usetags = $this-&gt;_applyTagSettings($tags, $GSUBFeatures, $omittags, false);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $this-&gt;_applyGSUBrules($usetags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>                    $this-&gt;restrictToSyllable = false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 5(D). GSUB - Shaper - DEFAULT (including THAI and LAO and MYANMAR v1 [mymr] and TIBETAN)&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                else { // DEFAULT&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // a. First decompose/compose in Thai / Lao - Tibetan&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // Decomposition for THAI or LAO&nbsp;</div></li><li><div>                    /** This function implements the shaping logic documented here:&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     *   http://linux.thai.net/~thep/th-otf/shaping.html&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * The first shaping rule listed there is needed even if the font has Thai&nbsp;</div></li><li><div>                     * OpenType tables.&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * The following is NOT specified in the MS OT Thai spec, however, it seems&nbsp;</div></li><li><div>                     * to be what Uniscribe and other engines implement.  According to Eric Muller:&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * When you have a SARA AM, decompose it in NIKHAHIT + SARA AA, *and* move the&nbsp;</div></li><li><div>                     * NIKHAHIT backwards over any tone mark (0E48-0E4B).&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * &lt;0E14, 0E4B, 0E33&gt; -&gt; &lt;0E14, 0E4D, 0E4B, 0E32&gt;&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * This reordering is legit only when the NIKHAHIT comes from a SARA AM, not&nbsp;</div></li><li><div>                     * when it's there to start with. The string &lt;0E14, 0E4B, 0E4D&gt; is probably&nbsp;</div></li><li><div>                     * not what a user wanted, but the rendering is nevertheless nikhahit above&nbsp;</div></li><li><div>                     * chattawa.&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * Same for Lao.&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     *          Thai        Lao&nbsp;</div></li><li><div>                     * SARA AM:     U+0E33  U+0EB3&nbsp;</div></li><li><div>                     * SARA AA:     U+0E32  U+0EB2&nbsp;</div></li><li><div>                     * Nikhahit:    U+0E4D  U+0ECD&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * Testing shows that Uniscribe reorder the following marks:&nbsp;</div></li><li><div>                     * Thai:    &lt;0E31, 0E34..0E37, 0E47..0E4E&gt;&nbsp;</div></li><li><div>                     * Lao: &lt;0EB1, 0EB4..0EB7, 0EC7..0ECE&gt;&nbsp;</div></li><li><div>                     *&nbsp;</div></li><li><div>                     * Lao versions are the same as Thai + 0x80.&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>                    if ($this-&gt;shaper == 'T' || $this-&gt;shaper == 'L') {&nbsp;</div></li><li><div>                        for ($ptr = 0; $ptr &lt; count($this-&gt;OTLdata); $ptr++) {&nbsp;</div></li><li><div>                            $char = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                            if (($char & ~0x0080) == 0x0E33) { // if SARA_AM (U+0E33 or U+0EB3)&nbsp;</div></li><li><div>                                $NIKHAHIT = $char + 0x1A;&nbsp;</div></li><li><div>                                $SARA_AA = $char - 1;&nbsp;</div></li><li><div>                                $sub = array($SARA_AA, $NIKHAHIT);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $newinfo = array();&nbsp;</div></li><li><div>                                $ucd_record = UCDN::get_ucd_record($sub[0]);&nbsp;</div></li><li><div>                                $newinfo[0]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                                $newinfo[0]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                                $charasstr = $this-&gt;unicode_hex($sub[0]);&nbsp;</div></li><li><div>                                if (strpos($this-&gt;GlyphClassMarks, $charasstr) !== false) {&nbsp;</div></li><li><div>                                    $newinfo[0]['group'] = 'M';&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $newinfo[0]['group'] = 'C';&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $newinfo[0]['uni'] = $sub[0];&nbsp;</div></li><li><div>                                $newinfo[0]['hex'] = $charasstr;&nbsp;</div></li><li><div>                                $this-&gt;OTLdata[$ptr] = $newinfo[0]; // Substitute SARA_AM =&gt; SARA_AA&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $ntones = 0; // number of (preceding) tone marks&nbsp;</div></li><li><div>                                // IS_TONE_MARK ((x) & ~0x0080, 0x0E34 - 0x0E37, 0x0E47 - 0x0E4E, 0x0E31)&nbsp;</div></li><li><div>                                while (isset($this-&gt;OTLdata[$ptr - 1 - $ntones]) && (&nbsp;</div></li><li><div>                                ($this-&gt;OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) == 0x0E31 ||&nbsp;</div></li><li><div>                                (($this-&gt;OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) &gt;= 0x0E34 &&&nbsp;</div></li><li><div>                                ($this-&gt;OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) &lt;= 0x0E37) ||&nbsp;</div></li><li><div>                                (($this-&gt;OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) &gt;= 0x0E47 &&&nbsp;</div></li><li><div>                                ($this-&gt;OTLdata[$ptr - 1 - $ntones]['uni'] & ~0x0080) &lt;= 0x0E4E)&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                                    $ntones++;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $newinfo = array();&nbsp;</div></li><li><div>                                $ucd_record = UCDN::get_ucd_record($sub[1]);&nbsp;</div></li><li><div>                                $newinfo[0]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                                $newinfo[0]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                                $charasstr = $this-&gt;unicode_hex($sub[1]);&nbsp;</div></li><li><div>                                if (strpos($this-&gt;GlyphClassMarks, $charasstr) !== false) {&nbsp;</div></li><li><div>                                    $newinfo[0]['group'] = 'M';&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $newinfo[0]['group'] = 'C';&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $newinfo[0]['uni'] = $sub[1];&nbsp;</div></li><li><div>                                $newinfo[0]['hex'] = $charasstr;&nbsp;</div></li><li><div>                                // Insert NIKAHIT&nbsp;</div></li><li><div>                                array_splice($this-&gt;OTLdata, $ptr - $ntones, 0, $newinfo);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $ptr++;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($scriptblock == UCDN::SCRIPT_TIBETAN) {&nbsp;</div></li><li><div>                        // =========================&nbsp;</div></li><li><div>                        // Reordering TIBETAN&nbsp;</div></li><li><div>                        // =========================&nbsp;</div></li><li><div>                        // Tibetan does not need to need a shaper generally, as long as characters are presented in the correct order&nbsp;</div></li><li><div>                        // so we will do one minor change here:&nbsp;</div></li><li><div>                        // From ICU: If the present character is a number, and the next character is a pre-number combining mark&nbsp;</div></li><li><div>                        // then the two characters are reordered&nbsp;</div></li><li><div>                        // From MS OTL spec the following are Digit modifiers (Md): 0F18*0F19, 0F3E*0F3F&nbsp;</div></li><li><div>                        // Digits: 0F20*0F33&nbsp;</div></li><li><div>                        // On testing only 0x0F3F (pre-based mark) seems to need re-ordering&nbsp;</div></li><li><div>                        for ($ptr = 0; $ptr &lt; count($this-&gt;OTLdata) - 1; $ptr++) {&nbsp;</div></li><li><div>                            if (INDIC::in_range($this-&gt;OTLdata[$ptr]['uni'], 0x0F20, 0x0F33) && $this-&gt;OTLdata[$ptr + 1]['uni'] == 0x0F3F) {&nbsp;</div></li><li><div>                                $tmp = $this-&gt;OTLdata[$ptr + 1];&nbsp;</div></li><li><div>                                $this-&gt;OTLdata[$ptr + 1] = $this-&gt;OTLdata[$ptr];&nbsp;</div></li><li><div>                                $this-&gt;OTLdata[$ptr] = $tmp;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // =========================&nbsp;</div></li><li><div>                        // Decomposition for TIBETAN&nbsp;</div></li><li><div>                        // =========================&nbsp;</div></li><li><div>                        /** Recommended, but does not seem to change anything...&nbsp;</div></li><li><div>                          for($ptr=0; $ptr&lt;count($this-&gt;OTLdata); $ptr++) {&nbsp;</div></li><li><div>                          $char = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                          $sub = INDIC::decompose_indic($char);&nbsp;</div></li><li><div>                          if ($sub) {&nbsp;</div></li><li><div>                          $newinfo = array();&nbsp;</div></li><li><div>                          for($i=0;$i&lt;count($sub);$i++) {&nbsp;</div></li><li><div>                          $newinfo[$i] = array();&nbsp;</div></li><li><div>                          $ucd_record = UCDN::get_ucd_record($sub[$i]);&nbsp;</div></li><li><div>                          $newinfo[$i]['general_category'] = $ucd_record[0];&nbsp;</div></li><li><div>                          $newinfo[$i]['bidi_type'] = $ucd_record[2];&nbsp;</div></li><li><div>                          $charasstr = $this-&gt;unicode_hex($sub[$i]);&nbsp;</div></li><li><div>                          if (strpos($this-&gt;GlyphClassMarks, $charasstr)!==false) { $newinfo[$i]['group'] =  'M'; }&nbsp;</div></li><li><div>                          else { $newinfo[$i]['group'] =  'C'; }&nbsp;</div></li><li><div>                          $newinfo[$i]['uni'] =  $sub[$i];&nbsp;</div></li><li><div>                          $newinfo[$i]['hex'] =  $charasstr;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          array_splice($this-&gt;OTLdata, $ptr, 1, $newinfo);&nbsp;</div></li><li><div>                          $ptr += count($sub)-1;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                         */&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    // b. Apply all GSUB Lookups (in order specified in lookup list)&nbsp;</div></li><li><div>                    //-----------------------------------------------------------------------------------&nbsp;</div></li><li><div>                    $tags = 'locl ccmp pref blwf abvf pstf pres abvs blws psts haln rlig calt liga clig mset  RQD';&nbsp;</div></li><li><div>                    // pref blwf abvf pstf required for Tibetan&nbsp;</div></li><li><div>                    // &quot; RQD&quot; is a non-standard tag in Garuda font - presumably intended to be used by default ? &quot;ReQuireD&quot;&nbsp;</div></li><li><div>                    // Being a 3 letter tag is non-standard, and does not allow it to be set by font-feature-settings&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** ?Add these until shapers witten?&nbsp;</div></li><li><div>                      Hangul:   ljmo vjmo tjmo&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $omittags = '';&nbsp;</div></li><li><div>                    $useGSUBtags = $tags;&nbsp;</div></li><li><div>                    if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                        $useGSUBtags = $this-&gt;_applyTagSettings($tags, $GSUBFeatures, $omittags, false);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    // APPLY GSUB rules (as long as not Latin + SmallCaps - but not OTL smcp)&nbsp;</div></li><li><div>                    if (!(($this-&gt;mpdf-&gt;textvar & FC_SMALLCAPS) && $scriptblock == UCDN::SCRIPT_LATIN && strpos($useGSUBtags, 'smcp') === false)) {&nbsp;</div></li><li><div>                        $this-&gt;_applyGSUBrules($useGSUBtags, $GSUBscriptTag, $GSUBlangsys);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Shapers - KHMER & THAI & LAO - Replace Word boundary marker with U+200B&nbsp;</div></li><li><div>            // Also TIBETAN (no shaper)&nbsp;</div></li><li><div>            //=======================================================&nbsp;</div></li><li><div>            if (($this-&gt;shaper == &quot;K&quot; || $this-&gt;shaper == &quot;T&quot; || $this-&gt;shaper == &quot;L&quot;) || $scriptblock == UCDN::SCRIPT_TIBETAN) {&nbsp;</div></li><li><div>                // Set up properties to insert a U+200B character&nbsp;</div></li><li><div>                $newinfo = array();&nbsp;</div></li><li><div>                //$newinfo[0] = array('general_category' =&gt; 1, 'bidi_type' =&gt; 14, 'group' =&gt; 'S', 'uni' =&gt; 0x200B, 'hex' =&gt; '0200B');&nbsp;</div></li><li><div>                $newinfo[0] = array(&nbsp;</div></li><li><div>                    'general_category' =&gt; UCDN::UNICODE_GENERAL_CATEGORY_FORMAT, &nbsp;</div></li><li><div>                    'bidi_type' =&gt; UCDN::BIDI_CLASS_BN, &nbsp;</div></li><li><div>                    'group' =&gt; 'S', 'uni' =&gt; 0x200B, 'hex' =&gt; '0200B');&nbsp;</div></li><li><div>                // Then insert U+200B at (after) all word end boundaries&nbsp;</div></li><li><div>                for ($i = count($this-&gt;OTLdata) - 1; $i &gt; 0; $i--) {&nbsp;</div></li><li><div>                    // Make sure after GSUB that wordend has not been moved - check next char is not in the same syllable&nbsp;</div></li><li><div>                    if (isset($this-&gt;OTLdata[$i]['wordend']) && $this-&gt;OTLdata[$i]['wordend'] &&&nbsp;</div></li><li><div>                        isset($this-&gt;OTLdata[$i + 1]['uni']) && (!isset($this-&gt;OTLdata[$i + 1]['syllable']) || !isset($this-&gt;OTLdata[$i + 1]['syllable']) || $this-&gt;OTLdata[$i + 1]['syllable'] != $this-&gt;OTLdata[$i]['syllable'])) {&nbsp;</div></li><li><div>                        array_splice($this-&gt;OTLdata, $i + 1, 0, $newinfo);&nbsp;</div></li><li><div>                        $this-&gt;_updateLigatureMarks($i, 1);&nbsp;</div></li><li><div>                    } else if ($this-&gt;OTLdata[$i]['uni'] == 0x2e) { // Word end if Full-stop.&nbsp;</div></li><li><div>                        array_splice($this-&gt;OTLdata, $i + 1, 0, $newinfo);&nbsp;</div></li><li><div>                        $this-&gt;_updateLigatureMarks($i, 1);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Shapers - INDIC & ARABIC & KHMER & SINHALA  & MYANMAR - Remove ZWJ and ZWNJ&nbsp;</div></li><li><div>            //=======================================================&nbsp;</div></li><li><div>            if ($this-&gt;shaper == 'I' || $this-&gt;shaper == 'S' || $this-&gt;shaper == 'A' || $this-&gt;shaper == 'K' || $this-&gt;shaper == 'M') {&nbsp;</div></li><li><div>                // Remove ZWJ and ZWNJ&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>                    if ($this-&gt;OTLdata[$i]['uni'] == 8204 || $this-&gt;OTLdata[$i]['uni'] == 8205) {&nbsp;</div></li><li><div>                        array_splice($this-&gt;OTLdata, $i, 1);&nbsp;</div></li><li><div>                        $this-&gt;_updateLigatureMarks($i, -1);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>//print_r($this-&gt;OTLdata); echo '&lt;br /&gt;';&nbsp;</div></li><li><div>//print_r($this-&gt;assocMarks);  echo '&lt;br /&gt;';&nbsp;</div></li><li><div>//print_r($this-&gt;assocLigs); exit;&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>//////////       GPOS          /////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (($useOTL & 0xFF) && $GPOSscriptTag && $GPOSlangsys && $GPOSFeatures) {&nbsp;</div></li><li><div>                $this-&gt;Entry = array();&nbsp;</div></li><li><div>                $this-&gt;Exit = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 6. Load GPOS data, Coverage & Lookups&nbsp;</div></li><li><div>                //=================================================================&nbsp;</div></li><li><div>                if (!isset($this-&gt;GPOSdata[$this-&gt;fontkey])) {&nbsp;</div></li><li><div>                    include(_MPDF_TTFONTDATAPATH . $this-&gt;mpdf-&gt;CurrentFont['fontkey'] . '.GPOSdata.php');&nbsp;</div></li><li><div>                    $this-&gt;LuCoverage = $this-&gt;GPOSdata[$this-&gt;fontkey]['LuCoverage'] = $LuCoverage;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $this-&gt;LuCoverage = $this-&gt;GPOSdata[$this-&gt;fontkey]['LuCoverage'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $this-&gt;GPOSLookups = $this-&gt;mpdf-&gt;CurrentFont['GPOSLookups'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 7. Select Feature tags to use (incl optional)&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                $tags = 'abvm blwm mark mkmk curs cpsp dist requ'; // Default set&nbsp;</div></li><li><div>                /** 'requ' is not listed in the Microsoft registry of Feature tags&nbsp;</div></li><li><div>                  Found in Arial Unicode MS, it repositions the baseline for punctuation in Kannada script */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // ZZZ96&nbsp;</div></li><li><div>                // Set kern to be included by default in non-Latin script (? just when shapers used)&nbsp;</div></li><li><div>                // Kern is used in some fonts to reposition marks etc. and is essential for correct display&nbsp;</div></li><li><div>                //if ($this-&gt;shaper) {$tags .= ' kern'; }&nbsp;</div></li><li><div>                if ($scriptblock != UCDN::SCRIPT_LATIN) {&nbsp;</div></li><li><div>                    $tags .= ' kern';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $omittags = '';&nbsp;</div></li><li><div>                $usetags = $tags;&nbsp;</div></li><li><div>                if (!empty($this-&gt;mpdf-&gt;OTLtags)) {&nbsp;</div></li><li><div>                    $usetags = $this-&gt;_applyTagSettings($tags, $GPOSFeatures, $omittags, false);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 8. Get GPOS LookupList from Feature tags&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                $LookupList = array();&nbsp;</div></li><li><div>                foreach ($GPOSFeatures AS $tag =&gt; $arr) {&nbsp;</div></li><li><div>                    if (strpos($usetags, $tag) !== false) {&nbsp;</div></li><li><div>                        foreach ($arr AS $lu) {&nbsp;</div></li><li><div>                            $LookupList[$lu] = $tag;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                ksort($LookupList);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 9. Apply GPOS Lookups (in order specified in lookup list but selecting from specified tags)&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                // APPLY THE GPOS RULES (as long as not Latin + SmallCaps - but not OTL smcp)&nbsp;</div></li><li><div>                if (!(($this-&gt;mpdf-&gt;textvar & FC_SMALLCAPS) && $scriptblock == UCDN::SCRIPT_LATIN && strpos($useGSUBtags, 'smcp') === false)) {&nbsp;</div></li><li><div>                    $this-&gt;_applyGPOSrules($LookupList, $is_old_spec);&nbsp;</div></li><li><div>                    // (sets: $this-&gt;OTLdata[n]['GPOSinfo'] XPlacement YPlacement XAdvance Entry Exit )&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // 10. Process cursive text&nbsp;</div></li><li><div>                //==============================&nbsp;</div></li><li><div>                if (count($this-&gt;Entry) || count($this-&gt;Exit)) {&nbsp;</div></li><li><div>                    // RTL&nbsp;</div></li><li><div>                    $incurs = false;&nbsp;</div></li><li><div>                    for ($i = (count($this-&gt;OTLdata) - 1); $i &gt;= 0; $i--) {&nbsp;</div></li><li><div>                        if (isset($this-&gt;Entry[$i]) && isset($this-&gt;Entry[$i]['Y']) && $this-&gt;Entry[$i]['dir'] == 'RTL') {&nbsp;</div></li><li><div>                            $nextbase = $i - 1; // Set as next base ignoring marks (next base reading RTL in logical oder&nbsp;</div></li><li><div>                            while (isset($this-&gt;OTLdata[$nextbase]['hex']) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$nextbase]['hex']) !== false) {&nbsp;</div></li><li><div>                                $nextbase--;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if (isset($this-&gt;Exit[$nextbase]) && isset($this-&gt;Exit[$nextbase]['Y'])) {&nbsp;</div></li><li><div>                                $diff = $this-&gt;Entry[$i]['Y'] - $this-&gt;Exit[$nextbase]['Y'];&nbsp;</div></li><li><div>                                if ($incurs === false) {&nbsp;</div></li><li><div>                                    $incurs = $diff;&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $incurs += $diff;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                for ($j = ($i - 1); $j &gt;= $nextbase; $j--) {&nbsp;</div></li><li><div>                                    if (isset($this-&gt;OTLdata[$j]['GPOSinfo']['YPlacement'])) {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$j]['GPOSinfo']['YPlacement'] += $incurs;&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$j]['GPOSinfo']['YPlacement'] = $incurs;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if (isset($this-&gt;Exit[$i]['X']) && isset($this-&gt;Entry[$nextbase]['X'])) {&nbsp;</div></li><li><div>                                    $adj = -($this-&gt;Entry[$i]['X'] - $this-&gt;Exit[$nextbase]['X']);&nbsp;</div></li><li><div>                                    // If XAdvance is aplied - in order for PDF to position the Advance correctly need to place it on:&nbsp;</div></li><li><div>                                    // in RTL - the current glyph or the last of any associated marks&nbsp;</div></li><li><div>                                    if (isset($this-&gt;OTLdata[$nextbase + 1]['GPOSinfo']['XAdvance'])) {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$nextbase + 1]['GPOSinfo']['XAdvance'] += $adj;&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$nextbase + 1]['GPOSinfo']['XAdvance'] = $adj;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $incurs = false;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        } else if (strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$i]['hex']) !== false) {&nbsp;</div></li><li><div>                            continue;&nbsp;</div></li><li><div>                        } // ignore Marks&nbsp;</div></li><li><div>                        else {&nbsp;</div></li><li><div>                            $incurs = false;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    // LTR&nbsp;</div></li><li><div>                    $incurs = false;&nbsp;</div></li><li><div>                    for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>                        if (isset($this-&gt;Exit[$i]) && isset($this-&gt;Exit[$i]['Y']) && $this-&gt;Exit[$i]['dir'] == 'LTR') {&nbsp;</div></li><li><div>                            $nextbase = $i + 1; // Set as next base ignoring marks&nbsp;</div></li><li><div>                            while (strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$nextbase]['hex']) !== false) {&nbsp;</div></li><li><div>                                $nextbase++;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if (isset($this-&gt;Entry[$nextbase]) && isset($this-&gt;Entry[$nextbase]['Y'])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $diff = $this-&gt;Exit[$i]['Y'] - $this-&gt;Entry[$nextbase]['Y'];&nbsp;</div></li><li><div>                                if ($incurs === false) {&nbsp;</div></li><li><div>                                    $incurs = $diff;&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $incurs += $diff;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                for ($j = ($i + 1); $j &lt;= $nextbase; $j++) {&nbsp;</div></li><li><div>                                    if (isset($this-&gt;OTLdata[$j]['GPOSinfo']['YPlacement'])) {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$j]['GPOSinfo']['YPlacement'] += $incurs;&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$j]['GPOSinfo']['YPlacement'] = $incurs;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if (isset($this-&gt;Exit[$i]['X']) && isset($this-&gt;Entry[$nextbase]['X'])) {&nbsp;</div></li><li><div>                                    $adj = -($this-&gt;Exit[$i]['X'] - $this-&gt;Entry[$nextbase]['X']);&nbsp;</div></li><li><div>                                    // If XAdvance is aplied - in order for PDF to position the Advance correctly need to place it on:&nbsp;</div></li><li><div>                                    // in LTR - the next glyph, ignoring marks&nbsp;</div></li><li><div>                                    if (isset($this-&gt;OTLdata[$nextbase]['GPOSinfo']['XAdvance'])) {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$nextbase]['GPOSinfo']['XAdvance'] += $adj;&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $this-&gt;OTLdata[$nextbase]['GPOSinfo']['XAdvance'] = $adj;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $incurs = false;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        } else if (strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$i]['hex']) !== false) {&nbsp;</div></li><li><div>                            continue;&nbsp;</div></li><li><div>                        } // ignore Marks&nbsp;</div></li><li><div>                        else {&nbsp;</div></li><li><div>                            $incurs = false;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } // end GPOS&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                $this-&gt;_dumpproc('END', '-', '-', '-', '-', 0, '-', 0);&nbsp;</div></li><li><div>                exit;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;schOTLdata[$sch] = $this-&gt;OTLdata;&nbsp;</div></li><li><div>            $this-&gt;OTLdata = array();&nbsp;</div></li><li><div>        } // END foreach subchunk&nbsp;</div></li><li><div>        // 11. Re-assemble and return text string&nbsp;</div></li><li><div>        //==============================&nbsp;</div></li><li><div>        $newGPOSinfo = array();&nbsp;</div></li><li><div>        $newOTLdata = array();&nbsp;</div></li><li><div>        $newchar_data = array();&nbsp;</div></li><li><div>        $newgroup = '';&nbsp;</div></li><li><div>        $e = '';&nbsp;</div></li><li><div>        $ectr = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($sch = 0; $sch &lt;= $subchunk; $sch++) {&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; count($this-&gt;schOTLdata[$sch]); $i++) {&nbsp;</div></li><li><div>                if (isset($this-&gt;schOTLdata[$sch][$i]['GPOSinfo'])) {&nbsp;</div></li><li><div>                    $newGPOSinfo[$ectr] = $this-&gt;schOTLdata[$sch][$i]['GPOSinfo'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $newchar_data[$ectr] = array('bidi_class' =&gt; $this-&gt;schOTLdata[$sch][$i]['bidi_type'], 'uni' =&gt; $this-&gt;schOTLdata[$sch][$i]['uni']);&nbsp;</div></li><li><div>                $newgroup .= $this-&gt;schOTLdata[$sch][$i]['group'];&nbsp;</div></li><li><div>                $e.=code2utf($this-&gt;schOTLdata[$sch][$i]['uni']);&nbsp;</div></li><li><div>                if (isset($this-&gt;mpdf-&gt;CurrentFont['subset'])) {&nbsp;</div></li><li><div>                    $this-&gt;mpdf-&gt;CurrentFont['subset'][$this-&gt;schOTLdata[$sch][$i]['uni']] = $this-&gt;schOTLdata[$sch][$i]['uni'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $ectr++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $this-&gt;OTLdata['GPOSinfo'] = $newGPOSinfo;&nbsp;</div></li><li><div>        $this-&gt;OTLdata['char_data'] = $newchar_data;&nbsp;</div></li><li><div>        $this-&gt;OTLdata['group'] = $newgroup;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // This leaves OTLdata::GPOSinfo, ::bidi_type, & ::group&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $e;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyTagSettings($tags, $Features, $omittags = '', $onlytags = false)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (empty($this-&gt;mpdf-&gt;OTLtags['Plus']) && empty($this-&gt;mpdf-&gt;OTLtags['Minus']) && empty($this-&gt;mpdf-&gt;OTLtags['FFPlus']) && empty($this-&gt;mpdf-&gt;OTLtags['FFMinus'])) {&nbsp;</div></li><li><div>            return $tags;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Use $tags as starting point&nbsp;</div></li><li><div>        $usetags = $tags;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Only set / unset tags which are in the font&nbsp;</div></li><li><div>        // Ignore tags which are in $omittags&nbsp;</div></li><li><div>        // If $onlytags, then just unset tags which are already in the Tag list&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $fp = $fm = $ffp = $ffm = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Font features to enable - set by font-variant-xx&nbsp;</div></li><li><div>        if (isset($this-&gt;mpdf-&gt;OTLtags['Plus']))&nbsp;</div></li><li><div>            $fp = $this-&gt;mpdf-&gt;OTLtags['Plus'];&nbsp;</div></li><li><div>        preg_match_all('/([a-zA-Z0-9]{4})/', $fp, $m);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($m[0]); $i++) {&nbsp;</div></li><li><div>            $t = $m[1][$i];&nbsp;</div></li><li><div>            // Is it a valid tag?&nbsp;</div></li><li><div>            if (isset($Features[$t]) && strpos($omittags, $t) === false && (!$onlytags || strpos($tags, $t) !== false )) {&nbsp;</div></li><li><div>                $usetags .= ' ' . $t;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Font features to disable - set by font-variant-xx&nbsp;</div></li><li><div>        if (isset($this-&gt;mpdf-&gt;OTLtags['Minus']))&nbsp;</div></li><li><div>            $fm = $this-&gt;mpdf-&gt;OTLtags['Minus'];&nbsp;</div></li><li><div>        preg_match_all('/([a-zA-Z0-9]{4})/', $fm, $m);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($m[0]); $i++) {&nbsp;</div></li><li><div>            $t = $m[1][$i];&nbsp;</div></li><li><div>            // Is it a valid tag?&nbsp;</div></li><li><div>            if (isset($Features[$t]) && strpos($omittags, $t) === false && (!$onlytags || strpos($tags, $t) !== false )) {&nbsp;</div></li><li><div>                $usetags = str_replace($t, '', $usetags);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Font features to enable - set by font-feature-settings&nbsp;</div></li><li><div>        if (isset($this-&gt;mpdf-&gt;OTLtags['FFPlus']))&nbsp;</div></li><li><div>            $ffp = $this-&gt;mpdf-&gt;OTLtags['FFPlus']; // Font Features - may include integer: salt4&nbsp;</div></li><li><div>        preg_match_all('/([a-zA-Z0-9]{4})([\d+]*)/', $ffp, $m);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($m[0]); $i++) {&nbsp;</div></li><li><div>            $t = $m[1][$i];&nbsp;</div></li><li><div>            // Is it a valid tag?&nbsp;</div></li><li><div>            if (isset($Features[$t]) && strpos($omittags, $t) === false && (!$onlytags || strpos($tags, $t) !== false )) {&nbsp;</div></li><li><div>                $usetags .= ' ' . $m[0][$i];  //  - may include integer: salt4&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Font features to disable - set by font-feature-settings&nbsp;</div></li><li><div>        if (isset($this-&gt;mpdf-&gt;OTLtags['FFMinus']))&nbsp;</div></li><li><div>            $ffm = $this-&gt;mpdf-&gt;OTLtags['FFMinus'];&nbsp;</div></li><li><div>        preg_match_all('/([a-zA-Z0-9]{4})/', $ffm, $m);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($m[0]); $i++) {&nbsp;</div></li><li><div>            $t = $m[1][$i];&nbsp;</div></li><li><div>            // Is it a valid tag?&nbsp;</div></li><li><div>            if (isset($Features[$t]) && strpos($omittags, $t) === false && (!$onlytags || strpos($tags, $t) !== false )) {&nbsp;</div></li><li><div>                $usetags = str_replace($t, '', $usetags);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $usetags;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGSUBrules($usetags, $scriptTag, $langsys)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // Features from all Tags are applied together, in Lookup List order.&nbsp;</div></li><li><div>        // For Indic - should be applied one syllable at a time&nbsp;</div></li><li><div>        // - Implemented in functions checkContextMatch and checkContextMatchMultiple by failing to match if outside scope of current 'syllable'&nbsp;</div></li><li><div>        // if $this-&gt;restrictToSyllable is true&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $GSUBFeatures = $this-&gt;mpdf-&gt;CurrentFont['GSUBFeatures'][$scriptTag][$langsys];&nbsp;</div></li><li><div>        $LookupList = array();&nbsp;</div></li><li><div>        foreach ($GSUBFeatures AS $tag =&gt; $arr) {&nbsp;</div></li><li><div>            if (strpos($usetags, $tag) !== false) {&nbsp;</div></li><li><div>                foreach ($arr AS $lu) {&nbsp;</div></li><li><div>                    $LookupList[$lu] = $tag;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        ksort($LookupList);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($LookupList AS $lu =&gt; $tag) {&nbsp;</div></li><li><div>            $Type = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>            $Flag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>            $MarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>            $tagInt = 1;&nbsp;</div></li><li><div>            if (preg_match('/' . $tag . '([0-9]{1, 2})/', $usetags, $m)) {&nbsp;</div></li><li><div>                $tagInt = $m[1];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $ptr = 0;&nbsp;</div></li><li><div>            // Test each glyph sequentially&nbsp;</div></li><li><div>            while ($ptr &lt; (count($this-&gt;OTLdata))) { // whilst there is another glyph ..0064&nbsp;</div></li><li><div>                $currGlyph = $this-&gt;OTLdata[$ptr]['hex'];&nbsp;</div></li><li><div>                $currGID = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                $shift = 1;&nbsp;</div></li><li><div>                foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $c =&gt; $subtable_offset) {&nbsp;</div></li><li><div>                    // NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)&nbsp;</div></li><li><div>                    if (isset($this-&gt;GSLuCoverage[$lu][$c][$currGID])) {&nbsp;</div></li><li><div>                        // Get rules from font GSUB subtable&nbsp;</div></li><li><div>                        $shift = $this-&gt;_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this-&gt;GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$c], 0, $tag, 0, $tagInt);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ($shift) {&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($shift == 0) {&nbsp;</div></li><li><div>                    $shift = 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $ptr += $shift;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGSUBrulesSingly($usetags, $scriptTag, $langsys)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // Features are applied one at a time, working through each codepoint&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $GSUBFeatures = $this-&gt;mpdf-&gt;CurrentFont['GSUBFeatures'][$scriptTag][$langsys];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $tags = explode(' ', $usetags);&nbsp;</div></li><li><div>        foreach ($tags AS $usetag) {&nbsp;</div></li><li><div>            $LookupList = array();&nbsp;</div></li><li><div>            foreach ($GSUBFeatures AS $tag =&gt; $arr) {&nbsp;</div></li><li><div>                if (strpos($usetags, $tag) !== false) {&nbsp;</div></li><li><div>                    foreach ($arr AS $lu) {&nbsp;</div></li><li><div>                        $LookupList[$lu] = $tag;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ksort($LookupList);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $ptr = 0;&nbsp;</div></li><li><div>            // Test each glyph sequentially&nbsp;</div></li><li><div>            while ($ptr &lt; (count($this-&gt;OTLdata))) { // whilst there is another glyph ..0064&nbsp;</div></li><li><div>                $currGlyph = $this-&gt;OTLdata[$ptr]['hex'];&nbsp;</div></li><li><div>                $currGID = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                $shift = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                foreach ($LookupList AS $lu =&gt; $tag) {&nbsp;</div></li><li><div>                    $Type = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                    $Flag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                    $MarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>                    $tagInt = 1;&nbsp;</div></li><li><div>                    if (preg_match('/' . $tag . '([0-9]{1, 2})/', $usetags, $m)) {&nbsp;</div></li><li><div>                        $tagInt = $m[1];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $c =&gt; $subtable_offset) {&nbsp;</div></li><li><div>                        // NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)&nbsp;</div></li><li><div>                        if (isset($this-&gt;GSLuCoverage[$lu][$c][$currGID])) {&nbsp;</div></li><li><div>                            // Get rules from font GSUB subtable&nbsp;</div></li><li><div>                            $shift = $this-&gt;_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this-&gt;GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$c], 0, $tag, 0, $tagInt);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($shift) {&nbsp;</div></li><li><div>                                break 2;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($shift == 0) {&nbsp;</div></li><li><div>                    $shift = 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $ptr += $shift;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGSUBrulesMyanmar($usetags, $scriptTag, $langsys)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // $usetags = locl ccmp rphf pref blwf pstf';&nbsp;</div></li><li><div>        // applied to all characters&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $GSUBFeatures = $this-&gt;mpdf-&gt;CurrentFont['GSUBFeatures'][$scriptTag][$langsys];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ALL should be applied one syllable at a time&nbsp;</div></li><li><div>        // Implemented in functions checkContextMatch and checkContextMatchMultiple by failing to match if outside scope of current 'syllable'&nbsp;</div></li><li><div>        $tags = explode(' ', $usetags);&nbsp;</div></li><li><div>        foreach ($tags AS $usetag) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $LookupList = array();&nbsp;</div></li><li><div>            foreach ($GSUBFeatures AS $tag =&gt; $arr) {&nbsp;</div></li><li><div>                if ($tag == $usetag) {&nbsp;</div></li><li><div>                    foreach ($arr AS $lu) {&nbsp;</div></li><li><div>                        $LookupList[$lu] = $tag;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ksort($LookupList);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            foreach ($LookupList AS $lu =&gt; $tag) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $Type = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                $Flag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                $MarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>                $tagInt = 1;&nbsp;</div></li><li><div>                if (preg_match('/' . $tag . '([0-9]{1, 2})/', $usetags, $m)) {&nbsp;</div></li><li><div>                    $tagInt = $m[1];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $ptr = 0;&nbsp;</div></li><li><div>                // Test each glyph sequentially&nbsp;</div></li><li><div>                while ($ptr &lt; (count($this-&gt;OTLdata))) { // whilst there is another glyph ..0064&nbsp;</div></li><li><div>                    $currGlyph = $this-&gt;OTLdata[$ptr]['hex'];&nbsp;</div></li><li><div>                    $currGID = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                    $shift = 1;&nbsp;</div></li><li><div>                    foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $c =&gt; $subtable_offset) {&nbsp;</div></li><li><div>                        // NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)&nbsp;</div></li><li><div>                        if (isset($this-&gt;GSLuCoverage[$lu][$c][$currGID])) {&nbsp;</div></li><li><div>                            // Get rules from font GSUB subtable&nbsp;</div></li><li><div>                            $shift = $this-&gt;_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this-&gt;GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$c], 0, $usetag, 0, $tagInt);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($shift) {&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($shift == 0) {&nbsp;</div></li><li><div>                        $shift = 1;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $ptr += $shift;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGSUBrulesIndic($usetags, $scriptTag, $langsys, $is_old_spec)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // $usetags = 'locl ccmp nukt akhn rphf rkrf pref blwf half pstf vatu cjct'; then later - init&nbsp;</div></li><li><div>        // rphf, pref, blwf, half, abvf, pstf, and init are only applied where ['mask'] indicates:  INDIC::FLAG(INDIC::RPHF);&nbsp;</div></li><li><div>        // The rest are applied to all characters&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $GSUBFeatures = $this-&gt;mpdf-&gt;CurrentFont['GSUBFeatures'][$scriptTag][$langsys];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // ALL should be applied one syllable at a time&nbsp;</div></li><li><div>        // Implemented in functions checkContextMatch and checkContextMatchMultiple by failing to match if outside scope of current 'syllable'&nbsp;</div></li><li><div>        $tags = explode(' ', $usetags);&nbsp;</div></li><li><div>        foreach ($tags AS $usetag) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $LookupList = array();&nbsp;</div></li><li><div>            foreach ($GSUBFeatures AS $tag =&gt; $arr) {&nbsp;</div></li><li><div>                if ($tag == $usetag) {&nbsp;</div></li><li><div>                    foreach ($arr AS $lu) {&nbsp;</div></li><li><div>                        $LookupList[$lu] = $tag;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ksort($LookupList);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            foreach ($LookupList AS $lu =&gt; $tag) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $Type = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                $Flag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                $MarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>                $tagInt = 1;&nbsp;</div></li><li><div>                if (preg_match('/' . $tag . '([0-9]{1, 2})/', $usetags, $m)) {&nbsp;</div></li><li><div>                    $tagInt = $m[1];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $ptr = 0;&nbsp;</div></li><li><div>                // Test each glyph sequentially&nbsp;</div></li><li><div>                while ($ptr &lt; (count($this-&gt;OTLdata))) { // whilst there is another glyph ..0064&nbsp;</div></li><li><div>                    $currGlyph = $this-&gt;OTLdata[$ptr]['hex'];&nbsp;</div></li><li><div>                    $currGID = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                    $shift = 1;&nbsp;</div></li><li><div>                    foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $c =&gt; $subtable_offset) {&nbsp;</div></li><li><div>                        // NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)&nbsp;</div></li><li><div>                        if (isset($this-&gt;GSLuCoverage[$lu][$c][$currGID])) {&nbsp;</div></li><li><div>                            if (strpos('rphf pref blwf half pstf cfar init', $usetag) !== false) { // only apply when mask indicates&nbsp;</div></li><li><div>                                $mask = 0;&nbsp;</div></li><li><div>                                switch ($usetag) {&nbsp;</div></li><li><div>                                    case 'rphf': $mask = (1 &lt;&lt; (INDIC::RPHF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'pref': $mask = (1 &lt;&lt; (INDIC::PREF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'blwf': $mask = (1 &lt;&lt; (INDIC::BLWF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'half': $mask = (1 &lt;&lt; (INDIC::HALF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'pstf': $mask = (1 &lt;&lt; (INDIC::PSTF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'cfar': $mask = (1 &lt;&lt; (INDIC::CFAR));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'init': $mask = (1 &lt;&lt; (INDIC::INIT));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if (!($this-&gt;OTLdata[$ptr]['mask'] & $mask)) {&nbsp;</div></li><li><div>                                    continue;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            // Get rules from font GSUB subtable&nbsp;</div></li><li><div>                            $shift = $this-&gt;_applyGSUBsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this-&gt;GSUB_offset), $Type, $Flag, $MarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$c], 0, $usetag, $is_old_spec, $tagInt);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($shift) {&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        // Special case for Indic  ZZZ99S&nbsp;</div></li><li><div>                        // Check to substitute Halant-Consonant in PREF, BLWF or PSTF&nbsp;</div></li><li><div>                        // i.e. new spec but GSUB tables have Consonant-Halant in Lookups e.g. FreeSerif, which&nbsp;</div></li><li><div>                        // incorrectly just moved old spec tables to new spec. Uniscribe seems to cope with this&nbsp;</div></li><li><div>                        // See also ttffontsuni.php&nbsp;</div></li><li><div>                        // First check if current glyph is a Halant/Virama&nbsp;</div></li><li><div>                        else if (_OTL_OLD_SPEC_COMPAT_1 && $Type == 4 && !$is_old_spec && strpos('0094D 009CD 00A4D 00ACD 00B4D 00BCD 00C4D 00CCD 00D4D', $currGlyph) !== false) {&nbsp;</div></li><li><div>                            // only apply when 'pref blwf pstf' tags, and when mask indicates&nbsp;</div></li><li><div>                            if (strpos('pref blwf pstf', $usetag) !== false) {&nbsp;</div></li><li><div>                                $mask = 0;&nbsp;</div></li><li><div>                                switch ($usetag) {&nbsp;</div></li><li><div>                                    case 'pref': $mask = (1 &lt;&lt; (INDIC::PREF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'blwf': $mask = (1 &lt;&lt; (INDIC::BLWF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    case 'pstf': $mask = (1 &lt;&lt; (INDIC::PSTF));&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if (!($this-&gt;OTLdata[$ptr]['mask'] & $mask)) {&nbsp;</div></li><li><div>                                    continue;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $nextGlyph = $this-&gt;OTLdata[$ptr + 1]['hex'];&nbsp;</div></li><li><div>                                $nextGID = $this-&gt;OTLdata[$ptr + 1]['uni'];&nbsp;</div></li><li><div>                                if (isset($this-&gt;GSLuCoverage[$lu][$c][$nextGID])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    // Get rules from font GSUB subtable&nbsp;</div></li><li><div>                                    $shift = $this-&gt;_applyGSUBsubtableSpecial($lu, $c, $ptr, $currGlyph, $currGID, $nextGlyph, $nextGID, ($subtable_offset - $this-&gt;GSUB_offset), $Type, $this-&gt;GSLuCoverage[$lu][$c]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    if ($shift) {&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($shift == 0) {&nbsp;</div></li><li><div>                        $shift = 1;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $ptr += $shift;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGSUBsubtableSpecial($lookupID, $subtable, $ptr, $currGlyph, $currGID, $nextGlyph, $nextGID, $subtable_offset, $Type, $LuCoverage)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Special case for Indic&nbsp;</div></li><li><div>        // Check to substitute Halant-Consonant in PREF, BLWF or PSTF&nbsp;</div></li><li><div>        // i.e. new spec but GSUB tables have Consonant-Halant in Lookups e.g. FreeSerif, which&nbsp;</div></li><li><div>        // incorrectly just moved old spec tables to new spec. Uniscribe seems to cope with this&nbsp;</div></li><li><div>        // See also ttffontsuni.php&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;seek($subtable_offset);&nbsp;</div></li><li><div>        $SubstFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Subtable contains Consonant - Halant&nbsp;</div></li><li><div>        // Text string contains Halant ($CurrGlyph) - Consonant ($nextGlyph)&nbsp;</div></li><li><div>        // Halant has already been matched, and already checked that $nextGID is in Coverage table&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // Only does: LookupType 4: Ligature Substitution Subtable : n to 1&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>        $NextGlyphPos = $LuCoverage[$nextGID];&nbsp;</div></li><li><div>        $LigSetCount = $this-&gt;read_short();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;skip($NextGlyphPos * 2);&nbsp;</div></li><li><div>        $LigSet = $subtable_offset + $this-&gt;read_short();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $this-&gt;seek($LigSet);&nbsp;</div></li><li><div>        $LigCount = $this-&gt;read_short();&nbsp;</div></li><li><div>        // LigatureSet i.e. all starting with the same Glyph $nextGlyph [Consonant]&nbsp;</div></li><li><div>        $LigatureOffset = array();&nbsp;</div></li><li><div>        for ($g = 0; $g &lt; $LigCount; $g++) {&nbsp;</div></li><li><div>            $LigatureOffset[$g] = $LigSet + $this-&gt;read_ushort();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        for ($g = 0; $g &lt; $LigCount; $g++) {&nbsp;</div></li><li><div>            // Ligature tables&nbsp;</div></li><li><div>            $this-&gt;seek($LigatureOffset[$g]);&nbsp;</div></li><li><div>            $LigGlyph = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $substitute = $this-&gt;glyphToChar($LigGlyph);&nbsp;</div></li><li><div>            $CompCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($CompCount != 2) {&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            } // Only expecting to work with 2:1 (and no ignore characters in between)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $gid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $checkGlyph = $this-&gt;glyphToChar($gid); // Other component/input Glyphs starting at position 2 (arrayindex 1)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($currGID == $checkGlyph) {&nbsp;</div></li><li><div>                $match = true;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $match = false;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $GlyphPos = array();&nbsp;</div></li><li><div>            $GlyphPos[] = $ptr;&nbsp;</div></li><li><div>            $GlyphPos[] = $ptr + 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($match) {&nbsp;</div></li><li><div>                $shift = $this-&gt;GSUBsubstitute($ptr, $substitute, 4, $GlyphPos); // GlyphPos contains positions to set null&nbsp;</div></li><li><div>                if ($shift)&nbsp;</div></li><li><div>                    return 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return 0;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGSUBsubtable($lookupID, $subtable, $ptr, $currGlyph, $currGID, $subtable_offset, $Type, $Flag, $MarkFilteringSet, $LuCoverage, $level = 0, $currentTag, $is_old_spec, $tagInt)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $ignore = $this-&gt;_getGCOMignoreString($Flag, $MarkFilteringSet);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Lets start&nbsp;</div></li><li><div>        $this-&gt;seek($subtable_offset);&nbsp;</div></li><li><div>        $SubstFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 1: Single Substitution Subtable : 1 to 1&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        if ($Type == 1) {&nbsp;</div></li><li><div>            // Flag = Ignore&nbsp;</div></li><li><div>            if ($this-&gt;_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) {&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $CoverageOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $GlyphPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            if ($SubstFormat == 1) { // Calculated output glyph indices&nbsp;</div></li><li><div>                $DeltaGlyphID = $this-&gt;read_short();&nbsp;</div></li><li><div>                $this-&gt;seek($CoverageOffset);&nbsp;</div></li><li><div>                $glyphs = $this-&gt;_getCoverageGID();&nbsp;</div></li><li><div>                $GlyphID = $glyphs[$GlyphPos] + $DeltaGlyphID;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            else if ($SubstFormat == 2) { // Specified output glyph indices&nbsp;</div></li><li><div>                $GlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $this-&gt;skip($GlyphPos * 2);&nbsp;</div></li><li><div>                $GlyphID = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $substitute = $this-&gt;glyphToChar($GlyphID);&nbsp;</div></li><li><div>            $shift = $this-&gt;GSUBsubstitute($ptr, $substitute, $Type);&nbsp;</div></li><li><div>            if ($this-&gt;debugOTL && $shift) {&nbsp;</div></li><li><div>                $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($shift)&nbsp;</div></li><li><div>                return 1;&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 2: Multiple Substitution Subtable : 1 to n&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 2) {&nbsp;</div></li><li><div>            // Flag = Ignore&nbsp;</div></li><li><div>            if ($this-&gt;_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) {&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $GlyphPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>            $this-&gt;skip(2);&nbsp;</div></li><li><div>            $this-&gt;skip($GlyphPos * 2);&nbsp;</div></li><li><div>            $Sequences = $subtable_offset + $this-&gt;read_short();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;seek($Sequences);&nbsp;</div></li><li><div>            $GlyphCount = $this-&gt;read_short();&nbsp;</div></li><li><div>            $SubstituteGlyphs = array();&nbsp;</div></li><li><div>            for ($g = 0; $g &lt; $GlyphCount; $g++) {&nbsp;</div></li><li><div>                $sgid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $SubstituteGlyphs[] = $this-&gt;glyphToChar($sgid);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $shift = $this-&gt;GSUBsubstitute($ptr, $SubstituteGlyphs, $Type);&nbsp;</div></li><li><div>            if ($this-&gt;debugOTL && $shift) {&nbsp;</div></li><li><div>                $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($shift)&nbsp;</div></li><li><div>                return $shift;&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 3: Alternate Forms : 1 to 1(n)&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 3) {&nbsp;</div></li><li><div>            // Flag = Ignore&nbsp;</div></li><li><div>            if ($this-&gt;_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) {&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $AlternateSetCount = $this-&gt;read_short();&nbsp;</div></li><li><div>            ///////////////////////////////////////////////////////////////////////////////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&nbsp;</div></li><li><div>            // Need to set alternate IF set by CSS3 font-feature for a tag&nbsp;</div></li><li><div>            // i.e. if this is 'salt' alternate may be set to 2&nbsp;</div></li><li><div>            // default value will be $alt=1 ( === index of 0 in list of alternates)&nbsp;</div></li><li><div>            $alt = 1; // $alt=1 points to Alternative[0]&nbsp;</div></li><li><div>            if ($tagInt &gt; 1) {&nbsp;</div></li><li><div>                $alt = $tagInt;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ///////////////////////////////////////////////////////////////////////////////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&nbsp;</div></li><li><div>            if ($alt == 0) {&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            } // If specified alternate not present, cancel [ or could default $alt = 1 ?]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $GlyphPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>            $this-&gt;skip($GlyphPos * 2);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $AlternateSets = $subtable_offset + $this-&gt;read_short();&nbsp;</div></li><li><div>            $this-&gt;seek($AlternateSets);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $AlternateGlyphCount = $this-&gt;read_short();&nbsp;</div></li><li><div>            if ($alt &gt; $AlternateGlyphCount) {&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            } // If specified alternate not present, cancel [ or could default $alt = 1 ?]&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;skip(($alt - 1) * 2);&nbsp;</div></li><li><div>            $GlyphID = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $substitute = $this-&gt;glyphToChar($GlyphID);&nbsp;</div></li><li><div>            $shift = $this-&gt;GSUBsubstitute($ptr, $substitute, $Type);&nbsp;</div></li><li><div>            if ($this-&gt;debugOTL && $shift) {&nbsp;</div></li><li><div>                $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($shift)&nbsp;</div></li><li><div>                return 1;&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 4: Ligature Substitution Subtable : n to 1&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 4) {&nbsp;</div></li><li><div>            // Flag = Ignore&nbsp;</div></li><li><div>            if ($this-&gt;_checkGCOMignore($Flag, $currGlyph, $MarkFilteringSet)) {&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $FirstGlyphPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $LigSetCount = $this-&gt;read_short();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;skip($FirstGlyphPos * 2);&nbsp;</div></li><li><div>            $LigSet = $subtable_offset + $this-&gt;read_short();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;seek($LigSet);&nbsp;</div></li><li><div>            $LigCount = $this-&gt;read_short();&nbsp;</div></li><li><div>            // LigatureSet i.e. all starting with the same first Glyph $currGlyph&nbsp;</div></li><li><div>            $LigatureOffset = array();&nbsp;</div></li><li><div>            for ($g = 0; $g &lt; $LigCount; $g++) {&nbsp;</div></li><li><div>                $LigatureOffset[$g] = $LigSet + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            for ($g = 0; $g &lt; $LigCount; $g++) {&nbsp;</div></li><li><div>                // Ligature tables&nbsp;</div></li><li><div>                $this-&gt;seek($LigatureOffset[$g]);&nbsp;</div></li><li><div>                $LigGlyph = $this-&gt;read_ushort(); // Output Ligature GlyphID&nbsp;</div></li><li><div>                $substitute = $this-&gt;glyphToChar($LigGlyph);&nbsp;</div></li><li><div>                $CompCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $spos = $ptr;&nbsp;</div></li><li><div>                $match = true;&nbsp;</div></li><li><div>                $GlyphPos = array();&nbsp;</div></li><li><div>                $GlyphPos[] = $spos;&nbsp;</div></li><li><div>                for ($l = 1; $l &lt; $CompCount; $l++) {&nbsp;</div></li><li><div>                    $gid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $checkGlyph = $this-&gt;glyphToChar($gid); // Other component/input Glyphs starting at position 2 (arrayindex 1)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $spos++;&nbsp;</div></li><li><div>                    //while $this-&gt;OTLdata[$spos]['uni'] is an &quot;ignore&quot; =&gt;  spos++&nbsp;</div></li><li><div>                    while (isset($this-&gt;OTLdata[$spos]) && strpos($ignore, $this-&gt;OTLdata[$spos]['hex']) !== false) {&nbsp;</div></li><li><div>                        $spos++;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if (isset($this-&gt;OTLdata[$spos]) && $this-&gt;OTLdata[$spos]['uni'] == $checkGlyph) {&nbsp;</div></li><li><div>                        $GlyphPos[] = $spos;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $match = false;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ($match) {&nbsp;</div></li><li><div>                    $shift = $this-&gt;GSUBsubstitute($ptr, $substitute, $Type, $GlyphPos); // GlyphPos contains positions to set null&nbsp;</div></li><li><div>                    if ($this-&gt;debugOTL && $shift) {&nbsp;</div></li><li><div>                        $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($shift)&nbsp;</div></li><li><div>                        return ($spos - $ptr + 1 - ($CompCount - 1));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 5: Contextual Substitution Subtable&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 5) {&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1: Simple Context Glyph Substitution&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            if ($SubstFormat == 1) {&nbsp;</div></li><li><div>                $CoverageTableOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $SubRuleSetCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $SubRuleSetOffset = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $SubRuleSetCount; $b++) {&nbsp;</div></li><li><div>                    $offset = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    if ($offset == 0x0000) {&nbsp;</div></li><li><div>                        $SubRuleSetOffset[] = $offset;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $SubRuleSetOffset[] = $subtable_offset + $offset;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // SubRuleSet tables: All contexts beginning with the same glyph&nbsp;</div></li><li><div>                // Select the SubRuleSet required using the position of the glyph in the coverage table&nbsp;</div></li><li><div>                $GlyphPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>                if ($SubRuleSetOffset[$GlyphPos] &gt; 0) {&nbsp;</div></li><li><div>                    $this-&gt;seek($SubRuleSetOffset[$GlyphPos]);&nbsp;</div></li><li><div>                    $SubRuleCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $SubRule = array();&nbsp;</div></li><li><div>                    for ($b = 0; $b &lt; $SubRuleCnt; $b++) {&nbsp;</div></li><li><div>                        $SubRule[$b] = $SubRuleSetOffset[$GlyphPos] + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    for ($b = 0; $b &lt; $SubRuleCnt; $b++) {  // EACH RULE&nbsp;</div></li><li><div>                        $this-&gt;seek($SubRule[$b]);&nbsp;</div></li><li><div>                        $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $SubstCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $Backtrack = array();&nbsp;</div></li><li><div>                        $Lookahead = array();&nbsp;</div></li><li><div>                        $Input = array();&nbsp;</div></li><li><div>                        $Input[0] = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                        for ($r = 1; $r &lt; $InputGlyphCount; $r++) {&nbsp;</div></li><li><div>                            $gid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $Input[$r] = $this-&gt;glyphToChar($gid);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $matched = $this-&gt;checkContextMatch($Input, $Backtrack, $Lookahead, $ignore, $ptr);&nbsp;</div></li><li><div>                        if ($matched) {&nbsp;</div></li><li><div>                            if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                                $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            for ($p = 0; $p &lt; $SubstCount; $p++) { // EACH LOOKUP&nbsp;</div></li><li><div>                                $SequenceIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                $LookupListIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            for ($p = 0; $p &lt; $SubstCount; $p++) {&nbsp;</div></li><li><div>                                // Apply  $LookupListIndex  at   $SequenceIndex&nbsp;</div></li><li><div>                                if ($SequenceIndex[$p] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                                    continue;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $lu = $LookupListIndex[$p];&nbsp;</div></li><li><div>                                $luType = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                                $luFlag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                                $luMarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $luptr = $matched[$SequenceIndex[$p]];&nbsp;</div></li><li><div>                                $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                                $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                                    $shift = $this-&gt;_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GSUB_offset), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);&nbsp;</div></li><li><div>                                    if ($shift) {&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if (!defined(&quot;OMIT_OTL_FIX_3&quot;) || OMIT_OTL_FIX_3 != 1) {&nbsp;</div></li><li><div>                                return $shift;&nbsp;</div></li><li><div>                            } /** OTL_FIX_3 */&nbsp;</div></li><li><div>                            else&nbsp;</div></li><li><div>                                return $InputGlyphCount; // should be + matched ignores in Input Sequence&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2: Class-based Context Glyph Substitution&nbsp;</div></li><li><div>            else if ($SubstFormat == 2) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $CoverageTableOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $InputClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $SubClassSetCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $SubClassSetOffset = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $SubClassSetCnt; $b++) {&nbsp;</div></li><li><div>                    $offset = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    if ($offset == 0x0000) {&nbsp;</div></li><li><div>                        $SubClassSetOffset[] = $offset;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $SubClassSetOffset[] = $subtable_offset + $offset;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $InputClasses = $this-&gt;_getClasses($InputClassDefOffset);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                for ($s = 0; $s &lt; $SubClassSetCnt; $s++) { // $SubClassSet is ordered by input class-may be NULL&nbsp;</div></li><li><div>                    // Select $SubClassSet if currGlyph is in First Input Class&nbsp;</div></li><li><div>                    if ($SubClassSetOffset[$s] &gt; 0 && isset($InputClasses[$s][$currGID])) {&nbsp;</div></li><li><div>                        $this-&gt;seek($SubClassSetOffset[$s]);&nbsp;</div></li><li><div>                        $SubClassRuleCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $SubClassRule = array();&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $SubClassRuleCnt; $b++) {&nbsp;</div></li><li><div>                            $SubClassRule[$b] = $SubClassSetOffset[$s] + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $SubClassRuleCnt; $b++) {  // EACH RULE&nbsp;</div></li><li><div>                            $this-&gt;seek($SubClassRule[$b]);&nbsp;</div></li><li><div>                            $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $SubstCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $Input = array();&nbsp;</div></li><li><div>                            for ($r = 1; $r &lt; $InputGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Input[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $inputClass = $s;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $inputGlyphs = array();&nbsp;</div></li><li><div>                            $inputGlyphs[0] = $InputClasses[$inputClass];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($InputGlyphCount &gt; 1) {&nbsp;</div></li><li><div>                                //  NB starts at 1&nbsp;</div></li><li><div>                                for ($gcl = 1; $gcl &lt; $InputGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Input[$gcl];&nbsp;</div></li><li><div>                                    if (isset($InputClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = $InputClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $class0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($InputClasses); $gc++) {&nbsp;</div></li><li><div>                                if (is_array($InputClasses[$gc]))&nbsp;</div></li><li><div>                                    $class0excl = $class0excl + $InputClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $backtrackGlyphs = array();&nbsp;</div></li><li><div>                            $lookaheadGlyphs = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $matched = $this-&gt;checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl);&nbsp;</div></li><li><div>                            if ($matched) {&nbsp;</div></li><li><div>                                if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                                    $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $SubstCount; $p++) { // EACH LOOKUP&nbsp;</div></li><li><div>                                    $SequenceIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                    $LookupListIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $SubstCount; $p++) {&nbsp;</div></li><li><div>                                    // Apply  $LookupListIndex  at   $SequenceIndex&nbsp;</div></li><li><div>                                    if ($SequenceIndex[$p] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                                        continue;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    $lu = $LookupListIndex[$p];&nbsp;</div></li><li><div>                                    $luType = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                                    $luFlag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                                    $luMarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    $luptr = $matched[$SequenceIndex[$p]];&nbsp;</div></li><li><div>                                    $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                                    $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                                        $shift = $this-&gt;_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GSUB_offset), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);&nbsp;</div></li><li><div>                                        if ($shift) {&nbsp;</div></li><li><div>                                            break;&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                if (!defined(&quot;OMIT_OTL_FIX_3&quot;) || OMIT_OTL_FIX_3 != 1) {&nbsp;</div></li><li><div>                                    return $shift;&nbsp;</div></li><li><div>                                } /** OTL_FIX_3 */&nbsp;</div></li><li><div>                                else&nbsp;</div></li><li><div>                                    return $InputGlyphCount; // should be + matched ignores in Input Sequence&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 3:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 3: Coverage-based Context Glyph Substitution&nbsp;</div></li><li><div>            else if ($SubstFormat == 3) {&nbsp;</div></li><li><div>                throw new MpdfException(&quot;GSUB Lookup Type &quot; . $Type . &quot; Format &quot; . $SubstFormat . &quot; not TESTED YET.&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 6: Chaining Contextual Substitution Subtable&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 6) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1: Simple Chaining Context Glyph Substitution&nbsp;</div></li><li><div>            if ($SubstFormat == 1) {&nbsp;</div></li><li><div>                $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $GlyphPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>                $ChainSubRuleSetCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                // All of the ChainSubRule tables defining contexts that begin with the same first glyph are grouped together and defined in a ChainSubRuleSet table&nbsp;</div></li><li><div>                $this-&gt;skip($GlyphPos * 2);&nbsp;</div></li><li><div>                $ChainSubRuleSet = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $this-&gt;seek($ChainSubRuleSet);&nbsp;</div></li><li><div>                $ChainSubRuleCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                for ($s = 0; $s &lt; $ChainSubRuleCount; $s++) {&nbsp;</div></li><li><div>                    $ChainSubRule[$s] = $ChainSubRuleSet + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                for ($s = 0; $s &lt; $ChainSubRuleCount; $s++) {&nbsp;</div></li><li><div>                    $this-&gt;seek($ChainSubRule[$s]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $BacktrackGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $Backtrack = array();&nbsp;</div></li><li><div>                    for ($b = 0; $b &lt; $BacktrackGlyphCount; $b++) {&nbsp;</div></li><li><div>                        $gid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $Backtrack[] = $this-&gt;glyphToChar($gid);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $Input = array();&nbsp;</div></li><li><div>                    $Input[0] = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                    $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    for ($b = 1; $b &lt; $InputGlyphCount; $b++) {&nbsp;</div></li><li><div>                        $gid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $Input[$b] = $this-&gt;glyphToChar($gid);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $LookaheadGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $Lookahead = array();&nbsp;</div></li><li><div>                    for ($b = 0; $b &lt; $LookaheadGlyphCount; $b++) {&nbsp;</div></li><li><div>                        $gid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $Lookahead[] = $this-&gt;glyphToChar($gid);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $matched = $this-&gt;checkContextMatch($Input, $Backtrack, $Lookahead, $ignore, $ptr);&nbsp;</div></li><li><div>                    if ($matched) {&nbsp;</div></li><li><div>                        if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                            $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $SubstCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        for ($p = 0; $p &lt; $SubstCount; $p++) {&nbsp;</div></li><li><div>                            // SubstLookupRecord&nbsp;</div></li><li><div>                            $SubstLookupRecord[$p]['SequenceIndex'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $SubstLookupRecord[$p]['LookupListIndex'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        for ($p = 0; $p &lt; $SubstCount; $p++) {&nbsp;</div></li><li><div>                            // Apply  $SubstLookupRecord[$p]['LookupListIndex']  at   $SubstLookupRecord[$p]['SequenceIndex']&nbsp;</div></li><li><div>                            if ($SubstLookupRecord[$p]['SequenceIndex'] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                                continue;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $lu = $SubstLookupRecord[$p]['LookupListIndex'];&nbsp;</div></li><li><div>                            $luType = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                            $luFlag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                            $luMarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $luptr = $matched[$SubstLookupRecord[$p]['SequenceIndex']];&nbsp;</div></li><li><div>                            $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                            $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                                $shift = $this-&gt;_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GSUB_offset), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);&nbsp;</div></li><li><div>                                if ($shift) {&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        if (!defined(&quot;OMIT_OTL_FIX_3&quot;) || OMIT_OTL_FIX_3 != 1) {&nbsp;</div></li><li><div>                            return $shift;&nbsp;</div></li><li><div>                        } /** OTL_FIX_3 */&nbsp;</div></li><li><div>                        else&nbsp;</div></li><li><div>                            return $InputGlyphCount; // should be + matched ignores in Input Sequence&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2: Class-based Chaining Context Glyph Substitution  p257&nbsp;</div></li><li><div>            else if ($SubstFormat == 2) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // NB Format 2 specifies fixed class assignments (identical for each position in the backtrack, input, or lookahead sequence) and exclusive classes (a glyph cannot be in more than one class at a time)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $CoverageTableOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $BacktrackClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $InputClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $LookaheadClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ChainSubClassSetCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ChainSubClassSetOffset = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $ChainSubClassSetCnt; $b++) {&nbsp;</div></li><li><div>                    $offset = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    if ($offset == 0x0000) {&nbsp;</div></li><li><div>                        $ChainSubClassSetOffset[] = $offset;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $ChainSubClassSetOffset[] = $subtable_offset + $offset;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $BacktrackClasses = $this-&gt;_getClasses($BacktrackClassDefOffset);&nbsp;</div></li><li><div>                $InputClasses = $this-&gt;_getClasses($InputClassDefOffset);&nbsp;</div></li><li><div>                $LookaheadClasses = $this-&gt;_getClasses($LookaheadClassDefOffset);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                for ($s = 0; $s &lt; $ChainSubClassSetCnt; $s++) { // $ChainSubClassSet is ordered by input class-may be NULL&nbsp;</div></li><li><div>                    // Select $ChainSubClassSet if currGlyph is in First Input Class&nbsp;</div></li><li><div>                    if ($ChainSubClassSetOffset[$s] &gt; 0 && isset($InputClasses[$s][$currGID])) {&nbsp;</div></li><li><div>                        $this-&gt;seek($ChainSubClassSetOffset[$s]);&nbsp;</div></li><li><div>                        $ChainSubClassRuleCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $ChainSubClassRule = array();&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $ChainSubClassRuleCnt; $b++) {&nbsp;</div></li><li><div>                            $ChainSubClassRule[$b] = $ChainSubClassSetOffset[$s] + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $ChainSubClassRuleCnt; $b++) {  // EACH RULE&nbsp;</div></li><li><div>                            $this-&gt;seek($ChainSubClassRule[$b]);&nbsp;</div></li><li><div>                            $BacktrackGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            for ($r = 0; $r &lt; $BacktrackGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Backtrack[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            for ($r = 1; $r &lt; $InputGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Input[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $LookaheadGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            for ($r = 0; $r &lt; $LookaheadGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Lookahead[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // These contain classes of glyphs as arrays&nbsp;</div></li><li><div>                            // $InputClasses[(class)] e.g. 0x02E6, 0x02E7, 0x02E8&nbsp;</div></li><li><div>                            // $LookaheadClasses[(class)]&nbsp;</div></li><li><div>                            // $BacktrackClasses[(class)]&nbsp;</div></li><li><div>                            // These contain arrays of classIndexes&nbsp;</div></li><li><div>                            // [Backtrack] [Lookahead] and [Input] (Input is from the second position only)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $inputClass = $s; //???&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $inputGlyphs = array();&nbsp;</div></li><li><div>                            $inputGlyphs[0] = $InputClasses[$inputClass];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($InputGlyphCount &gt; 1) {&nbsp;</div></li><li><div>                                //  NB starts at 1&nbsp;</div></li><li><div>                                for ($gcl = 1; $gcl &lt; $InputGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Input[$gcl];&nbsp;</div></li><li><div>                                    if (isset($InputClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = $InputClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $class0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($InputClasses); $gc++) {&nbsp;</div></li><li><div>                                if (isset($InputClasses[$gc]))&nbsp;</div></li><li><div>                                    $class0excl = $class0excl + $InputClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($BacktrackGlyphCount) {&nbsp;</div></li><li><div>                                for ($gcl = 0; $gcl &lt; $BacktrackGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Backtrack[$gcl];&nbsp;</div></li><li><div>                                    if (isset($BacktrackClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $backtrackGlyphs[$gcl] = $BacktrackClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $backtrackGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $backtrackGlyphs = array();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $bclass0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($BacktrackClasses); $gc++) {&nbsp;</div></li><li><div>                                if (isset($BacktrackClasses[$gc]))&nbsp;</div></li><li><div>                                    $bclass0excl = $bclass0excl + $BacktrackClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($LookaheadGlyphCount) {&nbsp;</div></li><li><div>                                for ($gcl = 0; $gcl &lt; $LookaheadGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Lookahead[$gcl];&nbsp;</div></li><li><div>                                    if (isset($LookaheadClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $lookaheadGlyphs[$gcl] = $LookaheadClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $lookaheadGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $lookaheadGlyphs = array();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $lclass0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($LookaheadClasses); $gc++) {&nbsp;</div></li><li><div>                                if (isset($LookaheadClasses[$gc]))&nbsp;</div></li><li><div>                                    $lclass0excl = $lclass0excl + $LookaheadClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $matched = $this-&gt;checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl, $bclass0excl, $lclass0excl);&nbsp;</div></li><li><div>                            if ($matched) {&nbsp;</div></li><li><div>                                if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                                    $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $SubstCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $SubstCount; $p++) { // EACH LOOKUP&nbsp;</div></li><li><div>                                    $SequenceIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                    $LookupListIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $SubstCount; $p++) {&nbsp;</div></li><li><div>                                    // Apply  $LookupListIndex  at   $SequenceIndex&nbsp;</div></li><li><div>                                    if ($SequenceIndex[$p] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                                        continue;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    $lu = $LookupListIndex[$p];&nbsp;</div></li><li><div>                                    $luType = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                                    $luFlag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                                    $luMarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    $luptr = $matched[$SequenceIndex[$p]];&nbsp;</div></li><li><div>                                    $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                                    $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                                        $shift = $this-&gt;_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GSUB_offset), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);&nbsp;</div></li><li><div>                                        if ($shift) {&nbsp;</div></li><li><div>                                            break;&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                if (!defined(&quot;OMIT_OTL_FIX_3&quot;) || OMIT_OTL_FIX_3 != 1) {&nbsp;</div></li><li><div>                                    return $shift;&nbsp;</div></li><li><div>                                } /** OTL_FIX_3 */&nbsp;</div></li><li><div>                                else&nbsp;</div></li><li><div>                                    return $InputGlyphCount; // should be + matched ignores in Input Sequence&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 3:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 3: Coverage-based Chaining Context Glyph Substitution  p259&nbsp;</div></li><li><div>            else if ($SubstFormat == 3) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $BacktrackGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $BacktrackGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $CoverageBacktrackOffset[] = $subtable_offset + $this-&gt;read_ushort(); // in glyph sequence order&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $InputGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $CoverageInputOffset[] = $subtable_offset + $this-&gt;read_ushort(); // in glyph sequence order&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $LookaheadGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $LookaheadGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $CoverageLookaheadOffset[] = $subtable_offset + $this-&gt;read_ushort(); // in glyph sequence order&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $SubstCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $save_pos = $this-&gt;_pos; // Save the point just after PosCount&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $CoverageBacktrackGlyphs = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $BacktrackGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $this-&gt;seek($CoverageBacktrackOffset[$b]);&nbsp;</div></li><li><div>                    $glyphs = $this-&gt;_getCoverage();&nbsp;</div></li><li><div>                    $CoverageBacktrackGlyphs[$b] = implode(&quot;|&quot;, $glyphs);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $CoverageInputGlyphs = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $InputGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $this-&gt;seek($CoverageInputOffset[$b]);&nbsp;</div></li><li><div>                    $glyphs = $this-&gt;_getCoverage();&nbsp;</div></li><li><div>                    $CoverageInputGlyphs[$b] = implode(&quot;|&quot;, $glyphs);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $CoverageLookaheadGlyphs = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $LookaheadGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $this-&gt;seek($CoverageLookaheadOffset[$b]);&nbsp;</div></li><li><div>                    $glyphs = $this-&gt;_getCoverage();&nbsp;</div></li><li><div>                    $CoverageLookaheadGlyphs[$b] = implode(&quot;|&quot;, $glyphs);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $matched = $this-&gt;checkContextMatchMultiple($CoverageInputGlyphs, $CoverageBacktrackGlyphs, $CoverageLookaheadGlyphs, $ignore, $ptr);&nbsp;</div></li><li><div>                if ($matched) {&nbsp;</div></li><li><div>                    if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                        $this-&gt;_dumpproc('GSUB', $lookupID, $subtable, $Type, $SubstFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;seek($save_pos); // Return to just after PosCount&nbsp;</div></li><li><div>                    for ($p = 0; $p &lt; $SubstCount; $p++) {&nbsp;</div></li><li><div>                        // SubstLookupRecord&nbsp;</div></li><li><div>                        $SubstLookupRecord[$p]['SequenceIndex'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $SubstLookupRecord[$p]['LookupListIndex'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    for ($p = 0; $p &lt; $SubstCount; $p++) {&nbsp;</div></li><li><div>                        // Apply  $SubstLookupRecord[$p]['LookupListIndex']  at   $SubstLookupRecord[$p]['SequenceIndex']&nbsp;</div></li><li><div>                        if ($SubstLookupRecord[$p]['SequenceIndex'] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                            continue;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $lu = $SubstLookupRecord[$p]['LookupListIndex'];&nbsp;</div></li><li><div>                        $luType = $this-&gt;GSUBLookups[$lu]['Type'];&nbsp;</div></li><li><div>                        $luFlag = $this-&gt;GSUBLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                        $luMarkFilteringSet = $this-&gt;GSUBLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $luptr = $matched[$SubstLookupRecord[$p]['SequenceIndex']];&nbsp;</div></li><li><div>                        $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                        $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        foreach ($this-&gt;GSUBLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                            $shift = $this-&gt;_applyGSUBsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GSUB_offset), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;GSLuCoverage[$lu][$luc], 1, $currentTag, $is_old_spec, $tagInt);&nbsp;</div></li><li><div>                            if ($shift) {&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if (!defined(&quot;OMIT_OTL_FIX_3&quot;) || OMIT_OTL_FIX_3 != 1) {&nbsp;</div></li><li><div>                        return (isset($shift) ? $shift : 0);&nbsp;</div></li><li><div>                    } /** OTL_FIX_3 */&nbsp;</div></li><li><div>                    else&nbsp;</div></li><li><div>                        return $InputGlyphCount; // should be + matched ignores in Input Sequence&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            throw new MpdfException(&quot;GSUB Lookup Type &quot; . $Type . &quot; not supported.&quot;);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _updateLigatureMarks($pos, $n)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if ($n &gt; 0) {&nbsp;</div></li><li><div>            // Update position of Ligatures and associated Marks&nbsp;</div></li><li><div>            // Foreach lig/assocMarks&nbsp;</div></li><li><div>            // Any position lpos or mpos &gt; $pos + count($substitute)&nbsp;</div></li><li><div>            //  $this-&gt;assocMarks = array();    // assocMarks[$pos mpos] =&gt; array(compID, ligPos)&nbsp;</div></li><li><div>            //  $this-&gt;assocLigs = array(); // Ligatures[$pos lpos] =&gt; nc&nbsp;</div></li><li><div>            for ($p = count($this-&gt;OTLdata) - 1; $p &gt;= ($pos + $n); $p--) {&nbsp;</div></li><li><div>                if (isset($this-&gt;assocLigs[$p])) {&nbsp;</div></li><li><div>                    $tmp = $this-&gt;assocLigs[$p];&nbsp;</div></li><li><div>                    unset($this-&gt;assocLigs[$p]);&nbsp;</div></li><li><div>                    $this-&gt;assocLigs[($p + $n)] = $tmp;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            for ($p = count($this-&gt;OTLdata) - 1; $p &gt;= 0; $p--) {&nbsp;</div></li><li><div>                if (isset($this-&gt;assocMarks[$p])) {&nbsp;</div></li><li><div>                    if ($this-&gt;assocMarks[$p]['ligPos'] &gt;= ($pos + $n)) {&nbsp;</div></li><li><div>                        $this-&gt;assocMarks[$p]['ligPos'] += $n;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($p &gt;= ($pos + $n)) {&nbsp;</div></li><li><div>                        $tmp = $this-&gt;assocMarks[$p];&nbsp;</div></li><li><div>                        unset($this-&gt;assocMarks[$p]);&nbsp;</div></li><li><div>                        $this-&gt;assocMarks[($p + $n)] = $tmp;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else if ($n &lt; 1) { // glyphs removed&nbsp;</div></li><li><div>            $nrem = -$n;&nbsp;</div></li><li><div>            // Update position of pre-existing Ligatures and associated Marks&nbsp;</div></li><li><div>            for ($p = ($pos + 1); $p &lt; count($this-&gt;OTLdata); $p++) {&nbsp;</div></li><li><div>                if (isset($this-&gt;assocLigs[$p])) {&nbsp;</div></li><li><div>                    $tmp = $this-&gt;assocLigs[$p];&nbsp;</div></li><li><div>                    unset($this-&gt;assocLigs[$p]);&nbsp;</div></li><li><div>                    $this-&gt;assocLigs[($p - $nrem)] = $tmp;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            for ($p = 0; $p &lt; count($this-&gt;OTLdata); $p++) {&nbsp;</div></li><li><div>                if (isset($this-&gt;assocMarks[$p])) {&nbsp;</div></li><li><div>                    if ($this-&gt;assocMarks[$p]['ligPos'] &gt;= ($pos)) {&nbsp;</div></li><li><div>                        $this-&gt;assocMarks[$p]['ligPos'] -= $nrem;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($p &gt; $pos) {&nbsp;</div></li><li><div>                        $tmp = $this-&gt;assocMarks[$p];&nbsp;</div></li><li><div>                        unset($this-&gt;assocMarks[$p]);&nbsp;</div></li><li><div>                        $this-&gt;assocMarks[($p - $nrem)] = $tmp;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function GSUBsubstitute($pos, $substitute, $Type, $GlyphPos = NULL)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // LookupType 1: Simple Substitution Subtable : 1 to 1&nbsp;</div></li><li><div>        // LookupType 3: Alternate Forms : 1 to 1(n)&nbsp;</div></li><li><div>        if ($Type == 1 || $Type == 3) {&nbsp;</div></li><li><div>            $this-&gt;OTLdata[$pos]['uni'] = $substitute;&nbsp;</div></li><li><div>            $this-&gt;OTLdata[$pos]['hex'] = $this-&gt;unicode_hex($substitute);&nbsp;</div></li><li><div>            return 1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // LookupType 2: Multiple Substitution Subtable : 1 to n&nbsp;</div></li><li><div>        else if ($Type == 2) {&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; count($substitute); $i++) {&nbsp;</div></li><li><div>                $uni = $substitute[$i];&nbsp;</div></li><li><div>                $newOTLdata[$i] = array();&nbsp;</div></li><li><div>                $newOTLdata[$i]['uni'] = $uni;&nbsp;</div></li><li><div>                $newOTLdata[$i]['hex'] = $this-&gt;unicode_hex($uni);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Get types of new inserted chars - or replicate type of char being replaced&nbsp;</div></li><li><div>                //  $bt = UCDN::get_bidi_class($uni);&nbsp;</div></li><li><div>                //  if (!$bt) {&nbsp;</div></li><li><div>                $bt = $this-&gt;OTLdata[$pos]['bidi_type'];&nbsp;</div></li><li><div>                //  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (strpos($this-&gt;GlyphClassMarks, $newOTLdata[$i]['hex']) !== false) {&nbsp;</div></li><li><div>                    $gp = 'M';&nbsp;</div></li><li><div>                } else if ($uni == 32) {&nbsp;</div></li><li><div>                    $gp = 'S';&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $gp = 'C';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Need to update matra_type ??? of new glyphs inserted ???????????????????????????????????????&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $newOTLdata[$i]['bidi_type'] = $bt;&nbsp;</div></li><li><div>                $newOTLdata[$i]['group'] = $gp;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Need to update details of new glyphs inserted&nbsp;</div></li><li><div>                $newOTLdata[$i]['general_category'] = $this-&gt;OTLdata[$pos]['general_category'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ($this-&gt;shaper == 'I' || $this-&gt;shaper == 'K' || $this-&gt;shaper == 'S') {&nbsp;</div></li><li><div>                    $newOTLdata[$i]['indic_category'] = $this-&gt;OTLdata[$pos]['indic_category'];&nbsp;</div></li><li><div>                    $newOTLdata[$i]['indic_position'] = $this-&gt;OTLdata[$pos]['indic_position'];&nbsp;</div></li><li><div>                } else if ($this-&gt;shaper == 'M') {&nbsp;</div></li><li><div>                    $newOTLdata[$i]['myanmar_category'] = $this-&gt;OTLdata[$pos]['myanmar_category'];&nbsp;</div></li><li><div>                    $newOTLdata[$i]['myanmar_position'] = $this-&gt;OTLdata[$pos]['myanmar_position'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$pos]['mask'])) {&nbsp;</div></li><li><div>                    $newOTLdata[$i]['mask'] = $this-&gt;OTLdata[$pos]['mask'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$pos]['syllable'])) {&nbsp;</div></li><li><div>                    $newOTLdata[$i]['syllable'] = $this-&gt;OTLdata[$pos]['syllable'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($this-&gt;shaper == 'K' || $this-&gt;shaper == 'T' || $this-&gt;shaper == 'L') {&nbsp;</div></li><li><div>                if ($this-&gt;OTLdata[$pos]['wordend']) {&nbsp;</div></li><li><div>                    $newOTLdata[count($substitute) - 1]['wordend'] = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            array_splice($this-&gt;OTLdata, $pos, 1, $newOTLdata); // Replace 1 with n&nbsp;</div></li><li><div>            // Update position of Ligatures and associated Marks&nbsp;</div></li><li><div>            // count($substitute)-1  is the number of glyphs added&nbsp;</div></li><li><div>            $nadd = count($substitute) - 1;&nbsp;</div></li><li><div>            $this-&gt;_updateLigatureMarks($pos, $nadd);&nbsp;</div></li><li><div>            return count($substitute);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // LookupType 4: Ligature Substitution Subtable : n to 1&nbsp;</div></li><li><div>        else if ($Type == 4) {&nbsp;</div></li><li><div>            // Create Ligatures and associated Marks&nbsp;</div></li><li><div>            $firstGlyph = $this-&gt;OTLdata[$pos]['hex'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // If all components of the ligature are marks (and in the same syllable), we call this a mark ligature.&nbsp;</div></li><li><div>            $contains_marks = false;&nbsp;</div></li><li><div>            $contains_nonmarks = false;&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$pos]['syllable'])) {&nbsp;</div></li><li><div>                $current_syllable = $this-&gt;OTLdata[$pos]['syllable'];&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $current_syllable = 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; count($GlyphPos); $i++) {&nbsp;</div></li><li><div>                // If subsequent components are not Marks as well - don't ligate&nbsp;</div></li><li><div>                $unistr = $this-&gt;OTLdata[$GlyphPos[$i]]['hex'];&nbsp;</div></li><li><div>                if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$GlyphPos[$i]]['syllable']) && $this-&gt;OTLdata[$GlyphPos[$i]]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                    return 0;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (strpos($this-&gt;GlyphClassMarks, $unistr) !== false) {&nbsp;</div></li><li><div>                    $contains_marks = true;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $contains_nonmarks = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($contains_marks && !$contains_nonmarks) {&nbsp;</div></li><li><div>                // Mark Ligature (all components are Marks)&nbsp;</div></li><li><div>                $firstMarkAssoc = '';&nbsp;</div></li><li><div>                if (isset($this-&gt;assocMarks[$pos])) {&nbsp;</div></li><li><div>                    $firstMarkAssoc = $this-&gt;assocMarks[$pos];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // If all components of the ligature are marks, we call this a mark ligature.&nbsp;</div></li><li><div>                for ($i = 1; $i &lt; count($GlyphPos); $i++) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // If subsequent components are not Marks as well - don't ligate&nbsp;</div></li><li><div>                    //      $unistr = $this-&gt;OTLdata[$GlyphPos[$i]]['hex'];&nbsp;</div></li><li><div>                    //      if (strpos($this-&gt;GlyphClassMarks, $unistr )===false) { return; }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $nextMarkAssoc = '';&nbsp;</div></li><li><div>                    if (isset($this-&gt;assocMarks[$GlyphPos[$i]])) {&nbsp;</div></li><li><div>                        $nextMarkAssoc = $this-&gt;assocMarks[$GlyphPos[$i]];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    // If first component was attached to a previous ligature component, &nbsp;</div></li><li><div>                    // all subsequent components should be attached to the same ligature&nbsp;</div></li><li><div>                    // component, otherwise we shouldn't ligate them.&nbsp;</div></li><li><div>                    // If first component was NOT attached to a previous ligature component, &nbsp;</div></li><li><div>                    // all subsequent components should also NOT be attached to any ligature component, &nbsp;</div></li><li><div>                    if ($firstMarkAssoc != $nextMarkAssoc) {&nbsp;</div></li><li><div>                        // unless they are attached to the first component itself!&nbsp;</div></li><li><div>                        //          if (!is_array($nextMarkAssoc) || $nextMarkAssoc['ligPos']!= $pos) { return; }&nbsp;</div></li><li><div>                        // Update/Edit - In test with myanmartext font&nbsp;</div></li><li><div>                        // &#x1004;&#x103a;&#x1039;&#x1000;&#x1039;&#x1000;&#x103b;&#x103c;&#x103d;&#x1031;&#x102d;&nbsp;</div></li><li><div>                        // =&gt; Lookup 17  E003 E066B E05A 102D&nbsp;</div></li><li><div>                        // E003 and 102D should form a mark ligature, but 102D is already associated with (non-mark) ligature E05A&nbsp;</div></li><li><div>                        // So instead of disallowing the mark ligature to form, just dissociate...&nbsp;</div></li><li><div>                        if (!is_array($nextMarkAssoc) || $nextMarkAssoc['ligPos'] != $pos) {&nbsp;</div></li><li><div>                            unset($this-&gt;assocMarks[$GlyphPos[$i]]);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /**&nbsp;</div></li><li><div>                 * - If it *is* a mark ligature, we don't allocate a new ligature id, and leave&nbsp;</div></li><li><div>                 *   the ligature to keep its old ligature id.  This will allow it to attach to&nbsp;</div></li><li><div>                 *   a base ligature in GPOS.  Eg. if the sequence is: LAM, LAM, SHADDA, FATHA, HEH, &nbsp;</div></li><li><div>                 *   and LAM, LAM, HEH form a ligature, they will leave SHADDA and FATHA wit a&nbsp;</div></li><li><div>                 *   ligature id and component value of 2.  Then if SHADDA, FATHA form a ligature&nbsp;</div></li><li><div>                 *   later, we don't want them to lose their ligature id/component, otherwise&nbsp;</div></li><li><div>                 *   GPOS will fail to correctly position the mark ligature on top of the&nbsp;</div></li><li><div>                 *   LAM, LAM, HEH ligature.&nbsp;</div></li><li><div>                 */&nbsp;</div></li><li><div>                // So if is_array($firstMarkAssoc) - the new (Mark) ligature should keep this association&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $lastPos = $GlyphPos[(count($GlyphPos) - 1)];&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                /**&nbsp;</div></li><li><div>                 * - Ligatures cannot be formed across glyphs attached to different components&nbsp;</div></li><li><div>                 *   of previous ligatures.  Eg. the sequence is LAM, SHADDA, LAM, FATHA, HEH, and&nbsp;</div></li><li><div>                 *   LAM, LAM, HEH form a ligature, leaving SHADDA, FATHA next to eachother.&nbsp;</div></li><li><div>                 *   However, it would be wrong to ligate that SHADDA, FATHA sequence.&nbsp;</div></li><li><div>                 *   There is an exception to this: If a ligature tries ligating with marks that&nbsp;</div></li><li><div>                 *   belong to it itself, go ahead, assuming that the font designer knows what&nbsp;</div></li><li><div>                 *   they are doing (otherwise it can break Indic stuff when a matra wants to&nbsp;</div></li><li><div>                 *   ligate with a conjunct...)&nbsp;</div></li><li><div>                 */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /**&nbsp;</div></li><li><div>                 * - If a ligature is formed of components that some of which are also ligatures&nbsp;</div></li><li><div>                 *   themselves, and those ligature components had marks attached to *their*&nbsp;</div></li><li><div>                 *   components, we have to attach the marks to the new ligature component&nbsp;</div></li><li><div>                 *   positions!  Now *that*'s tricky!  And these marks may be following the&nbsp;</div></li><li><div>                 *   last component of the whole sequence, so we should loop forward looking&nbsp;</div></li><li><div>                 *   for them and update them.&nbsp;</div></li><li><div>                 *&nbsp;</div></li><li><div>                 *   Eg. the sequence is LAM, LAM, SHADDA, FATHA, HEH, and the font first forms a&nbsp;</div></li><li><div>                 *   'calt' ligature of LAM, HEH, leaving the SHADDA and FATHA with a ligature&nbsp;</div></li><li><div>                 *   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature&nbsp;</div></li><li><div>                 *   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to&nbsp;</div></li><li><div>                 *   the new ligature with a component value of 2.&nbsp;</div></li><li><div>                 *&nbsp;</div></li><li><div>                 *   This in fact happened to a font...  See:&nbsp;</div></li><li><div>                 *   https://bugzilla.gnome.org/show_bug.cgi?id=437633&nbsp;</div></li><li><div>                 */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $currComp = 0;&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; count($GlyphPos); $i++) {&nbsp;</div></li><li><div>                    if ($i &gt; 0 && isset($this-&gt;assocLigs[$GlyphPos[$i]])) { // One of the other components is already a ligature&nbsp;</div></li><li><div>                        $nc = $this-&gt;assocLigs[$GlyphPos[$i]];&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $nc = 1;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    // While next char to right is a mark (but not the next matched glyph)&nbsp;</div></li><li><div>                    // ?? + also include a Mark Ligature here&nbsp;</div></li><li><div>                    $ic = 1;&nbsp;</div></li><li><div>                    while ((($i == count($GlyphPos) - 1) || (isset($GlyphPos[$i + 1]) && ($GlyphPos[$i] + $ic) &lt; $GlyphPos[$i + 1])) && isset($this-&gt;OTLdata[($GlyphPos[$i] + $ic)]) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[($GlyphPos[$i] + $ic)]['hex']) !== false) {&nbsp;</div></li><li><div>                        $newComp = $currComp;&nbsp;</div></li><li><div>                        if (isset($this-&gt;assocMarks[$GlyphPos[$i] + $ic])) { // One of the inbetween Marks is already associated with a Lig&nbsp;</div></li><li><div>                            // OK as long as it is associated with the current Lig&nbsp;</div></li><li><div>                            //      if ($this-&gt;assocMarks[($GlyphPos[$i]+$ic)]['ligPos'] != ($GlyphPos[$i]+$ic)) { die(&quot;Problem #1&quot;); }&nbsp;</div></li><li><div>                            $newComp += $this-&gt;assocMarks[($GlyphPos[$i] + $ic)]['compID'];&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $this-&gt;assocMarks[($GlyphPos[$i] + $ic)] = array('compID' =&gt; $newComp, 'ligPos' =&gt; $pos);&nbsp;</div></li><li><div>                        $ic++;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $currComp += $nc;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $lastPos = $GlyphPos[(count($GlyphPos) - 1)] + $ic - 1;&nbsp;</div></li><li><div>                $this-&gt;assocLigs[$pos] = $currComp; // Number of components in new Ligature&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Now remove the unwanted glyphs and associated metadata&nbsp;</div></li><li><div>            $newOTLdata[0] = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Get types of new inserted chars - or replicate type of char being replaced&nbsp;</div></li><li><div>            //  $bt = UCDN::get_bidi_class($substitute);&nbsp;</div></li><li><div>            //  if (!$bt) {&nbsp;</div></li><li><div>            $bt = $this-&gt;OTLdata[$pos]['bidi_type'];&nbsp;</div></li><li><div>            //  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (strpos($this-&gt;GlyphClassMarks, $this-&gt;unicode_hex($substitute)) !== false) {&nbsp;</div></li><li><div>                $gp = 'M';&nbsp;</div></li><li><div>            } else if ($substitute == 32) {&nbsp;</div></li><li><div>                $gp = 'S';&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $gp = 'C';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Need to update details of new glyphs inserted&nbsp;</div></li><li><div>            $newOTLdata[0]['general_category'] = $this-&gt;OTLdata[$pos]['general_category'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $newOTLdata[0]['bidi_type'] = $bt;&nbsp;</div></li><li><div>            $newOTLdata[0]['group'] = $gp;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // KASHIDA: If forming a ligature when the last component was identified as a kashida point (final form)&nbsp;</div></li><li><div>            // If previous/first component of ligature is a medial form, then keep this as a kashida point&nbsp;</div></li><li><div>            // TEST (Arabic Typesetting) &#x64a;&#x64e;&#x646;&#x62a;&#x64f;&#x645;&nbsp;</div></li><li><div>            $ka = 0;&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$GlyphPos[(count($GlyphPos) - 1)]]['GPOSinfo']['kashida'])) {&nbsp;</div></li><li><div>                $ka = $this-&gt;OTLdata[$GlyphPos[(count($GlyphPos) - 1)]]['GPOSinfo']['kashida'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($ka == 1 && isset($this-&gt;OTLdata[$pos]['form']) && $this-&gt;OTLdata[$pos]['form'] == 3) {&nbsp;</div></li><li><div>                $newOTLdata[0]['GPOSinfo']['kashida'] = $ka;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $newOTLdata[0]['uni'] = $substitute;&nbsp;</div></li><li><div>            $newOTLdata[0]['hex'] = $this-&gt;unicode_hex($substitute);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($this-&gt;shaper == 'I' || $this-&gt;shaper == 'K' || $this-&gt;shaper == 'S') {&nbsp;</div></li><li><div>                $newOTLdata[0]['indic_category'] = $this-&gt;OTLdata[$pos]['indic_category'];&nbsp;</div></li><li><div>                $newOTLdata[0]['indic_position'] = $this-&gt;OTLdata[$pos]['indic_position'];&nbsp;</div></li><li><div>            } else if ($this-&gt;shaper == 'M') {&nbsp;</div></li><li><div>                $newOTLdata[0]['myanmar_category'] = $this-&gt;OTLdata[$pos]['myanmar_category'];&nbsp;</div></li><li><div>                $newOTLdata[0]['myanmar_position'] = $this-&gt;OTLdata[$pos]['myanmar_position'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$pos]['mask'])) {&nbsp;</div></li><li><div>                $newOTLdata[0]['mask'] = $this-&gt;OTLdata[$pos]['mask'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$pos]['syllable'])) {&nbsp;</div></li><li><div>                $newOTLdata[0]['syllable'] = $this-&gt;OTLdata[$pos]['syllable'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $newOTLdata[0]['is_ligature'] = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            array_splice($this-&gt;OTLdata, $pos, 1, $newOTLdata);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // GlyphPos contains array of arr_pos to set null - not necessarily contiguous&nbsp;</div></li><li><div>            // +- Remove any assocMarks or assocLigs from the main components (the ones that are deleted)&nbsp;</div></li><li><div>            for ($i = count($GlyphPos) - 1; $i &gt; 0; $i--) {&nbsp;</div></li><li><div>                $gpos = $GlyphPos[$i];&nbsp;</div></li><li><div>                array_splice($this-&gt;OTLdata, $gpos, 1);&nbsp;</div></li><li><div>                unset($this-&gt;assocLigs[$gpos]);&nbsp;</div></li><li><div>                unset($this-&gt;assocMarks[$gpos]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //  $this-&gt;assocLigs = array(); // Ligatures[$posarr lpos] =&gt; nc&nbsp;</div></li><li><div>            //  $this-&gt;assocMarks = array();    // assocMarks[$posarr mpos] =&gt; array(compID, ligPos)&nbsp;</div></li><li><div>            // Update position of pre-existing Ligatures and associated Marks&nbsp;</div></li><li><div>            // Start after first GlyphPos&nbsp;</div></li><li><div>            // count($GlyphPos)-1  is the number of glyphs removed from string&nbsp;</div></li><li><div>            for ($p = ($GlyphPos[0] + 1); $p &lt; (count($this-&gt;OTLdata) + count($GlyphPos) - 1); $p++) {&nbsp;</div></li><li><div>                $nrem = 0; // Number of Glyphs removed at this point in the string&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; count($GlyphPos); $i++) {&nbsp;</div></li><li><div>                    if ($i &gt; 0 && $p &gt; $GlyphPos[$i]) {&nbsp;</div></li><li><div>                        $nrem++;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($this-&gt;assocLigs[$p])) {&nbsp;</div></li><li><div>                    $tmp = $this-&gt;assocLigs[$p];&nbsp;</div></li><li><div>                    unset($this-&gt;assocLigs[$p]);&nbsp;</div></li><li><div>                    $this-&gt;assocLigs[($p - $nrem)] = $tmp;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($this-&gt;assocMarks[$p])) {&nbsp;</div></li><li><div>                    $tmp = $this-&gt;assocMarks[$p];&nbsp;</div></li><li><div>                    unset($this-&gt;assocMarks[$p]);&nbsp;</div></li><li><div>                    if ($tmp['ligPos'] &gt; $GlyphPos[0]) {&nbsp;</div></li><li><div>                        $tmp['ligPos'] -= $nrem;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $this-&gt;assocMarks[($p - $nrem)] = $tmp;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return 1;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>//////////       ARABIC        /////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function arabic_initialise()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // cf. http://unicode.org/Public/UNIDATA/ArabicShaping.txt&nbsp;</div></li><li><div>        // http://unicode.org/Public/UNIDATA/extracted/DerivedJoiningType.txt&nbsp;</div></li><li><div>        // JOIN TO FOLLOWING LETTER IN LOGICAL ORDER (i.e. AS INITIAL/MEDIAL FORM) = Unicode Left-Joining (+ Dual-Joining + Join_Causing 00640)&nbsp;</div></li><li><div>        $this-&gt;arabLeftJoining = array(&nbsp;</div></li><li><div>            0x0620 =&gt; 1, 0x0626 =&gt; 1, 0x0628 =&gt; 1, 0x062A =&gt; 1, 0x062B =&gt; 1, 0x062C =&gt; 1, 0x062D =&gt; 1, 0x062E =&gt; 1, &nbsp;</div></li><li><div>            0x0633 =&gt; 1, 0x0634 =&gt; 1, 0x0635 =&gt; 1, 0x0636 =&gt; 1, 0x0637 =&gt; 1, 0x0638 =&gt; 1, 0x0639 =&gt; 1, 0x063A =&gt; 1, &nbsp;</div></li><li><div>            0x063B =&gt; 1, 0x063C =&gt; 1, 0x063D =&gt; 1, 0x063E =&gt; 1, 0x063F =&gt; 1, 0x0640 =&gt; 1, 0x0641 =&gt; 1, 0x0642 =&gt; 1, &nbsp;</div></li><li><div>            0x0643 =&gt; 1, 0x0644 =&gt; 1, 0x0645 =&gt; 1, 0x0646 =&gt; 1, 0x0647 =&gt; 1, 0x0649 =&gt; 1, 0x064A =&gt; 1, 0x066E =&gt; 1, &nbsp;</div></li><li><div>            0x066F =&gt; 1, 0x0678 =&gt; 1, 0x0679 =&gt; 1, 0x067A =&gt; 1, 0x067B =&gt; 1, 0x067C =&gt; 1, 0x067D =&gt; 1, 0x067E =&gt; 1, &nbsp;</div></li><li><div>            0x067F =&gt; 1, 0x0680 =&gt; 1, 0x0681 =&gt; 1, 0x0682 =&gt; 1, 0x0683 =&gt; 1, 0x0684 =&gt; 1, 0x0685 =&gt; 1, 0x0686 =&gt; 1, &nbsp;</div></li><li><div>            0x0687 =&gt; 1, 0x069A =&gt; 1, 0x069B =&gt; 1, 0x069C =&gt; 1, 0x069D =&gt; 1, 0x069E =&gt; 1, 0x069F =&gt; 1, 0x06A0 =&gt; 1, &nbsp;</div></li><li><div>            0x06A1 =&gt; 1, 0x06A2 =&gt; 1, 0x06A3 =&gt; 1, 0x06A4 =&gt; 1, 0x06A5 =&gt; 1, 0x06A6 =&gt; 1, 0x06A7 =&gt; 1, 0x06A8 =&gt; 1, &nbsp;</div></li><li><div>            0x06A9 =&gt; 1, 0x06AA =&gt; 1, 0x06AB =&gt; 1, 0x06AC =&gt; 1, 0x06AD =&gt; 1, 0x06AE =&gt; 1, 0x06AF =&gt; 1, 0x06B0 =&gt; 1, &nbsp;</div></li><li><div>            0x06B1 =&gt; 1, 0x06B2 =&gt; 1, 0x06B3 =&gt; 1, 0x06B4 =&gt; 1, 0x06B5 =&gt; 1, 0x06B6 =&gt; 1, 0x06B7 =&gt; 1, 0x06B8 =&gt; 1, &nbsp;</div></li><li><div>            0x06B9 =&gt; 1, 0x06BA =&gt; 1, 0x06BB =&gt; 1, 0x06BC =&gt; 1, 0x06BD =&gt; 1, 0x06BE =&gt; 1, 0x06BF =&gt; 1, 0x06C1 =&gt; 1, &nbsp;</div></li><li><div>            0x06C2 =&gt; 1, 0x06CC =&gt; 1, 0x06CE =&gt; 1, 0x06D0 =&gt; 1, 0x06D1 =&gt; 1, 0x06FA =&gt; 1, 0x06FB =&gt; 1, 0x06FC =&gt; 1, &nbsp;</div></li><li><div>            0x06FF =&gt; 1, &nbsp;</div></li><li><div>            /** Arabic Supplement */&nbsp;</div></li><li><div>            0x0750 =&gt; 1, 0x0751 =&gt; 1, 0x0752 =&gt; 1, 0x0753 =&gt; 1, 0x0754 =&gt; 1, 0x0755 =&gt; 1, 0x0756 =&gt; 1, 0x0757 =&gt; 1, &nbsp;</div></li><li><div>            0x0758 =&gt; 1, 0x075C =&gt; 1, 0x075D =&gt; 1, 0x075E =&gt; 1, 0x075F =&gt; 1, 0x0760 =&gt; 1, 0x0761 =&gt; 1, 0x0762 =&gt; 1, &nbsp;</div></li><li><div>            0x0763 =&gt; 1, 0x0764 =&gt; 1, 0x0765 =&gt; 1, 0x0766 =&gt; 1, 0x0767 =&gt; 1, 0x0768 =&gt; 1, 0x0769 =&gt; 1, 0x076A =&gt; 1, &nbsp;</div></li><li><div>            0x076D =&gt; 1, 0x076E =&gt; 1, 0x076F =&gt; 1, 0x0770 =&gt; 1, 0x0772 =&gt; 1, 0x0775 =&gt; 1, 0x0776 =&gt; 1, 0x0777 =&gt; 1, &nbsp;</div></li><li><div>            0x077A =&gt; 1, 0x077B =&gt; 1, 0x077C =&gt; 1, 0x077D =&gt; 1, 0x077E =&gt; 1, 0x077F =&gt; 1, &nbsp;</div></li><li><div>            /** Extended Arabic */&nbsp;</div></li><li><div>            0x08A0 =&gt; 1, 0x08A2 =&gt; 1, 0x08A3 =&gt; 1, 0x08A4 =&gt; 1, 0x08A5 =&gt; 1, 0x08A6 =&gt; 1, 0x08A7 =&gt; 1, 0x08A8 =&gt; 1, &nbsp;</div></li><li><div>            0x08A9 =&gt; 1, &nbsp;</div></li><li><div>            /** 'syrc' Syriac */&nbsp;</div></li><li><div>            0x0712 =&gt; 1, 0x0713 =&gt; 1, 0x0714 =&gt; 1, 0x071A =&gt; 1, 0x071B =&gt; 1, 0x071C =&gt; 1, 0x071D =&gt; 1, 0x071F =&gt; 1, &nbsp;</div></li><li><div>            0x0720 =&gt; 1, 0x0721 =&gt; 1, 0x0722 =&gt; 1, 0x0723 =&gt; 1, 0x0724 =&gt; 1, 0x0725 =&gt; 1, 0x0726 =&gt; 1, 0x0727 =&gt; 1, &nbsp;</div></li><li><div>            0x0729 =&gt; 1, 0x072B =&gt; 1, 0x072D =&gt; 1, 0x072E =&gt; 1, 0x074E =&gt; 1, 0x074F =&gt; 1, &nbsp;</div></li><li><div>            /** N'Ko */&nbsp;</div></li><li><div>            0x07CA =&gt; 1, 0x07CB =&gt; 1, 0x07CC =&gt; 1, 0x07CD =&gt; 1, 0x07CE =&gt; 1, 0x07CF =&gt; 1, 0x07D0 =&gt; 1, 0x07D1 =&gt; 1, &nbsp;</div></li><li><div>            0x07D2 =&gt; 1, 0x07D3 =&gt; 1, 0x07D4 =&gt; 1, 0x07D5 =&gt; 1, 0x07D6 =&gt; 1, 0x07D7 =&gt; 1, 0x07D8 =&gt; 1, 0x07D9 =&gt; 1, &nbsp;</div></li><li><div>            0x07DA =&gt; 1, 0x07DB =&gt; 1, 0x07DC =&gt; 1, 0x07DD =&gt; 1, 0x07DE =&gt; 1, 0x07DF =&gt; 1, 0x07E0 =&gt; 1, 0x07E1 =&gt; 1, &nbsp;</div></li><li><div>            0x07E2 =&gt; 1, 0x07E3 =&gt; 1, 0x07E4 =&gt; 1, 0x07E5 =&gt; 1, 0x07E6 =&gt; 1, 0x07E7 =&gt; 1, 0x07E8 =&gt; 1, 0x07E9 =&gt; 1, &nbsp;</div></li><li><div>            0x07EA =&gt; 1, 0x07FA =&gt; 1, &nbsp;</div></li><li><div>            /** Mandaic */&nbsp;</div></li><li><div>            0x0841 =&gt; 1, 0x0842 =&gt; 1, 0x0843 =&gt; 1, 0x0844 =&gt; 1, 0x0845 =&gt; 1, 0x0847 =&gt; 1, 0x0848 =&gt; 1, 0x084A =&gt; 1, &nbsp;</div></li><li><div>            0x084B =&gt; 1, 0x084C =&gt; 1, 0x084D =&gt; 1, 0x084E =&gt; 1, 0x0850 =&gt; 1, 0x0851 =&gt; 1, 0x0852 =&gt; 1, 0x0853 =&gt; 1, &nbsp;</div></li><li><div>            0x0855 =&gt; 1, &nbsp;</div></li><li><div>            /** ZWJ U+200D */&nbsp;</div></li><li><div>            0x0200D =&gt; 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** JOIN TO PREVIOUS LETTER IN LOGICAL ORDER (i.e. AS FINAL/MEDIAL FORM) = Unicode Right-Joining (+ Dual-Joining + Join_Causing) */&nbsp;</div></li><li><div>        $this-&gt;arabRightJoining = array(&nbsp;</div></li><li><div>            0x0620 =&gt; 1, 0x0622 =&gt; 1, 0x0623 =&gt; 1, 0x0624 =&gt; 1, 0x0625 =&gt; 1, 0x0626 =&gt; 1, 0x0627 =&gt; 1, 0x0628 =&gt; 1, &nbsp;</div></li><li><div>            0x0629 =&gt; 1, 0x062A =&gt; 1, 0x062B =&gt; 1, 0x062C =&gt; 1, 0x062D =&gt; 1, 0x062E =&gt; 1, 0x062F =&gt; 1, 0x0630 =&gt; 1, &nbsp;</div></li><li><div>            0x0631 =&gt; 1, 0x0632 =&gt; 1, 0x0633 =&gt; 1, 0x0634 =&gt; 1, 0x0635 =&gt; 1, 0x0636 =&gt; 1, 0x0637 =&gt; 1, 0x0638 =&gt; 1, &nbsp;</div></li><li><div>            0x0639 =&gt; 1, 0x063A =&gt; 1, 0x063B =&gt; 1, 0x063C =&gt; 1, 0x063D =&gt; 1, 0x063E =&gt; 1, 0x063F =&gt; 1, 0x0640 =&gt; 1, &nbsp;</div></li><li><div>            0x0641 =&gt; 1, 0x0642 =&gt; 1, 0x0643 =&gt; 1, 0x0644 =&gt; 1, 0x0645 =&gt; 1, 0x0646 =&gt; 1, 0x0647 =&gt; 1, 0x0648 =&gt; 1, &nbsp;</div></li><li><div>            0x0649 =&gt; 1, 0x064A =&gt; 1, 0x066E =&gt; 1, 0x066F =&gt; 1, 0x0671 =&gt; 1, 0x0672 =&gt; 1, 0x0673 =&gt; 1, 0x0675 =&gt; 1, &nbsp;</div></li><li><div>            0x0676 =&gt; 1, 0x0677 =&gt; 1, 0x0678 =&gt; 1, 0x0679 =&gt; 1, 0x067A =&gt; 1, 0x067B =&gt; 1, 0x067C =&gt; 1, 0x067D =&gt; 1, &nbsp;</div></li><li><div>            0x067E =&gt; 1, 0x067F =&gt; 1, 0x0680 =&gt; 1, 0x0681 =&gt; 1, 0x0682 =&gt; 1, 0x0683 =&gt; 1, 0x0684 =&gt; 1, 0x0685 =&gt; 1, &nbsp;</div></li><li><div>            0x0686 =&gt; 1, 0x0687 =&gt; 1, 0x0688 =&gt; 1, 0x0689 =&gt; 1, 0x068A =&gt; 1, 0x068B =&gt; 1, 0x068C =&gt; 1, 0x068D =&gt; 1, &nbsp;</div></li><li><div>            0x068E =&gt; 1, 0x068F =&gt; 1, 0x0690 =&gt; 1, 0x0691 =&gt; 1, 0x0692 =&gt; 1, 0x0693 =&gt; 1, 0x0694 =&gt; 1, 0x0695 =&gt; 1, &nbsp;</div></li><li><div>            0x0696 =&gt; 1, 0x0697 =&gt; 1, 0x0698 =&gt; 1, 0x0699 =&gt; 1, 0x069A =&gt; 1, 0x069B =&gt; 1, 0x069C =&gt; 1, 0x069D =&gt; 1, &nbsp;</div></li><li><div>            0x069E =&gt; 1, 0x069F =&gt; 1, 0x06A0 =&gt; 1, 0x06A1 =&gt; 1, 0x06A2 =&gt; 1, 0x06A3 =&gt; 1, 0x06A4 =&gt; 1, 0x06A5 =&gt; 1, &nbsp;</div></li><li><div>            0x06A6 =&gt; 1, 0x06A7 =&gt; 1, 0x06A8 =&gt; 1, 0x06A9 =&gt; 1, 0x06AA =&gt; 1, 0x06AB =&gt; 1, 0x06AC =&gt; 1, 0x06AD =&gt; 1, &nbsp;</div></li><li><div>            0x06AE =&gt; 1, 0x06AF =&gt; 1, 0x06B0 =&gt; 1, 0x06B1 =&gt; 1, 0x06B2 =&gt; 1, 0x06B3 =&gt; 1, 0x06B4 =&gt; 1, 0x06B5 =&gt; 1, &nbsp;</div></li><li><div>            0x06B6 =&gt; 1, 0x06B7 =&gt; 1, 0x06B8 =&gt; 1, 0x06B9 =&gt; 1, 0x06BA =&gt; 1, 0x06BB =&gt; 1, 0x06BC =&gt; 1, 0x06BD =&gt; 1, &nbsp;</div></li><li><div>            0x06BE =&gt; 1, 0x06BF =&gt; 1, 0x06C0 =&gt; 1, 0x06C1 =&gt; 1, 0x06C2 =&gt; 1, 0x06C3 =&gt; 1, 0x06C4 =&gt; 1, 0x06C5 =&gt; 1, &nbsp;</div></li><li><div>            0x06C6 =&gt; 1, 0x06C7 =&gt; 1, 0x06C8 =&gt; 1, 0x06C9 =&gt; 1, 0x06CA =&gt; 1, 0x06CB =&gt; 1, 0x06CC =&gt; 1, 0x06CD =&gt; 1, &nbsp;</div></li><li><div>            0x06CE =&gt; 1, 0x06CF =&gt; 1, 0x06D0 =&gt; 1, 0x06D1 =&gt; 1, 0x06D2 =&gt; 1, 0x06D3 =&gt; 1, 0x06D5 =&gt; 1, 0x06EE =&gt; 1, &nbsp;</div></li><li><div>            0x06EF =&gt; 1, 0x06FA =&gt; 1, 0x06FB =&gt; 1, 0x06FC =&gt; 1, 0x06FF =&gt; 1, &nbsp;</div></li><li><div>            /** Arabic Supplement */&nbsp;</div></li><li><div>            0x0750 =&gt; 1, 0x0751 =&gt; 1, 0x0752 =&gt; 1, 0x0753 =&gt; 1, 0x0754 =&gt; 1, 0x0755 =&gt; 1, 0x0756 =&gt; 1, 0x0757 =&gt; 1, &nbsp;</div></li><li><div>            0x0758 =&gt; 1, 0x0759 =&gt; 1, 0x075A =&gt; 1, 0x075B =&gt; 1, 0x075C =&gt; 1, 0x075D =&gt; 1, 0x075E =&gt; 1, 0x075F =&gt; 1, &nbsp;</div></li><li><div>            0x0760 =&gt; 1, 0x0761 =&gt; 1, 0x0762 =&gt; 1, 0x0763 =&gt; 1, 0x0764 =&gt; 1, 0x0765 =&gt; 1, 0x0766 =&gt; 1, 0x0767 =&gt; 1, &nbsp;</div></li><li><div>            0x0768 =&gt; 1, 0x0769 =&gt; 1, 0x076A =&gt; 1, 0x076B =&gt; 1, 0x076C =&gt; 1, 0x076D =&gt; 1, 0x076E =&gt; 1, 0x076F =&gt; 1, &nbsp;</div></li><li><div>            0x0770 =&gt; 1, 0x0771 =&gt; 1, 0x0772 =&gt; 1, 0x0773 =&gt; 1, 0x0774 =&gt; 1, 0x0775 =&gt; 1, 0x0776 =&gt; 1, 0x0777 =&gt; 1, &nbsp;</div></li><li><div>            0x0778 =&gt; 1, 0x0779 =&gt; 1, 0x077A =&gt; 1, 0x077B =&gt; 1, 0x077C =&gt; 1, 0x077D =&gt; 1, 0x077E =&gt; 1, 0x077F =&gt; 1, &nbsp;</div></li><li><div>            /** Extended Arabic */&nbsp;</div></li><li><div>            0x08A0 =&gt; 1, 0x08A2 =&gt; 1, 0x08A3 =&gt; 1, 0x08A4 =&gt; 1, 0x08A5 =&gt; 1, 0x08A6 =&gt; 1, 0x08A7 =&gt; 1, 0x08A8 =&gt; 1, &nbsp;</div></li><li><div>            0x08A9 =&gt; 1, 0x08AA =&gt; 1, 0x08AB =&gt; 1, 0x08AC =&gt; 1, &nbsp;</div></li><li><div>            /** 'syrc' Syriac */&nbsp;</div></li><li><div>            0x0710 =&gt; 1, 0x0712 =&gt; 1, 0x0713 =&gt; 1, 0x0714 =&gt; 1, 0x0715 =&gt; 1, 0x0716 =&gt; 1, 0x0717 =&gt; 1, 0x0718 =&gt; 1, &nbsp;</div></li><li><div>            0x0719 =&gt; 1, 0x071A =&gt; 1, 0x071B =&gt; 1, 0x071C =&gt; 1, 0x071D =&gt; 1, 0x071E =&gt; 1, 0x071F =&gt; 1, 0x0720 =&gt; 1, &nbsp;</div></li><li><div>            0x0721 =&gt; 1, 0x0722 =&gt; 1, 0x0723 =&gt; 1, 0x0724 =&gt; 1, 0x0725 =&gt; 1, 0x0726 =&gt; 1, 0x0727 =&gt; 1, 0x0728 =&gt; 1, &nbsp;</div></li><li><div>            0x0729 =&gt; 1, 0x072A =&gt; 1, 0x072B =&gt; 1, 0x072C =&gt; 1, 0x072D =&gt; 1, 0x072E =&gt; 1, 0x072F =&gt; 1, 0x074D =&gt; 1, &nbsp;</div></li><li><div>            0x074E =&gt; 1, 0x074F, &nbsp;</div></li><li><div>            /** N'Ko */&nbsp;</div></li><li><div>            0x07CA =&gt; 1, 0x07CB =&gt; 1, 0x07CC =&gt; 1, 0x07CD =&gt; 1, 0x07CE =&gt; 1, 0x07CF =&gt; 1, 0x07D0 =&gt; 1, 0x07D1 =&gt; 1, &nbsp;</div></li><li><div>            0x07D2 =&gt; 1, 0x07D3 =&gt; 1, 0x07D4 =&gt; 1, 0x07D5 =&gt; 1, 0x07D6 =&gt; 1, 0x07D7 =&gt; 1, 0x07D8 =&gt; 1, 0x07D9 =&gt; 1, &nbsp;</div></li><li><div>            0x07DA =&gt; 1, 0x07DB =&gt; 1, 0x07DC =&gt; 1, 0x07DD =&gt; 1, 0x07DE =&gt; 1, 0x07DF =&gt; 1, 0x07E0 =&gt; 1, 0x07E1 =&gt; 1, &nbsp;</div></li><li><div>            0x07E2 =&gt; 1, 0x07E3 =&gt; 1, 0x07E4 =&gt; 1, 0x07E5 =&gt; 1, 0x07E6 =&gt; 1, 0x07E7 =&gt; 1, 0x07E8 =&gt; 1, 0x07E9 =&gt; 1, &nbsp;</div></li><li><div>            0x07EA =&gt; 1, 0x07FA =&gt; 1, &nbsp;</div></li><li><div>            /** Mandaic */&nbsp;</div></li><li><div>            0x0841 =&gt; 1, 0x0842 =&gt; 1, 0x0843 =&gt; 1, 0x0844 =&gt; 1, 0x0845 =&gt; 1, 0x0847 =&gt; 1, 0x0848 =&gt; 1, 0x084A =&gt; 1, &nbsp;</div></li><li><div>            0x084B =&gt; 1, 0x084C =&gt; 1, 0x084D =&gt; 1, 0x084E =&gt; 1, 0x0850 =&gt; 1, 0x0851 =&gt; 1, 0x0852 =&gt; 1, 0x0853 =&gt; 1, &nbsp;</div></li><li><div>            0x0855 =&gt; 1, &nbsp;</div></li><li><div>            0x0840 =&gt; 1, 0x0846 =&gt; 1, 0x0849 =&gt; 1, 0x084F =&gt; 1, 0x0854 =&gt; 1, /** Right joining */&nbsp;</div></li><li><div>            /** ZWJ U+200D */&nbsp;</div></li><li><div>            0x0200D =&gt; 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** VOWELS = TRANSPARENT-JOINING = Unicode Transparent-Joining type (not just vowels) */&nbsp;</div></li><li><div>        $this-&gt;arabTransparent = array(&nbsp;</div></li><li><div>            0x0610 =&gt; 1, 0x0611 =&gt; 1, 0x0612 =&gt; 1, 0x0613 =&gt; 1, 0x0614 =&gt; 1, 0x0615 =&gt; 1, 0x0616 =&gt; 1, 0x0617 =&gt; 1, &nbsp;</div></li><li><div>            0x0618 =&gt; 1, 0x0619 =&gt; 1, 0x061A =&gt; 1, 0x064B =&gt; 1, 0x064C =&gt; 1, 0x064D =&gt; 1, 0x064E =&gt; 1, 0x064F =&gt; 1, &nbsp;</div></li><li><div>            0x0650 =&gt; 1, 0x0651 =&gt; 1, 0x0652 =&gt; 1, 0x0653 =&gt; 1, 0x0654 =&gt; 1, 0x0655 =&gt; 1, 0x0656 =&gt; 1, 0x0657 =&gt; 1, &nbsp;</div></li><li><div>            0x0658 =&gt; 1, 0x0659 =&gt; 1, 0x065A =&gt; 1, 0x065B =&gt; 1, 0x065C =&gt; 1, 0x065D =&gt; 1, 0x065E =&gt; 1, 0x065F =&gt; 1, &nbsp;</div></li><li><div>            0x0670 =&gt; 1, 0x06D6 =&gt; 1, 0x06D7 =&gt; 1, 0x06D8 =&gt; 1, 0x06D9 =&gt; 1, 0x06DA =&gt; 1, 0x06DB =&gt; 1, 0x06DC =&gt; 1, &nbsp;</div></li><li><div>            0x06DF =&gt; 1, 0x06E0 =&gt; 1, 0x06E1 =&gt; 1, 0x06E2 =&gt; 1, 0x06E3 =&gt; 1, 0x06E4 =&gt; 1, 0x06E7 =&gt; 1, 0x06E8 =&gt; 1, &nbsp;</div></li><li><div>            0x06EA =&gt; 1, 0x06EB =&gt; 1, 0x06EC =&gt; 1, 0x06ED =&gt; 1, &nbsp;</div></li><li><div>            /** Extended Arabic */&nbsp;</div></li><li><div>            0x08E4 =&gt; 1, 0x08E5 =&gt; 1, 0x08E6 =&gt; 1, 0x08E7 =&gt; 1, 0x08E8 =&gt; 1, 0x08E9 =&gt; 1, 0x08EA =&gt; 1, 0x08EB =&gt; 1, &nbsp;</div></li><li><div>            0x08EC =&gt; 1, 0x08ED =&gt; 1, 0x08EE =&gt; 1, 0x08EF =&gt; 1, 0x08F0 =&gt; 1, 0x08F1 =&gt; 1, 0x08F2 =&gt; 1, 0x08F3 =&gt; 1, &nbsp;</div></li><li><div>            0x08F4 =&gt; 1, 0x08F5 =&gt; 1, 0x08F6 =&gt; 1, 0x08F7 =&gt; 1, 0x08F8 =&gt; 1, 0x08F9 =&gt; 1, 0x08FA =&gt; 1, 0x08FB =&gt; 1, &nbsp;</div></li><li><div>            0x08FC =&gt; 1, 0x08FD =&gt; 1, 0x08FE =&gt; 1, &nbsp;</div></li><li><div>            /** Arabic ligatures in presentation form (converted in 'ccmp' in e.g. Arial and Times ? need to add others in this range) */&nbsp;</div></li><li><div>            0xFC5E =&gt; 1, 0xFC5F =&gt; 1, 0xFC60 =&gt; 1, 0xFC61 =&gt; 1, 0xFC62 =&gt; 1, &nbsp;</div></li><li><div>            /**  'syrc' Syriac */&nbsp;</div></li><li><div>            0x070F =&gt; 1, 0x0711 =&gt; 1, 0x0730 =&gt; 1, 0x0731 =&gt; 1, 0x0732 =&gt; 1, 0x0733 =&gt; 1, 0x0734 =&gt; 1, 0x0735 =&gt; 1, &nbsp;</div></li><li><div>            0x0736 =&gt; 1, 0x0737 =&gt; 1, 0x0738 =&gt; 1, 0x0739 =&gt; 1, 0x073A =&gt; 1, 0x073B =&gt; 1, 0x073C =&gt; 1, 0x073D =&gt; 1, &nbsp;</div></li><li><div>            0x073E =&gt; 1, 0x073F =&gt; 1, 0x0740 =&gt; 1, 0x0741 =&gt; 1, 0x0742 =&gt; 1, 0x0743 =&gt; 1, 0x0744 =&gt; 1, 0x0745 =&gt; 1, &nbsp;</div></li><li><div>            0x0746 =&gt; 1, 0x0747 =&gt; 1, 0x0748 =&gt; 1, 0x0749 =&gt; 1, 0x074A =&gt; 1, &nbsp;</div></li><li><div>            /** N'Ko */&nbsp;</div></li><li><div>            0x07EB =&gt; 1, 0x07EC =&gt; 1, 0x07ED =&gt; 1, 0x07EE =&gt; 1, 0x07EF =&gt; 1, 0x07F0 =&gt; 1, 0x07F1 =&gt; 1, 0x07F2 =&gt; 1, &nbsp;</div></li><li><div>            0x07F3 =&gt; 1, &nbsp;</div></li><li><div>            /** Mandaic */&nbsp;</div></li><li><div>            0x0859 =&gt; 1, 0x085A =&gt; 1, 0x085B =&gt; 1, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function arabic_shaper($usetags, $scriptTag)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $chars = array();&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>            $chars[] = $this-&gt;OTLdata[$i]['hex'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $crntChar = null;&nbsp;</div></li><li><div>        $prevChar = null;&nbsp;</div></li><li><div>        $nextChar = null;&nbsp;</div></li><li><div>        $output = array();&nbsp;</div></li><li><div>        $max = count($chars);&nbsp;</div></li><li><div>        for ($i = $max - 1; $i &gt;= 0; $i--) {&nbsp;</div></li><li><div>            $crntChar = $chars[$i];&nbsp;</div></li><li><div>            if ($i &gt; 0) {&nbsp;</div></li><li><div>                $prevChar = hexdec($chars[$i - 1]);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $prevChar = NULL;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($prevChar && isset($this-&gt;arabTransparentJoin[$prevChar]) && isset($chars[$i - 2])) {&nbsp;</div></li><li><div>                $prevChar = hexdec($chars[$i - 2]);&nbsp;</div></li><li><div>                if ($prevChar && isset($this-&gt;arabTransparentJoin[$prevChar]) && isset($chars[$i - 3])) {&nbsp;</div></li><li><div>                    $prevChar = hexdec($chars[$i - 3]);&nbsp;</div></li><li><div>                    if ($prevChar && isset($this-&gt;arabTransparentJoin[$prevChar]) && isset($chars[$i - 4])) {&nbsp;</div></li><li><div>                        $prevChar = hexdec($chars[$i - 4]);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($crntChar && isset($this-&gt;arabTransparentJoin[hexdec($crntChar)])) {&nbsp;</div></li><li><div>                // If next_char = RightJoining && prev_char = LeftJoining:&nbsp;</div></li><li><div>                if (isset($chars[$i + 1]) && $chars[$i + 1] && isset($this-&gt;arabRightJoining[hexdec($chars[$i + 1])]) && $prevChar && isset($this-&gt;arabLeftJoining[$prevChar])) {&nbsp;</div></li><li><div>                    $output[] = $this-&gt;get_arab_glyphs($crntChar, 1, $chars, $i, $scriptTag, $usetags); // &lt;final&gt; form&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $output[] = $this-&gt;get_arab_glyphs($crntChar, 0, $chars, $i, $scriptTag, $usetags);  // &lt;isolated&gt; form&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (hexdec($crntChar) &lt; 128) {&nbsp;</div></li><li><div>                $output[] = array($crntChar, 0);&nbsp;</div></li><li><div>                $nextChar = $crntChar;&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // 0=ISOLATED FORM :: 1=FINAL :: 2=INITIAL :: 3=MEDIAL&nbsp;</div></li><li><div>            $form = 0;&nbsp;</div></li><li><div>            if ($prevChar && isset($this-&gt;arabLeftJoining[$prevChar])) {&nbsp;</div></li><li><div>                $form++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($nextChar && isset($this-&gt;arabRightJoining[hexdec($nextChar)])) {&nbsp;</div></li><li><div>                $form += 2;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $output[] = $this-&gt;get_arab_glyphs($crntChar, $form, $chars, $i, $scriptTag, $usetags);&nbsp;</div></li><li><div>            $nextChar = $crntChar;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $ra = array_reverse($output);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>            $this-&gt;OTLdata[$i]['uni'] = hexdec($ra[$i][0]);&nbsp;</div></li><li><div>            $this-&gt;OTLdata[$i]['hex'] = $ra[$i][0];&nbsp;</div></li><li><div>            $this-&gt;OTLdata[$i]['form'] = $ra[$i][1]; // Actaul form substituted 0=ISOLATED FORM :: 1=FINAL :: 2=INITIAL :: 3=MEDIAL&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function get_arab_glyphs($char, $type, &$chars, $i, $scriptTag, $usetags)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Optional Feature settings    // doesn't control Syriac at present&nbsp;</div></li><li><div>        if (($type === 0 && strpos($usetags, 'isol') === false) || ($type === 1 && strpos($usetags, 'fina') === false) || ($type === 2 && strpos($usetags, 'init') === false) || ($type === 3 && strpos($usetags, 'medi') === false)) {&nbsp;</div></li><li><div>            return array($char, 0);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // 0=ISOLATED FORM :: 1=FINAL :: 2=INITIAL :: 3=MEDIAL (:: 4=MED2 :: 5=FIN2 :: 6=FIN3)&nbsp;</div></li><li><div>        $retk = -1;&nbsp;</div></li><li><div>        // Alaph 00710 in Syriac&nbsp;</div></li><li><div>        if ($scriptTag == 'syrc' && $char == '00710') {&nbsp;</div></li><li><div>            // if there is a preceding (base?) character *** should search back to previous base - ignoring vowels and change $n&nbsp;</div></li><li><div>            // set $n as the position of the last base; for now we'll just do this:&nbsp;</div></li><li><div>            $n = $i - 1;&nbsp;</div></li><li><div>            // if the preceding (base) character cannot be joined to&nbsp;</div></li><li><div>            // not in $this-&gt;arabLeftJoining i.e. not a char which can join to the next one&nbsp;</div></li><li><div>            if (isset($chars[$n]) && isset($this-&gt;arabLeftJoining[hexdec($chars[$n])])) {&nbsp;</div></li><li><div>                // if in the middle of Syriac words&nbsp;</div></li><li><div>                if (isset($chars[$i + 1]) && preg_match('/[\x{0700}-\x{0745}]/u', code2utf(hexdec($chars[$n]))) && preg_match('/[\x{0700}-\x{0745}]/u', code2utf(hexdec($chars[$i + 1]))) && isset($this-&gt;arabGlyphs[$char][4])) {&nbsp;</div></li><li><div>                    $retk = 4;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // if at the end of Syriac words&nbsp;</div></li><li><div>                else if (!isset($chars[$i + 1]) || !preg_match('/[\x{0700}-\x{0745}]/u', code2utf(hexdec($chars[$i + 1])))) {&nbsp;</div></li><li><div>                    // if preceding base character IS (00715|00716|0072A)&nbsp;</div></li><li><div>                    if (strpos('0715|0716|072A', $chars[$n]) !== false && isset($this-&gt;arabGlyphs[$char][6])) {&nbsp;</div></li><li><div>                        $retk = 6;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // else if preceding base character is NOT (00715|00716|0072A)&nbsp;</div></li><li><div>                    else if (isset($this-&gt;arabGlyphs[$char][5])) {&nbsp;</div></li><li><div>                        $retk = 5;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($retk != -1) {&nbsp;</div></li><li><div>                return array($this-&gt;arabGlyphs[$char][$retk], $retk);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                return array($char, 0);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (($type &gt; 0 || $type === 0) && isset($this-&gt;arabGlyphs[$char][$type])) {&nbsp;</div></li><li><div>            $retk = $type;&nbsp;</div></li><li><div>        } else if ($type == 3 && isset($this-&gt;arabGlyphs[$char][1])) { // if &lt;medial&gt; not defined, but &lt;final&gt;, return &lt;final&gt;&nbsp;</div></li><li><div>            $retk = 1;&nbsp;</div></li><li><div>        } else if ($type == 2 && isset($this-&gt;arabGlyphs[$char][0])) { // if &lt;initial&gt; not defined, but &lt;isolated&gt;, return &lt;isolated&gt;&nbsp;</div></li><li><div>            $retk = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($retk != -1) {&nbsp;</div></li><li><div>            $match = true;&nbsp;</div></li><li><div>            // If GSUB includes a Backtrack or Lookahead condition (e.g. font ArabicTypesetting)&nbsp;</div></li><li><div>            if (isset($this-&gt;arabGlyphs[$char]['prel'][$retk]) && $this-&gt;arabGlyphs[$char]['prel'][$retk]) {&nbsp;</div></li><li><div>                $ig = 1;&nbsp;</div></li><li><div>                foreach ($this-&gt;arabGlyphs[$char]['prel'][$retk] AS $k =&gt; $v) { // $k starts 0, 1...&nbsp;</div></li><li><div>                    if (!isset($chars[$i - $ig - $k])) {&nbsp;</div></li><li><div>                        $match = false;&nbsp;</div></li><li><div>                    } else if (strpos($v, $chars[$i - $ig - $k]) === false) {&nbsp;</div></li><li><div>                        while (strpos($this-&gt;arabGlyphs[$char]['ignore'][$retk], $chars[$i - $ig - $k]) !== false) {  // ignore&nbsp;</div></li><li><div>                            $ig++;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        if (!isset($chars[$i - $ig - $k])) {&nbsp;</div></li><li><div>                            $match = false;&nbsp;</div></li><li><div>                        } else if (strpos($v, $chars[$i - $ig - $k]) === false) {&nbsp;</div></li><li><div>                            $match = false;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($this-&gt;arabGlyphs[$char]['postl'][$retk]) && $this-&gt;arabGlyphs[$char]['postl'][$retk]) {&nbsp;</div></li><li><div>                $ig = 1;&nbsp;</div></li><li><div>                foreach ($this-&gt;arabGlyphs[$char]['postl'][$retk] AS $k =&gt; $v) { // $k starts 0, 1...&nbsp;</div></li><li><div>                    if (!isset($chars[$i + $ig + $k])) {&nbsp;</div></li><li><div>                        $match = false;&nbsp;</div></li><li><div>                    } else if (strpos($v, $chars[$i + $ig + $k]) === false) {&nbsp;</div></li><li><div>                        while (strpos($this-&gt;arabGlyphs[$char]['ignore'][$retk], $chars[$i + $ig + $k]) !== false) {  // ignore&nbsp;</div></li><li><div>                            $ig++;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        if (!isset($chars[$i + $ig + $k])) {&nbsp;</div></li><li><div>                            $match = false;&nbsp;</div></li><li><div>                        } else if (strpos($v, $chars[$i + $ig + $k]) === false) {&nbsp;</div></li><li><div>                            $match = false;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($match) {&nbsp;</div></li><li><div>                return array($this-&gt;arabGlyphs[$char][$retk], $retk);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                return array($char, 0);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            return array($char, 0);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>/////////////////       LINE BREAKING    ///////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>/////////////       TIBETAN LINE BREAKING    ///////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>// Sets $this-&gt;OTLdata[$i]['wordend']=true at possible end of word boundaries&nbsp;</div></li><li><div>    function TibetanlineBreaking()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        for ($ptr = 0; $ptr &lt; count($this-&gt;OTLdata); $ptr++) {&nbsp;</div></li><li><div>            // Break opportunities at U+0F0B Tsheg or U=0F0D&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$ptr]['uni']) && ($this-&gt;OTLdata[$ptr]['uni'] == 0x0F0B || $this-&gt;OTLdata[$ptr]['uni'] == 0x0F0D)) {&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$ptr + 1]['uni']) && ($this-&gt;OTLdata[$ptr + 1]['uni'] == 0x0F0D || $this-&gt;OTLdata[$ptr + 1]['uni'] == 0xF0E)) {&nbsp;</div></li><li><div>                    continue;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // Set end of word marker in OTLdata at matchpos&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$ptr]['wordend'] = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>//////////       SOUTH EAST ASIAN LINE BREAKING    /////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>// South East Asian Linebreaking (Thai, Khmer and Lao) using dictionary of words&nbsp;</div></li><li><div>// Sets $this-&gt;OTLdata[$i]['wordend']=true at possible end of word boundaries&nbsp;</div></li><li><div>    function SEAlineBreaking()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // Load Line-breaking dictionary&nbsp;</div></li><li><div>        if (!isset($this-&gt;lbdicts[$this-&gt;shaper]) && file_exists(_MPDF_PATH . 'includes/linebrdict' . $this-&gt;shaper . '.dat')) {&nbsp;</div></li><li><div>            $this-&gt;lbdicts[$this-&gt;shaper] = file_get_contents(_MPDF_PATH . 'includes/linebrdict' . $this-&gt;shaper . '.dat');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $dict = &$this-&gt;lbdicts[$this-&gt;shaper];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Find all word boundaries and mark end of word $this-&gt;OTLdata[$i]['wordend']=true on last character&nbsp;</div></li><li><div>        // If Thai, allow for possible suffixes (not in Lao or Khmer)&nbsp;</div></li><li><div>        // repeater/ellision characters&nbsp;</div></li><li><div>        // (0x0E2F);        // Ellision character THAI_PAIYANNOI 0x0E2F  UTF-8 0xE0 0xB8 0xAF&nbsp;</div></li><li><div>        // (0x0E46);        // Repeat character THAI_MAIYAMOK 0x0E46   UTF-8 0xE0 0xB9 0x86&nbsp;</div></li><li><div>        // (0x0EC6);        // Repeat character LAO   UTF-8 0xE0 0xBB 0x86&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $rollover = array();&nbsp;</div></li><li><div>        $ptr = 0;&nbsp;</div></li><li><div>        while ($ptr &lt; count($this-&gt;OTLdata) - 3) {&nbsp;</div></li><li><div>            if (count($rollover)) {&nbsp;</div></li><li><div>                $matches = $rollover;&nbsp;</div></li><li><div>                $rollover = array();&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $matches = $this-&gt;checkwordmatch($dict, $ptr);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (count($matches) == 1) {&nbsp;</div></li><li><div>                $matchpos = $matches[0];&nbsp;</div></li><li><div>                // Check for repeaters - if so $matchpos++&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$matchpos + 1]['uni']) && ($this-&gt;OTLdata[$matchpos + 1]['uni'] == 0x0E2F || $this-&gt;OTLdata[$matchpos + 1]['uni'] == 0x0E46 || $this-&gt;OTLdata[$matchpos + 1]['uni'] == 0x0EC6)) {&nbsp;</div></li><li><div>                    $matchpos++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // Set end of word marker in OTLdata at matchpos&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$matchpos]['wordend'] = true;&nbsp;</div></li><li><div>                $ptr = $matchpos + 1;&nbsp;</div></li><li><div>            } else if (empty($matches)) {&nbsp;</div></li><li><div>                $ptr++;&nbsp;</div></li><li><div>                // Move past any ASCII characters&nbsp;</div></li><li><div>                while (isset($this-&gt;OTLdata[$ptr]['uni']) && ($this-&gt;OTLdata[$ptr]['uni'] &gt;&gt; 8) == 0) {&nbsp;</div></li><li><div>                    $ptr++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else { // Multiple matches&nbsp;</div></li><li><div>                $secondmatch = false;&nbsp;</div></li><li><div>                for ($m = count($matches) - 1; $m &gt;= 0; $m--) {&nbsp;</div></li><li><div>                    //for ($m=0;$m&lt;count($matches);$m++) {&nbsp;</div></li><li><div>                    $firstmatch = $matches[$m];&nbsp;</div></li><li><div>                    $matches2 = $this-&gt;checkwordmatch($dict, $firstmatch + 1);&nbsp;</div></li><li><div>                    if (count($matches2)) {&nbsp;</div></li><li><div>                        // Set end of word marker in OTLdata at matchpos&nbsp;</div></li><li><div>                        $this-&gt;OTLdata[$firstmatch]['wordend'] = true;&nbsp;</div></li><li><div>                        $ptr = $firstmatch + 1;&nbsp;</div></li><li><div>                        $rollover = $matches2;&nbsp;</div></li><li><div>                        $secondmatch = true;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (!$secondmatch) {&nbsp;</div></li><li><div>                    // Set end of word marker in OTLdata at end of longest first match&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$matches[count($matches) - 1]]['wordend'] = true;&nbsp;</div></li><li><div>                    $ptr = $matches[count($matches) - 1] + 1;&nbsp;</div></li><li><div>                    // Move past any ASCII characters&nbsp;</div></li><li><div>                    while (isset($this-&gt;OTLdata[$ptr]['uni']) && ($this-&gt;OTLdata[$ptr]['uni'] &gt;&gt; 8) == 0) {&nbsp;</div></li><li><div>                        $ptr++;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function checkwordmatch(&$dict, $ptr)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>          define(&quot;_DICT_NODE_TYPE_SPLIT&quot;, 0x01);&nbsp;</div></li><li><div>          define(&quot;_DICT_NODE_TYPE_LINEAR&quot;, 0x02);&nbsp;</div></li><li><div>          define(&quot;_DICT_INTERMEDIATE_MATCH&quot;, 0x03);&nbsp;</div></li><li><div>          define(&quot;_DICT_FINAL_MATCH&quot;, 0x04);&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>          Node type: Split.&nbsp;</div></li><li><div>          Divide at &lt; 98 &gt;= 98&nbsp;</div></li><li><div>          Offset for &gt;= 98 == 79    (long 4-byte unsigned)&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>          Node type: Linear match.&nbsp;</div></li><li><div>          Char = 97&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>          Intermediate match&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>          Final match&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $dictptr = 0;&nbsp;</div></li><li><div>        $ok = true;&nbsp;</div></li><li><div>        $matches = array();&nbsp;</div></li><li><div>        while ($ok) {&nbsp;</div></li><li><div>            $x = ord($dict{$dictptr});&nbsp;</div></li><li><div>            $c = $this-&gt;OTLdata[$ptr]['uni'] & 0xFF;&nbsp;</div></li><li><div>            if ($x == _DICT_INTERMEDIATE_MATCH) {&nbsp;</div></li><li><div>//echo &quot;DICT_INTERMEDIATE_MATCH: &quot;.dechex($c).'&lt;br /&gt;';&nbsp;</div></li><li><div>                // Do not match if next character in text is a Mark&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$ptr]['uni']) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$ptr]['hex']) === false) {&nbsp;</div></li><li><div>                    $matches[] = $ptr - 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $dictptr++;&nbsp;</div></li><li><div>            } else if ($x == _DICT_FINAL_MATCH) {&nbsp;</div></li><li><div>//echo &quot;DICT_FINAL_MATCH: &quot;.dechex($c).'&lt;br /&gt;';&nbsp;</div></li><li><div>                // Do not match if next character in text is a Mark&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$ptr]['uni']) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$ptr]['hex']) === false) {&nbsp;</div></li><li><div>                    $matches[] = $ptr - 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return $matches;&nbsp;</div></li><li><div>            } else if ($x == _DICT_NODE_TYPE_LINEAR) {&nbsp;</div></li><li><div>//echo &quot;DICT_NODE_TYPE_LINEAR: &quot;.dechex($c).'&lt;br /&gt;';&nbsp;</div></li><li><div>                $dictptr++;&nbsp;</div></li><li><div>                $m = ord($dict{$dictptr});&nbsp;</div></li><li><div>                if ($c == $m) {&nbsp;</div></li><li><div>                    $ptr++;&nbsp;</div></li><li><div>                    if ($ptr &gt; count($this-&gt;OTLdata) - 1) {&nbsp;</div></li><li><div>                        $next = ord($dict{$dictptr + 1});&nbsp;</div></li><li><div>                        if ($next == _DICT_INTERMEDIATE_MATCH || $next == _DICT_FINAL_MATCH) {&nbsp;</div></li><li><div>                            // Do not match if next character in text is a Mark&nbsp;</div></li><li><div>                            if (isset($this-&gt;OTLdata[$ptr]['uni']) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$ptr]['hex']) === false) {&nbsp;</div></li><li><div>                                $matches[] = $ptr - 1;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        return $matches;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $dictptr++;&nbsp;</div></li><li><div>                    continue;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>//echo &quot;DICT_NODE_TYPE_LINEAR NOT: &quot;.dechex($c).'&lt;br /&gt;';&nbsp;</div></li><li><div>                    return $matches;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($x == _DICT_NODE_TYPE_SPLIT) {&nbsp;</div></li><li><div>//echo &quot;DICT_NODE_TYPE_SPLIT ON &quot;.dechex($d).&quot;: &quot;.dechex($c).'&lt;br /&gt;';&nbsp;</div></li><li><div>                $dictptr++;&nbsp;</div></li><li><div>                $d = ord($dict{$dictptr});&nbsp;</div></li><li><div>                if ($c &lt; $d) {&nbsp;</div></li><li><div>                    $dictptr += 5;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $dictptr++;&nbsp;</div></li><li><div>                    // Unsigned long 32-bit offset&nbsp;</div></li><li><div>                    $offset = (ord($dict{$dictptr}) * 16777216) + (ord($dict{$dictptr + 1}) &lt;&lt; 16) + (ord($dict{$dictptr + 2}) &lt;&lt; 8) + ord($dict{$dictptr + 3});&nbsp;</div></li><li><div>                    $dictptr = $offset;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>//echo &quot;PROBLEM: &quot;.($x).'&lt;br /&gt;';&nbsp;</div></li><li><div>                $ok = false; // Something has gone wrong&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $matches;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>//////////       GPOS    ///////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGPOSrules($LookupList, $is_old_spec = false)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        foreach ($LookupList AS $lu =&gt; $tag) {&nbsp;</div></li><li><div>            $Type = $this-&gt;GPOSLookups[$lu]['Type'];&nbsp;</div></li><li><div>            $Flag = $this-&gt;GPOSLookups[$lu]['Flag'];&nbsp;</div></li><li><div>            $MarkFilteringSet = '';&nbsp;</div></li><li><div>            if (isset($this-&gt;GPOSLookups[$lu]['MarkFilteringSet']))&nbsp;</div></li><li><div>                $MarkFilteringSet = $this-&gt;GPOSLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>            $ptr = 0;&nbsp;</div></li><li><div>            // Test each glyph sequentially&nbsp;</div></li><li><div>            while ($ptr &lt; (count($this-&gt;OTLdata))) { // whilst there is another glyph ..0064&nbsp;</div></li><li><div>                $currGlyph = $this-&gt;OTLdata[$ptr]['hex'];&nbsp;</div></li><li><div>                $currGID = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                $shift = 1;&nbsp;</div></li><li><div>                foreach ($this-&gt;GPOSLookups[$lu]['Subtables'] AS $c =&gt; $subtable_offset) {&nbsp;</div></li><li><div>                    // NB Coverage only looks at glyphs for position 1 (esp. 7.3 and 8.3)&nbsp;</div></li><li><div>                    if (isset($this-&gt;LuCoverage[$lu][$c][$currGID])) {&nbsp;</div></li><li><div>                        // Get rules from font GPOS subtable&nbsp;</div></li><li><div>                        if (isset($this-&gt;OTLdata[$ptr]['bidi_type'])) {  // No need to check bidi_type - just a check that it exists&nbsp;</div></li><li><div>                            $shift = $this-&gt;_applyGPOSsubtable($lu, $c, $ptr, $currGlyph, $currGID, ($subtable_offset - $this-&gt;GPOS_offset + $this-&gt;GSUB_length), $Type, $Flag, $MarkFilteringSet, $this-&gt;LuCoverage[$lu][$c], $tag, 0, $is_old_spec);&nbsp;</div></li><li><div>                            if ($shift) {&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($shift == 0) {&nbsp;</div></li><li><div>                    $shift = 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $ptr += $shift;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>    // GPOS Types&nbsp;</div></li><li><div>    // Lookup Type 1: Single Adjustment Positioning Subtable        Adjust position of a single glyph&nbsp;</div></li><li><div>    // Lookup Type 2: Pair Adjustment Positioning Subtable      Adjust position of a pair of glyphs&nbsp;</div></li><li><div>    // Lookup Type 3: Cursive Attachment Positioning Subtable       Attach cursive glyphs&nbsp;</div></li><li><div>    // Lookup Type 4: MarkToBase Attachment Positioning Subtable    Attach a combining mark to a base glyph&nbsp;</div></li><li><div>    // Lookup Type 5: MarkToLigature Attachment Positioning Subtable    Attach a combining mark to a ligature&nbsp;</div></li><li><div>    // Lookup Type 6: MarkToMark Attachment Positioning Subtable    Attach a combining mark to another mark&nbsp;</div></li><li><div>    // Lookup Type 7: Contextual Positioning Subtables          Position one or more glyphs in context&nbsp;</div></li><li><div>    // Lookup Type 8: Chaining Contextual Positioning Subtable      Position one or more glyphs in chained context&nbsp;</div></li><li><div>    // Lookup Type 9: Extension positioning&nbsp;</div></li><li><div>    //////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>    function _applyGPOSvaluerecord($basepos, $Value)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If current glyph is a mark with a defined width, any XAdvance is considered to REPLACE the character Advance Width&nbsp;</div></li><li><div>        // Test case &lt;div style=&quot;font-family:myanmartext&quot;&gt;&#x1004;&#x103a;&#x1039;&#x1000;&#x1039;&#x1000;&#x103b;&#x103c;&#x103d;&#x1031;&#x102d;&lt;/div&gt;&nbsp;</div></li><li><div>        if (strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$basepos]['hex']) !== false) {&nbsp;</div></li><li><div>            $cw = round($this-&gt;mpdf-&gt;_getCharWidth($this-&gt;mpdf-&gt;CurrentFont['cw'], $this-&gt;OTLdata[$basepos]['uni']) * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000); // convert back to font design units&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $cw = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $apos = $this-&gt;_getXAdvancePos($basepos);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($Value['XAdvance']) && ($Value['XAdvance'] - $cw) != 0) {&nbsp;</div></li><li><div>            // However DON'T REPLACE the character Advance Width if Advance Width is negative&nbsp;</div></li><li><div>            // Test case &lt;div style=&quot;font-family: dejavusansmono&quot;&gt;&#x440;&#x443;&#x301;&#x441;&#x441;&#x43a;&#x438;&#x439;&lt;/div&gt;&nbsp;</div></li><li><div>            if ($Value['XAdvance'] &lt; 0) {&nbsp;</div></li><li><div>                $cw = 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // For LTR apply XAdvanceL to the last mark following the base = at $apos&nbsp;</div></li><li><div>            // For RTL apply XAdvanceR to base = at $basepos&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$apos]['GPOSinfo']['XAdvanceL'])) {&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$apos]['GPOSinfo']['XAdvanceL'] += $Value['XAdvance'] - $cw;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$apos]['GPOSinfo']['XAdvanceL'] = $Value['XAdvance'] - $cw;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$basepos]['GPOSinfo']['XAdvanceR'])) {&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$basepos]['GPOSinfo']['XAdvanceR'] += $Value['XAdvance'] - $cw;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$basepos]['GPOSinfo']['XAdvanceR'] = $Value['XAdvance'] - $cw;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Any XPlacement (? and Y Placement) apply to base and marks (from basepos to apos)&nbsp;</div></li><li><div>        for ($a = $basepos; $a &lt;= $apos; $a++) {&nbsp;</div></li><li><div>            if (isset($Value['XPlacement'])) {&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$a]['GPOSinfo']['XPlacement'])) {&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$a]['GPOSinfo']['XPlacement'] += $Value['XPlacement'];&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$a]['GPOSinfo']['XPlacement'] = $Value['XPlacement'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($Value['YPlacement'])) {&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$a]['GPOSinfo']['YPlacement'])) {&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$a]['GPOSinfo']['YPlacement'] += $Value['YPlacement'];&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$a]['GPOSinfo']['YPlacement'] = $Value['YPlacement'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// If XAdvance is aplied to $ptr - in order for PDF to position the Advance correctly need to place it on&nbsp;</div></li><li><div>// the last of any Marks which immediately follow the current glyph&nbsp;</div></li><li><div>    function _getXAdvancePos($pos)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // NB Not all fonts have all marks specified in GlyphClassMarks&nbsp;</div></li><li><div>        // If the current glyph is not a base (but a mark) then ignore this, and apply to the current position&nbsp;</div></li><li><div>        if (strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$pos]['hex']) !== false) {&nbsp;</div></li><li><div>            return $pos;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while (isset($this-&gt;OTLdata[$pos + 1]['hex']) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$pos + 1]['hex']) !== false) {&nbsp;</div></li><li><div>            $pos++;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $pos;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _applyGPOSsubtable($lookupID, $subtable, $ptr, $currGlyph, $currGID, $subtable_offset, $Type, $Flag, $MarkFilteringSet, $LuCoverage, $tag, $level = 0, $is_old_spec)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (($Flag & 0x0001) == 1) {&nbsp;</div></li><li><div>            $dir = 'RTL';&nbsp;</div></li><li><div>        } // only used for Type 3&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            $dir = 'LTR';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $ignore = $this-&gt;_getGCOMignoreString($Flag, $MarkFilteringSet);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Lets start&nbsp;</div></li><li><div>        $this-&gt;seek($subtable_offset);&nbsp;</div></li><li><div>        $PosFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 1: Single adjustment  Adjust position of a single glyph (e.g. SmallCaps/Sups/Subs)&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        if ($Type == 1) {&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            if ($PosFormat == 1) {&nbsp;</div></li><li><div>                $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ValueFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $Value = $this-&gt;_getValueRecord($ValueFormat);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            else if ($PosFormat == 2) {&nbsp;</div></li><li><div>                $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ValueFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ValueCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $GlyphPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>                $this-&gt;skip($GlyphPos * 2 * $this-&gt;count_bits($ValueFormat));&nbsp;</div></li><li><div>                $Value = $this-&gt;_getValueRecord($ValueFormat);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $this-&gt;_applyGPOSvaluerecord($ptr, $Value);&nbsp;</div></li><li><div>            if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return 1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 2: Pair adjustment    Adjust position of a pair of glyphs (Kerning)&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 2) {&nbsp;</div></li><li><div>            $Coverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $ValueFormat1 = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $ValueFormat2 = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $sizeOfPair = ( 2 * $this-&gt;count_bits($ValueFormat1) ) + ( 2 * $this-&gt;count_bits($ValueFormat2) );&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            if ($PosFormat == 1) {&nbsp;</div></li><li><div>                $PairSetCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $PairSetOffset = array();&nbsp;</div></li><li><div>                for ($p = 0; $p &lt; $PairSetCount; $p++) {&nbsp;</div></li><li><div>                    $PairSetOffset[] = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                for ($p = 0; $p &lt; $PairSetCount; $p++) {&nbsp;</div></li><li><div>                    if (isset($LuCoverage[$currGID]) && $LuCoverage[$currGID] == $p) {&nbsp;</div></li><li><div>                        $this-&gt;seek($PairSetOffset[$p]);&nbsp;</div></li><li><div>                        //PairSet table&nbsp;</div></li><li><div>                        $PairValueCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        for ($pv = 0; $pv &lt; $PairValueCount; $pv++) {&nbsp;</div></li><li><div>                            //PairValueRecord&nbsp;</div></li><li><div>                            $gid = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $SecondGlyph = $this-&gt;glyphToChar($gid);&nbsp;</div></li><li><div>                            $FirstGlyph = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $checkpos = $ptr;&nbsp;</div></li><li><div>                            $checkpos++;&nbsp;</div></li><li><div>                            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                                $checkpos++;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if (isset($this-&gt;OTLdata[$checkpos]) && $this-&gt;OTLdata[$checkpos]['uni'] == $SecondGlyph) {&nbsp;</div></li><li><div>                                $matchedpos = $checkpos;&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $matchedpos = false;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($matchedpos !== false) {&nbsp;</div></li><li><div>                                $Value1 = $this-&gt;_getValueRecord($ValueFormat1);&nbsp;</div></li><li><div>                                $Value2 = $this-&gt;_getValueRecord($ValueFormat2);&nbsp;</div></li><li><div>                                if ($ValueFormat1) {&nbsp;</div></li><li><div>                                    $this-&gt;_applyGPOSvaluerecord($ptr, $Value1);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if ($ValueFormat2) {&nbsp;</div></li><li><div>                                    $this-&gt;_applyGPOSvaluerecord($matchedpos, $Value2);&nbsp;</div></li><li><div>                                    if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                                        $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    return $matchedpos - $ptr + 1;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                                    $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                return $matchedpos - $ptr;&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $this-&gt;skip($sizeOfPair);&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            else if ($PosFormat == 2) {&nbsp;</div></li><li><div>                $ClassDef1 = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ClassDef2 = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $Class1Count = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $Class2Count = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $sizeOfValueRecords = $Class1Count * $Class2Count * $sizeOfPair;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                //$this-&gt;skip($sizeOfValueRecords );  ???? NOT NEEDED&nbsp;</div></li><li><div>                // NB Class1Count includes Class 0 even though it is not defined by $ClassDef1&nbsp;</div></li><li><div>                // i.e. Class1Count = 5; Class1 will contain array(indices 1-4);&nbsp;</div></li><li><div>                $Class1 = $this-&gt;_getClassDefinitionTable($ClassDef1);&nbsp;</div></li><li><div>                $Class2 = $this-&gt;_getClassDefinitionTable($ClassDef2);&nbsp;</div></li><li><div>                $FirstGlyph = $this-&gt;OTLdata[$ptr]['uni'];&nbsp;</div></li><li><div>                $checkpos = $ptr;&nbsp;</div></li><li><div>                $checkpos++;&nbsp;</div></li><li><div>                while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                    $checkpos++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$checkpos])) {&nbsp;</div></li><li><div>                    $matchedpos = $checkpos;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    return 0;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $SecondGlyph = $this-&gt;OTLdata[$matchedpos]['uni'];&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $Class1Count; $i++) {&nbsp;</div></li><li><div>                    if (isset($Class1[$i]) && count($Class1[$i])) {&nbsp;</div></li><li><div>                        $FirstClassPos = array_search($FirstGlyph, $Class1[$i]);&nbsp;</div></li><li><div>                        if ($FirstClassPos === false) {&nbsp;</div></li><li><div>                            continue;&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            for ($j = 0; $j &lt; $Class2Count; $j++) {&nbsp;</div></li><li><div>                                if (isset($Class2[$j]) && count($Class2[$j])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    $SecondClassPos = array_search($SecondGlyph, $Class2[$j]);&nbsp;</div></li><li><div>                                    if ($SecondClassPos === false) {&nbsp;</div></li><li><div>                                        continue;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    // Get ValueRecord[$i][$j]&nbsp;</div></li><li><div>                                    $offs = ($i * $Class2Count * $sizeOfPair) + ($j * $sizeOfPair);&nbsp;</div></li><li><div>                                    $this-&gt;seek($subtable_offset + 16 + $offs);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    $Value1 = $this-&gt;_getValueRecord($ValueFormat1);&nbsp;</div></li><li><div>                                    $Value2 = $this-&gt;_getValueRecord($ValueFormat2);&nbsp;</div></li><li><div>                                    if ($ValueFormat1) {&nbsp;</div></li><li><div>                                        $this-&gt;_applyGPOSvaluerecord($ptr, $Value1);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    if ($ValueFormat2) {&nbsp;</div></li><li><div>                                        $this-&gt;_applyGPOSvaluerecord($matchedpos, $Value2);&nbsp;</div></li><li><div>                                        if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                                            $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                        return $matchedpos - $ptr + 1;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                                        $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    return $matchedpos - $ptr;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 3: Cursive attachment     Attach cursive glyphs&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 3) {&nbsp;</div></li><li><div>            $this-&gt;skip(4);&nbsp;</div></li><li><div>            // Need default XAdvance for glyph&nbsp;</div></li><li><div>            $pdfWidth = $this-&gt;mpdf-&gt;_getCharWidth($this-&gt;mpdf-&gt;CurrentFont['cw'], hexdec($currGlyph)); // DON'T convert back to design units&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $CPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>            $this-&gt;skip($CPos * 4);&nbsp;</div></li><li><div>            $EntryAnchor = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $ExitAnchor = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            if ($EntryAnchor != 0) {&nbsp;</div></li><li><div>                $EntryAnchor += $subtable_offset;&nbsp;</div></li><li><div>                list($x, $y) = $this-&gt;_getAnchorTable($EntryAnchor);&nbsp;</div></li><li><div>                if ($dir == 'RTL') {&nbsp;</div></li><li><div>                    if (round($pdfWidth) == round($x * 1000 / $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'])) {&nbsp;</div></li><li><div>                        $x = 0;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $x = $x - ($pdfWidth * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $this-&gt;Entry[$ptr] = array('X' =&gt; $x, 'Y' =&gt; $y, 'dir' =&gt; $dir);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($ExitAnchor != 0) {&nbsp;</div></li><li><div>                $ExitAnchor += $subtable_offset;&nbsp;</div></li><li><div>                list($x, $y) = $this-&gt;_getAnchorTable($ExitAnchor);&nbsp;</div></li><li><div>                if ($dir == 'LTR') {&nbsp;</div></li><li><div>                    if (round($pdfWidth) == round($x * 1000 / $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'])) {&nbsp;</div></li><li><div>                        $x = 0;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $x = $x - ($pdfWidth * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $this-&gt;Exit[$ptr] = array('X' =&gt; $x, 'Y' =&gt; $y, 'dir' =&gt; $dir);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return 1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 4: MarkToBase attachment  Attach a combining mark to a base glyph&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 4) {&nbsp;</div></li><li><div>            $MarkCoverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            //$MarkCoverage is already set in $LuCoverage 00065|00073 etc&nbsp;</div></li><li><div>            $BaseCoverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $ClassCount = $this-&gt;read_ushort(); // Number of classes defined for marks = Number of mark glyphs in the MarkCoverage table&nbsp;</div></li><li><div>            $MarkArray = $subtable_offset + $this-&gt;read_ushort(); // Offset to MarkArray table&nbsp;</div></li><li><div>            $BaseArray = $subtable_offset + $this-&gt;read_ushort(); // Offset to BaseArray table&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;seek($BaseCoverage);&nbsp;</div></li><li><div>            $BaseGlyphs = implode('|', $this-&gt;_getCoverage());&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $checkpos = $ptr;&nbsp;</div></li><li><div>            $checkpos--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // ZZZ93&nbsp;</div></li><li><div>            // In Lohit-Kannada font (old-spec), rules specify a Type 4 GPOS to attach below-forms to base glyph&nbsp;</div></li><li><div>            // the repositioning does not happen in MS Word, and shouldn't happen comparing with other fonts&nbsp;</div></li><li><div>            // ?Why not&nbsp;</div></li><li><div>            // This Fix blocks the GPOS rule if the &quot;mark&quot; is not actually classified as a mark in the GlyphClasses of GDEF&nbsp;</div></li><li><div>            // but only in Indic old-spec.&nbsp;</div></li><li><div>            // Test cases: &#xca8;&#xccd;&#xca8;&#xcc1; and &#xc95;&#xccd;&#xcb0;&#xccc;&nbsp;</div></li><li><div>            if ($this-&gt;shaper == 'I' && $is_old_spec && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$ptr]['hex']) === false) {&nbsp;</div></li><li><div>                return;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // &quot;To identify the base glyph that combines with a mark, the text-processing client must look backward in the glyph string from the mark to the preceding base glyph.&quot;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$checkpos]) && strpos($BaseGlyphs, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $matchedpos = $checkpos;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $matchedpos = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($matchedpos !== false) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Get the relevant MarkRecord&nbsp;</div></li><li><div>                $MarkPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>                $MarkRecord = $this-&gt;_getMarkRecord($MarkArray, $MarkPos); // e.g. Array ( [Class] =&gt; 0 [AnchorX] =&gt; -549 [AnchorY] =&gt; 1548 )&nbsp;</div></li><li><div>                //Mark Class is = $MarkRecord['Class']&nbsp;</div></li><li><div>                // Get the relevant BaseRecord&nbsp;</div></li><li><div>                $this-&gt;seek($BaseArray);&nbsp;</div></li><li><div>                $BaseCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $BasePos = strpos($BaseGlyphs, $this-&gt;OTLdata[$matchedpos]['hex']) / 6;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Move to the BaseRecord we want&nbsp;</div></li><li><div>                $nSkip = (2 * $BasePos * $ClassCount );&nbsp;</div></li><li><div>                $this-&gt;skip($nSkip);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Read BaseRecord we want for appropriate Class&nbsp;</div></li><li><div>                $nSkip = 2 * $MarkRecord['Class'];&nbsp;</div></li><li><div>                $this-&gt;skip($nSkip);&nbsp;</div></li><li><div>                $BaseRecordOffset = $BaseArray + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                list($x, $y) = $this-&gt;_getAnchorTable($BaseRecordOffset);&nbsp;</div></li><li><div>                $BaseRecord = array('AnchorX' =&gt; $x, 'AnchorY' =&gt; $y); // e.g. Array ( [AnchorX] =&gt; 660 [AnchorY] =&gt; 1556 )&nbsp;</div></li><li><div>                // Need default XAdvance for Base glyph&nbsp;</div></li><li><div>                $BaseWidth = $this-&gt;mpdf-&gt;_getCharWidth($this-&gt;mpdf-&gt;CurrentFont['cw'], $this-&gt;OTLdata[$matchedpos]['uni']) * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000; // convert back to font design units&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $BaseWidth;&nbsp;</div></li><li><div>                // And any intervening (ignored) characters&nbsp;</div></li><li><div>                if (($ptr - $matchedpos) &gt; 1) {&nbsp;</div></li><li><div>                    for ($i = $matchedpos + 1; $i &lt; $ptr; $i++) {&nbsp;</div></li><li><div>                        $BaseWidthExtra = $this-&gt;mpdf-&gt;_getCharWidth($this-&gt;mpdf-&gt;CurrentFont['cw'], $this-&gt;OTLdata[$i]['uni']) * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000; // convert back to font design units&nbsp;</div></li><li><div>                        $this-&gt;OTLdata[$ptr]['GPOSinfo']['BaseWidth'] += $BaseWidthExtra;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Align to previous Glyph by attachment - so need to add to previous placement values&nbsp;</div></li><li><div>                $prevXPlacement = (isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['XPlacement']) ? $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['XPlacement'] : 0);&nbsp;</div></li><li><div>                $prevYPlacement = (isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['YPlacement']) ? $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['YPlacement'] : 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$ptr]['GPOSinfo']['XPlacement'] = $prevXPlacement + $BaseRecord['AnchorX'] - $MarkRecord['AnchorX'];&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$ptr]['GPOSinfo']['YPlacement'] = $prevYPlacement + $BaseRecord['AnchorY'] - $MarkRecord['AnchorY'];&nbsp;</div></li><li><div>                if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                    $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 5: MarkToLigature attachment  Attach a combining mark to a ligature&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 5) {&nbsp;</div></li><li><div>            $MarkCoverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            //$MarkCoverage is already set in $LuCoverage 00065|00073 etc&nbsp;</div></li><li><div>            $LigatureCoverage = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $ClassCount = $this-&gt;read_ushort(); // Number of classes defined for marks = Number of mark glyphs in the MarkCoverage table&nbsp;</div></li><li><div>            $MarkArray = $subtable_offset + $this-&gt;read_ushort(); // Offset to MarkArray table&nbsp;</div></li><li><div>            $LigatureArray = $subtable_offset + $this-&gt;read_ushort(); // Offset to LigatureArray table&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $this-&gt;seek($LigatureCoverage);&nbsp;</div></li><li><div>            $LigatureGlyphs = implode('|', $this-&gt;_getCoverage());&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $checkpos = $ptr;&nbsp;</div></li><li><div>            $checkpos--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // &quot;To position a combining mark using a MarkToLigature attachment subtable, the text-processing client must work backward from the mark to the preceding ligature glyph.&quot;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($this-&gt;GlyphClassMarks, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$checkpos]) && strpos($LigatureGlyphs, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $matchedpos = $checkpos;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $matchedpos = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($matchedpos !== false) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Get the relevant MarkRecord&nbsp;</div></li><li><div>                $MarkPos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>                $MarkRecord = $this-&gt;_getMarkRecord($MarkArray, $MarkPos); // e.g. Array ( [Class] =&gt; 0 [AnchorX] =&gt; -549 [AnchorY] =&gt; 1548 )&nbsp;</div></li><li><div>                //Mark Class is = $MarkRecord['Class']&nbsp;</div></li><li><div>                // Get the relevant LigatureRecord&nbsp;</div></li><li><div>                $this-&gt;seek($LigatureArray);&nbsp;</div></li><li><div>                $LigatureCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $LigaturePos = strpos($LigatureGlyphs, $this-&gt;OTLdata[$matchedpos]['hex']) / 6;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Move to the LigatureAttach table Record we want&nbsp;</div></li><li><div>                $nSkip = (2 * $LigaturePos);&nbsp;</div></li><li><div>                $this-&gt;skip($nSkip);&nbsp;</div></li><li><div>                $LigatureAttachOffset = $LigatureArray + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $this-&gt;seek($LigatureAttachOffset);&nbsp;</div></li><li><div>                $ComponentCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $offsets = array();&nbsp;</div></li><li><div>                for ($comp = 0; $comp &lt; $ComponentCount; $comp++) {&nbsp;</div></li><li><div>                    // ComponentRecords&nbsp;</div></li><li><div>                    for ($class = 0; $class &lt; $ClassCount; $class++) {&nbsp;</div></li><li><div>                        $offsets[$comp][$class] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Get the specific component for this mark attachment&nbsp;</div></li><li><div>                if (isset($this-&gt;assocLigs[$matchedpos]) && isset($this-&gt;assocMarks[$ptr]['ligPos']) && $this-&gt;assocMarks[$ptr]['ligPos'] == $matchedpos) {&nbsp;</div></li><li><div>                    $component = $this-&gt;assocMarks[$ptr]['compID'];&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $component = $ComponentCount - 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $offset = $offsets[$component][$MarkRecord['Class']];&nbsp;</div></li><li><div>                if ($offset != 0) {&nbsp;</div></li><li><div>                    $LigatureRecordOffset = $offset + $LigatureAttachOffset;&nbsp;</div></li><li><div>                    list($x, $y) = $this-&gt;_getAnchorTable($LigatureRecordOffset);&nbsp;</div></li><li><div>                    $LigatureRecord = array('AnchorX' =&gt; $x, 'AnchorY' =&gt; $y);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Need default XAdvance for Ligature glyph&nbsp;</div></li><li><div>                    $LigatureWidth = $this-&gt;mpdf-&gt;_getCharWidth($this-&gt;mpdf-&gt;CurrentFont['cw'], $this-&gt;OTLdata[$matchedpos]['uni']) * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000; // convert back to font design units&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $LigatureWidth;&nbsp;</div></li><li><div>                    // And any intervening (ignored)characters&nbsp;</div></li><li><div>                    if (($ptr - $matchedpos) &gt; 1) {&nbsp;</div></li><li><div>                        for ($i = $matchedpos + 1; $i &lt; $ptr; $i++) {&nbsp;</div></li><li><div>                            $LigatureWidthExtra = $this-&gt;mpdf-&gt;_getCharWidth($this-&gt;mpdf-&gt;CurrentFont['cw'], $this-&gt;OTLdata[$i]['uni']) * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000; // convert back to font design units&nbsp;</div></li><li><div>                            $this-&gt;OTLdata[$ptr]['GPOSinfo']['BaseWidth'] += $LigatureWidthExtra;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // Align to previous Ligature by attachment - so need to add to previous placement values&nbsp;</div></li><li><div>                    if (isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['XPlacement']))&nbsp;</div></li><li><div>                        $prevXPlacement = $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['XPlacement'];&nbsp;</div></li><li><div>                    else {&nbsp;</div></li><li><div>                        $prevXPlacement = 0;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if (isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['YPlacement'])) {&nbsp;</div></li><li><div>                        $prevYPlacement = $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['YPlacement'];&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $prevYPlacement = 0;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$ptr]['GPOSinfo']['XPlacement'] = $prevXPlacement + $LigatureRecord['AnchorX'] - $MarkRecord['AnchorX'];&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$ptr]['GPOSinfo']['YPlacement'] = $prevYPlacement + $LigatureRecord['AnchorY'] - $MarkRecord['AnchorY'];&nbsp;</div></li><li><div>                    if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                        $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    return 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 6: MarkToMark attachment  Attach a combining mark to another mark&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 6) {&nbsp;</div></li><li><div>            $Mark1Coverage = $subtable_offset + $this-&gt;read_ushort(); // Combining Mark&nbsp;</div></li><li><div>            //$Mark1Coverage is already set in $LuCoverage 0065|0073 etc&nbsp;</div></li><li><div>            $Mark2Coverage = $subtable_offset + $this-&gt;read_ushort(); // Base Mark&nbsp;</div></li><li><div>            $ClassCount = $this-&gt;read_ushort(); // Number of classes defined for marks = No. of Combining mark1 glyphs in the MarkCoverage table&nbsp;</div></li><li><div>            $Mark1Array = $subtable_offset + $this-&gt;read_ushort(); // Offset to MarkArray table&nbsp;</div></li><li><div>            $Mark2Array = $subtable_offset + $this-&gt;read_ushort(); // Offset to Mark2Array table&nbsp;</div></li><li><div>            $this-&gt;seek($Mark2Coverage);&nbsp;</div></li><li><div>            $Mark2Glyphs = implode('|', $this-&gt;_getCoverage());&nbsp;</div></li><li><div>            $checkpos = $ptr;&nbsp;</div></li><li><div>            $checkpos--;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($this-&gt;OTLdata[$checkpos]) && strpos($Mark2Glyphs, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $matchedpos = $checkpos;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $matchedpos = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($matchedpos !== false) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Get the relevant MarkRecord&nbsp;</div></li><li><div>                $Mark1Pos = $LuCoverage[$currGID];&nbsp;</div></li><li><div>                $Mark1Record = $this-&gt;_getMarkRecord($Mark1Array, $Mark1Pos); // e.g. Array ( [Class] =&gt; 0 [AnchorX] =&gt; -549 [AnchorY] =&gt; 1548 )&nbsp;</div></li><li><div>                //Mark Class is = $Mark1Record['Class']&nbsp;</div></li><li><div>                // Get the relevant Mark2Record&nbsp;</div></li><li><div>                $this-&gt;seek($Mark2Array);&nbsp;</div></li><li><div>                $Mark2Count = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $Mark2Pos = strpos($Mark2Glyphs, $this-&gt;OTLdata[$matchedpos]['hex']) / 6;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Move to the Mark2Record we want&nbsp;</div></li><li><div>                $nSkip = (2 * $Mark2Pos * $ClassCount );&nbsp;</div></li><li><div>                $this-&gt;skip($nSkip);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Read Mark2Record we want for appropriate Class&nbsp;</div></li><li><div>                $nSkip = 2 * $Mark1Record['Class'];&nbsp;</div></li><li><div>                $this-&gt;skip($nSkip);&nbsp;</div></li><li><div>                $Mark2RecordOffset = $Mark2Array + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                list($x, $y) = $this-&gt;_getAnchorTable($Mark2RecordOffset);&nbsp;</div></li><li><div>                $Mark2Record = array('AnchorX' =&gt; $x, 'AnchorY' =&gt; $y); // e.g. Array ( [AnchorX] =&gt; 660 [AnchorY] =&gt; 1556 )&nbsp;</div></li><li><div>                // Need default XAdvance for Mark2 glyph&nbsp;</div></li><li><div>                $Mark2Width = $this-&gt;mpdf-&gt;_getCharWidth($this-&gt;mpdf-&gt;CurrentFont['cw'], $this-&gt;OTLdata[$matchedpos]['uni']) * $this-&gt;mpdf-&gt;CurrentFont['unitsPerEm'] / 1000; // convert back to font design units&nbsp;</div></li><li><div>                // IF combining marks are set on different components of a ligature glyph, do not apply this rule&nbsp;</div></li><li><div>                // Test: arabictypesetting: &#x625;&#x650;&#x644;&#x64e;&#x649;&#x670;&#x653;&nbsp;</div></li><li><div>                // Test: arabictypesetting: &#x628;&#x651;&#x64e;&#x64a;&#x652;&#x646;&#x64e;&#x643;&#x64f;&#x645;&#x652;&nbsp;</div></li><li><div>                $prevLig = -1;&nbsp;</div></li><li><div>                $thisLig = -1;&nbsp;</div></li><li><div>                $prevComp = -1;&nbsp;</div></li><li><div>                $thisComp = -1;&nbsp;</div></li><li><div>                if (isset($this-&gt;assocMarks[$matchedpos])) {&nbsp;</div></li><li><div>                    $prevLig = $this-&gt;assocMarks[$matchedpos]['ligPos'];&nbsp;</div></li><li><div>                    $prevComp = $this-&gt;assocMarks[$matchedpos]['compID'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if (isset($this-&gt;assocMarks[$ptr])) {&nbsp;</div></li><li><div>                    $thisLig = $this-&gt;assocMarks[$ptr]['ligPos'];&nbsp;</div></li><li><div>                    $thisComp = $this-&gt;assocMarks[$ptr]['compID'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // However IF Mark2 (first in logical order, i.e. being attached to) is not associated with a base, carry on&nbsp;</div></li><li><div>                // This happens in Indic when the Mark being attached to e.g. [Halant Ma lig] -&gt; MatraU, [U+0B4D + U+B2E as E0F5]-&gt; U+0B41 become E135&nbsp;</div></li><li><div>                if (!defined(&quot;OMIT_OTL_FIX_1&quot;) || OMIT_OTL_FIX_1 != 1) {&nbsp;</div></li><li><div>                    /** OTL_FIX_1 */&nbsp;</div></li><li><div>                    if (isset($this-&gt;assocMarks[$matchedpos]) && ($prevLig != $thisLig || $prevComp != $thisComp )) {&nbsp;</div></li><li><div>                        return 0;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    /** Original code */&nbsp;</div></li><li><div>                    if ($prevLig != $thisLig || $prevComp != $thisComp) {&nbsp;</div></li><li><div>                        return 0;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!defined(&quot;OMIT_OTL_FIX_2&quot;) || OMIT_OTL_FIX_2 != 1) {&nbsp;</div></li><li><div>                    /** OTL_FIX_2 */&nbsp;</div></li><li><div>                    if (!isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) || !$this-&gt;OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) {&nbsp;</div></li><li><div>                        $this-&gt;OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $Mark2Width;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // ZZZ99Q - Test Case font-family: garuda &#xe19;&#xe49;&#xe33;&nbsp;</div></li><li><div>                if (isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) && $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['BaseWidth']) {&nbsp;</div></li><li><div>                    $this-&gt;OTLdata[$ptr]['GPOSinfo']['BaseWidth'] = $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['BaseWidth'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // Align to previous Mark by attachment - so need to add the previous placement values&nbsp;</div></li><li><div>                $prevXPlacement = (isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['XPlacement']) ? $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['XPlacement'] : 0);&nbsp;</div></li><li><div>                $prevYPlacement = (isset($this-&gt;OTLdata[$matchedpos]['GPOSinfo']['YPlacement']) ? $this-&gt;OTLdata[$matchedpos]['GPOSinfo']['YPlacement'] : 0);&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$ptr]['GPOSinfo']['XPlacement'] = $prevXPlacement + $Mark2Record['AnchorX'] - $Mark1Record['AnchorX'];&nbsp;</div></li><li><div>                $this-&gt;OTLdata[$ptr]['GPOSinfo']['YPlacement'] = $prevYPlacement + $Mark2Record['AnchorY'] - $Mark1Record['AnchorY'];&nbsp;</div></li><li><div>                if ($this-&gt;debugOTL) {&nbsp;</div></li><li><div>                    $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 7: Context positioning    Position one or more glyphs in context&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 7) {&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            if ($PosFormat == 1) {&nbsp;</div></li><li><div>                throw new MpdfException(&quot;GPOS Lookup Type &quot; . $Type . &quot; Format &quot; . $PosFormat . &quot; not TESTED YET.&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            else if ($PosFormat == 2) {&nbsp;</div></li><li><div>                $CoverageTableOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $InputClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $PosClassSetCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $PosClassSetOffset = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $PosClassSetCnt; $b++) {&nbsp;</div></li><li><div>                    $offset = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    if ($offset == 0x0000) {&nbsp;</div></li><li><div>                        $PosClassSetOffset[] = $offset;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $PosClassSetOffset[] = $subtable_offset + $offset;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $InputClasses = $this-&gt;_getClasses($InputClassDefOffset);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                for ($s = 0; $s &lt; $PosClassSetCnt; $s++) { // $ChainPosClassSet is ordered by input class-may be NULL&nbsp;</div></li><li><div>                    // Select $PosClassSet if currGlyph is in First Input Class&nbsp;</div></li><li><div>                    if ($PosClassSetOffset[$s] &gt; 0 && isset($InputClasses[$s][$currGID])) {&nbsp;</div></li><li><div>                        $this-&gt;seek($PosClassSetOffset[$s]);&nbsp;</div></li><li><div>                        $PosClassRuleCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $PosClassRule = array();&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $PosClassRuleCnt; $b++) {&nbsp;</div></li><li><div>                            $PosClassRule[$b] = $PosClassSetOffset[$s] + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $PosClassRuleCnt; $b++) {  // EACH RULE&nbsp;</div></li><li><div>                            $this-&gt;seek($PosClassRule[$b]);&nbsp;</div></li><li><div>                            $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $PosCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $Input = array();&nbsp;</div></li><li><div>                            for ($r = 1; $r &lt; $InputGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Input[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $inputClass = $s;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $inputGlyphs = array();&nbsp;</div></li><li><div>                            $inputGlyphs[0] = $InputClasses[$inputClass];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($InputGlyphCount &gt; 1) {&nbsp;</div></li><li><div>                                //  NB starts at 1&nbsp;</div></li><li><div>                                for ($gcl = 1; $gcl &lt; $InputGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Input[$gcl];&nbsp;</div></li><li><div>                                    if (isset($InputClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = $InputClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $class0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($InputClasses); $gc++) {&nbsp;</div></li><li><div>                                if (is_array($InputClasses[$gc]))&nbsp;</div></li><li><div>                                    $class0excl = $class0excl + $InputClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $backtrackGlyphs = array();&nbsp;</div></li><li><div>                            $lookaheadGlyphs = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $matched = $this-&gt;checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl);&nbsp;</div></li><li><div>                            if ($matched) {&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $PosCount; $p++) { // EACH LOOKUP&nbsp;</div></li><li><div>                                    $SequenceIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                    $LookupListIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $PosCount; $p++) {&nbsp;</div></li><li><div>                                    // Apply  $LookupListIndex  at   $SequenceIndex&nbsp;</div></li><li><div>                                    if ($SequenceIndex[$p] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                                        continue;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    $lu = $LookupListIndex[$p];&nbsp;</div></li><li><div>                                    $luType = $this-&gt;GPOSLookups[$lu]['Type'];&nbsp;</div></li><li><div>                                    $luFlag = $this-&gt;GPOSLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                                    $luMarkFilteringSet = $this-&gt;GPOSLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    $luptr = $matched[$SequenceIndex[$p]];&nbsp;</div></li><li><div>                                    $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                                    $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    foreach ($this-&gt;GPOSLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                                        $shift = $this-&gt;_applyGPOSsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GPOS_offset + $this-&gt;GSUB_length), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;LuCoverage[$lu][$luc], $tag, 1, $is_old_spec);&nbsp;</div></li><li><div>                                        if ($this-&gt;debugOTL && $shift) {&nbsp;</div></li><li><div>                                            $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                        if ($shift) {&nbsp;</div></li><li><div>                                            break;&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                if (!defined(&quot;OMIT_OTL_FIX_3&quot;) || OMIT_OTL_FIX_3 != 1) {&nbsp;</div></li><li><div>                                    return $shift;&nbsp;</div></li><li><div>                                } /** OTL_FIX_3 */&nbsp;</div></li><li><div>                                else&nbsp;</div></li><li><div>                                    return $InputGlyphCount; // should be + matched ignores in Input Sequence&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 3:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            else if ($PosFormat == 3) {&nbsp;</div></li><li><div>                throw new MpdfException(&quot;GPOS Lookup Type &quot; . $Type . &quot; Format &quot; . $PosFormat . &quot; not TESTED YET.&quot;);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                throw new MpdfException(&quot;GPOS Lookup Type &quot; . $Type . &quot;, Format &quot; . $PosFormat . &quot; not supported.&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        // LookupType 8: Chained Context positioning    Position one or more glyphs in chained context&nbsp;</div></li><li><div>        ////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>        else if ($Type == 8) {&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 1:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            if ($PosFormat == 1) {&nbsp;</div></li><li><div>                throw new MpdfException(&quot;GPOS Lookup Type &quot; . $Type . &quot; Format &quot; . $PosFormat . &quot; not TESTED YET.&quot;);&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 2:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            else if ($PosFormat == 2) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $CoverageTableOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $BacktrackClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $InputClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $LookaheadClassDefOffset = $subtable_offset + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ChainPosClassSetCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $ChainPosClassSetOffset = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $ChainPosClassSetCnt; $b++) {&nbsp;</div></li><li><div>                    $offset = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    if ($offset == 0x0000) {&nbsp;</div></li><li><div>                        $ChainPosClassSetOffset[] = $offset;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $ChainPosClassSetOffset[] = $subtable_offset + $offset;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $BacktrackClasses = $this-&gt;_getClasses($BacktrackClassDefOffset);&nbsp;</div></li><li><div>                $InputClasses = $this-&gt;_getClasses($InputClassDefOffset);&nbsp;</div></li><li><div>                $LookaheadClasses = $this-&gt;_getClasses($LookaheadClassDefOffset);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                for ($s = 0; $s &lt; $ChainPosClassSetCnt; $s++) { // $ChainPosClassSet is ordered by input class-may be NULL&nbsp;</div></li><li><div>                    // Select $ChainPosClassSet if currGlyph is in First Input Class&nbsp;</div></li><li><div>                    if ($ChainPosClassSetOffset[$s] &gt; 0 && isset($InputClasses[$s][$currGID])) {&nbsp;</div></li><li><div>                        $this-&gt;seek($ChainPosClassSetOffset[$s]);&nbsp;</div></li><li><div>                        $ChainPosClassRuleCnt = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $ChainPosClassRule = array();&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $ChainPosClassRuleCnt; $b++) {&nbsp;</div></li><li><div>                            $ChainPosClassRule[$b] = $ChainPosClassSetOffset[$s] + $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        for ($b = 0; $b &lt; $ChainPosClassRuleCnt; $b++) {  // EACH RULE&nbsp;</div></li><li><div>                            $this-&gt;seek($ChainPosClassRule[$b]);&nbsp;</div></li><li><div>                            $BacktrackGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $Backtrack = array();&nbsp;</div></li><li><div>                            for ($r = 0; $r &lt; $BacktrackGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Backtrack[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $Input = array();&nbsp;</div></li><li><div>                            for ($r = 1; $r &lt; $InputGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Input[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            $LookaheadGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            $Lookahead = array();&nbsp;</div></li><li><div>                            for ($r = 0; $r &lt; $LookaheadGlyphCount; $r++) {&nbsp;</div></li><li><div>                                $Lookahead[$r] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $inputClass = $s; //???&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $inputGlyphs = array();&nbsp;</div></li><li><div>                            $inputGlyphs[0] = $InputClasses[$inputClass];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($InputGlyphCount &gt; 1) {&nbsp;</div></li><li><div>                                //  NB starts at 1&nbsp;</div></li><li><div>                                for ($gcl = 1; $gcl &lt; $InputGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Input[$gcl];&nbsp;</div></li><li><div>                                    if (isset($InputClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = $InputClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $inputGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $class0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($InputClasses); $gc++) {&nbsp;</div></li><li><div>                                if (isset($InputClasses[$gc]) && is_array($InputClasses[$gc]))&nbsp;</div></li><li><div>                                    $class0excl = $class0excl + $InputClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($BacktrackGlyphCount) {&nbsp;</div></li><li><div>                                $backtrackGlyphs = array();&nbsp;</div></li><li><div>                                for ($gcl = 0; $gcl &lt; $BacktrackGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Backtrack[$gcl];&nbsp;</div></li><li><div>                                    if (isset($BacktrackClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $backtrackGlyphs[$gcl] = $BacktrackClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $backtrackGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $backtrackGlyphs = array();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $bclass0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($BacktrackClasses); $gc++) {&nbsp;</div></li><li><div>                                if (isset($BacktrackClasses[$gc]) && is_array($BacktrackClasses[$gc]))&nbsp;</div></li><li><div>                                    $bclass0excl = $bclass0excl + $BacktrackClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            if ($LookaheadGlyphCount) {&nbsp;</div></li><li><div>                                $lookaheadGlyphs = array();&nbsp;</div></li><li><div>                                for ($gcl = 0; $gcl &lt; $LookaheadGlyphCount; $gcl++) {&nbsp;</div></li><li><div>                                    $classindex = $Lookahead[$gcl];&nbsp;</div></li><li><div>                                    if (isset($LookaheadClasses[$classindex])) {&nbsp;</div></li><li><div>                                        $lookaheadGlyphs[$gcl] = $LookaheadClasses[$classindex];&nbsp;</div></li><li><div>                                    } else {&nbsp;</div></li><li><div>                                        $lookaheadGlyphs[$gcl] = '';&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $lookaheadGlyphs = array();&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            // Class 0 contains all the glyphs NOT in the other classes&nbsp;</div></li><li><div>                            $lclass0excl = array();&nbsp;</div></li><li><div>                            for ($gc = 1; $gc &lt;= count($LookaheadClasses); $gc++) {&nbsp;</div></li><li><div>                                if (isset($LookaheadClasses[$gc]) && is_array($LookaheadClasses[$gc]))&nbsp;</div></li><li><div>                                    $lclass0excl = $lclass0excl + $LookaheadClasses[$gc];&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            $matched = $this-&gt;checkContextMatchMultipleUni($inputGlyphs, $backtrackGlyphs, $lookaheadGlyphs, $ignore, $ptr, $class0excl, $bclass0excl, $lclass0excl);&nbsp;</div></li><li><div>                            if ($matched) {&nbsp;</div></li><li><div>                                $PosCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                $SequenceIndex = array();&nbsp;</div></li><li><div>                                $LookupListIndex = array();&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $PosCount; $p++) { // EACH LOOKUP&nbsp;</div></li><li><div>                                    $SequenceIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                    $LookupListIndex[$p] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                for ($p = 0; $p &lt; $PosCount; $p++) {&nbsp;</div></li><li><div>                                    // Apply  $LookupListIndex  at   $SequenceIndex&nbsp;</div></li><li><div>                                    if ($SequenceIndex[$p] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                                        continue;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                    $lu = $LookupListIndex[$p];&nbsp;</div></li><li><div>                                    $luType = $this-&gt;GPOSLookups[$lu]['Type'];&nbsp;</div></li><li><div>                                    $luFlag = $this-&gt;GPOSLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                                    $luMarkFilteringSet = $this-&gt;GPOSLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    $luptr = $matched[$SequenceIndex[$p]];&nbsp;</div></li><li><div>                                    $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                                    $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                    foreach ($this-&gt;GPOSLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                                        $shift = $this-&gt;_applyGPOSsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GPOS_offset + $this-&gt;GSUB_length), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;LuCoverage[$lu][$luc], $tag, 1, $is_old_spec);&nbsp;</div></li><li><div>                                        if ($this-&gt;debugOTL && $shift) {&nbsp;</div></li><li><div>                                            $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                        if ($shift) {&nbsp;</div></li><li><div>                                            break;&nbsp;</div></li><li><div>                                        }&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                if (!defined(&quot;OMIT_OTL_FIX_3&quot;) || OMIT_OTL_FIX_3 != 1) {&nbsp;</div></li><li><div>                                    return $shift;&nbsp;</div></li><li><div>                                } /** OTL_FIX_3 */&nbsp;</div></li><li><div>                                else&nbsp;</div></li><li><div>                                    return $InputGlyphCount; // should be + matched ignores in Input Sequence&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                return 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            // Format 3:&nbsp;</div></li><li><div>            //===========&nbsp;</div></li><li><div>            else if ($PosFormat == 3) {&nbsp;</div></li><li><div>                $BacktrackGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $BacktrackGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $CoverageBacktrackOffset[] = $subtable_offset + $this-&gt;read_ushort(); // in glyph sequence order&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $InputGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $InputGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $CoverageInputOffset[] = $subtable_offset + $this-&gt;read_ushort(); // in glyph sequence order&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $LookaheadGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $LookaheadGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $CoverageLookaheadOffset[] = $subtable_offset + $this-&gt;read_ushort(); // in glyph sequence order&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $PosCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $save_pos = $this-&gt;_pos; // Save the point just after PosCount&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $CoverageBacktrackGlyphs = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $BacktrackGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $this-&gt;seek($CoverageBacktrackOffset[$b]);&nbsp;</div></li><li><div>                    $glyphs = $this-&gt;_getCoverage();&nbsp;</div></li><li><div>                    $CoverageBacktrackGlyphs[$b] = implode(&quot;|&quot;, $glyphs);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $CoverageInputGlyphs = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $InputGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $this-&gt;seek($CoverageInputOffset[$b]);&nbsp;</div></li><li><div>                    $glyphs = $this-&gt;_getCoverage();&nbsp;</div></li><li><div>                    $CoverageInputGlyphs[$b] = implode(&quot;|&quot;, $glyphs);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $CoverageLookaheadGlyphs = array();&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $LookaheadGlyphCount; $b++) {&nbsp;</div></li><li><div>                    $this-&gt;seek($CoverageLookaheadOffset[$b]);&nbsp;</div></li><li><div>                    $glyphs = $this-&gt;_getCoverage();&nbsp;</div></li><li><div>                    $CoverageLookaheadGlyphs[$b] = implode(&quot;|&quot;, $glyphs);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $matched = $this-&gt;checkContextMatchMultiple($CoverageInputGlyphs, $CoverageBacktrackGlyphs, $CoverageLookaheadGlyphs, $ignore, $ptr);&nbsp;</div></li><li><div>                if ($matched) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $this-&gt;seek($save_pos); // Return to just after PosCount&nbsp;</div></li><li><div>                    for ($p = 0; $p &lt; $PosCount; $p++) {&nbsp;</div></li><li><div>                        // PosLookupRecord&nbsp;</div></li><li><div>                        $PosLookupRecord[$p]['SequenceIndex'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                        $PosLookupRecord[$p]['LookupListIndex'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    for ($p = 0; $p &lt; $PosCount; $p++) {&nbsp;</div></li><li><div>                        // Apply  $PosLookupRecord[$p]['LookupListIndex']  at   $PosLookupRecord[$p]['SequenceIndex']&nbsp;</div></li><li><div>                        if ($PosLookupRecord[$p]['SequenceIndex'] &gt;= $InputGlyphCount) {&nbsp;</div></li><li><div>                            continue;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        $lu = $PosLookupRecord[$p]['LookupListIndex'];&nbsp;</div></li><li><div>                        $luType = $this-&gt;GPOSLookups[$lu]['Type'];&nbsp;</div></li><li><div>                        $luFlag = $this-&gt;GPOSLookups[$lu]['Flag'];&nbsp;</div></li><li><div>                        if (isset($this-&gt;GPOSLookups[$lu]['MarkFilteringSet'])) {&nbsp;</div></li><li><div>                            $luMarkFilteringSet = $this-&gt;GPOSLookups[$lu]['MarkFilteringSet'];&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $luMarkFilteringSet = '';&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $luptr = $matched[$PosLookupRecord[$p]['SequenceIndex']];&nbsp;</div></li><li><div>                        $lucurrGlyph = $this-&gt;OTLdata[$luptr]['hex'];&nbsp;</div></li><li><div>                        $lucurrGID = $this-&gt;OTLdata[$luptr]['uni'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        foreach ($this-&gt;GPOSLookups[$lu]['Subtables'] AS $luc =&gt; $lusubtable_offset) {&nbsp;</div></li><li><div>                            $shift = $this-&gt;_applyGPOSsubtable($lu, $luc, $luptr, $lucurrGlyph, $lucurrGID, ($lusubtable_offset - $this-&gt;GPOS_offset + $this-&gt;GSUB_length), $luType, $luFlag, $luMarkFilteringSet, $this-&gt;LuCoverage[$lu][$luc], $tag, 1, $is_old_spec);&nbsp;</div></li><li><div>                            if ($this-&gt;debugOTL && $shift) {&nbsp;</div></li><li><div>                                $this-&gt;_dumpproc('GPOS', $lookupID, $subtable, $Type, $PosFormat, $ptr, $currGlyph, $level);&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if ($shift) {&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                throw new MpdfException(&quot;GPOS Lookup Type &quot; . $Type . &quot;, Format &quot; . $PosFormat . &quot; not supported.&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            throw new MpdfException(&quot;GPOS Lookup Type &quot; . $Type . &quot; not supported.&quot;);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    //////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>    //////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>    // GPOS / GSUB / GCOM (common) functions&nbsp;</div></li><li><div>    //////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>    //////////////////////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function checkContextMatch($Input, $Backtrack, $Lookahead, $ignore, $ptr)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // Input etc are single numbers - GSUB Format 6.1&nbsp;</div></li><li><div>        // Input starts with (1=&gt;xxx)&nbsp;</div></li><li><div>        // return false if no match, else an array of ptr for matches (0=&gt;0, 1=&gt;3, ...)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $current_syllable = (isset($this-&gt;OTLdata[$ptr]['syllable']) ? $this-&gt;OTLdata[$ptr]['syllable'] : 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // BACKTRACK&nbsp;</div></li><li><div>        $checkpos = $ptr;&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($Backtrack); $i++) {&nbsp;</div></li><li><div>            $checkpos--;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            } else if (!isset($this-&gt;OTLdata[$checkpos]) || $this-&gt;OTLdata[$checkpos]['uni'] != $Backtrack[$i]) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // INPUT&nbsp;</div></li><li><div>        $matched = array(0 =&gt; $ptr);&nbsp;</div></li><li><div>        $checkpos = $ptr;&nbsp;</div></li><li><div>        for ($i = 1; $i &lt; count($Input); $i++) {&nbsp;</div></li><li><div>            $checkpos++;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            } else if (isset($this-&gt;OTLdata[$checkpos]) && $this-&gt;OTLdata[$checkpos]['uni'] == $Input[$i]) {&nbsp;</div></li><li><div>                $matched[] = $checkpos;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // LOOKAHEAD&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($Lookahead); $i++) {&nbsp;</div></li><li><div>            $checkpos++;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            } else if (!isset($this-&gt;OTLdata[$checkpos]) || $this-&gt;OTLdata[$checkpos]['uni'] != $Lookahead[$i]) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $matched;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function checkContextMatchMultiple($Input, $Backtrack, $Lookahead, $ignore, $ptr, $class0excl = '', $bclass0excl = '', $lclass0excl = '')&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // Input etc are string/array of glyph strings  - GSUB Format 5.2, 5.3, 6.2, 6.3, GPOS Format 7.2, 7.3, 8.2, 8.3&nbsp;</div></li><li><div>        // Input starts with (1=&gt;xxx)&nbsp;</div></li><li><div>        // return false if no match, else an array of ptr for matches (0=&gt;0, 1=&gt;3, ...)&nbsp;</div></li><li><div>        // $class0excl is the string of glyphs in all classes except Class 0 (GSUB 5.2, 6.2, GPOS 7.2, 8.2)&nbsp;</div></li><li><div>        // $bclass0excl & $lclass0excl are the same for lookahead and backtrack (GSUB 6.2, GPOS 8.2)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $current_syllable = (isset($this-&gt;OTLdata[$ptr]['syllable']) ? $this-&gt;OTLdata[$ptr]['syllable'] : 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // BACKTRACK&nbsp;</div></li><li><div>        $checkpos = $ptr;&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($Backtrack); $i++) {&nbsp;</div></li><li><div>            $checkpos--;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If Class 0 specified, matches anything NOT in $bclass0excl&nbsp;</div></li><li><div>            else if (!$Backtrack[$i] && isset($this-&gt;OTLdata[$checkpos]) && strpos($bclass0excl, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            } else if (!isset($this-&gt;OTLdata[$checkpos]) || strpos($Backtrack[$i], $this-&gt;OTLdata[$checkpos]['hex']) === false) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // INPUT&nbsp;</div></li><li><div>        $matched = array(0 =&gt; $ptr);&nbsp;</div></li><li><div>        $checkpos = $ptr;&nbsp;</div></li><li><div>        for ($i = 1; $i &lt; count($Input); $i++) { // Start at 1 - already matched the first InputGlyph&nbsp;</div></li><li><div>            $checkpos++;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If Input Class 0 specified, matches anything NOT in $class0excl&nbsp;</div></li><li><div>            else if (!$Input[$i] && isset($this-&gt;OTLdata[$checkpos]) && strpos($class0excl, $this-&gt;OTLdata[$checkpos]['hex']) === false) {&nbsp;</div></li><li><div>                $matched[] = $checkpos;&nbsp;</div></li><li><div>            } else if (isset($this-&gt;OTLdata[$checkpos]) && strpos($Input[$i], $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $matched[] = $checkpos;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // LOOKAHEAD&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($Lookahead); $i++) {&nbsp;</div></li><li><div>            $checkpos++;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If Class 0 specified, matches anything NOT in $lclass0excl&nbsp;</div></li><li><div>            else if (!$Lookahead[$i] && isset($this-&gt;OTLdata[$checkpos]) && strpos($lclass0excl, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            } else if (!isset($this-&gt;OTLdata[$checkpos]) || strpos($Lookahead[$i], $this-&gt;OTLdata[$checkpos]['hex']) === false) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $matched;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function checkContextMatchMultipleUni($Input, $Backtrack, $Lookahead, $ignore, $ptr, $class0excl = array(), $bclass0excl = array(), $lclass0excl = array())&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // Input etc are array of glyphs - GSUB Format 5.2, 5.3, 6.2, 6.3, GPOS Format 7.2, 7.3, 8.2, 8.3&nbsp;</div></li><li><div>        // Input starts with (1=&gt;xxx)&nbsp;</div></li><li><div>        // return false if no match, else an array of ptr for matches (0=&gt;0, 1=&gt;3, ...)&nbsp;</div></li><li><div>        // $class0excl is array of glyphs in all classes except Class 0 (GSUB 5.2, 6.2, GPOS 7.2, 8.2)&nbsp;</div></li><li><div>        // $bclass0excl & $lclass0excl are the same for lookahead and backtrack (GSUB 6.2, GPOS 8.2)&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $current_syllable = (isset($this-&gt;OTLdata[$ptr]['syllable']) ? $this-&gt;OTLdata[$ptr]['syllable'] : 0);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // BACKTRACK&nbsp;</div></li><li><div>        $checkpos = $ptr;&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($Backtrack); $i++) {&nbsp;</div></li><li><div>            $checkpos--;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If Class 0 specified, matches anything NOT in $bclass0excl&nbsp;</div></li><li><div>            else if (!$Backtrack[$i] && isset($this-&gt;OTLdata[$checkpos]) && isset($bclass0excl[$this-&gt;OTLdata[$checkpos]['uni']])) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            } else if (!isset($this-&gt;OTLdata[$checkpos]) || !isset($Backtrack[$i][$this-&gt;OTLdata[$checkpos]['uni']])) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // INPUT&nbsp;</div></li><li><div>        $matched = array(0 =&gt; $ptr);&nbsp;</div></li><li><div>        $checkpos = $ptr;&nbsp;</div></li><li><div>        for ($i = 1; $i &lt; count($Input); $i++) { // Start at 1 - already matched the first InputGlyph&nbsp;</div></li><li><div>            $checkpos++;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If Input Class 0 specified, matches anything NOT in $class0excl&nbsp;</div></li><li><div>            else if (!$Input[$i] && isset($this-&gt;OTLdata[$checkpos]) && !isset($class0excl[$this-&gt;OTLdata[$checkpos]['uni']])) {&nbsp;</div></li><li><div>                $matched[] = $checkpos;&nbsp;</div></li><li><div>            } else if (isset($this-&gt;OTLdata[$checkpos]) && isset($Input[$i][$this-&gt;OTLdata[$checkpos]['uni']])) {&nbsp;</div></li><li><div>                $matched[] = $checkpos;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // LOOKAHEAD&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($Lookahead); $i++) {&nbsp;</div></li><li><div>            $checkpos++;&nbsp;</div></li><li><div>            while (isset($this-&gt;OTLdata[$checkpos]) && strpos($ignore, $this-&gt;OTLdata[$checkpos]['hex']) !== false) {&nbsp;</div></li><li><div>                $checkpos++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If outside scope of current syllable - return no match&nbsp;</div></li><li><div>            if ($this-&gt;restrictToSyllable && isset($this-&gt;OTLdata[$checkpos]['syllable']) && $this-&gt;OTLdata[$checkpos]['syllable'] != $current_syllable) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // If Class 0 specified, matches anything NOT in $lclass0excl&nbsp;</div></li><li><div>            else if (!$Lookahead[$i] && isset($this-&gt;OTLdata[$checkpos]) && isset($lclass0excl[$this-&gt;OTLdata[$checkpos]['uni']])) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            } else if (!isset($this-&gt;OTLdata[$checkpos]) || !isset($Lookahead[$i][$this-&gt;OTLdata[$checkpos]['uni']])) {&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $matched;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getClassDefinitionTable($offset)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (isset($this-&gt;LuDataCache[$this-&gt;fontkey][$offset])) {&nbsp;</div></li><li><div>            $GlyphByClass = $this-&gt;LuDataCache[$this-&gt;fontkey][$offset];&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $this-&gt;seek($offset);&nbsp;</div></li><li><div>            $ClassFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $GlyphClass = array();&nbsp;</div></li><li><div>            //      $GlyphByClass = array(0=&gt;array());  // NB This forces an index[0]&nbsp;</div></li><li><div>            if ($ClassFormat == 1) {&nbsp;</div></li><li><div>                $StartGlyph = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $GlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $GlyphCount; $i++) {&nbsp;</div></li><li><div>                    $GlyphClass[$i]['startGlyphID'] = $StartGlyph + $i;&nbsp;</div></li><li><div>                    $GlyphClass[$i]['endGlyphID'] = $StartGlyph + $i;&nbsp;</div></li><li><div>                    $GlyphClass[$i]['class'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    for ($g = $GlyphClass[$i]['startGlyphID']; $g &lt;= $GlyphClass[$i]['endGlyphID']; $g++) {&nbsp;</div></li><li><div>                        $GlyphByClass[$GlyphClass[$i]['class']][] = $this-&gt;glyphToChar($g);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($ClassFormat == 2) {&nbsp;</div></li><li><div>                $tableCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $tableCount; $i++) {&nbsp;</div></li><li><div>                    $GlyphClass[$i]['startGlyphID'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $GlyphClass[$i]['endGlyphID'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $GlyphClass[$i]['class'] = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    for ($g = $GlyphClass[$i]['startGlyphID']; $g &lt;= $GlyphClass[$i]['endGlyphID']; $g++) {&nbsp;</div></li><li><div>                        $GlyphByClass[$GlyphClass[$i]['class']][] = $this-&gt;glyphToChar($g);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ksort($GlyphByClass);&nbsp;</div></li><li><div>            $this-&gt;LuDataCache[$this-&gt;fontkey][$offset] = $GlyphByClass;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $GlyphByClass;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function count_bits($n)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        for ($c = 0; $n; $c++) {&nbsp;</div></li><li><div>            $n &= $n - 1; // clear the least significant bit set&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $c;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getValueRecord($ValueFormat)&nbsp;</div></li><li><div>    { // Common ValueRecord for GPOS&nbsp;</div></li><li><div>        // Only returns 3 possible: $vra['XPlacement'] $vra['YPlacement'] $vra['XAdvance']&nbsp;</div></li><li><div>        $vra = array();&nbsp;</div></li><li><div>        // Horizontal adjustment for placement - in design units&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0001) == 0x0001) {&nbsp;</div></li><li><div>            $vra['XPlacement'] = $this-&gt;read_short();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Vertical adjustment for placement - in design units&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0002) == 0x0002) {&nbsp;</div></li><li><div>            $vra['YPlacement'] = $this-&gt;read_short();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Horizontal adjustment for advance - in design units (only used for horizontal writing)&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0004) == 0x0004) {&nbsp;</div></li><li><div>            $vra['XAdvance'] = $this-&gt;read_short();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Vertical adjustment for advance - in design units (only used for vertical writing)&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0008) == 0x0008) {&nbsp;</div></li><li><div>            $this-&gt;read_short();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Offset to Device table for horizontal placement-measured from beginning of PosTable (may be NULL)&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0010) == 0x0010) {&nbsp;</div></li><li><div>            $this-&gt;read_ushort();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Offset to Device table for vertical placement-measured from beginning of PosTable (may be NULL)&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0020) == 0x0020) {&nbsp;</div></li><li><div>            $this-&gt;read_ushort();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Offset to Device table for horizontal advance-measured from beginning of PosTable (may be NULL)&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0040) == 0x0040) {&nbsp;</div></li><li><div>            $this-&gt;read_ushort();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Offset to Device table for vertical advance-measured from beginning of PosTable (may be NULL)&nbsp;</div></li><li><div>        if (($ValueFormat & 0x0080) == 0x0080) {&nbsp;</div></li><li><div>            $this-&gt;read_ushort();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $vra;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getAnchorTable($offset = 0)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if ($offset) {&nbsp;</div></li><li><div>            $this-&gt;seek($offset);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $AnchorFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>        $XCoordinate = $this-&gt;read_short();&nbsp;</div></li><li><div>        $YCoordinate = $this-&gt;read_short();&nbsp;</div></li><li><div>        // Format 2 specifies additional link to contour point; Format 3 additional Device table&nbsp;</div></li><li><div>        return array($XCoordinate, $YCoordinate);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getMarkRecord($offset, $MarkPos)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;seek($offset);&nbsp;</div></li><li><div>        $MarkCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>        $this-&gt;skip($MarkPos * 4);&nbsp;</div></li><li><div>        $Class = $this-&gt;read_ushort();&nbsp;</div></li><li><div>        $MarkAnchor = $offset + $this-&gt;read_ushort();  // = Offset to anchor table&nbsp;</div></li><li><div>        list($x, $y) = $this-&gt;_getAnchorTable($MarkAnchor);&nbsp;</div></li><li><div>        $MarkRecord = array('Class' =&gt; $Class, 'AnchorX' =&gt; $x, 'AnchorY' =&gt; $y);&nbsp;</div></li><li><div>        return $MarkRecord;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getGCOMignoreString($flag, $MarkFilteringSet)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // If ignoreFlag set, combine all ignore glyphs into -&gt; &quot;(?:( 0FBA1| 0FBA2| 0FBA3)*)&quot;&nbsp;</div></li><li><div>        // else &quot;()&quot;&nbsp;</div></li><li><div>        // for Input - set on secondary Lookup table if in Context, and set Backtrack and Lookahead on Context Lookup&nbsp;</div></li><li><div>        $str = &quot;&quot;;&nbsp;</div></li><li><div>        $ignoreflag = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Flag & 0xFF?? = MarkAttachmentType&nbsp;</div></li><li><div>        if ($flag & 0xFF00) {&nbsp;</div></li><li><div>            // &quot;a lookup must ignore any mark glyphs that are not in the specified mark attachment class&quot;&nbsp;</div></li><li><div>            // $this-&gt;MarkAttachmentType is already adjusted for this i.e. contains all Marks except those in the MarkAttachmentClassDef table&nbsp;</div></li><li><div>            $MarkAttachmentType = $flag &gt;&gt; 8;&nbsp;</div></li><li><div>            $ignoreflag = $flag;&nbsp;</div></li><li><div>            $str = $this-&gt;MarkAttachmentType[$MarkAttachmentType];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Flag & 0x0010 = UseMarkFilteringSet&nbsp;</div></li><li><div>        if ($flag & 0x0010) {&nbsp;</div></li><li><div>            throw new MpdfException(&quot;This font [&quot; . $this-&gt;fontkey . &quot;] contains MarkGlyphSets - Not tested yet&quot;);&nbsp;</div></li><li><div>            // Change also in ttfontsuni.php&nbsp;</div></li><li><div>            if ($MarkFilteringSet == '')&nbsp;</div></li><li><div>                throw new MpdfException(&quot;This font [&quot; . $this-&gt;fontkey . &quot;] contains MarkGlyphSets - but MarkFilteringSet not set&quot;);&nbsp;</div></li><li><div>            $str = $this-&gt;MarkGlyphSets[$MarkFilteringSet];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If Ignore Marks set, supercedes any above&nbsp;</div></li><li><div>        // Flag & 0x0008 = Ignore Marks - (unless already done with MarkAttachmentType)&nbsp;</div></li><li><div>        if (($flag & 0x0008) == 0x0008 && ($flag & 0xFF00) == 0) {&nbsp;</div></li><li><div>            $ignoreflag = 8;&nbsp;</div></li><li><div>            $str = $this-&gt;GlyphClassMarks;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Flag & 0x0004 = Ignore Ligatures&nbsp;</div></li><li><div>        if (($flag & 0x0004) == 0x0004) {&nbsp;</div></li><li><div>            $ignoreflag += 4;&nbsp;</div></li><li><div>            if ($str) {&nbsp;</div></li><li><div>                $str .= &quot;|&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $str .= $this-&gt;GlyphClassLigatures;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Flag & 0x0002 = Ignore BaseGlyphs&nbsp;</div></li><li><div>        if (($flag & 0x0002) == 0x0002) {&nbsp;</div></li><li><div>            $ignoreflag += 2;&nbsp;</div></li><li><div>            if ($str) {&nbsp;</div></li><li><div>                $str .= &quot;|&quot;;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $str .= $this-&gt;GlyphClassBases;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($str) {&nbsp;</div></li><li><div>            return &quot;((?:(?:&quot; . $str . &quot;))*)&quot;;&nbsp;</div></li><li><div>        } else&nbsp;</div></li><li><div>            return &quot;()&quot;;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _checkGCOMignore($flag, $glyph, $MarkFilteringSet)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $ignore = false;&nbsp;</div></li><li><div>        // Flag & 0x0008 = Ignore Marks - (unless already done with MarkAttachmentType)&nbsp;</div></li><li><div>        if (($flag & 0x0008 && ($flag & 0xFF00) == 0) && strpos($this-&gt;GlyphClassMarks, $glyph)) {&nbsp;</div></li><li><div>            $ignore = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (($flag & 0x0004) && strpos($this-&gt;GlyphClassLigatures, $glyph)) {&nbsp;</div></li><li><div>            $ignore = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (($flag & 0x0002) && strpos($this-&gt;GlyphClassBases, $glyph)) {&nbsp;</div></li><li><div>            $ignore = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Flag & 0xFF?? = MarkAttachmentType&nbsp;</div></li><li><div>        if ($flag & 0xFF00) {&nbsp;</div></li><li><div>            // &quot;a lookup must ignore any mark glyphs that are not in the specified mark attachment class&quot;&nbsp;</div></li><li><div>            // $this-&gt;MarkAttachmentType is already adjusted for this i.e. contains all Marks except those in the MarkAttachmentClassDef table&nbsp;</div></li><li><div>            if (strpos($this-&gt;MarkAttachmentType[($flag &gt;&gt; 8)], $glyph)) {&nbsp;</div></li><li><div>                $ignore = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Flag & 0x0010 = UseMarkFilteringSet&nbsp;</div></li><li><div>        if (($flag & 0x0010) && strpos($this-&gt;MarkGlyphSets[$MarkFilteringSet], $glyph)) {&nbsp;</div></li><li><div>            $ignore = true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $ignore;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>//////////       BIDI ALGORITHM         ////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>// These functions are called from mpdf after GSUB/GPOS has taken place&nbsp;</div></li><li><div>// At this stage the bidi-type is in string form&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>      Bidirectional Character Types&nbsp;</div></li><li><div> =============================&nbsp;</div></li><li><div>      Type  Description     General Scope&nbsp;</div></li><li><div>      Strong&nbsp;</div></li><li><div>      L     Left-to-Right       LRM, most alphabetic, syllabic, Han ideographs, non-European or non-Arabic digits, ...&nbsp;</div></li><li><div>      LRE   Left-to-Right Embedding LRE&nbsp;</div></li><li><div>      LRO   Left-to-Right Override  LRO&nbsp;</div></li><li><div>      R     Right-to-Left       RLM, Hebrew alphabet, and related punctuation&nbsp;</div></li><li><div>      AL    Right-to-Left Arabic    Arabic, Thaana, and Syriac alphabets, most punctuation specific to those scripts, ...&nbsp;</div></li><li><div>      RLE   Right-to-Left Embedding RLE&nbsp;</div></li><li><div>      RLO   Right-to-Left Override  RLO&nbsp;</div></li><li><div>      Weak&nbsp;</div></li><li><div>      PDF   Pop Directional Format      PDF&nbsp;</div></li><li><div>      EN    European Number             European digits, Eastern Arabic-Indic digits, ...&nbsp;</div></li><li><div>      ES    European Number Separator   Plus sign, minus sign&nbsp;</div></li><li><div>      ET    European Number Terminator  Degree sign, currency symbols, ...&nbsp;</div></li><li><div>      AN    Arabic Number           Arabic-Indic digits, Arabic decimal and thousands separators, ...&nbsp;</div></li><li><div>      CS    Common Number Separator     Colon, comma, full stop (period), No-break space, ...&nbsp;</div></li><li><div>      NSM   Nonspacing Mark             Characters marked Mn (Nonspacing_Mark) and Me (Enclosing_Mark) in the Unicode Character Database&nbsp;</div></li><li><div>      BN    Boundary Neutral            Default ignorables, non-characters, and control characters, other than those explicitly given other types.&nbsp;</div></li><li><div>      Neutral&nbsp;</div></li><li><div>      B     Paragraph Separator     Paragraph separator, appropriate Newline Functions, higher-level protocol paragraph determination&nbsp;</div></li><li><div>      S     Segment Separator   Tab&nbsp;</div></li><li><div>      WS    Whitespace          Space, figure space, line separator, form feed, General Punctuation spaces, ...&nbsp;</div></li><li><div>      ON    Other Neutrals      All other characters, including OBJECT REPLACEMENT CHARACTER&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _bidiSort($ta, $str = '', $dir, &$chunkOTLdata, $useGPOS)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $pel = 0; // paragraph embedding level&nbsp;</div></li><li><div>        $maxlevel = 0;&nbsp;</div></li><li><div>        $numchars = count($chunkOTLdata['char_data']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Set the initial paragraph embedding level&nbsp;</div></li><li><div>        if ($dir == 'rtl') {&nbsp;</div></li><li><div>            $pel = 1;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $pel = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // X1. Begin by setting the current embedding level to the paragraph embedding level. Set the directional override status to neutral.&nbsp;</div></li><li><div>        // Current Embedding Level&nbsp;</div></li><li><div>        $cel = $pel;&nbsp;</div></li><li><div>        // directional override status (-1 is Neutral)&nbsp;</div></li><li><div>        $dos = -1;&nbsp;</div></li><li><div>        $remember = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Array of characters data&nbsp;</div></li><li><div>        $chardata = Array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Process each character iteratively, applying rules X2 through X9. Only embedding levels from 0 to 61 are valid in this phase.&nbsp;</div></li><li><div>        // In the resolution of levels in rules I1 and I2, the maximum embedding level of 62 can be reached.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chunkOTLdata['char_data'][$i]['uni'] == 8235) { // RLE&nbsp;</div></li><li><div>                // X2. With each RLE, compute the least greater odd embedding level.&nbsp;</div></li><li><div>                //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to neutral.&nbsp;</div></li><li><div>                //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                $next_level = $cel + ($cel % 2) + 1;&nbsp;</div></li><li><div>                if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                    $remember[] = array('num' =&gt; 8235, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                    $cel = $next_level;&nbsp;</div></li><li><div>                    $dos = -1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8234) { // LRE&nbsp;</div></li><li><div>                // X3. With each LRE, compute the least greater even embedding level.&nbsp;</div></li><li><div>                //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to neutral.&nbsp;</div></li><li><div>                //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                $next_level = $cel + 2 - ($cel % 2);&nbsp;</div></li><li><div>                if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                    $remember[] = array('num' =&gt; 8234, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                    $cel = $next_level;&nbsp;</div></li><li><div>                    $dos = -1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8238) { // RLO&nbsp;</div></li><li><div>                // X4. With each RLO, compute the least greater odd embedding level.&nbsp;</div></li><li><div>                //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to right-to-left.&nbsp;</div></li><li><div>                //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                $next_level = $cel + ($cel % 2) + 1;&nbsp;</div></li><li><div>                if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                    $remember[] = array('num' =&gt; 8238, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                    $cel = $next_level;&nbsp;</div></li><li><div>                    $dos = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8237) { // LRO&nbsp;</div></li><li><div>                // X5. With each LRO, compute the least greater even embedding level.&nbsp;</div></li><li><div>                //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to left-to-right.&nbsp;</div></li><li><div>                //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                $next_level = $cel + 2 - ($cel % 2);&nbsp;</div></li><li><div>                if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                    $remember[] = array('num' =&gt; 8237, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                    $cel = $next_level;&nbsp;</div></li><li><div>                    $dos = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8236) { // PDF&nbsp;</div></li><li><div>                // X7. With each PDF, determine the matching embedding or override code. If there was a valid matching code, restore (pop) the last remembered (pushed) embedding level and directional override.&nbsp;</div></li><li><div>                if (count($remember)) {&nbsp;</div></li><li><div>                    $last = count($remember) - 1;&nbsp;</div></li><li><div>                    if (($remember[$last]['num'] == 8235) || ($remember[$last]['num'] == 8234) || ($remember[$last]['num'] == 8238) ||&nbsp;</div></li><li><div>                        ($remember[$last]['num'] == 8237)) {&nbsp;</div></li><li><div>                        $match = array_pop($remember);&nbsp;</div></li><li><div>                        $cel = $match['cel'];&nbsp;</div></li><li><div>                        $dos = $match['dos'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($chunkOTLdata['char_data'][$i]['uni'] == 10) { // NEW LINE&nbsp;</div></li><li><div>                // Reset to start values&nbsp;</div></li><li><div>                $cel = $pel;&nbsp;</div></li><li><div>                $dos = -1;&nbsp;</div></li><li><div>                $remember = array();&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                // X6. For all types besides RLE, LRE, RLO, LRO, and PDF:&nbsp;</div></li><li><div>                //  a. Set the level of the current character to the current embedding level.&nbsp;</div></li><li><div>                //  b. When the directional override status is not neutral, reset the current character type to directional override status.&nbsp;</div></li><li><div>                if ($dos != -1) {&nbsp;</div></li><li><div>                    $chardir = $dos;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $chardir = $chunkOTLdata['char_data'][$i]['bidi_class'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // stores string characters and other information&nbsp;</div></li><li><div>                if (isset($chunkOTLdata['GPOSinfo'][$i])) {&nbsp;</div></li><li><div>                    $gpos = $chunkOTLdata['GPOSinfo'][$i];&nbsp;</div></li><li><div>                } else&nbsp;</div></li><li><div>                    $gpos = '';&nbsp;</div></li><li><div>                $chardata[] = array('char' =&gt; $chunkOTLdata['char_data'][$i]['uni'], 'level' =&gt; $cel, 'type' =&gt; $chardir, 'group' =&gt; $chunkOTLdata['group']{$i}, 'GPOSinfo' =&gt; $gpos);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $numchars = count($chardata);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // X8. All explicit directional embeddings and overrides are completely terminated at the end of each paragraph.&nbsp;</div></li><li><div>        // Paragraph separators are not included in the embedding.&nbsp;</div></li><li><div>        // X9. Remove all RLE, LRE, RLO, LRO, and PDF codes.&nbsp;</div></li><li><div>        // This is effectively done by only saving other codes to chardata&nbsp;</div></li><li><div>        // X10. Determine the start-of-sequence (sor) and end-of-sequence (eor) types, either L or R, for each isolating run sequence. These depend on the higher of the two levels on either side of the sequence boundary:&nbsp;</div></li><li><div>        // For sor, compare the level of the first character in the sequence with the level of the character preceding it in the paragraph or if there is none, with the paragraph embedding level.&nbsp;</div></li><li><div>        // For eor, compare the level of the last character in the sequence with the level of the character following it in the paragraph or if there is none, with the paragraph embedding level.&nbsp;</div></li><li><div>        // If the higher level is odd, the sor or eor is R; otherwise, it is L.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $prelevel = $pel;&nbsp;</div></li><li><div>        $postlevel = $pel;&nbsp;</div></li><li><div>        $cel = $prelevel; // current embedding level&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            $level = $chardata[$i]['level'];&nbsp;</div></li><li><div>            if ($i == 0) {&nbsp;</div></li><li><div>                $left = $prelevel;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $left = $chardata[$i - 1]['level'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($i == ($numchars - 1)) {&nbsp;</div></li><li><div>                $right = $postlevel;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $right = $chardata[$i + 1]['level'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $chardata[$i]['sor'] = max($left, $level) % 2 ? UCDN::BIDI_CLASS_R : UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>            $chardata[$i]['eor'] = max($right, $level) % 2 ? UCDN::BIDI_CLASS_R : UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // 3.3.3 Resolving Weak Types&nbsp;</div></li><li><div>        // Weak types are now resolved one level run at a time. At level run boundaries where the type of the character on the other side of the boundary is required, the type assigned to sor or eor is used.&nbsp;</div></li><li><div>        // Nonspacing marks are now resolved based on the previous characters.&nbsp;</div></li><li><div>        // W1. Examine each nonspacing mark (NSM) in the level run, and change the type of the NSM to the type of the previous character. If the NSM is at the start of the level run, it will get the type of sor.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_NSM) {&nbsp;</div></li><li><div>                if ($i == 0 || $chardata[$i]['level'] != $chardata[$i - 1]['level']) {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = $chardata[$i]['sor'];&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = $chardata[($i - 1)]['type'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sor) is found. If an AL is found, change the type of the European number to Arabic number.&nbsp;</div></li><li><div>        $prevlevel = -1;&nbsp;</div></li><li><div>        $levcount = 0;&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                $found = false;&nbsp;</div></li><li><div>                for ($j = $levcount; $j &gt;= 0; $j--) {&nbsp;</div></li><li><div>                    if ($chardata[$j]['type'] == UCDN::BIDI_CLASS_AL) {&nbsp;</div></li><li><div>                        $chardata[$i]['type'] = UCDN::BIDI_CLASS_AN;&nbsp;</div></li><li><div>                        $found = true;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    } else if (($chardata[$j]['type'] == UCDN::BIDI_CLASS_L) || ($chardata[$j]['type'] == UCDN::BIDI_CLASS_R)) {&nbsp;</div></li><li><div>                        $found = true;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($chardata[$i]['level'] != $prevlevel) {&nbsp;</div></li><li><div>                $levcount = 0;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                ++$levcount;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $prevlevel = $chardata[$i]['level'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W3. Change all ALs to R.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_AL) {&nbsp;</div></li><li><div>                $chardata[$i]['type'] = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W4. A single European separator between two European numbers changes to a European number. A single common separator between two numbers of the same type changes to that type.&nbsp;</div></li><li><div>        for ($i = 1; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if (($i + 1) &lt; $numchars && $chardata[($i)]['level'] == $chardata[($i + 1)]['level'] && $chardata[($i)]['level'] == $chardata[($i - 1)]['level']) {&nbsp;</div></li><li><div>                if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ES && $chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_EN && $chardata[($i + 1)]['type'] == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                } else if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_CS && $chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_EN && $chardata[($i + 1)]['type'] == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                } else if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_CS && $chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_AN && $chardata[($i + 1)]['type'] == UCDN::BIDI_CLASS_AN) {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = UCDN::BIDI_CLASS_AN;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ET) {&nbsp;</div></li><li><div>                if ($i &gt; 0 && $chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_EN && $chardata[($i)]['level'] == $chardata[($i - 1)]['level']) {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $j = $i + 1;&nbsp;</div></li><li><div>                    while ($j &lt; $numchars && $chardata[$j]['level'] == $chardata[$i]['level']) {&nbsp;</div></li><li><div>                        if ($chardata[$j]['type'] == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        } else if ($chardata[$j]['type'] != UCDN::BIDI_CLASS_ET) {&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        ++$j;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W6. Otherwise, separators and terminators change to Other Neutral.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if (($chardata[$i]['type'] == UCDN::BIDI_CLASS_ET) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ES) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_CS)) {&nbsp;</div></li><li><div>                $chardata[$i]['type'] = UCDN::BIDI_CLASS_ON;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //W7. Search backward from each instance of a European number until the first strong type (R, L, or sor) is found. If an L is found, then change the type of the European number to L.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                if ($i == 0) { // Start of Level run&nbsp;</div></li><li><div>                    if ($chardata[$i]['sor'] == UCDN::BIDI_CLASS_L)&nbsp;</div></li><li><div>                        $chardata[$i]['type'] = $chardata[$i]['sor'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                else {&nbsp;</div></li><li><div>                    for ($j = $i - 1; $j &gt;= 0; $j--) {&nbsp;</div></li><li><div>                        if ($chardata[$j]['level'] != $chardata[$i]['level']) { // Level run boundary&nbsp;</div></li><li><div>                            if ($chardata[$j + 1]['sor'] == UCDN::BIDI_CLASS_L)&nbsp;</div></li><li><div>                                $chardata[$i]['type'] = $chardata[$j + 1]['sor'];&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        else if ($chardata[$j]['type'] == UCDN::BIDI_CLASS_L) {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        } else if ($chardata[$j]['type'] == UCDN::BIDI_CLASS_R) {&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // N1. A sequence of neutrals takes the direction of the surrounding strong text if the text on both sides has the same direction. European and Arabic numbers act as if they were R in terms of their influence on neutrals. Start-of-level-run (sor) and end-of-level-run (eor) are used at level run boundaries.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ON || $chardata[$i]['type'] == UCDN::BIDI_CLASS_WS) {&nbsp;</div></li><li><div>                $left = -1;&nbsp;</div></li><li><div>                // LEFT&nbsp;</div></li><li><div>                if ($i == 0) {  // first char&nbsp;</div></li><li><div>                    $left = $chardata[($i)]['sor'];&nbsp;</div></li><li><div>                } else if ($chardata[($i - 1)]['level'] != $chardata[($i)]['level']) {  // run boundary&nbsp;</div></li><li><div>                    $left = $chardata[($i)]['sor'];&nbsp;</div></li><li><div>                } else if ($chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_L) {&nbsp;</div></li><li><div>                    $left = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                } else if ($chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_R || $chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_EN || $chardata[($i - 1)]['type'] == UCDN::BIDI_CLASS_AN) {&nbsp;</div></li><li><div>                    $left = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                // RIGHT&nbsp;</div></li><li><div>                $right = -1;&nbsp;</div></li><li><div>                $j = $i;&nbsp;</div></li><li><div>                // move to the right of any following neutrals OR hit a run boundary&nbsp;</div></li><li><div>                while (($chardata[$j]['type'] == UCDN::BIDI_CLASS_ON || $chardata[$j]['type'] == UCDN::BIDI_CLASS_WS) && $j &lt;= ($numchars - 1)) {&nbsp;</div></li><li><div>                    if ($j == ($numchars - 1)) {  // last char&nbsp;</div></li><li><div>                        $right = $chardata[($j)]['eor'];&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    } else if ($chardata[($j + 1)]['level'] != $chardata[($j)]['level']) {  // run boundary&nbsp;</div></li><li><div>                        $right = $chardata[($j)]['eor'];&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    } else if ($chardata[($j + 1)]['type'] == UCDN::BIDI_CLASS_L) {&nbsp;</div></li><li><div>                        $right = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    } else if ($chardata[($j + 1)]['type'] == UCDN::BIDI_CLASS_R || $chardata[($j + 1)]['type'] == UCDN::BIDI_CLASS_EN || $chardata[($j + 1)]['type'] == UCDN::BIDI_CLASS_AN) {&nbsp;</div></li><li><div>                        $right = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $j++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($left &gt; -1 && $left == $right) {&nbsp;</div></li><li><div>                    $chardata[$i]['orig_type'] = $chardata[$i]['type']; // Need to store the original 'WS' for reference in L1 below&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = $left;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // N2. Any remaining neutrals take the embedding direction&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ON || $chardata[$i]['type'] == UCDN::BIDI_CLASS_WS) {&nbsp;</div></li><li><div>                $chardata[$i]['type'] = ($chardata[$i]['level'] % 2) ? UCDN::BIDI_CLASS_R : UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                $chardata[$i]['orig_type'] = $chardata[$i]['type']; // Need to store the original 'WS' for reference in L1 below&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // I1. For all characters with an even (left-to-right) embedding direction, those of type R go up one level and those of type AN or EN go up two levels.&nbsp;</div></li><li><div>        // I2. For all characters with an odd (right-to-left) embedding direction, those of type L, EN or AN go up one level.&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>            $odd = $chardata[$i]['level'] % 2;&nbsp;</div></li><li><div>            if ($odd) {&nbsp;</div></li><li><div>                if (($chardata[$i]['type'] == UCDN::BIDI_CLASS_L) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_AN) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_EN)) {&nbsp;</div></li><li><div>                    $chardata[$i]['level'] += 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_R) {&nbsp;</div></li><li><div>                    $chardata[$i]['level'] += 1;&nbsp;</div></li><li><div>                } else if (($chardata[$i]['type'] == UCDN::BIDI_CLASS_AN) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_EN)) {&nbsp;</div></li><li><div>                    $chardata[$i]['level'] += 2;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $maxlevel = max($chardata[$i]['level'], $maxlevel);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// NB&nbsp;</div></li><li><div>//  Separate into lines at this point************&nbsp;</div></li><li><div>//&nbsp;</div></li><li><div>        // L1. On each line, reset the embedding level of the following characters to the paragraph embedding level:&nbsp;</div></li><li><div>        //  1. Segment separators (Tab) 'S', &nbsp;</div></li><li><div>        //  2. Paragraph separators 'B', &nbsp;</div></li><li><div>        //  3. Any sequence of whitespace characters 'WS' preceding a segment separator or paragraph separator, and&nbsp;</div></li><li><div>        //  4. Any sequence of whitespace characters 'WS' at the end of the line.&nbsp;</div></li><li><div>        //  The types of characters used here are the original types, not those modified by the previous phase cf N1 and N2*******&nbsp;</div></li><li><div>        //  Because a Paragraph Separator breaks lines, there will be at most one per line, at the end of that line.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($i = ($numchars - 1); $i &gt; 0; $i--) {&nbsp;</div></li><li><div>            if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_WS || (isset($chardata[$i]['orig_type']) && $chardata[$i]['orig_type'] == UCDN::BIDI_CLASS_WS)) {&nbsp;</div></li><li><div>                $chardata[$i]['level'] = $pel;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.&nbsp;</div></li><li><div>        for ($j = $maxlevel; $j &gt; 0; $j--) {&nbsp;</div></li><li><div>            $ordarray = array();&nbsp;</div></li><li><div>            $revarr = array();&nbsp;</div></li><li><div>            $onlevel = false;&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                if ($chardata[$i]['level'] &gt;= $j) {&nbsp;</div></li><li><div>                    $onlevel = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // L4. A character is depicted by a mirrored glyph if and only if (a) the resolved directionality of that character is R, and (b) the Bidi_Mirrored property value of that character is true.&nbsp;</div></li><li><div>                    if (isset(UCDN::$mirror_pairs[$chardata[$i]['char']]) && $chardata[$i]['type'] == UCDN::BIDI_CLASS_R) {&nbsp;</div></li><li><div>                        $chardata[$i]['char'] = UCDN::$mirror_pairs[$chardata[$i]['char']];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $revarr[] = $chardata[$i];&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    if ($onlevel) {&nbsp;</div></li><li><div>                        $revarr = array_reverse($revarr);&nbsp;</div></li><li><div>                        $ordarray = array_merge($ordarray, $revarr);&nbsp;</div></li><li><div>                        $revarr = Array();&nbsp;</div></li><li><div>                        $onlevel = false;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $ordarray[] = $chardata[$i];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($onlevel) {&nbsp;</div></li><li><div>                $revarr = array_reverse($revarr);&nbsp;</div></li><li><div>                $ordarray = array_merge($ordarray, $revarr);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $chardata = $ordarray;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $group = '';&nbsp;</div></li><li><div>        $e = '';&nbsp;</div></li><li><div>        $GPOS = array();&nbsp;</div></li><li><div>        $cctr = 0;&nbsp;</div></li><li><div>        $rtl_content = 0x0;&nbsp;</div></li><li><div>        foreach ($chardata as $cd) {&nbsp;</div></li><li><div>            $e.=code2utf($cd['char']);&nbsp;</div></li><li><div>            $group .= $cd['group'];&nbsp;</div></li><li><div>            if ($useGPOS && is_array($cd['GPOSinfo'])) {&nbsp;</div></li><li><div>                $GPOS[$cctr] = $cd['GPOSinfo'];&nbsp;</div></li><li><div>                $GPOS[$cctr]['wDir'] = ($cd['level'] % 2) ? 'RTL' : 'LTR';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($cd['type'] == UCDN::BIDI_CLASS_L) {&nbsp;</div></li><li><div>                $rtl_content |= 1;&nbsp;</div></li><li><div>            } else if ($cd['type'] == UCDN::BIDI_CLASS_R) {&nbsp;</div></li><li><div>                $rtl_content |= 2;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $cctr++;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $chunkOTLdata['group'] = $group;&nbsp;</div></li><li><div>        if ($useGPOS) {&nbsp;</div></li><li><div>            $chunkOTLdata['GPOSinfo'] = $GPOS;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return array($e, $rtl_content);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// **********************************************************************************************&nbsp;</div></li><li><div>// The following versions for BidiSort work on amalgamated chunks to process the whole paragraph&nbsp;</div></li><li><div>// Firstly set the level in the OTLdata - called from fn printbuffer() [_bidiPrepare]&nbsp;</div></li><li><div>// Secondly re-order - called from fn writeFlowingBlock and FinishFlowingBlock, when already divided into lines. [_bidiReorder]&nbsp;</div></li><li><div>// **********************************************************************************************&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _bidiPrepare(&$para, $dir)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Set the initial paragraph embedding level&nbsp;</div></li><li><div>        $pel = 0; // paragraph embedding level&nbsp;</div></li><li><div>        if ($dir == 'rtl') {&nbsp;</div></li><li><div>            $pel = 1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // X1. Begin by setting the current embedding level to the paragraph embedding level. Set the directional override status to neutral.&nbsp;</div></li><li><div>        // Current Embedding Level&nbsp;</div></li><li><div>        $cel = $pel;&nbsp;</div></li><li><div>        // directional override status (-1 is Neutral)&nbsp;</div></li><li><div>        $dos = -1;&nbsp;</div></li><li><div>        $remember = array();&nbsp;</div></li><li><div>        $controlchars = false;&nbsp;</div></li><li><div>        $strongrtl = false;&nbsp;</div></li><li><div>        $diid = 0; // direction isolate ID&nbsp;</div></li><li><div>        $dictr = 0; // direction isolate counter&nbsp;</div></li><li><div>        // Process each character iteratively, applying rules X2 through X9. Only embedding levels from 0 to 61 are valid in this phase.&nbsp;</div></li><li><div>        // In the resolution of levels in rules I1 and I2, the maximum embedding level of 62 can be reached.&nbsp;</div></li><li><div>        $numchunks = count($para);&nbsp;</div></li><li><div>        for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>            $chunkOTLdata = & $para[$nc][18];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $numchars = count($chunkOTLdata['char_data']);&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                if ($chunkOTLdata['char_data'][$i]['uni'] == 8235) { // RLE&nbsp;</div></li><li><div>                    // X2. With each RLE, compute the least greater odd embedding level.&nbsp;</div></li><li><div>                    //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to neutral.&nbsp;</div></li><li><div>                    //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                    $next_level = $cel + ($cel % 2) + 1;&nbsp;</div></li><li><div>                    if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                        $remember[] = array('num' =&gt; 8235, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                        $cel = $next_level;&nbsp;</div></li><li><div>                        $dos = -1;&nbsp;</div></li><li><div>                        $controlchars = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8234) { // LRE&nbsp;</div></li><li><div>                    // X3. With each LRE, compute the least greater even embedding level.&nbsp;</div></li><li><div>                    //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to neutral.&nbsp;</div></li><li><div>                    //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                    $next_level = $cel + 2 - ($cel % 2);&nbsp;</div></li><li><div>                    if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                        $remember[] = array('num' =&gt; 8234, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                        $cel = $next_level;&nbsp;</div></li><li><div>                        $dos = -1;&nbsp;</div></li><li><div>                        $controlchars = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8238) { // RLO&nbsp;</div></li><li><div>                    // X4. With each RLO, compute the least greater odd embedding level.&nbsp;</div></li><li><div>                    //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to right-to-left.&nbsp;</div></li><li><div>                    //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                    $next_level = $cel + ($cel % 2) + 1;&nbsp;</div></li><li><div>                    if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                        $remember[] = array('num' =&gt; 8238, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                        $cel = $next_level;&nbsp;</div></li><li><div>                        $dos = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                        $controlchars = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8237) { // LRO&nbsp;</div></li><li><div>                    // X5. With each LRO, compute the least greater even embedding level.&nbsp;</div></li><li><div>                    //  a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to left-to-right.&nbsp;</div></li><li><div>                    //  b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.&nbsp;</div></li><li><div>                    $next_level = $cel + 2 - ($cel % 2);&nbsp;</div></li><li><div>                    if ($next_level &lt; 62) {&nbsp;</div></li><li><div>                        $remember[] = array('num' =&gt; 8237, 'cel' =&gt; $cel, 'dos' =&gt; $dos);&nbsp;</div></li><li><div>                        $cel = $next_level;&nbsp;</div></li><li><div>                        $dos = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                        $controlchars = true;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8236) { // PDF&nbsp;</div></li><li><div>                    // X7. With each PDF, determine the matching embedding or override code. If there was a valid matching code, restore (pop) the last remembered (pushed) embedding level and directional override.&nbsp;</div></li><li><div>                    if (count($remember)) {&nbsp;</div></li><li><div>                        $last = count($remember) - 1;&nbsp;</div></li><li><div>                        if (($remember[$last]['num'] == 8235) || ($remember[$last]['num'] == 8234) || ($remember[$last]['num'] == 8238) ||&nbsp;</div></li><li><div>                            ($remember[$last]['num'] == 8237)) {&nbsp;</div></li><li><div>                            $match = array_pop($remember);&nbsp;</div></li><li><div>                            $cel = $match['cel'];&nbsp;</div></li><li><div>                            $dos = $match['dos'];&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8294 || $chunkOTLdata['char_data'][$i]['uni'] == 8295 ||&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['uni'] == 8296) { // LRI // RLI // FSI&nbsp;</div></li><li><div>                    // X5a. With each RLI:&nbsp;</div></li><li><div>                    // X5b. With each LRI:&nbsp;</div></li><li><div>                    // X5c. With each FSI, apply rules P2 and P3 for First Strong character&nbsp;</div></li><li><div>                    //  Set the RLI/LRI/FSI embedding level to the embedding level of the last entry on the directional status stack.&nbsp;</div></li><li><div>                    if ($dos != -1) {&nbsp;</div></li><li><div>                        $chardir = $dos;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $chardir = $chunkOTLdata['char_data'][$i]['bidi_class'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['level'] = $cel;&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['type'] = $chardir;&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['diid'] = $diid;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $fsi = '';&nbsp;</div></li><li><div>                    // X5c. With each FSI, apply rules P2 and P3 within the isolate run for First Strong character&nbsp;</div></li><li><div>                    if ($chunkOTLdata['char_data'][$i]['uni'] == 8296) { // FSI&nbsp;</div></li><li><div>                        $lvl = 0;&nbsp;</div></li><li><div>                        $nc2 = $nc;&nbsp;</div></li><li><div>                        $i2 = $i;&nbsp;</div></li><li><div>                        while (!($nc2 == ($numchunks - 1) && $i2 == ((count($para[$nc2][18]['char_data'])) - 1))) {  // while not at end of last chunk&nbsp;</div></li><li><div>                            $i2++;&nbsp;</div></li><li><div>                            if ($i2 &gt;= count($para[$nc2][18]['char_data'])) {&nbsp;</div></li><li><div>                                $nc2++;&nbsp;</div></li><li><div>                                $i2 = 0;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if ($lvl &gt; 0) {&nbsp;</div></li><li><div>                                continue;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if ($para[$nc2][18]['char_data'][$i2]['uni'] == 8294 || $para[$nc2][18]['char_data'][$i2]['uni'] == 8295 || $para[$nc2][18]['char_data'][$i2]['uni'] == 8296) {&nbsp;</div></li><li><div>                                $lvl++;&nbsp;</div></li><li><div>                                continue;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if ($para[$nc2][18]['char_data'][$i2]['uni'] == 8297) {&nbsp;</div></li><li><div>                                $lvl--;&nbsp;</div></li><li><div>                                if ($lvl &lt; 0) {&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if ($para[$nc2][18]['char_data'][$i2]['bidi_class'] === UCDN::BIDI_CLASS_L || $para[$nc2][18]['char_data'][$i2]['bidi_class'] == UCDN::BIDI_CLASS_AL || $para[$nc2][18]['char_data'][$i2]['bidi_class'] === UCDN::BIDI_CLASS_R) {&nbsp;</div></li><li><div>                                $fsi = $para[$nc2][18]['char_data'][$i2]['bidi_class'];&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        // if fsi not found, fsi is same as paragraph embedding level&nbsp;</div></li><li><div>                        if (!$fsi && $fsi !== 0) {&nbsp;</div></li><li><div>                            if ($pel == 1) {&nbsp;</div></li><li><div>                                $fsi = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                            } else {&nbsp;</div></li><li><div>                                $fsi = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($chunkOTLdata['char_data'][$i]['uni'] == 8294 || $fsi === UCDN::BIDI_CLASS_L) { // LRI or FSI-L&nbsp;</div></li><li><div>                        //  Compute the least even embedding level greater than the embedding level of the last entry on the directional status stack.&nbsp;</div></li><li><div>                        $next_level = $cel + 2 - ($cel % 2);&nbsp;</div></li><li><div>                    } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8295 || $fsi == UCDN::BIDI_CLASS_R || $fsi == UCDN::BIDI_CLASS_AL) { // RLI or FSI-R&nbsp;</div></li><li><div>                        //  Compute the least odd embedding level greater than the embedding level of the last entry on the directional status stack.&nbsp;</div></li><li><div>                        $next_level = $cel + ($cel % 2) + 1;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    //  Increment the isolate count by one, and push an entry consisting of the new embedding level, &nbsp;</div></li><li><div>                    //  neutral directional override status, and true directional isolate status onto the directional status stack.&nbsp;</div></li><li><div>                    $remember[] = array('num' =&gt; $chunkOTLdata['char_data'][$i]['uni'], 'cel' =&gt; $cel, 'dos' =&gt; $dos, 'diid' =&gt; $diid);&nbsp;</div></li><li><div>                    $cel = $next_level;&nbsp;</div></li><li><div>                    $dos = -1;&nbsp;</div></li><li><div>                    $diid = ++$dictr; // Set new direction isolate ID after incrementing direction isolate counter&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $controlchars = true;&nbsp;</div></li><li><div>                } else if ($chunkOTLdata['char_data'][$i]['uni'] == 8297) { // PDI&nbsp;</div></li><li><div>                    // X6a. With each PDI, perform the following steps:&nbsp;</div></li><li><div>                    //  Pop the last entry from the directional status stack and decrement the isolate count by one.&nbsp;</div></li><li><div>                    while (count($remember)) {&nbsp;</div></li><li><div>                        $last = count($remember) - 1;&nbsp;</div></li><li><div>                        if (($remember[$last]['num'] == 8294) || ($remember[$last]['num'] == 8295) || ($remember[$last]['num'] == 8296)) {&nbsp;</div></li><li><div>                            $match = array_pop($remember);&nbsp;</div></li><li><div>                            $cel = $match['cel'];&nbsp;</div></li><li><div>                            $dos = $match['dos'];&nbsp;</div></li><li><div>                            $diid = $match['diid'];&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        // End/close any open embedding states not explicitly closed during the isolate&nbsp;</div></li><li><div>                        else if (($remember[$last]['num'] == 8235) || ($remember[$last]['num'] == 8234) || ($remember[$last]['num'] == 8238) ||&nbsp;</div></li><li><div>                            ($remember[$last]['num'] == 8237)) {&nbsp;</div></li><li><div>                            $match = array_pop($remember);&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    //  In all cases, set the PDI*s level to the embedding level of the last entry on the directional status stack left after the steps above.&nbsp;</div></li><li><div>                    //  NB The level assigned to an isolate initiator is always the same as that assigned to the matching PDI.&nbsp;</div></li><li><div>                    if ($dos != -1) {&nbsp;</div></li><li><div>                        $chardir = $dos;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $chardir = $chunkOTLdata['char_data'][$i]['bidi_class'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['level'] = $cel;&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['type'] = $chardir;&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['diid'] = $diid;&nbsp;</div></li><li><div>                    $controlchars = true;&nbsp;</div></li><li><div>                } else if ($chunkOTLdata['char_data'][$i]['uni'] == 10) { // NEW LINE&nbsp;</div></li><li><div>                    // Reset to start values&nbsp;</div></li><li><div>                    $cel = $pel;&nbsp;</div></li><li><div>                    $dos = -1;&nbsp;</div></li><li><div>                    $remember = array();&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    // X6. For all types besides RLE, LRE, RLO, LRO, and PDF:&nbsp;</div></li><li><div>                    //  a. Set the level of the current character to the current embedding level.&nbsp;</div></li><li><div>                    //  b. When the directional override status is not neutral, reset the current character type to directional override status.&nbsp;</div></li><li><div>                    if ($dos != -1) {&nbsp;</div></li><li><div>                        $chardir = $dos;&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $chardir = $chunkOTLdata['char_data'][$i]['bidi_class'];&nbsp;</div></li><li><div>                        if ($chardir == UCDN::BIDI_CLASS_R || $chardir == UCDN::BIDI_CLASS_AL) {&nbsp;</div></li><li><div>                            $strongrtl = true;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['level'] = $cel;&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['type'] = $chardir;&nbsp;</div></li><li><div>                    $chunkOTLdata['char_data'][$i]['diid'] = $diid;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // X8. All explicit directional embeddings and overrides are completely terminated at the end of each paragraph.&nbsp;</div></li><li><div>            // Paragraph separators are not included in the embedding.&nbsp;</div></li><li><div>            // X9. Remove all RLE, LRE, RLO, LRO, and PDF codes.&nbsp;</div></li><li><div>            if ($controlchars) {&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x80\xaa&quot;);&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x80\xab&quot;);&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x80\xac&quot;);&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x80\xad&quot;);&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x80\xae&quot;);&nbsp;</div></li><li><div>                preg_replace(&quot;/\x{202a}-\x{202e}/u&quot;, '', $para[$nc][0]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Remove any blank chunks made by removing directional codes&nbsp;</div></li><li><div>        $numchunks = count($para);&nbsp;</div></li><li><div>        for ($nc = ($numchunks - 1); $nc &gt;= 0; $nc--) {&nbsp;</div></li><li><div>            if (count($para[$nc][18]['char_data']) == 0) {&nbsp;</div></li><li><div>                array_splice($para, $nc, 1);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($dir != 'rtl' && !$strongrtl && !$controlchars) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $numchunks = count($para);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // X10. Determine the start-of-sequence (sor) and end-of-sequence (eor) types, either L or R, for each isolating run sequence. These depend on the higher of the two levels on either side of the sequence boundary:&nbsp;</div></li><li><div>        // For sor, compare the level of the first character in the sequence with the level of the character preceding it in the paragraph or if there is none, with the paragraph embedding level.&nbsp;</div></li><li><div>        // For eor, compare the level of the last character in the sequence with the level of the character following it in the paragraph or if there is none, with the paragraph embedding level.&nbsp;</div></li><li><div>        // If the higher level is odd, the sor or eor is R; otherwise, it is L.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($ir = 0; $ir &lt;= $dictr; $ir++) {&nbsp;</div></li><li><div>            $prelevel = $pel;&nbsp;</div></li><li><div>            $postlevel = $pel;&nbsp;</div></li><li><div>            $firstchar = true;&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>                $numchars = count($chardata);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['diid']) || $chardata[$i]['diid'] != $ir) {&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    } // Ignore characters in a different isolate run&nbsp;</div></li><li><div>                    $right = $postlevel;&nbsp;</div></li><li><div>                    $nc2 = $nc;&nbsp;</div></li><li><div>                    $i2 = $i;&nbsp;</div></li><li><div>                    while (!($nc2 == ($numchunks - 1) && $i2 == ((count($para[$nc2][18]['char_data'])) - 1))) {  // while not at end of last chunk&nbsp;</div></li><li><div>                        $i2++;&nbsp;</div></li><li><div>                        if ($i2 &gt;= count($para[$nc2][18]['char_data'])) {&nbsp;</div></li><li><div>                            $nc2++;&nbsp;</div></li><li><div>                            $i2 = 0;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if (isset($para[$nc2][18]['char_data'][$i2]['diid']) && $para[$nc2][18]['char_data'][$i2]['diid'] == $ir) {&nbsp;</div></li><li><div>                            $right = $para[$nc2][18]['char_data'][$i2]['level'];&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $level = $chardata[$i]['level'];&nbsp;</div></li><li><div>                    if ($firstchar || $level != $prelevel) {&nbsp;</div></li><li><div>                        $chardata[$i]['sor'] = max($prelevel, $level) % 2 ? UCDN::BIDI_CLASS_R : UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if (($nc == ($numchunks - 1) && $i == ($numchars - 1)) || $level != $right) {&nbsp;</div></li><li><div>                        $chardata[$i]['eor'] = max($right, $level) % 2 ? UCDN::BIDI_CLASS_R : UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $prelevel = $level;&nbsp;</div></li><li><div>                    $firstchar = false;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // 3.3.3 Resolving Weak Types&nbsp;</div></li><li><div>        // Weak types are now resolved one level run at a time. At level run boundaries where the type of the character on the other side of the boundary is required, the type assigned to sor or eor is used.&nbsp;</div></li><li><div>        // Nonspacing marks are now resolved based on the previous characters.&nbsp;</div></li><li><div>        // W1. Examine each nonspacing mark (NSM) in the level run, and change the type of the NSM to the type of the previous character. If the NSM is at the start of the level run, it will get the type of sor.&nbsp;</div></li><li><div>        for ($ir = 0; $ir &lt;= $dictr; $ir++) {&nbsp;</div></li><li><div>            $prevtype = 0;&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>                $numchars = count($chardata);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['diid']) || $chardata[$i]['diid'] != $ir) {&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    } // Ignore characters in a different isolate run&nbsp;</div></li><li><div>                    if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_NSM) {&nbsp;</div></li><li><div>                        if (isset($chardata[$i]['sor'])) {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = $chardata[$i]['sor'];&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = $prevtype;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $prevtype = $chardata[$i]['type'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL or sor) is found. If an AL is found, change the type of the European number to Arabic number.&nbsp;</div></li><li><div>        for ($ir = 0; $ir &lt;= $dictr; $ir++) {&nbsp;</div></li><li><div>            $laststrongtype = -1;&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>                $numchars = count($chardata);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['diid']) || $chardata[$i]['diid'] != $ir) {&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    } // Ignore characters in a different isolate run&nbsp;</div></li><li><div>                    if (isset($chardata[$i]['sor'])) {&nbsp;</div></li><li><div>                        $laststrongtype = $chardata[$i]['sor'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_EN && $laststrongtype == UCDN::BIDI_CLASS_AL) {&nbsp;</div></li><li><div>                        $chardata[$i]['type'] = UCDN::BIDI_CLASS_AN;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_L || $chardata[$i]['type'] == UCDN::BIDI_CLASS_R || $chardata[$i]['type'] == UCDN::BIDI_CLASS_AL) {&nbsp;</div></li><li><div>                        $laststrongtype = $chardata[$i]['type'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W3. Change all ALs to R.&nbsp;</div></li><li><div>        for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>            $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>            $numchars = count($chardata);&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                if (isset($chardata[$i]['type']) && $chardata[$i]['type'] == UCDN::BIDI_CLASS_AL) {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W4. A single European separator between two European numbers changes to a European number. A single common separator between two numbers of the same type changes to that type.&nbsp;</div></li><li><div>        for ($ir = 0; $ir &lt;= $dictr; $ir++) {&nbsp;</div></li><li><div>            $prevtype = -1;&nbsp;</div></li><li><div>            $nexttype = -1;&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>                $numchars = count($chardata);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['diid']) || $chardata[$i]['diid'] != $ir) {&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    } // Ignore characters in a different isolate run&nbsp;</div></li><li><div>                    // Get next type&nbsp;</div></li><li><div>                    $nexttype = -1;&nbsp;</div></li><li><div>                    $nc2 = $nc;&nbsp;</div></li><li><div>                    $i2 = $i;&nbsp;</div></li><li><div>                    while (!($nc2 == ($numchunks - 1) && $i2 == ((count($para[$nc2][18]['char_data'])) - 1))) {  // while not at end of last chunk&nbsp;</div></li><li><div>                        $i2++;&nbsp;</div></li><li><div>                        if ($i2 &gt;= count($para[$nc2][18]['char_data'])) {&nbsp;</div></li><li><div>                            $nc2++;&nbsp;</div></li><li><div>                            $i2 = 0;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if (isset($para[$nc2][18]['char_data'][$i2]['diid']) && $para[$nc2][18]['char_data'][$i2]['diid'] == $ir) {&nbsp;</div></li><li><div>                            $nexttype = $para[$nc2][18]['char_data'][$i2]['type'];&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['sor']) && !isset($chardata[$i]['eor'])) {&nbsp;</div></li><li><div>                        if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ES && $prevtype == UCDN::BIDI_CLASS_EN && $nexttype == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                        } else if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_CS && $prevtype == UCDN::BIDI_CLASS_EN && $nexttype == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                        } else if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_CS && $prevtype == UCDN::BIDI_CLASS_AN && $nexttype == UCDN::BIDI_CLASS_AN) {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = UCDN::BIDI_CLASS_AN;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $prevtype = $chardata[$i]['type'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.&nbsp;</div></li><li><div>        for ($ir = 0; $ir &lt;= $dictr; $ir++) {&nbsp;</div></li><li><div>            $prevtype = -1;&nbsp;</div></li><li><div>            $nexttype = -1;&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>                $numchars = count($chardata);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['diid']) || $chardata[$i]['diid'] != $ir) {&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    } // Ignore characters in a different isolate run&nbsp;</div></li><li><div>                    if (isset($chardata[$i]['sor'])) {&nbsp;</div></li><li><div>                        $prevtype = $chardata[$i]['sor'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ET) {&nbsp;</div></li><li><div>                        if ($prevtype == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                        } else if (!isset($chardata[$i]['eor'])) {&nbsp;</div></li><li><div>                            $nexttype = -1;&nbsp;</div></li><li><div>                            $nc2 = $nc;&nbsp;</div></li><li><div>                            $i2 = $i;&nbsp;</div></li><li><div>                            while (!($nc2 == ($numchunks - 1) && $i2 == ((count($para[$nc2][18]['char_data'])) - 1))) { // while not at end of last chunk&nbsp;</div></li><li><div>                                $i2++;&nbsp;</div></li><li><div>                                if ($i2 &gt;= count($para[$nc2][18]['char_data'])) {&nbsp;</div></li><li><div>                                    $nc2++;&nbsp;</div></li><li><div>                                    $i2 = 0;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if ($para[$nc2][18]['char_data'][$i2]['diid'] != $ir) {&nbsp;</div></li><li><div>                                    continue;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $nexttype = $para[$nc2][18]['char_data'][$i2]['type'];&nbsp;</div></li><li><div>                                if (isset($para[$nc2][18]['char_data'][$i2]['sor'])) {&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if ($nexttype == UCDN::BIDI_CLASS_EN) {&nbsp;</div></li><li><div>                                    $chardata[$i]['type'] = UCDN::BIDI_CLASS_EN;&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                } else if ($nexttype != UCDN::BIDI_CLASS_ET) {&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $prevtype = $chardata[$i]['type'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // W6. Otherwise, separators and terminators change to Other Neutral.&nbsp;</div></li><li><div>        for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>            $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>            $numchars = count($chardata);&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                if (isset($chardata[$i]['type']) && (($chardata[$i]['type'] == UCDN::BIDI_CLASS_ET) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ES) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_CS))) {&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = UCDN::BIDI_CLASS_ON;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //W7. Search backward from each instance of a European number until the first strong type (R, L, or sor) is found. If an L is found, then change the type of the European number to L.&nbsp;</div></li><li><div>        for ($ir = 0; $ir &lt;= $dictr; $ir++) {&nbsp;</div></li><li><div>            $laststrongtype = -1;&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>                $numchars = count($chardata);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['diid']) || $chardata[$i]['diid'] != $ir) {&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    } // Ignore characters in a different isolate run&nbsp;</div></li><li><div>                    if (isset($chardata[$i]['sor'])) {&nbsp;</div></li><li><div>                        $laststrongtype = $chardata[$i]['sor'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if (isset($chardata[$i]['type']) && $chardata[$i]['type'] == UCDN::BIDI_CLASS_EN && $laststrongtype == UCDN::BIDI_CLASS_L) {&nbsp;</div></li><li><div>                        $chardata[$i]['type'] = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if (isset($chardata[$i]['type']) && ($chardata[$i]['type'] == UCDN::BIDI_CLASS_L || $chardata[$i]['type'] == UCDN::BIDI_CLASS_R || $chardata[$i]['type'] == UCDN::BIDI_CLASS_AL)) {&nbsp;</div></li><li><div>                        $laststrongtype = $chardata[$i]['type'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // N1. A sequence of neutrals takes the direction of the surrounding strong text if the text on both sides has the same direction. European and Arabic numbers act as if they were R in terms of their influence on neutrals. Start-of-level-run (sor) and end-of-level-run (eor) are used at level run boundaries.&nbsp;</div></li><li><div>        for ($ir = 0; $ir &lt;= $dictr; $ir++) {&nbsp;</div></li><li><div>            $laststrongtype = -1;&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>                $numchars = count($chardata);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                    if (!isset($chardata[$i]['diid']) || $chardata[$i]['diid'] != $ir) {&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    } // Ignore characters in a different isolate run&nbsp;</div></li><li><div>                    if (isset($chardata[$i]['sor'])) {&nbsp;</div></li><li><div>                        $laststrongtype = $chardata[$i]['sor'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ON || $chardata[$i]['type'] == UCDN::BIDI_CLASS_WS) {&nbsp;</div></li><li><div>                        $left = -1;&nbsp;</div></li><li><div>                        // LEFT&nbsp;</div></li><li><div>                        if ($laststrongtype == UCDN::BIDI_CLASS_R || $laststrongtype == UCDN::BIDI_CLASS_EN || $laststrongtype == UCDN::BIDI_CLASS_AN) {&nbsp;</div></li><li><div>                            $left = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                        } else if ($laststrongtype == UCDN::BIDI_CLASS_L) {&nbsp;</div></li><li><div>                            $left = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        // RIGHT&nbsp;</div></li><li><div>                        $right = -1;&nbsp;</div></li><li><div>                        // move to the right of any following neutrals OR hit a run boundary&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if (isset($chardata[$i]['eor'])) {&nbsp;</div></li><li><div>                            $right = $chardata[$i]['eor'];&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $nexttype = -1;&nbsp;</div></li><li><div>                            $nc2 = $nc;&nbsp;</div></li><li><div>                            $i2 = $i;&nbsp;</div></li><li><div>                            while (!($nc2 == ($numchunks - 1) && $i2 == ((count($para[$nc2][18]['char_data'])) - 1))) { // while not at end of last chunk&nbsp;</div></li><li><div>                                $i2++;&nbsp;</div></li><li><div>                                if ($i2 &gt;= count($para[$nc2][18]['char_data'])) {&nbsp;</div></li><li><div>                                    $nc2++;&nbsp;</div></li><li><div>                                    $i2 = 0;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                if (!isset($para[$nc2][18]['char_data'][$i2]['diid']) || $para[$nc2][18]['char_data'][$i2]['diid'] != $ir) {&nbsp;</div></li><li><div>                                    continue;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                $nexttype = $para[$nc2][18]['char_data'][$i2]['type'];&nbsp;</div></li><li><div>                                if ($nexttype == UCDN::BIDI_CLASS_R || $nexttype == UCDN::BIDI_CLASS_EN || $nexttype == UCDN::BIDI_CLASS_AN) {&nbsp;</div></li><li><div>                                    $right = UCDN::BIDI_CLASS_R;&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                } else if ($nexttype == UCDN::BIDI_CLASS_L) {&nbsp;</div></li><li><div>                                    $right = UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                } else if (isset($para[$nc2][18]['char_data'][$i2]['eor'])) {&nbsp;</div></li><li><div>                                    $right = $para[$nc2][18]['char_data'][$i2]['eor'];&nbsp;</div></li><li><div>                                    break;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ($left &gt; -1 && $left == $right) {&nbsp;</div></li><li><div>                            $chardata[$i]['orig_type'] = $chardata[$i]['type']; // Need to store the original 'WS' for reference in L1 below&nbsp;</div></li><li><div>                            $chardata[$i]['type'] = $left;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    } else if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_L || $chardata[$i]['type'] == UCDN::BIDI_CLASS_R || $chardata[$i]['type'] == UCDN::BIDI_CLASS_EN || $chardata[$i]['type'] == UCDN::BIDI_CLASS_AN) {&nbsp;</div></li><li><div>                        $laststrongtype = $chardata[$i]['type'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // N2. Any remaining neutrals take the embedding direction&nbsp;</div></li><li><div>        for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>            $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>            $numchars = count($chardata);&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                if (isset($chardata[$i]['type']) && ($chardata[$i]['type'] == UCDN::BIDI_CLASS_ON || $chardata[$i]['type'] == UCDN::BIDI_CLASS_WS)) {&nbsp;</div></li><li><div>                    $chardata[$i]['orig_type'] = $chardata[$i]['type']; // Need to store the original 'WS' for reference in L1 below&nbsp;</div></li><li><div>                    $chardata[$i]['type'] = ($chardata[$i]['level'] % 2) ? UCDN::BIDI_CLASS_R : UCDN::BIDI_CLASS_L;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // I1. For all characters with an even (left-to-right) embedding direction, those of type R go up one level and those of type AN or EN go up two levels.&nbsp;</div></li><li><div>        // I2. For all characters with an odd (right-to-left) embedding direction, those of type L, EN or AN go up one level.&nbsp;</div></li><li><div>        for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>            $chardata = & $para[$nc][18]['char_data'];&nbsp;</div></li><li><div>            $numchars = count($chardata);&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                if (isset($chardata[$i]['level'])) {&nbsp;</div></li><li><div>                    $odd = $chardata[$i]['level'] % 2;&nbsp;</div></li><li><div>                    if ($odd) {&nbsp;</div></li><li><div>                        if (($chardata[$i]['type'] == UCDN::BIDI_CLASS_L) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_AN) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_EN)) {&nbsp;</div></li><li><div>                            $chardata[$i]['level'] += 1;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        if ($chardata[$i]['type'] == UCDN::BIDI_CLASS_R) {&nbsp;</div></li><li><div>                            $chardata[$i]['level'] += 1;&nbsp;</div></li><li><div>                        } else if (($chardata[$i]['type'] == UCDN::BIDI_CLASS_AN) || ($chardata[$i]['type'] == UCDN::BIDI_CLASS_EN)) {&nbsp;</div></li><li><div>                            $chardata[$i]['level'] += 2;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Remove Isolate formatters&nbsp;</div></li><li><div>        $numchunks = count($para);&nbsp;</div></li><li><div>        if ($controlchars) {&nbsp;</div></li><li><div>            for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x81\xa6&quot;);&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x81\xa7&quot;);&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x81\xa8&quot;);&nbsp;</div></li><li><div>                $this-&gt;removeChar($para[$nc][0], $para[$nc][18], &quot;\xe2\x81\xa9&quot;);&nbsp;</div></li><li><div>                preg_replace(&quot;/\x{2066}-\x{2069}/u&quot;, '', $para[$nc][0]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Remove any blank chunks made by removing directional codes&nbsp;</div></li><li><div>            for ($nc = ($numchunks - 1); $nc &gt;= 0; $nc--) {&nbsp;</div></li><li><div>                if (count($para[$nc][18]['char_data']) == 0) {&nbsp;</div></li><li><div>                    array_splice($para, $nc, 1);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// Reorder, once divided into lines&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _bidiReorder(&$chunkorder, &$content, &$cOTLdata, $blockdir)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $bidiData = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // First combine into one array (and get the highest level in use)&nbsp;</div></li><li><div>        $numchunks = count($content);&nbsp;</div></li><li><div>        $maxlevel = 0;&nbsp;</div></li><li><div>        for ($nc = 0; $nc &lt; $numchunks; $nc++) {&nbsp;</div></li><li><div>            $numchars = count($cOTLdata[$nc]['char_data']);&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $carac = array();&nbsp;</div></li><li><div>                if (isset($cOTLdata[$nc]['GPOSinfo'][$i])) {&nbsp;</div></li><li><div>                    $carac['GPOSinfo'] = $cOTLdata[$nc]['GPOSinfo'][$i];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $carac['uni'] = $cOTLdata[$nc]['char_data'][$i]['uni'];&nbsp;</div></li><li><div>                if (isset($cOTLdata[$nc]['char_data'][$i]['type']))&nbsp;</div></li><li><div>                    $carac['type'] = $cOTLdata[$nc]['char_data'][$i]['type'];&nbsp;</div></li><li><div>                if (isset($cOTLdata[$nc]['char_data'][$i]['level']))&nbsp;</div></li><li><div>                    $carac['level'] = $cOTLdata[$nc]['char_data'][$i]['level'];&nbsp;</div></li><li><div>                if (isset($cOTLdata[$nc]['char_data'][$i]['orig_type'])) {&nbsp;</div></li><li><div>                    $carac['orig_type'] = $cOTLdata[$nc]['char_data'][$i]['orig_type'];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $carac['group'] = $cOTLdata[$nc]['group']{$i};&nbsp;</div></li><li><div>                $carac['chunkid'] = $chunkorder[$nc]; // gives font id and/or object ID&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $maxlevel = max((isset($carac['level']) ? $carac['level'] : 0), $maxlevel);&nbsp;</div></li><li><div>                $bidiData[] = $carac;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($maxlevel == 0) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $numchars = count($bidiData);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // L1. On each line, reset the embedding level of the following characters to the paragraph embedding level:&nbsp;</div></li><li><div>        //  1. Segment separators (Tab) 'S', &nbsp;</div></li><li><div>        //  2. Paragraph separators 'B', &nbsp;</div></li><li><div>        //  3. Any sequence of whitespace characters 'WS' preceding a segment separator or paragraph separator, and&nbsp;</div></li><li><div>        //  4. Any sequence of whitespace characters 'WS' at the end of the line.&nbsp;</div></li><li><div>        //  The types of characters used here are the original types, not those modified by the previous phase cf N1 and N2*******&nbsp;</div></li><li><div>        //  Because a Paragraph Separator breaks lines, there will be at most one per line, at the end of that line.&nbsp;</div></li><li><div>        // Set the initial paragraph embedding level&nbsp;</div></li><li><div>        if ($blockdir == 'rtl') {&nbsp;</div></li><li><div>            $pel = 1;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $pel = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($i = ($numchars - 1); $i &gt; 0; $i--) {&nbsp;</div></li><li><div>            if ($bidiData[$i]['type'] == UCDN::BIDI_CLASS_WS || (isset($bidiData[$i]['orig_type']) && $bidiData[$i]['orig_type'] == UCDN::BIDI_CLASS_WS)) {&nbsp;</div></li><li><div>                $bidiData[$i]['level'] = $pel;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.&nbsp;</div></li><li><div>        for ($j = $maxlevel; $j &gt; 0; $j--) {&nbsp;</div></li><li><div>            $ordarray = array();&nbsp;</div></li><li><div>            $revarr = array();&nbsp;</div></li><li><div>            $onlevel = false;&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numchars; ++$i) {&nbsp;</div></li><li><div>                if ($bidiData[$i]['level'] &gt;= $j) {&nbsp;</div></li><li><div>                    $onlevel = true;&nbsp;</div></li><li><div>                    // L4. A character is depicted by a mirrored glyph if and only if (a) the resolved directionality of that character is R, and (b) the Bidi_Mirrored property value of that character is true.&nbsp;</div></li><li><div>                    if (isset(UCDN::$mirror_pairs[$bidiData[$i]['uni']]) && $bidiData[$i]['type'] == UCDN::BIDI_CLASS_R) {&nbsp;</div></li><li><div>                        $bidiData[$i]['uni'] = UCDN::$mirror_pairs[$bidiData[$i]['uni']];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $revarr[] = $bidiData[$i];&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    if ($onlevel) {&nbsp;</div></li><li><div>                        $revarr = array_reverse($revarr);&nbsp;</div></li><li><div>                        $ordarray = array_merge($ordarray, $revarr);&nbsp;</div></li><li><div>                        $revarr = Array();&nbsp;</div></li><li><div>                        $onlevel = false;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $ordarray[] = $bidiData[$i];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($onlevel) {&nbsp;</div></li><li><div>                $revarr = array_reverse($revarr);&nbsp;</div></li><li><div>                $ordarray = array_merge($ordarray, $revarr);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $bidiData = $ordarray;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $content = array();&nbsp;</div></li><li><div>        $cOTLdata = array();&nbsp;</div></li><li><div>        $chunkorder = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $nc = -1; // New chunk order ID&nbsp;</div></li><li><div>        $chunkid = -1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($bidiData as $carac) {&nbsp;</div></li><li><div>            if ($carac['chunkid'] != $chunkid) {&nbsp;</div></li><li><div>                $nc++;&nbsp;</div></li><li><div>                $chunkorder[$nc] = $carac['chunkid'];&nbsp;</div></li><li><div>                $cctr = 0;&nbsp;</div></li><li><div>                $content[$nc] = '';&nbsp;</div></li><li><div>                $cOTLdata[$nc]['group'] = '';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($carac['uni'] != 0xFFFC) {   // Object replacement character (65532)&nbsp;</div></li><li><div>                $content[$nc] .= code2utf($carac['uni']);&nbsp;</div></li><li><div>                $cOTLdata[$nc]['group'] .= $carac['group'];&nbsp;</div></li><li><div>                if (!empty($carac['GPOSinfo'])) {&nbsp;</div></li><li><div>                    if (isset($carac['GPOSinfo'])) {&nbsp;</div></li><li><div>                        $cOTLdata[$nc]['GPOSinfo'][$cctr] = $carac['GPOSinfo'];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $cOTLdata[$nc]['GPOSinfo'][$cctr]['wDir'] = ($carac['level'] % 2) ? 'RTL' : 'LTR';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $chunkid = $carac['chunkid'];&nbsp;</div></li><li><div>            $cctr++;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>// These functions are called from mpdf after GSUB/GPOS has taken place&nbsp;</div></li><li><div>// At this stage the bidi-type is in string form&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>    function splitOTLdata(&$cOTLdata, $OTLcutoffpos, $OTLrestartpos = '')&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (!$OTLrestartpos) {&nbsp;</div></li><li><div>            $OTLrestartpos = $OTLcutoffpos;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $newOTLdata = array('GPOSinfo' =&gt; array(), 'char_data' =&gt; array());&nbsp;</div></li><li><div>        $newOTLdata['group'] = substr($cOTLdata['group'], $OTLrestartpos);&nbsp;</div></li><li><div>        $cOTLdata['group'] = substr($cOTLdata['group'], 0, $OTLcutoffpos);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($cOTLdata['GPOSinfo']) && $cOTLdata['GPOSinfo']) {&nbsp;</div></li><li><div>            foreach ($cOTLdata['GPOSinfo'] AS $k =&gt; $val) {&nbsp;</div></li><li><div>                if ($k &gt;= $OTLrestartpos) {&nbsp;</div></li><li><div>                    $newOTLdata['GPOSinfo'][($k - $OTLrestartpos)] = $val;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($k &gt;= $OTLcutoffpos) {&nbsp;</div></li><li><div>                    unset($cOTLdata['GPOSinfo'][$k]);&nbsp;</div></li><li><div>                    //$cOTLdata['GPOSinfo'][$k] = array();&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (isset($cOTLdata['char_data'])) {&nbsp;</div></li><li><div>            $newOTLdata['char_data'] = array_slice($cOTLdata['char_data'], $OTLrestartpos);&nbsp;</div></li><li><div>            array_splice($cOTLdata['char_data'], $OTLcutoffpos);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Not necessary - easier to debug&nbsp;</div></li><li><div>        if (isset($cOTLdata['GPOSinfo']))&nbsp;</div></li><li><div>            ksort($cOTLdata['GPOSinfo']);&nbsp;</div></li><li><div>        if (isset($newOTLdata['GPOSinfo']))&nbsp;</div></li><li><div>            ksort($newOTLdata['GPOSinfo']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $newOTLdata;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function sliceOTLdata($OTLdata, $pos, $len)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $newOTLdata = array('GPOSinfo' =&gt; array(), 'char_data' =&gt; array());&nbsp;</div></li><li><div>        $newOTLdata['group'] = substr($OTLdata['group'], $pos, $len);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($OTLdata['GPOSinfo']) {&nbsp;</div></li><li><div>            foreach ($OTLdata['GPOSinfo'] AS $k =&gt; $val) {&nbsp;</div></li><li><div>                if ($k &gt;= $pos && $k &lt; ($pos + $len)) {&nbsp;</div></li><li><div>                    $newOTLdata['GPOSinfo'][($k - $pos)] = $val;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (isset($OTLdata['char_data'])) {&nbsp;</div></li><li><div>            $newOTLdata['char_data'] = array_slice($OTLdata['char_data'], $pos, $len);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Not necessary - easier to debug&nbsp;</div></li><li><div>        if ($newOTLdata['GPOSinfo'])&nbsp;</div></li><li><div>            ksort($newOTLdata['GPOSinfo']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $newOTLdata;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// Remove one or more occurrences of $char (single character) from $txt and adjust OTLdata&nbsp;</div></li><li><div>    function removeChar(&$txt, &$cOTLdata, $char)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        while (mb_strpos($txt, $char, 0, $this-&gt;mpdf-&gt;mb_enc) !== false) {&nbsp;</div></li><li><div>            $pos = mb_strpos($txt, $char, 0, $this-&gt;mpdf-&gt;mb_enc);&nbsp;</div></li><li><div>            $newGPOSinfo = array();&nbsp;</div></li><li><div>            $cOTLdata['group'] = substr_replace($cOTLdata['group'], '', $pos, 1);&nbsp;</div></li><li><div>            if ($cOTLdata['GPOSinfo']) {&nbsp;</div></li><li><div>                foreach ($cOTLdata['GPOSinfo'] AS $k =&gt; $val) {&nbsp;</div></li><li><div>                    if ($k &gt; $pos) {&nbsp;</div></li><li><div>                        $newGPOSinfo[($k - 1)] = $val;&nbsp;</div></li><li><div>                    } else if ($k != $pos) {&nbsp;</div></li><li><div>                        $newGPOSinfo[$k] = $val;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $cOTLdata['GPOSinfo'] = $newGPOSinfo;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($cOTLdata['char_data'])) {&nbsp;</div></li><li><div>                array_splice($cOTLdata['char_data'], $pos, 1);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $txt = preg_replace(&quot;/&quot; . $char . &quot;/&quot;, '', $txt, 1);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// Remove one or more occurrences of $char (single character) from $txt and adjust OTLdata&nbsp;</div></li><li><div>    function replaceSpace(&$txt, &$cOTLdata)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $char = chr(194) . chr(160); // NBSP&nbsp;</div></li><li><div>        while (mb_strpos($txt, $char, 0, $this-&gt;mpdf-&gt;mb_enc) !== false) {&nbsp;</div></li><li><div>            $pos = mb_strpos($txt, $char, 0, $this-&gt;mpdf-&gt;mb_enc);&nbsp;</div></li><li><div>            if ($cOTLdata['char_data'][$pos]['uni'] == 160) {&nbsp;</div></li><li><div>                $cOTLdata['char_data'][$pos]['uni'] = 32;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $txt = preg_replace(&quot;/&quot; . $char . &quot;/&quot;, ' ', $txt, 1);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function trimOTLdata(&$cOTLdata, $Left = true, $Right = true)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $len = count($cOTLdata['char_data']);&nbsp;</div></li><li><div>        $nLeft = 0;&nbsp;</div></li><li><div>        $nRight = 0;&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $len; $i++) {&nbsp;</div></li><li><div>            if ($cOTLdata['char_data'][$i]['uni'] == 32 || $cOTLdata['char_data'][$i]['uni'] == 12288) {&nbsp;</div></li><li><div>                $nLeft++;&nbsp;</div></li><li><div>            } // 12288 = 0x3000 = CJK space&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        for ($i = ($len - 1); $i &gt;= 0; $i--) {&nbsp;</div></li><li><div>            if ($cOTLdata['char_data'][$i]['uni'] == 32 || $cOTLdata['char_data'][$i]['uni'] == 12288) {&nbsp;</div></li><li><div>                $nRight++;&nbsp;</div></li><li><div>            } // 12288 = 0x3000 = CJK space&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Trim Right&nbsp;</div></li><li><div>        if ($Right && $nRight) {&nbsp;</div></li><li><div>            $cOTLdata['group'] = substr($cOTLdata['group'], 0, strlen($cOTLdata['group']) - $nRight);&nbsp;</div></li><li><div>            if ($cOTLdata['GPOSinfo']) {&nbsp;</div></li><li><div>                foreach ($cOTLdata['GPOSinfo'] AS $k =&gt; $val) {&nbsp;</div></li><li><div>                    if ($k &gt;= $len - $nRight) {&nbsp;</div></li><li><div>                        unset($cOTLdata['GPOSinfo'][$k]);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($cOTLdata['char_data'])) {&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $nRight; $i++) {&nbsp;</div></li><li><div>                    array_pop($cOTLdata['char_data']);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // Trim Left&nbsp;</div></li><li><div>        if ($Left && $nLeft) {&nbsp;</div></li><li><div>            $cOTLdata['group'] = substr($cOTLdata['group'], $nLeft);&nbsp;</div></li><li><div>            if ($cOTLdata['GPOSinfo']) {&nbsp;</div></li><li><div>                $newPOSinfo = array();&nbsp;</div></li><li><div>                foreach ($cOTLdata['GPOSinfo'] AS $k =&gt; $val) {&nbsp;</div></li><li><div>                    if ($k &gt;= $nLeft) {&nbsp;</div></li><li><div>                        $newPOSinfo[$k - $nLeft] = $cOTLdata['GPOSinfo'][$k];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $cOTLdata['GPOSinfo'] = $newPOSinfo;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (isset($cOTLdata['char_data'])) {&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $nLeft; $i++) {&nbsp;</div></li><li><div>                    array_shift($cOTLdata['char_data']);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>//////////         GENERAL OTL FUNCTIONS       /////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>////////////////////////////////////////////////////////////////&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function glyphToChar($gid)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return (ord($this-&gt;glyphIDtoUni[$gid * 3]) &lt;&lt; 16) + (ord($this-&gt;glyphIDtoUni[$gid * 3 + 1]) &lt;&lt; 8) + ord($this-&gt;glyphIDtoUni[$gid * 3 + 2]);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function unicode_hex($unicode_dec)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return (str_pad(strtoupper(dechex($unicode_dec)), 5, '0', STR_PAD_LEFT));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function seek($pos)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;_pos = $pos;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function skip($delta)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $this-&gt;_pos += $delta;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function read_short()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $a = (ord($this-&gt;ttfOTLdata[$this-&gt;_pos]) &lt;&lt; 8) + ord($this-&gt;ttfOTLdata[$this-&gt;_pos + 1]);&nbsp;</div></li><li><div>        if ($a & (1 &lt;&lt; 15)) {&nbsp;</div></li><li><div>            $a = ($a - (1 &lt;&lt; 16));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $this-&gt;_pos += 2;&nbsp;</div></li><li><div>        return $a;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function read_ushort()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $a = (ord($this-&gt;ttfOTLdata[$this-&gt;_pos]) &lt;&lt; 8) + ord($this-&gt;ttfOTLdata[$this-&gt;_pos + 1]);&nbsp;</div></li><li><div>        $this-&gt;_pos += 2;&nbsp;</div></li><li><div>        return $a;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getCoverageGID()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // Called from Lookup Type 1, Format 1 - returns glyphIDs rather than hexstrings&nbsp;</div></li><li><div>        // Need to do this separately to cache separately&nbsp;</div></li><li><div>        // Otherwise the same as fn below _getCoverage&nbsp;</div></li><li><div>        $offset = $this-&gt;_pos;&nbsp;</div></li><li><div>        if (isset($this-&gt;LuDataCache[$this-&gt;fontkey]['GID'][$offset])) {&nbsp;</div></li><li><div>            $g = $this-&gt;LuDataCache[$this-&gt;fontkey]['GID'][$offset];&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $g = array();&nbsp;</div></li><li><div>            $CoverageFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            if ($CoverageFormat == 1) {&nbsp;</div></li><li><div>                $CoverageGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($gid = 0; $gid &lt; $CoverageGlyphCount; $gid++) {&nbsp;</div></li><li><div>                    $glyphID = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $g[] = $glyphID;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($CoverageFormat == 2) {&nbsp;</div></li><li><div>                $RangeCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($r = 0; $r &lt; $RangeCount; $r++) {&nbsp;</div></li><li><div>                    $start = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $end = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $StartCoverageIndex = $this-&gt;read_ushort(); // n/a&nbsp;</div></li><li><div>                    for ($glyphID = $start; $glyphID &lt;= $end; $glyphID++) {&nbsp;</div></li><li><div>                        $g[] = $glyphID;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $this-&gt;LuDataCache[$this-&gt;fontkey]['GID'][$offset] = $g;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $g;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getCoverage()&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $offset = $this-&gt;_pos;&nbsp;</div></li><li><div>        if (isset($this-&gt;LuDataCache[$this-&gt;fontkey][$offset])) {&nbsp;</div></li><li><div>            $g = $this-&gt;LuDataCache[$this-&gt;fontkey][$offset];&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $g = array();&nbsp;</div></li><li><div>            $CoverageFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            if ($CoverageFormat == 1) {&nbsp;</div></li><li><div>                $CoverageGlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($gid = 0; $gid &lt; $CoverageGlyphCount; $gid++) {&nbsp;</div></li><li><div>                    $glyphID = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $g[] = $this-&gt;unicode_hex($this-&gt;glyphToChar($glyphID));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($CoverageFormat == 2) {&nbsp;</div></li><li><div>                $RangeCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($r = 0; $r &lt; $RangeCount; $r++) {&nbsp;</div></li><li><div>                    $start = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $end = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $StartCoverageIndex = $this-&gt;read_ushort(); // n/a&nbsp;</div></li><li><div>                    for ($glyphID = $start; $glyphID &lt;= $end; $glyphID++) {&nbsp;</div></li><li><div>                        $g[] = $this-&gt;unicode_hex($this-&gt;glyphToChar($glyphID));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $this-&gt;LuDataCache[$this-&gt;fontkey][$offset] = $g;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $g;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getClasses($offset)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (isset($this-&gt;LuDataCache[$this-&gt;fontkey][$offset])) {&nbsp;</div></li><li><div>            $GlyphByClass = $this-&gt;LuDataCache[$this-&gt;fontkey][$offset];&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $this-&gt;seek($offset);&nbsp;</div></li><li><div>            $ClassFormat = $this-&gt;read_ushort();&nbsp;</div></li><li><div>            $GlyphByClass = array();&nbsp;</div></li><li><div>            if ($ClassFormat == 1) {&nbsp;</div></li><li><div>                $StartGlyph = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                $GlyphCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $GlyphCount; $i++) {&nbsp;</div></li><li><div>                    $startGlyphID = $StartGlyph + $i;&nbsp;</div></li><li><div>                    $endGlyphID = $StartGlyph + $i;&nbsp;</div></li><li><div>                    $class = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    // Note: Font FreeSerif , tag &quot;blws&quot;&nbsp;</div></li><li><div>                    // $BacktrackClasses[0] is defined ? a mistake in the font ???&nbsp;</div></li><li><div>                    // Let's ignore for now&nbsp;</div></li><li><div>                    if ($class &gt; 0) {&nbsp;</div></li><li><div>                        for ($g = $startGlyphID; $g &lt;= $endGlyphID; $g++) {&nbsp;</div></li><li><div>                            if ($this-&gt;glyphToChar($g)) {&nbsp;</div></li><li><div>                                $GlyphByClass[$class][$this-&gt;glyphToChar($g)] = 1;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($ClassFormat == 2) {&nbsp;</div></li><li><div>                $tableCount = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $tableCount; $i++) {&nbsp;</div></li><li><div>                    $startGlyphID = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $endGlyphID = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    $class = $this-&gt;read_ushort();&nbsp;</div></li><li><div>                    // Note: Font FreeSerif , tag &quot;blws&quot;&nbsp;</div></li><li><div>                    // $BacktrackClasses[0] is defined ? a mistake in the font ???&nbsp;</div></li><li><div>                    // Let's ignore for now&nbsp;</div></li><li><div>                    if ($class &gt; 0) {&nbsp;</div></li><li><div>                        for ($g = $startGlyphID; $g &lt;= $endGlyphID; $g++) {&nbsp;</div></li><li><div>                            if ($this-&gt;glyphToChar($g)) {&nbsp;</div></li><li><div>                                $GlyphByClass[$class][$this-&gt;glyphToChar($g)] = 1;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $this-&gt;LuDataCache[$this-&gt;fontkey][$offset] = $GlyphByClass;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $GlyphByClass;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _getOTLscriptTag($ScriptLang, $scripttag, $scriptblock, $shaper, $useOTL, $mode)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // ScriptLang is the array of available script/lang tags supported by the font&nbsp;</div></li><li><div>        // $scriptblock is the (number/code) for the script of the actual text string based on Unicode properties (UCDN::$uni_scriptblock)&nbsp;</div></li><li><div>        // $scripttag is the default tag derived from $scriptblock&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>          http://www.microsoft.com/typography/otspec/ttoreg.htm&nbsp;</div></li><li><div>          http://www.microsoft.com/typography/otspec/scripttags.htm&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>          Values for useOTL&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>          Bit   dn  hn  Value&nbsp;</div></li><li><div>          1 1   0x0001  GSUB/GPOS - Latin scripts&nbsp;</div></li><li><div>          2 2   0x0002  GSUB/GPOS - Cyrillic scripts&nbsp;</div></li><li><div>          3 4   0x0004  GSUB/GPOS - Greek scripts&nbsp;</div></li><li><div>          4 8   0x0008  GSUB/GPOS - CJK scripts (excluding Hangul-Jamo)&nbsp;</div></li><li><div>          5 16  0x0010  (Reserved)&nbsp;</div></li><li><div>          6 32  0x0020  (Reserved)&nbsp;</div></li><li><div>          7 64  0x0040  (Reserved)&nbsp;</div></li><li><div>          8 128 0x0080  GSUB/GPOS - All other scripts (including all RTL scripts, complex scripts with shapers etc)&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>          NB If change for RTL - cf. function magic_reverse_dir in mpdf.php to update&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($scriptblock == UCDN::SCRIPT_LATIN) {&nbsp;</div></li><li><div>            if (!($useOTL & 0x01)) {&nbsp;</div></li><li><div>                return array('', false);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else if ($scriptblock == UCDN::SCRIPT_CYRILLIC) {&nbsp;</div></li><li><div>            if (!($useOTL & 0x02)) {&nbsp;</div></li><li><div>                return array('', false);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else if ($scriptblock == UCDN::SCRIPT_GREEK) {&nbsp;</div></li><li><div>            if (!($useOTL & 0x04)) {&nbsp;</div></li><li><div>                return array('', false);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else if ($scriptblock &gt;= UCDN::SCRIPT_HIRAGANA && $scriptblock &lt;= UCDN::SCRIPT_YI) {&nbsp;</div></li><li><div>            if (!($useOTL & 0x08)) {&nbsp;</div></li><li><div>                return array('', false);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            if (!($useOTL & 0x80)) {&nbsp;</div></li><li><div>                return array('', false);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //  If availabletags includes scripttag - choose&nbsp;</div></li><li><div>        if (isset($ScriptLang[$scripttag])) {&nbsp;</div></li><li><div>            return array($scripttag, false);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //  If INDIC (or Myanmar) and available tag not includes new version, check if includes old version & choose old version&nbsp;</div></li><li><div>        if ($shaper) {&nbsp;</div></li><li><div>            switch ($scripttag) {&nbsp;</div></li><li><div>                CASE 'bng2': if (isset($ScriptLang['beng']))&nbsp;</div></li><li><div>                        return array('beng', true);&nbsp;</div></li><li><div>                CASE 'dev2': if (isset($ScriptLang['deva']))&nbsp;</div></li><li><div>                        return array('deva', true);&nbsp;</div></li><li><div>                CASE 'gjr2': if (isset($ScriptLang['gujr']))&nbsp;</div></li><li><div>                        return array('gujr', true);&nbsp;</div></li><li><div>                CASE 'gur2': if (isset($ScriptLang['guru']))&nbsp;</div></li><li><div>                        return array('guru', true);&nbsp;</div></li><li><div>                CASE 'knd2': if (isset($ScriptLang['knda']))&nbsp;</div></li><li><div>                        return array('knda', true);&nbsp;</div></li><li><div>                CASE 'mlm2': if (isset($ScriptLang['mlym']))&nbsp;</div></li><li><div>                        return array('mlym', true);&nbsp;</div></li><li><div>                CASE 'ory2': if (isset($ScriptLang['orya']))&nbsp;</div></li><li><div>                        return array('orya', true);&nbsp;</div></li><li><div>                CASE 'tml2': if (isset($ScriptLang['taml']))&nbsp;</div></li><li><div>                        return array('taml', true);&nbsp;</div></li><li><div>                CASE 'tel2': if (isset($ScriptLang['telu']))&nbsp;</div></li><li><div>                        return array('telu', true);&nbsp;</div></li><li><div>                CASE 'mym2': if (isset($ScriptLang['mymr']))&nbsp;</div></li><li><div>                        return array('mymr', true);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        //  choose DFLT if present&nbsp;</div></li><li><div>        if (isset($ScriptLang['DFLT'])) {&nbsp;</div></li><li><div>            return array('DFLT', false);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        //  else choose dflt if present&nbsp;</div></li><li><div>        if (isset($ScriptLang['dflt'])) {&nbsp;</div></li><li><div>            return array('dflt', false);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        //  else return no scriptTag&nbsp;</div></li><li><div>        if (isset($ScriptLang['latn'])) {&nbsp;</div></li><li><div>            return array('latn', false);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        //  else return no scriptTag&nbsp;</div></li><li><div>        return array('', false);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// LangSys tags&nbsp;</div></li><li><div>    function _getOTLLangTag($ietf, $available)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        // http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes&nbsp;</div></li><li><div>        // http://www.microsoft.com/typography/otspec/languagetags.htm&nbsp;</div></li><li><div>        // IETF tag = e.g. en-US, und-Arab, sr-Cyrl cf. config_lang2fonts.php&nbsp;</div></li><li><div>        if ($available == '') {&nbsp;</div></li><li><div>            return '';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $tags = preg_split('/-/', $ietf);&nbsp;</div></li><li><div>        $lang = '';&nbsp;</div></li><li><div>        $country = '';&nbsp;</div></li><li><div>        $script = '';&nbsp;</div></li><li><div>        $lang = strtolower($tags[0]);&nbsp;</div></li><li><div>        if (isset($tags[1]) && $tags[1]) {&nbsp;</div></li><li><div>            if (strlen($tags[1]) == 2) {&nbsp;</div></li><li><div>                $country = strtolower($tags[1]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (isset($tags[2]) && $tags[2]) {&nbsp;</div></li><li><div>            $country = strtolower($tags[2]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($lang != '' && isset(UCDN::$ot_languages[$lang])) {&nbsp;</div></li><li><div>            $langsys = UCDN::$ot_languages[$lang];&nbsp;</div></li><li><div>        } else if ($lang != '' && $country != '' && isset(UCDN::$ot_languages[$lang . '' . $country])) {&nbsp;</div></li><li><div>            $langsys = UCDN::$ot_languages[$lang . '' . $country];&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $langsys = &quot;DFLT&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (strpos($available, $langsys) === false) {&nbsp;</div></li><li><div>            if (strpos($available, &quot;DFLT&quot;) !== false) {&nbsp;</div></li><li><div>                return &quot;DFLT&quot;;&nbsp;</div></li><li><div>            } else&nbsp;</div></li><li><div>                return '';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $langsys;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    function _dumpproc($GPOSSUB, $lookupID, $subtable, $Type, $Format, $ptr, $currGlyph, $level)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        echo '&lt;div style=&quot;padding-left: ' . ($level * 2) . 'em;&quot;&gt;';&nbsp;</div></li><li><div>        echo $GPOSSUB . ' LookupID #' . $lookupID . ' Subtable#' . $subtable . ' Type: ' . $Type . ' Format: ' . $Format . '&lt;br /&gt;';&nbsp;</div></li><li><div>        echo '&lt;div style=&quot;font-family:monospace&quot;&gt;';&nbsp;</div></li><li><div>        echo 'Glyph position: ' . $ptr . ' Current Glyph: ' . $currGlyph . '&lt;br /&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>            if ($i == $ptr) {&nbsp;</div></li><li><div>                echo '&lt;b&gt;';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            echo $this-&gt;OTLdata[$i]['hex'] . ' ';&nbsp;</div></li><li><div>            if ($i == $ptr) {&nbsp;</div></li><li><div>                echo '&lt;/b&gt;';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        echo '&lt;br /&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>            if ($i == $ptr) {&nbsp;</div></li><li><div>                echo '&lt;b&gt;';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            echo str_pad($this-&gt;OTLdata[$i]['uni'], 5) . ' ';&nbsp;</div></li><li><div>            if ($i == $ptr) {&nbsp;</div></li><li><div>                echo '&lt;/b&gt;';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        echo '&lt;br /&gt;';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($GPOSSUB == 'GPOS') {&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; count($this-&gt;OTLdata); $i++) {&nbsp;</div></li><li><div>                if (!empty($this-&gt;OTLdata[$i]['GPOSinfo'])) {&nbsp;</div></li><li><div>                    echo $this-&gt;OTLdata[$i]['hex'] . ' &#x' . $this-&gt;OTLdata[$i]['hex'] . '; ';&nbsp;</div></li><li><div>                    print_r($this-&gt;OTLdata[$i]['GPOSinfo']);&nbsp;</div></li><li><div>                    echo ' ';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        echo '&lt;/div&gt;';&nbsp;</div></li><li><div>        echo '&lt;/div&gt;';&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 2.7.1</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/classes/otl/" class="active">2.8.1</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.0/classes/otl/" class="">2.8.0</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.7.3/classes/otl/" class="">2.7.3</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.7.2/classes/otl/" class="">2.7.2</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.7.1/classes/otl/" class="">2.7.1</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>otl</li><li><span></span>WooCommerce PDF Invoices</li><li><span></span>2.8.1</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>