<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="2.8.1" data-slug="woocommerce-pdf-invoices" data-type="class" data-id="20628"><head xmlns="http://www.w3.org/1999/xhtml"><title> indic | class | Woocommerce Pdf Invoices | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="INDIC, class, plugin, woocommerce-pdf-invoices, 2.8.1" /><meta name="description" content="The WooCommerce PDF Invoices INDIC class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=561eba34576647f71d08a67485f380fc' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/indic/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Findic%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Findic%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-woocommerce-pdf-invoices-2.8.1-class-indic","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="indic" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to woocommerce-pdf-invoices." href="http://hookr.io/plugins/woocommerce-pdf-invoices/" class="plugin"><span property="name">woocommerce-pdf-invoices</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 2.8.1." href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/" class="H_VERSION"><span property="name">2.8.1</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">indic</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="211"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/all/" title="All">All <span class="count badge">211</span></a></li><li class="" data-id="new" data-count="24"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/new/" title="New">New <span class="count badge">24</span></a></li><li class="" data-id="hooks" data-count="41"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/hooks/" title="Hooks">Hooks <span class="count badge">41</span></a></li><li class="" data-id="action" data-count="13"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/actions/" title="Actions">Actions <span class="count badge">13</span></a></li><li class="" data-id="filter" data-count="28"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/filters/" title="Filters">Filters <span class="count badge">28</span></a></li><li class="active" data-id="class" data-count="63"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/classes/" title="Classes">Classes <span class="count badge">63</span></a></li><li class="" data-id="constant" data-count="66"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/constants/" title="Constants">Constants <span class="count badge">66</span></a></li><li class="" data-id="function" data-count="40"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/functions/" title="Functions">Functions <span class="count badge">40</span></a></li><li class="" data-id="shortcode" data-count="1"><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">1</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>INDIC</strong></h1><p>The WooCommerce PDF Invoices <strong>INDIC</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/files/vendor-mpdf-mpdf-classes-indic/" class="file">/vendor/mpdf/mpdf/classes/indic.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="5" class="block" start="5"><li><div>class INDIC&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>    /** FROM hb-ot-shape-complex-indic-private.hh */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // indic_category&nbsp;</div></li><li><div>    const OT_X = 0;&nbsp;</div></li><li><div>    const OT_C = 1;&nbsp;</div></li><li><div>    const OT_V = 2;&nbsp;</div></li><li><div>    const OT_N = 3;&nbsp;</div></li><li><div>    const OT_H = 4;&nbsp;</div></li><li><div>    const OT_ZWNJ = 5;&nbsp;</div></li><li><div>    const OT_ZWJ = 6;&nbsp;</div></li><li><div>    const OT_M = 7; /** Matra or Dependent Vowel */&nbsp;</div></li><li><div>    const OT_SM = 8;&nbsp;</div></li><li><div>    const OT_VD = 9;&nbsp;</div></li><li><div>    const OT_A = 10;&nbsp;</div></li><li><div>    const OT_NBSP = 11;&nbsp;</div></li><li><div>    const OT_DOTTEDCIRCLE = 12; /** Not in the spec, but special in Uniscribe. /Very very/ special! */&nbsp;</div></li><li><div>    const OT_RS = 13; /** Register Shifter, used in Khmer OT spec */&nbsp;</div></li><li><div>    const OT_Coeng = 14;&nbsp;</div></li><li><div>    const OT_Repha = 15;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const OT_Ra = 16; /** Not explicitly listed in the OT spec, but used in the grammar. */&nbsp;</div></li><li><div>    const OT_CM = 17;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // Based on indic_category used to make string to find syllables&nbsp;</div></li><li><div>    // OT_ to string character (using e.g. OT_C from INDIC) hb-ot-shape-complex-indic-private.hh&nbsp;</div></li><li><div>    public static $indic_category_char = array(&nbsp;</div></li><li><div>        'x', &nbsp;</div></li><li><div>        'C', &nbsp;</div></li><li><div>        'V', &nbsp;</div></li><li><div>        'N', &nbsp;</div></li><li><div>        'H', &nbsp;</div></li><li><div>        'Z', &nbsp;</div></li><li><div>        'J', &nbsp;</div></li><li><div>        'M', &nbsp;</div></li><li><div>        'S', &nbsp;</div></li><li><div>        'v', &nbsp;</div></li><li><div>        'A', /** Spec gives Andutta U+0952 as OT_A. However, testing shows that Uniscribe&nbsp;</div></li><li><div>         * treats U+0951..U+0952 all as OT_VD - see set_indic_properties */&nbsp;</div></li><li><div>        's', &nbsp;</div></li><li><div>        'D', &nbsp;</div></li><li><div>        'F', /** Register shift Khmer only */&nbsp;</div></li><li><div>        'G', /** Khmer only */&nbsp;</div></li><li><div>        'r', /** 0D4E (dot reph) only one in Malayalam */&nbsp;</div></li><li><div>        'R', &nbsp;</div></li><li><div>        'm', /** Consonant medial only used in Indic 0A75 in Gurmukhi  (0A00..0A7F)  : also in Lao, Myanmar, Tai Tham, Javanese & Cham  */&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /** Visual positions in a syllable from left to right. */&nbsp;</div></li><li><div>    /** FROM hb-ot-shape-complex-indic-private.hh */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // indic_position&nbsp;</div></li><li><div>    const POS_START = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const POS_RA_TO_BECOME_REPH = 1;&nbsp;</div></li><li><div>    const POS_PRE_M = 2;&nbsp;</div></li><li><div>    const POS_PRE_C = 3;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const POS_BASE_C = 4;&nbsp;</div></li><li><div>    const POS_AFTER_MAIN = 5;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const POS_ABOVE_C = 6;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const POS_BEFORE_SUB = 7;&nbsp;</div></li><li><div>    const POS_BELOW_C = 8;&nbsp;</div></li><li><div>    const POS_AFTER_SUB = 9;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const POS_BEFORE_POST = 10;&nbsp;</div></li><li><div>    const POS_POST_C = 11;&nbsp;</div></li><li><div>    const POS_AFTER_POST = 12;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const POS_FINAL_C = 13;&nbsp;</div></li><li><div>    const POS_SMVD = 14;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const POS_END = 15;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Basic features.&nbsp;</div></li><li><div>     * These features are applied in order, one at a time, after initial_reordering.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Must be in the same order as the indic_features array. Ones starting with _ are F_GLOBAL&nbsp;</div></li><li><div>     * Ones without the _ are only applied where the mask says!&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const _NUKT = 0;&nbsp;</div></li><li><div>    const _AKHN = 1;&nbsp;</div></li><li><div>    const RPHF = 2;&nbsp;</div></li><li><div>    const _RKRF = 3;&nbsp;</div></li><li><div>    const PREF = 4;&nbsp;</div></li><li><div>    const BLWF = 5;&nbsp;</div></li><li><div>    const HALF = 6;&nbsp;</div></li><li><div>    const ABVF = 7;&nbsp;</div></li><li><div>    const PSTF = 8;&nbsp;</div></li><li><div>    const CFAR = 9; // Khmer only&nbsp;</div></li><li><div>    const _VATU = 10;&nbsp;</div></li><li><div>    const _CJCT = 11;&nbsp;</div></li><li><div>    const INIT = 12;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function set_indic_properties(&$info, $scriptblock)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $u = $info['uni'];&nbsp;</div></li><li><div>        $type = self::indic_get_categories($u);&nbsp;</div></li><li><div>        $cat = ($type & 0x7F);&nbsp;</div></li><li><div>        $pos = ($type &gt;&gt; 8);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Re-assign category&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($u == 0x17D1)&nbsp;</div></li><li><div>            $cat = self::OT_X;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($cat == self::OT_X && self::in_range($u, 0x17CB, 0x17D3)) { /** Khmer Various signs */&nbsp;</div></li><li><div>            /** These are like Top Matras. */&nbsp;</div></li><li><div>            $cat = self::OT_M;&nbsp;</div></li><li><div>            $pos = self::POS_ABOVE_C;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($u == 0x17C6)&nbsp;</div></li><li><div>            $cat = self::OT_N; /** Khmer Bindu doesn't like to be repositioned. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($u == 0x17D2)&nbsp;</div></li><li><div>            $cat = self::OT_Coeng; /** Khmer coeng */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** The spec says U+0952 is OT_A.    However, testing shows that Uniscribe&nbsp;</div></li><li><div>         * treats U+0951..U+0952 all as OT_VD.&nbsp;</div></li><li><div>         * TESTS:&nbsp;</div></li><li><div>         * U+092E, U+0947, U+0952&nbsp;</div></li><li><div>         * U+092E, U+0952, U+0947&nbsp;</div></li><li><div>         * U+092E, U+0947, U+0951&nbsp;</div></li><li><div>         * U+092E, U+0951, U+0947&nbsp;</div></li><li><div>         * */&nbsp;</div></li><li><div>        //if ($u == 0x0952) $cat = self::OT_A;&nbsp;</div></li><li><div>        if (self::in_range($u, 0x0951, 0x0954))&nbsp;</div></li><li><div>            $cat = self::OT_VD;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($u == 0x200C)&nbsp;</div></li><li><div>            $cat = self::OT_ZWNJ;&nbsp;</div></li><li><div>        else if ($u == 0x200D)&nbsp;</div></li><li><div>            $cat = self::OT_ZWJ;&nbsp;</div></li><li><div>        else if ($u == 0x25CC)&nbsp;</div></li><li><div>            $cat = self::OT_DOTTEDCIRCLE;&nbsp;</div></li><li><div>        else if ($u == 0x0A71)&nbsp;</div></li><li><div>            $cat = self::OT_SM; /** GURMUKHI ADDAK.    More like consonant medial. like 0A75. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($cat == self::OT_Repha) {&nbsp;</div></li><li><div>            /** There are two kinds of characters marked as Repha:&nbsp;</div></li><li><div>             * - The ones that are GenCat=Mn are already positioned visually, ie. after base. (eg. Khmer)&nbsp;</div></li><li><div>             * - The ones that are GenCat=Lo is encoded logically, ie. beginning of syllable. (eg. Malayalam)&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * We recategorize the first kind to look like a Nukta and attached to the base directly.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            if ($info['general_category'] == UCDN::UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)&nbsp;</div></li><li><div>                $cat = self::OT_N;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Re-assign position.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ((self::FLAG($cat) & (self::FLAG(self::OT_C) | self::FLAG(self::OT_CM) | self::FLAG(self::OT_Ra) | self::FLAG(self::OT_V) | self::FLAG(self::OT_NBSP) | self::FLAG(self::OT_DOTTEDCIRCLE)))) { // = CONSONANT_FLAGS like is_consonant&nbsp;</div></li><li><div>            if ($scriptblock == UCDN::SCRIPT_KHMER)&nbsp;</div></li><li><div>                $pos = self::POS_BELOW_C; /** Khmer differs from Indic here. */&nbsp;</div></li><li><div>            else&nbsp;</div></li><li><div>                $pos = self::POS_BASE_C; /** Will recategorize later based on font lookups. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (self::is_ra($u))&nbsp;</div></li><li><div>                $cat = self::OT_Ra;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        else if ($cat == self::OT_M) {&nbsp;</div></li><li><div>            $pos = self::matra_position($u, $pos);&nbsp;</div></li><li><div>        } else if ($cat == self::OT_SM || $cat == self::OT_VD) {&nbsp;</div></li><li><div>            $pos = self::POS_SMVD;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($u == 0x0B01)&nbsp;</div></li><li><div>            $pos = self::POS_BEFORE_SUB; /** Oriya Bindu is BeforeSub in the spec. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $info['indic_category'] = $cat;&nbsp;</div></li><li><div>        $info['indic_position'] = $pos;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // syllable_type&nbsp;</div></li><li><div>    const CONSONANT_SYLLABLE = 0;&nbsp;</div></li><li><div>    const VOWEL_SYLLABLE = 1;&nbsp;</div></li><li><div>    const STANDALONE_CLUSTER = 2;&nbsp;</div></li><li><div>    const BROKEN_CLUSTER = 3;&nbsp;</div></li><li><div>    const NON_INDIC_CLUSTER = 4;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function set_syllables(&$o, $s, &$broken_syllables)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $ptr = 0;&nbsp;</div></li><li><div>        $syllable_serial = 1;&nbsp;</div></li><li><div>        $broken_syllables = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while ($ptr &lt; strlen($s)) {&nbsp;</div></li><li><div>            $match = '';&nbsp;</div></li><li><div>            $syllable_length = 1;&nbsp;</div></li><li><div>            $syllable_type = self::NON_INDIC_CLUSTER;&nbsp;</div></li><li><div>            // CONSONANT_SYLLABLE Consonant syllable&nbsp;</div></li><li><div>            // From OT spec:&nbsp;</div></li><li><div>            if (preg_match('/^([CR]m*[N]?(H[ZJ]?|[ZJ]H))*[CR]m*[N]?[A]?(H[ZJ]?|[M]*[N]?[H]?)?[S]?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                // From HarfBuzz:&nbsp;</div></li><li><div>                //if (preg_match('/^r?([CR]J?(Z?[N]{0, 2})?[ZJ]?H(J[N]?)?) {0, 4}[CR]J?(Z?[N]{0, 2})?A?((([ZJ]?H(J[N]?)?)|HZ)|(HJ)?([ZJ]{0, 3}M[N]?(H|JHJR)?) {0, 4})?(S[Z]?)?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                $syllable_type = self::CONSONANT_SYLLABLE;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // VOWEL_SYLLABLE Vowel-based syllable&nbsp;</div></li><li><div>            // From OT spec:&nbsp;</div></li><li><div>            else if (preg_match('/^(RH|r)?V[N]?([ZJ]?H[CR]m*|J[CR]m*)?([M]*[N]?[H]?)?[S]?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                // From HarfBuzz:&nbsp;</div></li><li><div>                //else if (preg_match('/^(RH|r)?V(Z?[N]{0, 2})?(J|([ZJ]?H(J[N]?)?[CR]J?(Z?[N]{0, 2})?) {0, 4}((([ZJ]?H(J[N]?)?)|HZ)|(HJ)?([ZJ]{0, 3}M[N]?(H|JHJR)?) {0, 4})?(S[Z]?)?[v]{0, 2})/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                $syllable_type = self::VOWEL_SYLLABLE;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** Apply only if it's a word start. */&nbsp;</div></li><li><div>            // STANDALONE_CLUSTER Stand Alone syllable at start of word&nbsp;</div></li><li><div>            // From OT spec:&nbsp;</div></li><li><div>            else if (($ptr == 0 ||&nbsp;</div></li><li><div>                $o[$ptr - 1]['general_category'] &lt; UCDN::UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER ||&nbsp;</div></li><li><div>                $o[$ptr - 1]['general_category'] &gt; UCDN::UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK&nbsp;</div></li><li><div> ) && (preg_match('/^(RH|r)?[sD][N]?([ZJ]?H[CR]m*)?([M]*[N]?[H]?)?[S]?[v]{0, 2}/', substr($s, $ptr), $ma))) {&nbsp;</div></li><li><div>                // From HarfBuzz:&nbsp;</div></li><li><div>                // && (preg_match('/^(RH|r)?[sD](Z?[N]{0, 2})?(([ZJ]?H(J[N]?)?)[CR]J?(Z?[N]{0, 2})?) {0, 4}((([ZJ]?H(J[N]?)?)|HZ)|(HJ)?([ZJ]{0, 3}M[N]?(H|JHJR)?) {0, 4})?(S[Z]?)?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                $syllable_type = self::STANDALONE_CLUSTER;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // BROKEN_CLUSTER syllable&nbsp;</div></li><li><div>            else if (preg_match('/^(RH|r)?[N]?([ZJ]?H[CR])?([M]*[N]?[H]?)?[S]?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                // From HarfBuzz:&nbsp;</div></li><li><div>                //else if (preg_match('/^(RH|r)?(Z?[N]{0, 2})?(([ZJ]?H(J[N]?)?)[CR]J?(Z?[N]{0, 2})?) {0, 4}((([ZJ]?H(J[N]?)?)|HZ)|(HJ)?([ZJ]{0, 3}M[N]?(H|JHJR)?) {0, 4})(S[Z]?)?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                if (strlen($ma[0])) { // May match blank&nbsp;</div></li><li><div>                    $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                    $syllable_type = self::BROKEN_CLUSTER;&nbsp;</div></li><li><div>                    $broken_syllables = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            for ($i = $ptr; $i &lt; $ptr + $syllable_length; $i++) {&nbsp;</div></li><li><div>                $o[$i]['syllable'] = ($syllable_serial &lt;&lt; 4) | $syllable_type;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $ptr += $syllable_length;&nbsp;</div></li><li><div>            $syllable_serial++;&nbsp;</div></li><li><div>            if ($syllable_serial == 16)&nbsp;</div></li><li><div>                $syllable_serial = 1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function set_syllables_sinhala(&$o, $s, &$broken_syllables)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $ptr = 0;&nbsp;</div></li><li><div>        $syllable_serial = 1;&nbsp;</div></li><li><div>        $broken_syllables = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while ($ptr &lt; strlen($s)) {&nbsp;</div></li><li><div>            $match = '';&nbsp;</div></li><li><div>            $syllable_length = 1;&nbsp;</div></li><li><div>            $syllable_type = self::NON_INDIC_CLUSTER;&nbsp;</div></li><li><div>            // CONSONANT_SYLLABLE Consonant syllable&nbsp;</div></li><li><div>            // From OT spec:&nbsp;</div></li><li><div>            if (preg_match('/^([CR]HJ|[CR]JH) {0, 8}[CR][HM]{0, 3}[S]{0, 1}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                $syllable_type = self::CONSONANT_SYLLABLE;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // VOWEL_SYLLABLE Vowel-based syllable&nbsp;</div></li><li><div>            // From OT spec:&nbsp;</div></li><li><div>            else if (preg_match('/^V[S]{0, 1}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                $syllable_type = self::VOWEL_SYLLABLE;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            for ($i = $ptr; $i &lt; $ptr + $syllable_length; $i++) {&nbsp;</div></li><li><div>                $o[$i]['syllable'] = ($syllable_serial &lt;&lt; 4) | $syllable_type;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $ptr += $syllable_length;&nbsp;</div></li><li><div>            $syllable_serial++;&nbsp;</div></li><li><div>            if ($syllable_serial == 16)&nbsp;</div></li><li><div>                $syllable_serial = 1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function set_syllables_khmer(&$o, $s, &$broken_syllables)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $ptr = 0;&nbsp;</div></li><li><div>        $syllable_serial = 1;&nbsp;</div></li><li><div>        $broken_syllables = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while ($ptr &lt; strlen($s)) {&nbsp;</div></li><li><div>            $match = '';&nbsp;</div></li><li><div>            $syllable_length = 1;&nbsp;</div></li><li><div>            $syllable_type = self::NON_INDIC_CLUSTER;&nbsp;</div></li><li><div>            // CONSONANT_SYLLABLE Consonant syllable&nbsp;</div></li><li><div>            if (preg_match('/^r?([CR]J?((Z?F)?[N]{0, 2})?[ZJ]?G(JN?)?) {0, 4}[CR]J?((Z?F)?[N]{0, 2})?A?((([ZJ]?G(JN?)?)|GZ)|(GJ)?([ZJ]{0, 3}MN?(H|JHJR)?) {0, 4})?(G([CR]J?((Z?F)?[N]{0, 2})?|V))?(SZ?)?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                $syllable_type = self::CONSONANT_SYLLABLE;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // VOWEL_SYLLABLE Vowel-based syllable&nbsp;</div></li><li><div>            else if (preg_match('/^(RH|r)?V((Z?F)?[N]{0, 2})?(J|([ZJ]?G(JN?)?[CR]J?((Z?F)?[N]{0, 2})?) {0, 4}((([ZJ]?G(JN?)?)|GZ)|(GJ)?([ZJ]{0, 3}MN?(H|JHJR)?) {0, 4})?(G([CR]J?((Z?F)?[N]{0, 2})?|V))?(SZ?)?[v]{0, 2})/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                $syllable_type = self::VOWEL_SYLLABLE;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // BROKEN_CLUSTER syllable&nbsp;</div></li><li><div>            else if (preg_match('/^(RH|r)?((Z?F)?[N]{0, 2})?(([ZJ]?G(JN?)?)[CR]J?((Z?F)?[N]{0, 2})?) {0, 4}((([ZJ]?G(JN?)?)|GZ)|(GJ)?([ZJ]{0, 3}MN?(H|JHJR)?) {0, 4})(G([CR]J?((Z?F)?[N]{0, 2})?|V))?(SZ?)?[v]{0, 2}/', substr($s, $ptr), $ma)) {&nbsp;</div></li><li><div>                if (strlen($ma[0])) { // May match blank&nbsp;</div></li><li><div>                    $syllable_length = strlen($ma[0]);&nbsp;</div></li><li><div>                    $syllable_type = self::BROKEN_CLUSTER;&nbsp;</div></li><li><div>                    $broken_syllables = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            for ($i = $ptr; $i &lt; $ptr + $syllable_length; $i++) {&nbsp;</div></li><li><div>                $o[$i]['syllable'] = ($syllable_serial &lt;&lt; 4) | $syllable_type;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $ptr += $syllable_length;&nbsp;</div></li><li><div>            $syllable_serial++;&nbsp;</div></li><li><div>            if ($syllable_serial == 16)&nbsp;</div></li><li><div>                $syllable_serial = 1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function initial_reordering(&$info, $GSUBdata, $broken_syllables, $indic_config, $scriptblock, $is_old_spec, $dottedcircle)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        self::update_consonant_positions($info, $GSUBdata);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($broken_syllables && $dottedcircle) {&nbsp;</div></li><li><div>            self::insert_dotted_circles($info, $dottedcircle);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $count = count($info);&nbsp;</div></li><li><div>        if (!$count)&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        $last = 0;&nbsp;</div></li><li><div>        $last_syllable = $info[0]['syllable'];&nbsp;</div></li><li><div>        for ($i = 1; $i &lt; $count; $i++) {&nbsp;</div></li><li><div>            if ($last_syllable != $info[$i]['syllable']) {&nbsp;</div></li><li><div>                self::initial_reordering_syllable($info, $GSUBdata, $indic_config, $scriptblock, $is_old_spec, $last, $i);&nbsp;</div></li><li><div>                $last = $i;&nbsp;</div></li><li><div>                $last_syllable = $info[$last]['syllable'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        self::initial_reordering_syllable($info, $GSUBdata, $indic_config, $scriptblock, $is_old_spec, $last, $count);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function update_consonant_positions(&$info, $GSUBdata)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $count = count($info);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $count; $i++) {&nbsp;</div></li><li><div>            if ($info[$i]['indic_position'] == self::POS_BASE_C) {&nbsp;</div></li><li><div>                $c = $info[$i]['uni'];&nbsp;</div></li><li><div>                // If would substitute...&nbsp;</div></li><li><div>                if (isset($GSUBdata['pref'][$c])) {&nbsp;</div></li><li><div>                    $info[$i]['indic_position'] = self::POS_POST_C;&nbsp;</div></li><li><div>                } else if (isset($GSUBdata['blwf'][$c])) {&nbsp;</div></li><li><div>                    $info[$i]['indic_position'] = self::POS_BELOW_C;&nbsp;</div></li><li><div>                } else if (isset($GSUBdata['pstf'][$c])) {&nbsp;</div></li><li><div>                    $info[$i]['indic_position'] = self::POS_POST_C;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function insert_dotted_circles(&$info, $dottedcircle)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $idx = 0;&nbsp;</div></li><li><div>        $last_syllable = 0;&nbsp;</div></li><li><div>        while ($idx &lt; count($info)) {&nbsp;</div></li><li><div>            $syllable = $info[$idx]['syllable'];&nbsp;</div></li><li><div>            $syllable_type = ($syllable & 0x0F);&nbsp;</div></li><li><div>            if ($last_syllable != $syllable && $syllable_type == self::BROKEN_CLUSTER) {&nbsp;</div></li><li><div>                $last_syllable = $syllable;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $dottedcircle[0]['syllable'] = $info[$idx]['syllable'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /** Insert dottedcircle after possible Repha. */&nbsp;</div></li><li><div>                while ($idx &lt; count($info) && $last_syllable == $info[$idx]['syllable'] && $info[$idx]['indic_category'] == self::OT_Repha)&nbsp;</div></li><li><div>                    $idx++;&nbsp;</div></li><li><div>                array_splice($info, $idx, 0, $dottedcircle);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $idx++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // I am not sue how this code below got in here, since $idx should now be &gt; count($info) and thus invalid.&nbsp;</div></li><li><div>        // In case I am missing something(!) I'll leave a warning here for now:&nbsp;</div></li><li><div>        if (isset($info[$idx])) {&nbsp;</div></li><li><div>            throw new MpdfException('Unexpected error occured in Indic processing');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // In case of final bloken cluster...&nbsp;</div></li><li><div>        //$syllable = $info[$idx]['syllable'];&nbsp;</div></li><li><div>        //$syllable_type = ($syllable & 0x0F);&nbsp;</div></li><li><div>        //if ($last_syllable != $syllable && $syllable_type == self::BROKEN_CLUSTER) {&nbsp;</div></li><li><div>        //    $dottedcircle[0]['syllable'] = $info[$idx]['syllable'];&nbsp;</div></li><li><div>        //    array_splice($info, $idx, 0, $dottedcircle);&nbsp;</div></li><li><div>        //}&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /** Rules from:&nbsp;</div></li><li><div>     * https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function initial_reordering_syllable(&$info, $GSUBdata, $indic_config, $scriptblock, $is_old_spec, $start, $end)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        /** vowel_syllable: We made the vowels look like consonants. So uses the consonant logic! */&nbsp;</div></li><li><div>        /** broken_cluster: We already inserted dotted-circles, so just call the standalone_cluster. */&nbsp;</div></li><li><div>        /** standalone_cluster: We treat NBSP/dotted-circle as if they are consonants, so we should just chain. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $syllable_type = ($info[$start]['syllable'] & 0x0F);&nbsp;</div></li><li><div>        if ($syllable_type == self::NON_INDIC_CLUSTER) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($syllable_type == self::BROKEN_CLUSTER || $syllable_type == self::STANDALONE_CLUSTER) {&nbsp;</div></li><li><div>            //if ($uniscribe_bug_compatible) {&nbsp;</div></li><li><div>            /** For dotted-circle, this is what Uniscribe does:&nbsp;</div></li><li><div>             * If dotted-circle is the last glyph, it just does nothing.&nbsp;</div></li><li><div>             * i.e. It doesn't form Reph. */&nbsp;</div></li><li><div>            if ($info[$end - 1]['indic_category'] == self::OT_DOTTEDCIRCLE) {&nbsp;</div></li><li><div>                return;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 1. Find base consonant:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * The shaping engine finds the base consonant of the syllable, using the&nbsp;</div></li><li><div>         * following algorithm: starting from the end of the syllable, move backwards&nbsp;</div></li><li><div>         * until a consonant is found that does not have a below-base or post-base&nbsp;</div></li><li><div>         * form (post-base forms have to follow below-base forms), or that is not a&nbsp;</div></li><li><div>         * pre-base reordering Ra, or arrive at the first consonant. The consonant&nbsp;</div></li><li><div>         * stopped at will be the base.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         *     o If the syllable starts with Ra + Halant (in a script that has Reph)&nbsp;</div></li><li><div>         *     and has more than one consonant, Ra is excluded from candidates for&nbsp;</div></li><li><div>         *     base consonants.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $base = $end;&nbsp;</div></li><li><div>        $has_reph = false;&nbsp;</div></li><li><div>        $limit = $start;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($scriptblock != UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            /** -&gt; If the syllable starts with Ra + Halant (in a script that has Reph)&nbsp;</div></li><li><div>             *     and has more than one consonant, Ra is excluded from candidates for&nbsp;</div></li><li><div>             *     base consonants. */&nbsp;</div></li><li><div>            if (count($GSUBdata['rphf']) /** ?? $indic_plan-&gt;mask_array[RPHF] */ && $start + 3 &lt;= $end &&&nbsp;</div></li><li><div>                (&nbsp;</div></li><li><div>                ($indic_config[4] == self::REPH_MODE_IMPLICIT && !self::is_joiner($info[$start + 2])) ||&nbsp;</div></li><li><div>                ($indic_config[4] == self::REPH_MODE_EXPLICIT && $info[$start + 2]['indic_category'] == self::OT_ZWJ)&nbsp;</div></li><li><div> )) {&nbsp;</div></li><li><div>                /** See if it matches the 'rphf' feature. */&nbsp;</div></li><li><div>                //$glyphs = array($info[$start]['uni'], $info[$start + 1]['uni']);&nbsp;</div></li><li><div>                //if ($indic_plan-&gt;rphf-&gt;would_substitute ($glyphs, count($glyphs), true, face)) {&nbsp;</div></li><li><div>                if (isset($GSUBdata['rphf'][$info[$start]['uni']]) && self::is_halant_or_coeng($info[$start + 1])) {&nbsp;</div></li><li><div>                    $limit += 2;&nbsp;</div></li><li><div>                    while ($limit &lt; $end && self::is_joiner($info[$limit]))&nbsp;</div></li><li><div>                        $limit++;&nbsp;</div></li><li><div>                    $base = $start;&nbsp;</div></li><li><div>                    $has_reph = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($indic_config[4] == self::REPH_MODE_LOG_REPHA && $info[$start]['indic_category'] == self::OT_Repha) {&nbsp;</div></li><li><div>                $limit += 1;&nbsp;</div></li><li><div>                while ($limit &lt; $end && self::is_joiner($info[$limit]))&nbsp;</div></li><li><div>                    $limit++;&nbsp;</div></li><li><div>                $base = $start;&nbsp;</div></li><li><div>                $has_reph = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        switch ($indic_config[2]) { // base_pos&nbsp;</div></li><li><div>            case self::BASE_POS_LAST:&nbsp;</div></li><li><div>                /** -&gt; starting from the end of the syllable, move backwards */&nbsp;</div></li><li><div>                $i = $end;&nbsp;</div></li><li><div>                $seen_below = false;&nbsp;</div></li><li><div>                do {&nbsp;</div></li><li><div>                    $i--;&nbsp;</div></li><li><div>                    /** -&gt; until a consonant is found */&nbsp;</div></li><li><div>                    if (self::is_consonant($info[$i])) {&nbsp;</div></li><li><div>                        /** -&gt; that does not have a below-base or post-base form&nbsp;</div></li><li><div>                         * (post-base forms have to follow below-base forms), */&nbsp;</div></li><li><div>                        if ($info[$i]['indic_position'] != self::POS_BELOW_C && ($info[$i]['indic_position'] != self::POS_POST_C || $seen_below)) {&nbsp;</div></li><li><div>                            $base = $i;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        if ($info[$i]['indic_position'] == self::POS_BELOW_C)&nbsp;</div></li><li><div>                            $seen_below = true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** -&gt; or that is not a pre-base reordering Ra, &nbsp;</div></li><li><div>                         *&nbsp;</div></li><li><div>                         * IMPLEMENTATION NOTES:&nbsp;</div></li><li><div>                         *&nbsp;</div></li><li><div>                         * Our pre-base reordering Ra's are marked POS_POST_C, so will be skipped&nbsp;</div></li><li><div>                         * by the logic above already.&nbsp;</div></li><li><div>                         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        /** -&gt; or arrive at the first consonant. The consonant stopped at will&nbsp;</div></li><li><div>                         * be the base. */&nbsp;</div></li><li><div>                        $base = $i;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    else {&nbsp;</div></li><li><div>                        /** A ZWJ after a Halant stops the base search, and requests an explicit&nbsp;</div></li><li><div>                         * half form.&nbsp;</div></li><li><div>                         * [A ZWJ before a Halant, requests a subjoined form instead, and hence&nbsp;</div></li><li><div>                         * search continues. This is particularly important for Bengali&nbsp;</div></li><li><div>                         * sequence Ra, H, Ya that should form Ya-Phalaa by subjoining Ya] */&nbsp;</div></li><li><div>                        if ($start &lt; $i && $info[$i]['indic_category'] == self::OT_ZWJ && $info[$i - 1]['indic_category'] == self::OT_H) {&nbsp;</div></li><li><div>                            if (!defined(&quot;OMIT_INDIC_FIX_1&quot;) || OMIT_INDIC_FIX_1 != 1) {&nbsp;</div></li><li><div>                                $base = $i;&nbsp;</div></li><li><div>                            } // INDIC_FIX_1&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        // ZKI8&nbsp;</div></li><li><div>                        if ($start &lt; $i && $info[$i]['indic_category'] == self::OT_ZWNJ) {&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                } while ($i &gt; $limit);&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case self::BASE_POS_FIRST:&nbsp;</div></li><li><div>                /** In scripts without half forms (eg. Khmer), the first consonant is always the base. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if (!$has_reph)&nbsp;</div></li><li><div>                    $base = $limit;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /** Find the last base consonant that is not blocked by ZWJ.    If there is&nbsp;</div></li><li><div>                 * a ZWJ right before a base consonant, that would request a subjoined form. */&nbsp;</div></li><li><div>                for ($i = $limit; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>                    if (self::is_consonant($info[$i]) && $info[$i]['indic_position'] == self::POS_BASE_C) {&nbsp;</div></li><li><div>                        if ($limit &lt; $i && $info[$i - 1]['indic_category'] == self::OT_ZWJ)&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        else&nbsp;</div></li><li><div>                            $base = $i;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /** Mark all subsequent consonants as below. */&nbsp;</div></li><li><div>                for ($i = $base + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>                    if (self::is_consonant($info[$i]) && $info[$i]['indic_position'] == self::POS_BASE_C)&nbsp;</div></li><li><div>                        $info[$i]['indic_position'] = self::POS_BELOW_C;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            //default:&nbsp;</div></li><li><div>            //assert (false);&nbsp;</div></li><li><div>            /** fallthrough */&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** -&gt; If the syllable starts with Ra + Halant (in a script that has Reph)&nbsp;</div></li><li><div>         *     and has more than one consonant, Ra is excluded from candidates for&nbsp;</div></li><li><div>         *     base consonants.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         *     Only do this for unforced Reph. (ie. not for Ra, H, ZWJ. */&nbsp;</div></li><li><div>        if ($scriptblock != UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            if ($has_reph && $base == $start && $limit - $base &lt;= 2) {&nbsp;</div></li><li><div>                /** Have no other consonant, so Reph is not formed and Ra becomes base. */&nbsp;</div></li><li><div>                $has_reph = false;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 2. Decompose and reorder Matras:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Each matra and any syllable modifier sign in the cluster are moved to the&nbsp;</div></li><li><div>         * appropriate position relative to the consonant(s) in the cluster. The&nbsp;</div></li><li><div>         * shaping engine decomposes two- or three-part matras into their constituent&nbsp;</div></li><li><div>         * parts before any repositioning. Matra characters are classified by which&nbsp;</div></li><li><div>         * consonant in a conjunct they have affinity for and are reordered to the&nbsp;</div></li><li><div>         * following positions:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         *         o Before first half form in the syllable&nbsp;</div></li><li><div>         *         o After subjoined consonants&nbsp;</div></li><li><div>         *         o After post-form consonant&nbsp;</div></li><li><div>         *         o After main consonant (for above marks)&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * IMPLEMENTATION NOTES:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * The normalize() routine has already decomposed matras for us, so we don't&nbsp;</div></li><li><div>         * need to worry about that.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 3.    Reorder marks to canonical order:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Adjacent nukta and halant or nukta and vedic sign are always repositioned&nbsp;</div></li><li><div>         * if necessary, so that the nukta is first.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * IMPLEMENTATION NOTES:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Use the combining Class from Unicode categories? to bubble_sort.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Reorder characters */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($i = $start; $i &lt; $base; $i++)&nbsp;</div></li><li><div>            $info[$i]['indic_position'] = min(self::POS_PRE_C, $info[$i]['indic_position']);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($base &lt; $end)&nbsp;</div></li><li><div>            $info[$base]['indic_position'] = self::POS_BASE_C;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Mark final consonants. A final consonant is one appearing after a matra, &nbsp;</div></li><li><div>         * ? only in Khmer. */&nbsp;</div></li><li><div>        for ($i = $base + 1; $i &lt; $end; $i++)&nbsp;</div></li><li><div>            if ($info[$i]['indic_category'] == self::OT_M) {&nbsp;</div></li><li><div>                for ($j = $i + 1; $j &lt; $end; $j++)&nbsp;</div></li><li><div>                    if (self::is_consonant($info[$j])) {&nbsp;</div></li><li><div>                        $info[$j]['indic_position'] = self::POS_FINAL_C;&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Handle beginning Ra */&nbsp;</div></li><li><div>        if ($scriptblock != UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            if ($has_reph)&nbsp;</div></li><li><div>                $info[$start]['indic_position'] = self::POS_RA_TO_BECOME_REPH;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** For old-style Indic script tags, move the first post-base Halant after&nbsp;</div></li><li><div>         * last consonant.    Only do this if there is *not* a Halant after last&nbsp;</div></li><li><div>         * consonant. Otherwise it becomes messy. */&nbsp;</div></li><li><div>        if ($is_old_spec) {&nbsp;</div></li><li><div>            for ($i = $base + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>                if ($info[$i]['indic_category'] == self::OT_H) {&nbsp;</div></li><li><div>                    for ($j = $end - 1; $j &gt; $i; $j--) {&nbsp;</div></li><li><div>                        if (self::is_consonant($info[$j]) || $info[$j]['indic_category'] == self::OT_H) {&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if ($info[$j]['indic_category'] != self::OT_H && $j &gt; $i) {&nbsp;</div></li><li><div>                        /** Move Halant to after last consonant. */&nbsp;</div></li><li><div>                        self::_move_info_pos($info, $i, $j + 1);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Attach misc marks to previous char to move with them. */&nbsp;</div></li><li><div>        $last_pos = self::POS_START;&nbsp;</div></li><li><div>        for ($i = $start; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>            if ((self::FLAG($info[$i]['indic_category']) & (self::FLAG(self::OT_ZWJ) | self::FLAG(self::OT_ZWNJ) | self::FLAG(self::OT_N) | self::FLAG(self::OT_RS) | self::FLAG(self::OT_H) | self::FLAG(self::OT_Coeng) ))) {&nbsp;</div></li><li><div>                $info[$i]['indic_position'] = $last_pos;&nbsp;</div></li><li><div>                if ($info[$i]['indic_category'] == self::OT_H && $info[$i]['indic_position'] == self::POS_PRE_M) {&nbsp;</div></li><li><div>                    /**&nbsp;</div></li><li><div>                     * Uniscribe doesn't move the Halant with Left Matra.&nbsp;</div></li><li><div>                     * TEST: U+092B, U+093F, U+094DE&nbsp;</div></li><li><div>                     * We follow.    This is important for the Sinhala&nbsp;</div></li><li><div>                     * U+0DDA split matra since it decomposes to U+0DD9, U+0DCA&nbsp;</div></li><li><div>                     * where U+0DD9 is a left matra and U+0DCA is the virama.&nbsp;</div></li><li><div>                     * We don't want to move the virama with the left matra.&nbsp;</div></li><li><div>                     * TEST: U+0D9A, U+0DDA&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>                    for ($j = $i; $j &gt; $start; $j--)&nbsp;</div></li><li><div>                        if ($info[$j - 1]['indic_position'] != self::POS_PRE_M) {&nbsp;</div></li><li><div>                            $info[$i]['indic_position'] = $info[$j - 1]['indic_position'];&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else if ($info[$i]['indic_position'] != self::POS_SMVD) {&nbsp;</div></li><li><div>                $last_pos = $info[$i]['indic_position'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Re-attach ZWJ, ZWNJ, and halant to next char, for after-base consonants. */&nbsp;</div></li><li><div>        $last_halant = $end;&nbsp;</div></li><li><div>        for ($i = $base + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>            if (self::is_halant_or_coeng($info[$i]))&nbsp;</div></li><li><div>                $last_halant = $i;&nbsp;</div></li><li><div>            else if (self::is_consonant($info[$i])) {&nbsp;</div></li><li><div>                for ($j = $last_halant; $j &lt; $i; $j++)&nbsp;</div></li><li><div>                    if ($info[$j]['indic_position'] != self::POS_SMVD)&nbsp;</div></li><li><div>                        $info[$j]['indic_position'] = $info[$i]['indic_position'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($scriptblock == UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            /** KHMER_FIX_2 */&nbsp;</div></li><li><div>            /** Move Coeng+RO (Halant, Ra) sequence before base consonant. */&nbsp;</div></li><li><div>            for ($i = $base + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>                if (self::is_halant_or_coeng($info[$i]) && self::is_ra($info[$i + 1]['uni'])) {&nbsp;</div></li><li><div>                    $info[$i]['indic_position'] = self::POS_PRE_C;&nbsp;</div></li><li><div>                    $info[$i + 1]['indic_position'] = self::POS_PRE_C;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>          if (!defined(&quot;OMIT_INDIC_FIX_2&quot;) || OMIT_INDIC_FIX_2 != 1) {&nbsp;</div></li><li><div>          // INDIC_FIX_2&nbsp;</div></li><li><div>          $ZWNJ_found = false;&nbsp;</div></li><li><div>          $POST_ZWNJ_c_found = false;&nbsp;</div></li><li><div>          for ($i = $base + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>          if ($info[$i]['indic_category'] == self::OT_ZWNJ) { $ZWNJ_found = true; }&nbsp;</div></li><li><div>          else if ($ZWNJ_found && $info[$i]['indic_category'] == self::OT_C) { $POST_ZWNJ_c_found = true; }&nbsp;</div></li><li><div>          else if ($POST_ZWNJ_c_found && $info[$i]['indic_position'] == self::POS_BEFORE_SUB) { $info[$i]['indic_position'] = self::POS_AFTER_SUB; }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Setup masks now */&nbsp;</div></li><li><div>        for ($i = $start; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>            $info[$i]['mask'] = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($scriptblock == UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            /** Find a Coeng+RO (Halant, Ra) sequence and mark it for pre-base processing. */&nbsp;</div></li><li><div>            $mask = self::FLAG(self::PREF);&nbsp;</div></li><li><div>            for ($i = $base; $i &lt; $end - 1; $i++) { /** KHMER_FIX_1 From $start (not base) */&nbsp;</div></li><li><div>                if (self::is_halant_or_coeng($info[$i]) && self::is_ra($info[$i + 1]['uni'])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $info[$i]['mask'] |= self::FLAG(self::PREF);&nbsp;</div></li><li><div>                    $info[$i + 1]['mask'] |= self::FLAG(self::PREF);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** Mark the subsequent stuff with 'cfar'.  Used in Khmer.&nbsp;</div></li><li><div>                     * Read the feature spec.&nbsp;</div></li><li><div>                     * This allows distinguishing the following cases with MS Khmer fonts:&nbsp;</div></li><li><div>                     * U+1784, U+17D2, U+179A, U+17D2, U+1782  [C+Coeng+RO+Coeng+C] =&gt; Should activate CFAR&nbsp;</div></li><li><div>                     * U+1784, U+17D2, U+1782, U+17D2, U+179A  [C+Coeng+C+Coeng+RO] =&gt; Should NOT activate CFAR&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>                    for ($j = ($i + 2); $j &lt; $end; $j++)&nbsp;</div></li><li><div>                        $info[$j]['mask'] |= self::FLAG(self::CFAR);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Sit tight, rock 'n roll! */&nbsp;</div></li><li><div>        self::bubble_sort($info, $start, $end - $start);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Find base again */&nbsp;</div></li><li><div>        $base = $end;&nbsp;</div></li><li><div>        for ($i = $start; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>            if ($info[$i]['indic_position'] == self::POS_BASE_C) {&nbsp;</div></li><li><div>                $base = $i;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($scriptblock != UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            /** Reph */&nbsp;</div></li><li><div>            for ($i = $start; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>                if ($info[$i]['indic_position'] == self::POS_RA_TO_BECOME_REPH) {&nbsp;</div></li><li><div>                    $info[$i]['mask'] |= self::FLAG(self::RPHF);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** Pre-base */&nbsp;</div></li><li><div>            $mask = self::FLAG(self::HALF);&nbsp;</div></li><li><div>            for ($i = $start; $i &lt; $base; $i++) {&nbsp;</div></li><li><div>                $info[$i]['mask'] |= $mask;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Post-base */&nbsp;</div></li><li><div>        $mask = (self::FLAG(self::BLWF) | self::FLAG(self::ABVF) | self::FLAG(self::PSTF));&nbsp;</div></li><li><div>        for ($i = $base + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>            $info[$i]['mask'] |= $mask;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($scriptblock != UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            if (!defined(&quot;OMIT_INDIC_FIX_3&quot;) || OMIT_INDIC_FIX_3 != 1) {&nbsp;</div></li><li><div>                /** INDIC_FIX_3 */&nbsp;</div></li><li><div>                /** Find a (pre-base) Consonant, Halant, Ra sequence and mark Halant|Ra for below-base BLWF processing. */&nbsp;</div></li><li><div>                // TEST CASE &#x995;&#x9cd;&#x9b0;&#x9cd;&#x995; in FreeSans versus Vrinda&nbsp;</div></li><li><div>                if (($base - $start) &gt;= 3) {&nbsp;</div></li><li><div>                    for ($i = $start; $i &lt; ($base - 2); $i++) {&nbsp;</div></li><li><div>                        if (self::is_consonant($info[$i])) {&nbsp;</div></li><li><div>                            if (self::is_halant_or_coeng($info[$i + 1]) && self::is_ra($info[$i + 2]['uni'])) {&nbsp;</div></li><li><div>                                // If would substitute Halant+Ra...BLWF&nbsp;</div></li><li><div>                                if (isset($GSUBdata['blwf'][$info[$i + 2]['uni']])) {&nbsp;</div></li><li><div>                                    $info[$i + 1]['mask'] |= self::FLAG(self::BLWF);&nbsp;</div></li><li><div>                                    $info[$i + 2]['mask'] |= self::FLAG(self::BLWF);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                /** If would not substitute as blwf, mark Ra+Halant for RPHF using following Halant (if present) */ else if (self::is_halant_or_coeng($info[$i + 3])) {&nbsp;</div></li><li><div>                                    $info[$i + 2]['mask'] |= self::FLAG(self::RPHF);&nbsp;</div></li><li><div>                                    $info[$i + 3]['mask'] |= self::FLAG(self::RPHF);&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($is_old_spec && $scriptblock == UCDN::SCRIPT_DEVANAGARI) {&nbsp;</div></li><li><div>            /** Old-spec eye-lash Ra needs special handling.    From the spec:&nbsp;</div></li><li><div>             * &quot;The feature 'below-base form' is applied to consonants&nbsp;</div></li><li><div>             * having below-base forms and following the base consonant.&nbsp;</div></li><li><div>             * The exception is vattu, which may appear below half forms&nbsp;</div></li><li><div>             * as well as below the base glyph. The feature 'below-base&nbsp;</div></li><li><div>             * form' will be applied to all such occurrences of Ra as well.&quot;&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * Test case: U+0924, U+094D, U+0930, U+094d, U+0915&nbsp;</div></li><li><div>             * with Sanskrit 2003 font.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * However, note that Ra, Halant, ZWJ is the correct way to&nbsp;</div></li><li><div>             * request eyelash form of Ra, so we wouldbn't inhibit it&nbsp;</div></li><li><div>             * in that sequence.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * Test case: U+0924, U+094D, U+0930, U+094d, U+200D, U+0915&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            for ($i = $start; ($i + 1) &lt; $base; $i++) {&nbsp;</div></li><li><div>                if ($info[$i]['indic_category'] == self::OT_Ra && $info[$i + 1]['indic_category'] == self::OT_H &&&nbsp;</div></li><li><div>                    ($i + 2 == $base || $info[$i + 2]['indic_category'] != self::OT_ZWJ)) {&nbsp;</div></li><li><div>                    $info[$i]['mask'] |= self::FLAG(self::BLWF);&nbsp;</div></li><li><div>                    $info[$i + 1]['mask'] |= self::FLAG(self::BLWF);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($scriptblock != UCDN::SCRIPT_KHMER) {&nbsp;</div></li><li><div>            if (count($GSUBdata['pref']) && $base + 2 &lt; $end) {&nbsp;</div></li><li><div>                /** Find a Halant, Ra sequence and mark it for pre-base processing. */&nbsp;</div></li><li><div>                for ($i = $base + 1; $i + 1 &lt; $end; $i++) {&nbsp;</div></li><li><div>                    // If old_spec find Ra-Halant...&nbsp;</div></li><li><div>                    if ((isset($GSUBdata['pref'][$info[$i + 1]['uni']]) && self::is_halant_or_coeng($info[$i]) && self::is_ra($info[$i + 1]['uni']) ) ||&nbsp;</div></li><li><div>                        ($is_old_spec && isset($GSUBdata['pref'][$info[$i]['uni']]) && self::is_halant_or_coeng($info[$i + 1]) && self::is_ra($info[$i]['uni']) )&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                        $info[$i++]['mask'] |= self::FLAG(self::PREF);&nbsp;</div></li><li><div>                        $info[$i++]['mask'] |= self::FLAG(self::PREF);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Apply ZWJ/ZWNJ effects */&nbsp;</div></li><li><div>        for ($i = $start + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>            if (self::is_joiner($info[$i])) {&nbsp;</div></li><li><div>                $non_joiner = ($info[$i]['indic_category'] == self::OT_ZWNJ);&nbsp;</div></li><li><div>                $j = $i;&nbsp;</div></li><li><div>                while ($j &gt; $start) {&nbsp;</div></li><li><div>                    if (defined(&quot;OMIT_INDIC_FIX_4&quot;) && OMIT_INDIC_FIX_4 == 1) {&nbsp;</div></li><li><div>                        // INDIC_FIX_4 = do nothing - carry on //&nbsp;</div></li><li><div>                        // ZWNJ should block H C from forming blwf post-base - need to unmask backwards beyond first consonant arrived at //&nbsp;</div></li><li><div>                        if (!self::is_consonant($info[$j])) {&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $j--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** ZWJ/ZWNJ should disable CJCT.    They do that by simply&nbsp;</div></li><li><div>                     * being there, since we don't skip them for the CJCT&nbsp;</div></li><li><div>                     * feature (ie. F_MANUAL_ZWJ) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    /** A ZWNJ disables HALF. */&nbsp;</div></li><li><div>                    if ($non_joiner) {&nbsp;</div></li><li><div>                        $info[$j]['mask'] &= ~(self::FLAG(self::HALF) | self::FLAG(self::BLWF));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function final_reordering(&$info, $GSUBdata, $indic_config, $scriptblock, $is_old_spec)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $count = count($info);&nbsp;</div></li><li><div>        if (!$count)&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        $last = 0;&nbsp;</div></li><li><div>        $last_syllable = $info[0]['syllable'];&nbsp;</div></li><li><div>        for ($i = 1; $i &lt; $count; $i++) {&nbsp;</div></li><li><div>            if ($last_syllable != $info[$i]['syllable']) {&nbsp;</div></li><li><div>                self::final_reordering_syllable($info, $GSUBdata, $indic_config, $scriptblock, $is_old_spec, $last, $i);&nbsp;</div></li><li><div>                $last = $i;&nbsp;</div></li><li><div>                $last_syllable = $info[$last]['syllable'];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        self::final_reordering_syllable($info, $GSUBdata, $indic_config, $scriptblock, $is_old_spec, $last, $count);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function final_reordering_syllable(&$info, $GSUBdata, $indic_config, $scriptblock, $is_old_spec, $start, $end)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 4. Final reordering:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * After the localized forms and basic shaping forms GSUB features have been&nbsp;</div></li><li><div>         * applied (see below), the shaping engine performs some final glyph&nbsp;</div></li><li><div>         * reordering before applying all the remaining font features to the entire&nbsp;</div></li><li><div>         * cluster.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Find base again */&nbsp;</div></li><li><div>        for ($base = $start; $base &lt; $end; $base++)&nbsp;</div></li><li><div>            if ($info[$base]['indic_position'] &gt;= self::POS_BASE_C) {&nbsp;</div></li><li><div>                if ($start &lt; $base && $info[$base]['indic_position'] &gt; self::POS_BASE_C)&nbsp;</div></li><li><div>                    $base--;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        if ($base == $end && $start &lt; $base && $info[$base - 1]['indic_category'] != self::OT_ZWJ)&nbsp;</div></li><li><div>            $base--;&nbsp;</div></li><li><div>        while ($start &lt; $base && isset($info[$base]) && ($info[$base]['indic_category'] == self::OT_H || $info[$base]['indic_category'] == self::OT_N))&nbsp;</div></li><li><div>            $base--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**     o Reorder matras:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         *     If a pre-base matra character had been reordered before applying basic&nbsp;</div></li><li><div>         *     features, the glyph can be moved closer to the main consonant based on&nbsp;</div></li><li><div>         *     whether half-forms had been formed. Actual position for the matra is&nbsp;</div></li><li><div>         *     defined as &quot;after last standalone halant glyph, after initial matra&nbsp;</div></li><li><div>         *     position and before the main consonant&quot;. If ZWJ or ZWNJ follow this&nbsp;</div></li><li><div>         *     halant, position is moved after it.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($start + 1 &lt; $end && $start &lt; $base) { /** Otherwise there can't be any pre-base matra characters. */&nbsp;</div></li><li><div>            /** If we lost track of base, alas, position before last thingy. */&nbsp;</div></li><li><div>            $new_pos = ($base == $end) ? $base - 2 : $base - 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.&nbsp;</div></li><li><div>             * The glyphs formed by 'half' are Chillus or ligated explicit viramas.&nbsp;</div></li><li><div>             * We want to position matra after them.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            if ($scriptblock != UCDN::SCRIPT_MALAYALAM && $scriptblock != UCDN::SCRIPT_TAMIL) {&nbsp;</div></li><li><div>                while ($new_pos &gt; $start && !(self::is_one_of($info[$new_pos], (self::FLAG(self::OT_M) | self::FLAG(self::OT_H) | self::FLAG(self::OT_Coeng)))))&nbsp;</div></li><li><div>                    $new_pos--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /** If we found no Halant we are done.&nbsp;</div></li><li><div>                 * Otherwise only proceed if the Halant does&nbsp;</div></li><li><div>                 * not belong to the Matra itself! */&nbsp;</div></li><li><div>                if (self::is_halant_or_coeng($info[$new_pos]) && $info[$new_pos]['indic_position'] != self::POS_PRE_M) {&nbsp;</div></li><li><div>                    /** -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */&nbsp;</div></li><li><div>                    if ($new_pos + 1 &lt; $end && self::is_joiner($info[$new_pos + 1]))&nbsp;</div></li><li><div>                        $new_pos++;&nbsp;</div></li><li><div>                } else&nbsp;</div></li><li><div>                    $new_pos = $start; /** No move. */&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($start &lt; $new_pos && $info[$new_pos]['indic_position'] != self::POS_PRE_M) {&nbsp;</div></li><li><div>                /** Now go see if there's actually any matras... */&nbsp;</div></li><li><div>                for ($i = $new_pos; $i &gt; $start; $i--)&nbsp;</div></li><li><div>                    if ($info[$i - 1]['indic_position'] == self::POS_PRE_M) {&nbsp;</div></li><li><div>                        $old_pos = $i - 1;&nbsp;</div></li><li><div>                        //memmove (&info[$old_pos], &info[$old_pos + 1], ($new_pos - $old_pos) * sizeof ($info[0]));&nbsp;</div></li><li><div>                        self::_move_info_pos($info, $old_pos, $new_pos + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ($old_pos &lt; $base && $base &lt;= $new_pos) /** Shouldn't actually happen. */&nbsp;</div></li><li><div>                            $base--;&nbsp;</div></li><li><div>                        $new_pos--;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**     o Reorder reph:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         *     Reph's original position is always at the beginning of the syllable, &nbsp;</div></li><li><div>         *     (i.e. it is not reordered at the character reordering stage). However, &nbsp;</div></li><li><div>         *     it will be reordered according to the basic-forms shaping results.&nbsp;</div></li><li><div>         *     Possible positions for reph, depending on the script, are; after main, &nbsp;</div></li><li><div>         *     before post-base consonant forms, and after post-base consonant forms.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** If there's anything after the Ra that has the REPH pos, it ought to be halant.&nbsp;</div></li><li><div>         * Which means that the font has failed to ligate the Reph.    In which case, we&nbsp;</div></li><li><div>         * shouldn't move. */&nbsp;</div></li><li><div>        if ($start + 1 &lt; $end &&&nbsp;</div></li><li><div>            $info[$start]['indic_position'] == self::POS_RA_TO_BECOME_REPH && $info[$start + 1]['indic_position'] != self::POS_RA_TO_BECOME_REPH) {&nbsp;</div></li><li><div>            $reph_pos = $indic_config[3];&nbsp;</div></li><li><div>            $skip_to_reph_step_5 = false;&nbsp;</div></li><li><div>            $skip_to_reph_move = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**     1. If reph should be positioned after post-base consonant forms, &nbsp;</div></li><li><div>             *     proceed to step 5.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            if ($reph_pos == self::REPH_POS_AFTER_POST) {&nbsp;</div></li><li><div>                $skip_to_reph_step_5 = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**     2. If the reph repositioning class is not after post-base: target&nbsp;</div></li><li><div>             *     position is after the first explicit halant glyph between the&nbsp;</div></li><li><div>             *     first post-reph consonant and last main consonant. If ZWJ or ZWNJ&nbsp;</div></li><li><div>             *     are following this halant, position is moved after it. If such&nbsp;</div></li><li><div>             *     position is found, this is the target position. Otherwise, &nbsp;</div></li><li><div>             *     proceed to the next step.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             *     Note: in old-implementation fonts, where classifications were&nbsp;</div></li><li><div>             *     fixed in shaping engine, there was no case where reph position&nbsp;</div></li><li><div>             *     will be found on this step.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (!$skip_to_reph_step_5) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $new_reph_pos = $start + 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                while ($new_reph_pos &lt; $base && !self::is_halant_or_coeng($info[$new_reph_pos]))&nbsp;</div></li><li><div>                    $new_reph_pos++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ($new_reph_pos &lt; $base && self::is_halant_or_coeng($info[$new_reph_pos])) {&nbsp;</div></li><li><div>                    /** -&gt;If ZWJ or ZWNJ are following this halant, position is moved after it. */&nbsp;</div></li><li><div>                    if ($new_reph_pos + 1 &lt; $base && self::is_joiner($info[$new_reph_pos + 1]))&nbsp;</div></li><li><div>                        $new_reph_pos++;&nbsp;</div></li><li><div>                    $skip_to_reph_move = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**     3. If reph should be repositioned after the main consonant: find the&nbsp;</div></li><li><div>             *     first consonant not ligated with main, or find the first&nbsp;</div></li><li><div>             *     consonant that is not a potential pre-base reordering Ra.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            if ($reph_pos == self::REPH_POS_AFTER_MAIN && !$skip_to_reph_move && !$skip_to_reph_step_5) {&nbsp;</div></li><li><div>                $new_reph_pos = $base;&nbsp;</div></li><li><div>                /** XXX Skip potential pre-base reordering Ra. */&nbsp;</div></li><li><div>                while ($new_reph_pos + 1 &lt; $end && $info[$new_reph_pos + 1]['indic_position'] &lt;= self::POS_AFTER_MAIN)&nbsp;</div></li><li><div>                    $new_reph_pos++;&nbsp;</div></li><li><div>                if ($new_reph_pos &lt; $end)&nbsp;</div></li><li><div>                    $skip_to_reph_move = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**     4. If reph should be positioned before post-base consonant, find&nbsp;</div></li><li><div>             *     first post-base classified consonant not ligated with main. If no&nbsp;</div></li><li><div>             *     consonant is found, the target position should be before the&nbsp;</div></li><li><div>             *     first matra, syllable modifier sign or vedic sign.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            /** This is our take on what step 4 is trying to say (and failing, BADLY). */&nbsp;</div></li><li><div>            if ($reph_pos == self::REPH_POS_AFTER_SUB && !$skip_to_reph_move && !$skip_to_reph_step_5) {&nbsp;</div></li><li><div>                $new_reph_pos = $base;&nbsp;</div></li><li><div>                while ($new_reph_pos &lt; $end && isset($info[$new_reph_pos + 1]['indic_position']) &&&nbsp;</div></li><li><div>                !( self::FLAG($info[$new_reph_pos + 1]['indic_position']) & (self::FLAG(self::POS_POST_C) | self::FLAG(self::POS_AFTER_POST) | self::FLAG(self::POS_SMVD)))) {&nbsp;</div></li><li><div>                    $new_reph_pos++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                if ($new_reph_pos &lt; $end) {&nbsp;</div></li><li><div>                    $skip_to_reph_move = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**     5. If no consonant is found in steps 3 or 4, move reph to a position&nbsp;</div></li><li><div>             *         immediately before the first post-base matra, syllable modifier&nbsp;</div></li><li><div>             *         sign or vedic sign that has a reordering class after the intended&nbsp;</div></li><li><div>             *         reph position. For example, if the reordering position for reph&nbsp;</div></li><li><div>             *         is post-main, it will skip above-base matras that also have a&nbsp;</div></li><li><div>             *         post-main position.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            if (!$skip_to_reph_move) {&nbsp;</div></li><li><div>                /** Copied from step 2. */&nbsp;</div></li><li><div>                $new_reph_pos = $start + 1;&nbsp;</div></li><li><div>                while ($new_reph_pos &lt; $base && !self::is_halant_or_coeng($info[$new_reph_pos]))&nbsp;</div></li><li><div>                    $new_reph_pos++;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                if ($new_reph_pos &lt; $base && self::is_halant_or_coeng($info[$new_reph_pos])) {&nbsp;</div></li><li><div>                    /** -&gt;If ZWJ or ZWNJ are following this halant, position is moved after it. */&nbsp;</div></li><li><div>                    if ($new_reph_pos + 1 &lt; $base && self::is_joiner($info[$new_reph_pos + 1]))&nbsp;</div></li><li><div>                        $new_reph_pos++;&nbsp;</div></li><li><div>                    $skip_to_reph_move = true;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /**     6. Otherwise, reorder reph to the end of the syllable.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            if (!$skip_to_reph_move) {&nbsp;</div></li><li><div>                $new_reph_pos = $end - 1;&nbsp;</div></li><li><div>                while ($new_reph_pos &gt; $start && $info[$new_reph_pos]['indic_position'] == self::POS_SMVD)&nbsp;</div></li><li><div>                    $new_reph_pos--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                /**&nbsp;</div></li><li><div>                 * If the Reph is to be ending up after a Matra, Halant sequence, &nbsp;</div></li><li><div>                 * position it before that Halant so it can interact with the Matra.&nbsp;</div></li><li><div>                 * However, if it's a plain Consonant, Halant we shouldn't do that.&nbsp;</div></li><li><div>                 * Uniscribe doesn't do this.&nbsp;</div></li><li><div>                 * TEST: U+0930, U+094D, U+0915, U+094B, U+094D&nbsp;</div></li><li><div>                 */&nbsp;</div></li><li><div>                //if (!$hb_options.uniscribe_bug_compatible && self::is_halant_or_coeng($info[$new_reph_pos])) {&nbsp;</div></li><li><div>                if (self::is_halant_or_coeng($info[$new_reph_pos])) {&nbsp;</div></li><li><div>                    for ($i = $base + 1; $i &lt; $new_reph_pos; $i++)&nbsp;</div></li><li><div>                        if ($info[$i]['indic_category'] == self::OT_M) {&nbsp;</div></li><li><div>                            /** Ok, got it. */&nbsp;</div></li><li><div>                            $new_reph_pos--;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            /** Move */&nbsp;</div></li><li><div>            self::_move_info_pos($info, $start, $new_reph_pos + 1);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($start &lt; $base && $base &lt;= $new_reph_pos) {&nbsp;</div></li><li><div>                $base--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**     o Reorder pre-base reordering consonants:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         *     If a pre-base reordering consonant is found, reorder it according to&nbsp;</div></li><li><div>         *     the following rules:&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (count($GSUBdata['pref']) && $base + 1 &lt; $end) { /** Otherwise there can't be any pre-base reordering Ra. */&nbsp;</div></li><li><div>            for ($i = $base + 1; $i &lt; $end; $i++) {&nbsp;</div></li><li><div>                if ($info[$i]['mask'] & self::FLAG(self::PREF)) {&nbsp;</div></li><li><div>                    /**     1. Only reorder a glyph produced by substitution during application&nbsp;</div></li><li><div>                     *     of the &lt;pref&gt; feature. (Note that a font may shape a Ra consonant with&nbsp;</div></li><li><div>                     *     the feature generally but block it in certain contexts.)&nbsp;</div></li><li><div>                     */&nbsp;</div></li><li><div>// ??? Need to TEST if actual substitution has occurred&nbsp;</div></li><li><div>                    if ($i + 1 == $end || ($info[$i + 1]['mask'] & self::FLAG(self::PREF)) == 0) {&nbsp;</div></li><li><div>                        /**&nbsp;</div></li><li><div>                         *     2. Try to find a target position the same way as for pre-base matra.&nbsp;</div></li><li><div>                         *     If it is found, reorder pre-base consonant glyph.&nbsp;</div></li><li><div>                         *&nbsp;</div></li><li><div>                         *     3. If position is not found, reorder immediately before main&nbsp;</div></li><li><div>                         *     consonant.&nbsp;</div></li><li><div>                         */&nbsp;</div></li><li><div>                        $new_pos = $base;&nbsp;</div></li><li><div>                        /** Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.&nbsp;</div></li><li><div>                         * The glyphs formed by 'half' are Chillus or ligated explicit viramas.&nbsp;</div></li><li><div>                         * We want to position matra after them.&nbsp;</div></li><li><div>                         */&nbsp;</div></li><li><div>                        if ($scriptblock != UCDN::SCRIPT_MALAYALAM && $scriptblock != UCDN::SCRIPT_TAMIL) {&nbsp;</div></li><li><div>                            while ($new_pos &gt; $start &&&nbsp;</div></li><li><div>                            !(self::is_one_of($info[$new_pos - 1], self::FLAG(self::OT_M) | self::FLAG(self::OT_H) | self::FLAG(self::OT_Coeng))))&nbsp;</div></li><li><div>                                $new_pos--;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            /** In Khmer coeng model, a V, Ra can go *after* matras. If it goes after a&nbsp;</div></li><li><div>                             * split matra, it should be reordered to *before* the left part of such matra. */&nbsp;</div></li><li><div>                            if ($new_pos &gt; $start && $info[$new_pos - 1]['indic_category'] == self::OT_M) {&nbsp;</div></li><li><div>                                $old_pos = i;&nbsp;</div></li><li><div>                                for ($i = $base + 1; $i &lt; $old_pos; $i++)&nbsp;</div></li><li><div>                                    if ($info[$i]['indic_category'] == self::OT_M) {&nbsp;</div></li><li><div>                                        $new_pos--;&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ($new_pos &gt; $start && self::is_halant_or_coeng($info[$new_pos - 1])) {&nbsp;</div></li><li><div>                            /** -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */&nbsp;</div></li><li><div>                            if ($new_pos &lt; $end && self::is_joiner($info[$new_pos]))&nbsp;</div></li><li><div>                                $new_pos++;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        $old_pos = $i;&nbsp;</div></li><li><div>                        self::_move_info_pos($info, $old_pos, $new_pos);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                        if ($new_pos &lt;= $base && $base &lt; $old_pos)&nbsp;</div></li><li><div>                            $base++;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** Apply 'init' to the Left Matra if it's a word start. */&nbsp;</div></li><li><div>        if ($info[$start]['indic_position'] == self::POS_PRE_M &&&nbsp;</div></li><li><div>            ($start == 0 ||&nbsp;</div></li><li><div>            ($info[$start - 1]['general_category'] &lt; UCDN::UNICODE_GENERAL_CATEGORY_FORMAT || $info[$start - 1]['general_category'] &gt; UCDN::UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)&nbsp;</div></li><li><div> )) {&nbsp;</div></li><li><div>            $info[$start]['mask'] |= self::FLAG(self::INIT);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Finish off and go home!&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function _move_info_pos(&$info, $from, $to)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $t = array();&nbsp;</div></li><li><div>        $t[0] = $info[$from];&nbsp;</div></li><li><div>        if ($from &gt; $to) {&nbsp;</div></li><li><div>            array_splice($info, $from, 1);&nbsp;</div></li><li><div>            array_splice($info, $to, 0, $t);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            array_splice($info, $to, 0, $t);&nbsp;</div></li><li><div>            array_splice($info, $from, 1);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static $ra_chars = array(&nbsp;</div></li><li><div>        0x0930 =&gt; 1, /** Devanagari */&nbsp;</div></li><li><div>        0x09B0 =&gt; 1, /** Bengali */&nbsp;</div></li><li><div>        0x09F0 =&gt; 1, /** Bengali (Assamese) */&nbsp;</div></li><li><div>        0x0A30 =&gt; 1, /** Gurmukhi */ /** No Reph */&nbsp;</div></li><li><div>        0x0AB0 =&gt; 1, /** Gujarati */&nbsp;</div></li><li><div>        0x0B30 =&gt; 1, /** Oriya */&nbsp;</div></li><li><div>        0x0BB0 =&gt; 1, /** Tamil */ /** No Reph */&nbsp;</div></li><li><div>        0x0C30 =&gt; 1, /** Telugu */ /** Reph formed only with ZWJ */&nbsp;</div></li><li><div>        0x0CB0 =&gt; 1, /** Kannada */&nbsp;</div></li><li><div>        0x0D30 =&gt; 1, /** Malayalam */ /** No Reph, Logical Repha */&nbsp;</div></li><li><div>        0x0DBB =&gt; 1, /** Sinhala */ /** Reph formed only with ZWJ */&nbsp;</div></li><li><div>        0x179A =&gt; 1, /** Khmer */ /** No Reph, Visual Repha */&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function is_ra($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (isset(self::$ra_chars[$u]))&nbsp;</div></li><li><div>            return true;&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function is_one_of($info, $flags)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (isset($info['is_ligature']) && $info['is_ligature'])&nbsp;</div></li><li><div>            return false; /** If it ligated, all bets are off. */&nbsp;</div></li><li><div>        return !!(self::FLAG($info['indic_category']) & $flags);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function is_joiner($info)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::is_one_of($info, (self::FLAG(self::OT_ZWJ) | self::FLAG(self::OT_ZWNJ)));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /** Vowels and placeholders treated as if they were consonants. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function is_consonant($info)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::is_one_of($info, (self::FLAG(self::OT_C) | self::FLAG(self::OT_CM) | self::FLAG(self::OT_Ra) | self::FLAG(self::OT_V) | self::FLAG(self::OT_NBSP) | self::FLAG(self::OT_DOTTEDCIRCLE)));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function is_halant_or_coeng($info)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::is_one_of($info, (self::FLAG(self::OT_H) | self::FLAG(self::OT_Coeng)));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // From hb-private.hh&nbsp;</div></li><li><div>    public static function in_range($u, $lo, $hi)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if ((($lo ^ $hi) & $lo) == 0 && (($lo ^ $hi) & $hi) == ($lo ^ $hi) && (($lo ^ $hi) & (($lo ^ $hi) + 1)) == 0)&nbsp;</div></li><li><div>            return ($u & ~($lo ^ $hi)) == $lo;&nbsp;</div></li><li><div>        else&nbsp;</div></li><li><div>            return $lo &lt;= $u && $u &lt;= $hi;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // From hb-private.hh&nbsp;</div></li><li><div>    public static function FLAG($x)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return (1 &lt;&lt; ($x));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // BELOW from hb-ot-shape-complex-indic.cc&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Indic configurations.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // base_position&nbsp;</div></li><li><div>    const BASE_POS_FIRST = 0;&nbsp;</div></li><li><div>    const BASE_POS_LAST = 1;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // reph_position&nbsp;</div></li><li><div>    const REPH_POS_DEFAULT = 10; // POS_BEFORE_POST, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const REPH_POS_AFTER_MAIN = 5; // POS_AFTER_MAIN, &nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const REPH_POS_BEFORE_SUB = 7; // POS_BEFORE_SUB, &nbsp;</div></li><li><div>    const REPH_POS_AFTER_SUB = 9; // POS_AFTER_SUB, &nbsp;</div></li><li><div>    const REPH_POS_BEFORE_POST = 10; // POS_BEFORE_POST, &nbsp;</div></li><li><div>    const REPH_POS_AFTER_POST = 12; // POS_AFTER_POST&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // reph_mode&nbsp;</div></li><li><div>    const REPH_MODE_IMPLICIT = 0;  /** Reph formed out of initial Ra, H sequence. */&nbsp;</div></li><li><div>    const REPH_MODE_EXPLICIT = 1;  /** Reph formed out of initial Ra, H, ZWJ sequence. */&nbsp;</div></li><li><div>    const REPH_MODE_VIS_REPHA = 2; /** Encoded Repha character, no reordering needed. */&nbsp;</div></li><li><div>    const REPH_MODE_LOG_REPHA = 3; /** Encoded Repha character, needs reordering. */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>      struct of indic_configs{&nbsp;</div></li><li><div>      KEY - script;&nbsp;</div></li><li><div>      0 - has_old_spec;&nbsp;</div></li><li><div>      1 - virama;&nbsp;</div></li><li><div>      2 - base_pos;&nbsp;</div></li><li><div>      3 - reph_pos;&nbsp;</div></li><li><div>      4 - reph_mode;&nbsp;</div></li><li><div>      };&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static $indic_configs = array(/** index is SCRIPT_number from UCDN */&nbsp;</div></li><li><div>        9 =&gt; array(true, 0x094D, 1, 10, 0), &nbsp;</div></li><li><div>        10 =&gt; array(true, 0x09CD, 1, 9, 0), &nbsp;</div></li><li><div>        11 =&gt; array(true, 0x0A4D, 1, 7, 0), &nbsp;</div></li><li><div>        12 =&gt; array(true, 0x0ACD, 1, 10, 0), &nbsp;</div></li><li><div>        13 =&gt; array(true, 0x0B4D, 1, 5, 0), &nbsp;</div></li><li><div>        14 =&gt; array(true, 0x0BCD, 1, 12, 0), &nbsp;</div></li><li><div>        15 =&gt; array(true, 0x0C4D, 1, 12, 1), &nbsp;</div></li><li><div>        16 =&gt; array(true, 0x0CCD, 1, 12, 0), &nbsp;</div></li><li><div>        17 =&gt; array(true, 0x0D4D, 1, 5, 3), &nbsp;</div></li><li><div>        18 =&gt; array(false, 0x0DCA, 0, 5, 1), /** Sinhala */&nbsp;</div></li><li><div>        30 =&gt; array(false, 0x17D2, 0, 10, 2), /** Khmer */&nbsp;</div></li><li><div>        84 =&gt; array(false, 0xA9C0, 1, 10, 0), /** Javanese */&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>      // from &quot;hb-ot-shape-complex-indic-table.cc&quot;&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>      const ISC_A = 0; //    INDIC_SYLLABIC_CATEGORY_AVAGRAHA        Avagraha&nbsp;</div></li><li><div>      const ISC_Bi = 8; //    INDIC_SYLLABIC_CATEGORY_BINDU            Bindu&nbsp;</div></li><li><div>      const ISC_C = 1; //    INDIC_SYLLABIC_CATEGORY_CONSONANT        Consonant&nbsp;</div></li><li><div>      const ISC_CD = 1; //    INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD        Consonant_Dead&nbsp;</div></li><li><div>      const ISC_CF = 17; //    INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL        Consonant_Final&nbsp;</div></li><li><div>      const ISC_CHL = 1; //    INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER    Consonant_Head_Letter&nbsp;</div></li><li><div>      const ISC_CM = 17; //    INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL        Consonant_Medial&nbsp;</div></li><li><div>      const ISC_CP = 11; //    INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER    Consonant_Placeholder&nbsp;</div></li><li><div>      const ISC_CR = 15; //    INDIC_SYLLABIC_CATEGORY_CONSONANT_REPHA        Consonant_Repha&nbsp;</div></li><li><div>      const ISC_CS = 1; //    INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED    Consonant_Subjoined&nbsp;</div></li><li><div>      const ISC_ML = 0; //    INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER    Modifying_Letter&nbsp;</div></li><li><div>      const ISC_N = 3; //    INDIC_SYLLABIC_CATEGORY_NUKTA            Nukta&nbsp;</div></li><li><div>      const ISC_x = 0; //    INDIC_SYLLABIC_CATEGORY_OTHER            Other&nbsp;</div></li><li><div>      const ISC_RS = 13; //    INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER    Register_Shifter&nbsp;</div></li><li><div>      const ISC_TL = 0; //    INDIC_SYLLABIC_CATEGORY_TONE_LETTER        Tone_Letter&nbsp;</div></li><li><div>      const ISC_TM = 3; //    INDIC_SYLLABIC_CATEGORY_TONE_MARK        Tone_Mark&nbsp;</div></li><li><div>      const ISC_V = 4; //    INDIC_SYLLABIC_CATEGORY_VIRAMA        Virama&nbsp;</div></li><li><div>      const ISC_Vs = 8; //    INDIC_SYLLABIC_CATEGORY_VISARGA        Visarga&nbsp;</div></li><li><div>      const ISC_Vo = 2; //    INDIC_SYLLABIC_CATEGORY_VOWEL            Vowel&nbsp;</div></li><li><div>      const ISC_M = 7; //    INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT    Vowel_Dependent&nbsp;</div></li><li><div>      const ISC_VI = 2; //    INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT    Vowel_Independent&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>      const IMC_B = 8; //    INDIC_MATRA_CATEGORY_BOTTOM            Bottom&nbsp;</div></li><li><div>      const IMC_BR = 11; //    INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT    Bottom_And_Right&nbsp;</div></li><li><div>      const IMC_I = 15; //    INDIC_MATRA_CATEGORY_INVISIBLE        Invisible&nbsp;</div></li><li><div>      const IMC_L = 3; //    INDIC_MATRA_CATEGORY_LEFT            Left&nbsp;</div></li><li><div>      const IMC_LR = 11; //    INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT        Left_And_Right&nbsp;</div></li><li><div>      const IMC_x = 15; //    INDIC_MATRA_CATEGORY_NOT_APPLICABLE        Not_Applicable&nbsp;</div></li><li><div>      const IMC_O = 5; //    INDIC_MATRA_CATEGORY_OVERSTRUCK        Overstruck&nbsp;</div></li><li><div>      const IMC_R = 11; //    INDIC_MATRA_CATEGORY_RIGHT            Right&nbsp;</div></li><li><div>      const IMC_T = 6; //    INDIC_MATRA_CATEGORY_TOP            Top&nbsp;</div></li><li><div>      const IMC_TB = 8; //    INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM        Top_And_Bottom&nbsp;</div></li><li><div>      const IMC_TBR = 11; //    INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT    Top_And_Bottom_And_Right&nbsp;</div></li><li><div>      const IMC_TL = 6; //    INDIC_MATRA_CATEGORY_TOP_AND_LEFT        Top_And_Left&nbsp;</div></li><li><div>      const IMC_TLR = 11; //    INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT    Top_And_Left_And_Right&nbsp;</div></li><li><div>      const IMC_TR = 11; //    INDIC_MATRA_CATEGORY_TOP_AND_RIGHT        Top_And_Right&nbsp;</div></li><li><div>      const IMC_VOL = 2; //    INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT        Visual_Order_Left&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>      If in original table = _(C, x), that = ISC_C, IMC_x&nbsp;</div></li><li><div>      Value is IMC_x &lt;&lt; 8 (or IMC_x * 256) = 3840&nbsp;</div></li><li><div>      plus ISC_C = 1, so = 3841&nbsp;</div></li><li><div>&nbsp;&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static $indic_table = array(&nbsp;</div></li><li><div>        /** Devanagari  (0900..097F) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0900 */ 3848, 3848, 3848, 3848, 3842, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0908 */ 3842, 3842, 3842, 3842, 3842, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0910 */ 3842, 3842, 3842, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0918 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0920 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0928 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0930 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0938 */ 3841, 3841, 1543, 2823, 3843, 3840, 2823, 775, &nbsp;</div></li><li><div>        /** 0940 */ 2823, 2055, 2055, 2055, 2055, 1543, 1543, 1543, &nbsp;</div></li><li><div>        /** 0948 */ 1543, 2823, 2823, 2823, 2823, 2052, 775, 2823, &nbsp;</div></li><li><div>        /** 0950 */ 3840, 3840, 3840, 3840, 3840, 1543, 2055, 2055, &nbsp;</div></li><li><div>        /** 0958 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0960 */ 3842, 3842, 2055, 2055, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0968 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0970 */ 3840, 3840, 3842, 3842, 3842, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0978 */ 3840, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** Bengali  (0980..09FF) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0980 */ 3840, 3848, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0988 */ 3842, 3842, 3842, 3842, 3842, 3840, 3840, 3842, &nbsp;</div></li><li><div>        /** 0990 */ 3842, 3840, 3840, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0998 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 09A0 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 09A8 */ 3841, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 09B0 */ 3841, 3840, 3841, 3840, 3840, 3840, 3841, 3841, &nbsp;</div></li><li><div>        /** 09B8 */ 3841, 3841, 3840, 3840, 3843, 3840, 2823, 775, &nbsp;</div></li><li><div>        /** 09C0 */ 2823, 2055, 2055, 2055, 2055, 3840, 3840, 775, &nbsp;</div></li><li><div>        /** 09C8 */ 775, 3840, 3840, 2823, 2823, 2052, 3841, 3840, &nbsp;</div></li><li><div>        /** 09D0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 2823, &nbsp;</div></li><li><div>        /** 09D8 */ 3840, 3840, 3840, 3840, 3841, 3841, 3840, 3841, &nbsp;</div></li><li><div>        /** 09E0 */ 3842, 3842, 2055, 2055, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 09E8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 09F0 */ 3841, 3841, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 09F8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Gurmukhi  (0A00..0A7F) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0A00 */ 3840, 3848, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0A08 */ 3842, 3842, 3842, 3840, 3840, 3840, 3840, 3842, &nbsp;</div></li><li><div>        /** 0A10 */ 3842, 3840, 3840, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0A18 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0A20 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0A28 */ 3841, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0A30 */ 3841, 3840, 3841, 3841, 3840, 3841, 3841, 3840, &nbsp;</div></li><li><div>        /** 0A38 */ 3841, 3841, 3840, 3840, 3843, 3840, 2823, 775, &nbsp;</div></li><li><div>        /** 0A40 */ 2823, 2055, 2055, 3840, 3840, 3840, 3840, 1543, &nbsp;</div></li><li><div>        /** 0A48 */ 1543, 3840, 3840, 1543, 1543, 2052, 3840, 3840, &nbsp;</div></li><li><div>        /** 0A50 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0A58 */ 3840, 3841, 3841, 3841, 3841, 3840, 3841, 3840, &nbsp;</div></li><li><div>        /** 0A60 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0A68 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0A70 */ 3848, 3840, 13841, 13841, 3840, 3857, 3840, 3840, &nbsp;</div></li><li><div>        /** 0A78 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Gujarati  (0A80..0AFF) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0A80 */ 3840, 3848, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0A88 */ 3842, 3842, 3842, 3842, 3842, 3842, 3840, 3842, &nbsp;</div></li><li><div>        /** 0A90 */ 3842, 3842, 3840, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0A98 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0AA0 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0AA8 */ 3841, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0AB0 */ 3841, 3840, 3841, 3841, 3840, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0AB8 */ 3841, 3841, 3840, 3840, 3843, 3840, 2823, 775, &nbsp;</div></li><li><div>        /** 0AC0 */ 2823, 2055, 2055, 2055, 2055, 1543, 3840, 1543, &nbsp;</div></li><li><div>        /** 0AC8 */ 1543, 2823, 3840, 2823, 2823, 2052, 3840, 3840, &nbsp;</div></li><li><div>        /** 0AD0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0AD8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0AE0 */ 3842, 3842, 2055, 2055, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0AE8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0AF0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0AF8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Oriya  (0B00..0B7F) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0B00 */ 3840, 3848, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0B08 */ 3842, 3842, 3842, 3842, 3842, 3840, 3840, 3842, &nbsp;</div></li><li><div>        /** 0B10 */ 3842, 3840, 3840, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0B18 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0B20 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0B28 */ 3841, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0B30 */ 3841, 3840, 3841, 3841, 3840, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0B38 */ 3841, 3841, 3840, 3840, 3843, 3840, 2823, 1543, &nbsp;</div></li><li><div>        /** 0B40 */ 2823, 2055, 2055, 2055, 2055, 3840, 3840, 775, &nbsp;</div></li><li><div>        /** 0B48 */ 1543, 3840, 3840, 2823, 2823, 2052, 3840, 3840, &nbsp;</div></li><li><div>        /** 0B50 */ 3840, 3840, 3840, 3840, 3840, 3840, 1543, 2823, &nbsp;</div></li><li><div>        /** 0B58 */ 3840, 3840, 3840, 3840, 3841, 3841, 3840, 3841, &nbsp;</div></li><li><div>        /** 0B60 */ 3842, 3842, 2055, 2055, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0B68 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0B70 */ 3840, 3841, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0B78 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Tamil  (0B80..0BFF) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0B80 */ 3840, 3840, 3848, 3840, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0B88 */ 3842, 3842, 3842, 3840, 3840, 3840, 3842, 3842, &nbsp;</div></li><li><div>        /** 0B90 */ 3842, 3840, 3842, 3842, 3842, 3841, 3840, 3840, &nbsp;</div></li><li><div>        /** 0B98 */ 3840, 3841, 3841, 3840, 3841, 3840, 3841, 3841, &nbsp;</div></li><li><div>        /** 0BA0 */ 3840, 3840, 3840, 3841, 3841, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0BA8 */ 3841, 3841, 3841, 3840, 3840, 3840, 3841, 3841, &nbsp;</div></li><li><div>        /** 0BB0 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0BB8 */ 3841, 3841, 3840, 3840, 3840, 3840, 2823, 2823, &nbsp;</div></li><li><div>        /** 0BC0 */ 1543, 2055, 2055, 3840, 3840, 3840, 775, 775, &nbsp;</div></li><li><div>        /** 0BC8 */ 775, 3840, 2823, 2823, 2823, 1540, 3840, 3840, &nbsp;</div></li><li><div>        /** 0BD0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 2823, &nbsp;</div></li><li><div>        /** 0BD8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0BE0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0BE8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0BF0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0BF8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Telugu  (0C00..0C7F) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0C00 */ 3840, 3848, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0C08 */ 3842, 3842, 3842, 3842, 3842, 3840, 3842, 3842, &nbsp;</div></li><li><div>        /** 0C10 */ 3842, 3840, 3842, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0C18 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0C20 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0C28 */ 3841, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0C30 */ 3841, 3841, 3841, 3841, 3840, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0C38 */ 3841, 3841, 3840, 3840, 3840, 3840, 1543, 1543, &nbsp;</div></li><li><div>        /** 0C40 */ 1543, 2823, 2823, 2823, 2823, 3840, 1543, 1543, &nbsp;</div></li><li><div>        /** 0C48 */ 2055, 3840, 1543, 1543, 1543, 1540, 3840, 3840, &nbsp;</div></li><li><div>        /** 0C50 */ 3840, 3840, 3840, 3840, 3840, 1543, 2055, 3840, &nbsp;</div></li><li><div>        /** 0C58 */ 3841, 3841, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0C60 */ 3842, 3842, 2055, 2055, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0C68 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0C70 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0C78 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Kannada  (0C80..0CFF) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0C80 */ 3840, 3840, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0C88 */ 3842, 3842, 3842, 3842, 3842, 3840, 3842, 3842, &nbsp;</div></li><li><div>        /** 0C90 */ 3842, 3840, 3842, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0C98 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0CA0 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0CA8 */ 3841, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0CB0 */ 3841, 3841, 3841, 3841, 3840, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0CB8 */ 3841, 3841, 3840, 3840, 3843, 3840, 2823, 1543, &nbsp;</div></li><li><div>        /** 0CC0 */ 2823, 2823, 2823, 2823, 2823, 3840, 1543, 2823, &nbsp;</div></li><li><div>        /** 0CC8 */ 2823, 3840, 2823, 2823, 1543, 1540, 3840, 3840, &nbsp;</div></li><li><div>        /** 0CD0 */ 3840, 3840, 3840, 3840, 3840, 2823, 2823, 3840, &nbsp;</div></li><li><div>        /** 0CD8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3841, 3840, &nbsp;</div></li><li><div>        /** 0CE0 */ 3842, 3842, 2055, 2055, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0CE8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0CF0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0CF8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Malayalam  (0D00..0D7F) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0D00 */ 3840, 3840, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0D08 */ 3842, 3842, 3842, 3842, 3842, 3840, 3842, 3842, &nbsp;</div></li><li><div>        /** 0D10 */ 3842, 3840, 3842, 3842, 3842, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0D18 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0D20 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0D28 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0D30 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0D38 */ 3841, 3841, 3841, 3840, 3840, 3840, 2823, 2823, &nbsp;</div></li><li><div>        /** 0D40 */ 2823, 2823, 2823, 2055, 2055, 3840, 775, 775, &nbsp;</div></li><li><div>        /** 0D48 */ 775, 3840, 2823, 2823, 2823, 1540, 3855, 3840, &nbsp;</div></li><li><div>        /** 0D50 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 2823, &nbsp;</div></li><li><div>        /** 0D58 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0D60 */ 3842, 3842, 2055, 2055, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0D68 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0D70 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0D78 */ 3840, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** Sinhala  (0D80..0DFF) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 0D80 */ 3840, 3840, 3848, 3848, 3840, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0D88 */ 3842, 3842, 3842, 3842, 3842, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 0D90 */ 3842, 3842, 3842, 3842, 3842, 3842, 3842, 3840, &nbsp;</div></li><li><div>        /** 0D98 */ 3840, 3840, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0DA0 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0DA8 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0DB0 */ 3841, 3841, 3840, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 0DB8 */ 3841, 3841, 3841, 3841, 3840, 3841, 3840, 3840, &nbsp;</div></li><li><div>        /** 0DC0 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3840, &nbsp;</div></li><li><div>        /** 0DC8 */ 3840, 3840, 1540, 3840, 3840, 3840, 3840, 2823, &nbsp;</div></li><li><div>        /** 0DD0 */ 2823, 2823, 1543, 1543, 2055, 3840, 2055, 3840, &nbsp;</div></li><li><div>        /** 0DD8 */ 2823, 775, 1543, 775, 2823, 2823, 2823, 2823, &nbsp;</div></li><li><div>        /** 0DE0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0DE8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0DF0 */ 3840, 3840, 2823, 2823, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 0DF8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** Vedic Extensions  (1CD0..1CFF) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 1CD0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 1CD8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 1CE0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 1CE8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 1CF0 */ 3840, 3840, 3848, 3848, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 1CF8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static $khmer_table = array(&nbsp;</div></li><li><div>        /** Khmer  (1780..17FF) */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** 1780 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 1788 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 1790 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 1798 */ 3841, 3841, 3841, 3841, 3841, 3841, 3841, 3841, &nbsp;</div></li><li><div>        /** 17A0 */ 3841, 3841, 3841, 3842, 3842, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 17A8 */ 3842, 3842, 3842, 3842, 3842, 3842, 3842, 3842, &nbsp;</div></li><li><div>        /** 17B0 */ 3842, 3842, 3842, 3842, 3840, 3840, 2823, 1543, &nbsp;</div></li><li><div>        /** 17B8 */ 1543, 1543, 1543, 2055, 2055, 2055, 1543, 2823, &nbsp;</div></li><li><div>        /** 17C0 */ 2823, 775, 775, 775, 2823, 2823, 3848, 3848, &nbsp;</div></li><li><div>        /** 17C8 */ 2823, 3853, 3853, 3840, 3855, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 17D0 */ 3840, 1540, 3844, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 17D8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 17E0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 17E8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 17F0 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div>        /** 17F8 */ 3840, 3840, 3840, 3840, 3840, 3840, 3840, 3840, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // from &quot;hb-ot-shape-complex-indic-table.cc&quot;&nbsp;</div></li><li><div>    public static function indic_get_categories($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if (0x0900 &lt;= $u && $u &lt;= 0x0DFF)&nbsp;</div></li><li><div>            return self::$indic_table[$u - 0x0900 + 0]; // offset 0 for Most &quot;indic&quot;&nbsp;</div></li><li><div>        if (0x1CD0 &lt;= $u && $u &lt;= 0x1D00)&nbsp;</div></li><li><div>            return self::$indic_table[$u - 0x1CD0 + 1152]; // offset for Vedic extensions&nbsp;</div></li><li><div>        if (0x1780 &lt;= $u && $u &lt;= 0x17FF)&nbsp;</div></li><li><div>            return self::$khmer_table[$u - 0x1780];  // Khmer&nbsp;</div></li><li><div>        if ($u == 0x00A0)&nbsp;</div></li><li><div>            return 3851; // (ISC_CP | (IMC_x &lt;&lt; 8))&nbsp;</div></li><li><div>        if ($u == 0x25CC)&nbsp;</div></li><li><div>            return 3851; // (ISC_CP | (IMC_x &lt;&lt; 8))&nbsp;</div></li><li><div>        return 3840; // (ISC_x | (IMC_x &lt;&lt; 8))&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // BELOW from hb-ot-shape-complex-indic.cc&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Indic shaper.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IN_HALF_BLOCK($u, $Base)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return (($u & ~0x7F) == $Base);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_DEVA($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0900);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_BENG($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0980);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_GURU($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0A00);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_GUJR($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0A80);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_ORYA($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0B00);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_TAML($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0B80);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_TELU($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0C00);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_KNDA($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0C80);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_MLYM($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0D00);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_SINH($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x0D80);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IS_KHMR($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::IN_HALF_BLOCK($u, 0x1780);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function MATRA_POS_LEFT($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return self::POS_PRE_M;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function MATRA_POS_RIGHT($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return&nbsp;</div></li><li><div>            (self::IS_DEVA($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                (self::IS_BENG($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                    (self::IS_GURU($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                        (self::IS_GUJR($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                            (self::IS_ORYA($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                (self::IS_TAML($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                    (self::IS_TELU($u) ? ($u &lt;= 0x0C42 ? self::POS_BEFORE_SUB : self::POS_AFTER_SUB) :&nbsp;</div></li><li><div>                                        (self::IS_KNDA($u) ? ($u &lt; 0x0CC3 || $u &gt; 0xCD6 ? self::POS_BEFORE_SUB : self::POS_AFTER_SUB) :&nbsp;</div></li><li><div>                                            (self::IS_MLYM($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                                (self::IS_SINH($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                                                    (self::IS_KHMR($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                                        self::POS_AFTER_SUB))))))))))); /** default */&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function MATRA_POS_TOP($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return /** BENG and MLYM don't have top matras. */&nbsp;</div></li><li><div>            (self::IS_DEVA($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                (self::IS_GURU($u) ? self::POS_AFTER_POST : /** Deviate from spec */&nbsp;</div></li><li><div>                    (self::IS_GUJR($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                        (self::IS_ORYA($u) ? self::POS_AFTER_MAIN :&nbsp;</div></li><li><div>                            (self::IS_TAML($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                                (self::IS_TELU($u) ? self::POS_BEFORE_SUB :&nbsp;</div></li><li><div>                                    (self::IS_KNDA($u) ? self::POS_BEFORE_SUB :&nbsp;</div></li><li><div>                                        (self::IS_SINH($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                                            (self::IS_KHMR($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                                self::POS_AFTER_SUB))))))))); /** default */&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function MATRA_POS_BOTTOM($u)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        return&nbsp;</div></li><li><div>            (self::IS_DEVA($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                (self::IS_BENG($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                    (self::IS_GURU($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                        (self::IS_GUJR($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                            (self::IS_ORYA($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                                (self::IS_TAML($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                    (self::IS_TELU($u) ? self::POS_BEFORE_SUB :&nbsp;</div></li><li><div>                                        (self::IS_KNDA($u) ? self::POS_BEFORE_SUB :&nbsp;</div></li><li><div>                                            (self::IS_MLYM($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                                (self::IS_SINH($u) ? self::POS_AFTER_SUB :&nbsp;</div></li><li><div>                                                    (self::IS_KHMR($u) ? self::POS_AFTER_POST :&nbsp;</div></li><li><div>                                                        self::POS_AFTER_SUB))))))))))); /** default */&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function matra_position($u, $side)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        switch ($side) {&nbsp;</div></li><li><div>            case self::POS_PRE_C: return self::MATRA_POS_LEFT($u);&nbsp;</div></li><li><div>            case self::POS_POST_C: return self::MATRA_POS_RIGHT($u);&nbsp;</div></li><li><div>            case self::POS_ABOVE_C: return self::MATRA_POS_TOP($u);&nbsp;</div></li><li><div>            case self::POS_BELOW_C: return self::MATRA_POS_BOTTOM($u);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $side;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // vowel matras that have to be split into two parts.&nbsp;</div></li><li><div>    // From Harfbuzz (old)&nbsp;</div></li><li><div>    // New HarfBuzz uses /src/hb-ucdn/ucdn.c and unicodedata_db.h for full method of decomposition for all characters&nbsp;</div></li><li><div>    // Should always fully decompose and then recompose back, but we will just do the split matras&nbsp;</div></li><li><div>    public static function decompose_indic($ab)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        $sub = array();&nbsp;</div></li><li><div>        switch ($ab) {&nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Decompose split matras.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            /** bengali */&nbsp;</div></li><li><div>            case 0x9cb : $sub[0] = 0x9c7;&nbsp;</div></li><li><div>                $sub[1] = 0x9be;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0x9cc : $sub[0] = 0x9c7;&nbsp;</div></li><li><div>                $sub[1] = 0x9d7;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** oriya */&nbsp;</div></li><li><div>            case 0xb48 : $sub[0] = 0xb47;&nbsp;</div></li><li><div>                $sub[1] = 0xb56;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xb4b : $sub[0] = 0xb47;&nbsp;</div></li><li><div>                $sub[1] = 0xb3e;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xb4c : $sub[0] = 0xb47;&nbsp;</div></li><li><div>                $sub[1] = 0xb57;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** tamil */&nbsp;</div></li><li><div>            case 0xbca : $sub[0] = 0xbc6;&nbsp;</div></li><li><div>                $sub[1] = 0xbbe;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xbcb : $sub[0] = 0xbc7;&nbsp;</div></li><li><div>                $sub[1] = 0xbbe;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xbcc : $sub[0] = 0xbc6;&nbsp;</div></li><li><div>                $sub[1] = 0xbd7;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** telugu */&nbsp;</div></li><li><div>            case 0xc48 : $sub[0] = 0xc46;&nbsp;</div></li><li><div>                $sub[1] = 0xc56;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** kannada */&nbsp;</div></li><li><div>            case 0xcc0 : $sub[0] = 0xcbf;&nbsp;</div></li><li><div>                $sub[1] = 0xcd5;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xcc7 : $sub[0] = 0xcc6;&nbsp;</div></li><li><div>                $sub[1] = 0xcd5;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xcc8 : $sub[0] = 0xcc6;&nbsp;</div></li><li><div>                $sub[1] = 0xcd6;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xcca : $sub[0] = 0xcc6;&nbsp;</div></li><li><div>                $sub[1] = 0xcc2;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xccb : $sub[0] = 0xcc6;&nbsp;</div></li><li><div>                $sub[1] = 0xcc2;&nbsp;</div></li><li><div>                $sub[2] = 0xcd5;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** malayalam */&nbsp;</div></li><li><div>            case 0xd4a : $sub[0] = 0xd46;&nbsp;</div></li><li><div>                $sub[1] = 0xd3e;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xd4b : $sub[0] = 0xd47;&nbsp;</div></li><li><div>                $sub[1] = 0xd3e;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xd4c : $sub[0] = 0xd46;&nbsp;</div></li><li><div>                $sub[1] = 0xd57;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** sinhala */&nbsp;</div></li><li><div>            // NB Some fonts break with these Sinhala decomps (although this is Uniscribe spec)&nbsp;</div></li><li><div>            // Can check if character would be substituted by pstf and only decompose if true&nbsp;</div></li><li><div>            // e.g. if (isset($GSUBdata['pstf'][$ab])) - would need to pass $GSUBdata as parameter to this function&nbsp;</div></li><li><div>            case 0xdda : $sub[0] = 0xdd9;&nbsp;</div></li><li><div>                $sub[1] = 0xdca;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xddc : $sub[0] = 0xdd9;&nbsp;</div></li><li><div>                $sub[1] = 0xdcf;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xddd : $sub[0] = 0xdd9;&nbsp;</div></li><li><div>                $sub[1] = 0xdcf;&nbsp;</div></li><li><div>                $sub[2] = 0xdca;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xdde : $sub[0] = 0xdd9;&nbsp;</div></li><li><div>                $sub[1] = 0xddf;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** khmer */&nbsp;</div></li><li><div>            case 0x17be : $sub[0] = 0x17c1;&nbsp;</div></li><li><div>                $sub[1] = 0x17be;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0x17bf : $sub[0] = 0x17c1;&nbsp;</div></li><li><div>                $sub[1] = 0x17bf;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0x17c0 : $sub[0] = 0x17c1;&nbsp;</div></li><li><div>                $sub[1] = 0x17c0;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 0x17c4 : $sub[0] = 0x17c1;&nbsp;</div></li><li><div>                $sub[1] = 0x17c4;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0x17c5 : $sub[0] = 0x17c1;&nbsp;</div></li><li><div>                $sub[1] = 0x17c5;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            /** tibetan - included here although does not use Inidc shaper in other ways  */&nbsp;</div></li><li><div>            case 0xf73 : $sub[0] = 0xf71;&nbsp;</div></li><li><div>                $sub[1] = 0xf72;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xf75 : $sub[0] = 0xf71;&nbsp;</div></li><li><div>                $sub[1] = 0xf74;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xf76 : $sub[0] = 0xfb2;&nbsp;</div></li><li><div>                $sub[1] = 0xf80;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xf77 : $sub[0] = 0xfb2;&nbsp;</div></li><li><div>                $sub[1] = 0xf81;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xf78 : $sub[0] = 0xfb3;&nbsp;</div></li><li><div>                $sub[1] = 0xf80;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xf79 : $sub[0] = 0xfb3;&nbsp;</div></li><li><div>                $sub[1] = 0xf71;&nbsp;</div></li><li><div>                $sub[2] = 0xf80;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>            case 0xf81 : $sub[0] = 0xf71;&nbsp;</div></li><li><div>                $sub[1] = 0xf80;&nbsp;</div></li><li><div>                return $sub;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function bubble_sort(&$arr, $start, $len)&nbsp;</div></li><li><div>    {&nbsp;</div></li><li><div>        if ($len &lt; 2) {&nbsp;</div></li><li><div>            return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $k = $start + $len - 2;&nbsp;</div></li><li><div>        while ($k &gt;= $start) {&nbsp;</div></li><li><div>            for ($j = $start; $j &lt;= $k; $j++) {&nbsp;</div></li><li><div>                if ($arr[$j]['indic_position'] &gt; $arr[$j + 1]['indic_position']) {&nbsp;</div></li><li><div>                    $t = $arr[$j];&nbsp;</div></li><li><div>                    $arr[$j] = $arr[$j + 1];&nbsp;</div></li><li><div>                    $arr[$j + 1] = $t;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $k--;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 2.7.1</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.1/classes/indic/" class="active">2.8.1</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.8.0/classes/indic/" class="">2.8.0</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.7.3/classes/indic/" class="">2.7.3</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.7.2/classes/indic/" class="">2.7.2</a></li><li><a href="http://hookr.io/plugins/woocommerce-pdf-invoices/2.7.1/classes/indic/" class="">2.7.1</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>INDIC</li><li><span></span>WooCommerce PDF Invoices</li><li><span></span>2.8.1</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>