<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="2.3" data-slug="woocommerce-products-designer" data-type="class" data-id="58781"><head xmlns="http://www.w3.org/1999/xhtml"><title> tcpdf_parser | class | Woocommerce Products Designer | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="TCPDF_PARSER, class, plugin, woocommerce-products-designer, 2.3" /><meta name="description" content="The Woocommerce Products Designer TCPDF PARSER class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=2f46c3d446aff63bf16d00b632435465' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/tcpdf_parser/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Ftcpdf_parser%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Ftcpdf_parser%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-woocommerce-products-designer-2.3-class-tcpdf_parser","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="tcpdf_parser" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to woocommerce-products-designer." href="http://hookr.io/plugins/woocommerce-products-designer/" class="plugin"><span property="name">woocommerce-products-designer</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 2.3." href="http://hookr.io/plugins/woocommerce-products-designer/2.3/" class="H_VERSION"><span property="name">2.3</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/woocommerce-products-designer/2.3/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">tcpdf_parser</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="208"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/all/" title="All">All <span class="count badge">208</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="8"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/hooks/" title="Hooks">Hooks <span class="count badge">8</span></a></li><li class="" data-id="action" data-count="8"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/actions/" title="Actions">Actions <span class="count badge">8</span></a></li><li class="" data-id="filter" data-count="0"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/filters/" title="Filters">Filters <span class="count badge">0</span></a></li><li class="active" data-id="class" data-count="52"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/classes/" title="Classes">Classes <span class="count badge">52</span></a></li><li class="" data-id="constant" data-count="120"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/constants/" title="Constants">Constants <span class="count badge">120</span></a></li><li class="" data-id="function" data-count="22"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/functions/" title="Functions">Functions <span class="count badge">22</span></a></li><li class="" data-id="shortcode" data-count="6"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">6</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>TCPDF_PARSER</strong></h1><p>The Woocommerce Products Designer <strong>TCPDF PARSER</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(2)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/files/includes-tcpdf-tcpdf-parser/" class="file">/includes/tcpdf/tcpdf_parser.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="47" class="block" start="54"><li><div>/* @class TCPDF_PARSER&nbsp;</div></li><li><div> * This is a PHP class for parsing PDF documents.&lt;br&gt;&nbsp;</div></li><li><div> * @package com.tecnick.tcpdf&nbsp;</div></li><li><div> * @brief This is a PHP class for parsing PDF documents..&nbsp;</div></li><li><div> * @version 3.010&nbsp;</div></li><li><div> * @author Nicola Asuni - info@tecnick.com&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>class TCPDF_PARSER {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Raw content of the PDF document.&nbsp;</div></li><li><div> * @private&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>private $pdfdata = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * XREF data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected $xref = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Array of PDF objects.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected $objects = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Class object for decoding filters.&nbsp;</div></li><li><div> * @private&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>private $FilterDecoders;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Array of configuration parameters.&nbsp;</div></li><li><div> * @private&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>private $cfg = array(&nbsp;</div></li><li><div>    'die_for_errors' =&gt; false, &nbsp;</div></li><li><div>    'ignore_filter_decoding_errors' =&gt; true, &nbsp;</div></li><li><div>    'ignore_missing_filter_decoders' =&gt; true, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// -----------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Parse a PDF document an return an array of objects.&nbsp;</div></li><li><div> * @param $data (string) PDF data to parse.&nbsp;</div></li><li><div> * @param $cfg (array) Array of configuration parameters:&nbsp;</div></li><li><div> *             'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;&nbsp;</div></li><li><div> *             'ignore_filter_decoding_errors' : if true ignore filter decoding errors;&nbsp;</div></li><li><div> *             'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> * @since 3.000 (2011-05-24)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>public function __construct($data, $cfg=array()) {&nbsp;</div></li><li><div>    if (empty($data)) {&nbsp;</div></li><li><div>        $this-&gt;Error('Empty PDF data.');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // find the pdf header starting position&nbsp;</div></li><li><div>    if (($trimpos = strpos($data, '%PDF-')) === FALSE) {&nbsp;</div></li><li><div>        $this-&gt;Error('Invalid PDF data: missing %PDF header.');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // get PDF content string&nbsp;</div></li><li><div>    $this-&gt;pdfdata = substr($data, $trimpos);&nbsp;</div></li><li><div>    // get length&nbsp;</div></li><li><div>    $pdflen = strlen($this-&gt;pdfdata);&nbsp;</div></li><li><div>    // set configuration parameters&nbsp;</div></li><li><div>    $this-&gt;setConfig($cfg);&nbsp;</div></li><li><div>    // get xref and trailer data&nbsp;</div></li><li><div>    $this-&gt;xref = $this-&gt;getXrefData();&nbsp;</div></li><li><div>    // parse all document objects&nbsp;</div></li><li><div>    $this-&gt;objects = array();&nbsp;</div></li><li><div>    foreach ($this-&gt;xref['xref'] as $obj =&gt; $offset) {&nbsp;</div></li><li><div>        if (!isset($this-&gt;objects[$obj]) AND ($offset &gt; 0)) {&nbsp;</div></li><li><div>            // decode objects with positive offset&nbsp;</div></li><li><div>            $this-&gt;objects[$obj] = $this-&gt;getIndirectObject($obj, $offset, true);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // release some memory&nbsp;</div></li><li><div>    unset($this-&gt;pdfdata);&nbsp;</div></li><li><div>    $this-&gt;pdfdata = '';&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Set the configuration parameters.&nbsp;</div></li><li><div> * @param $cfg (array) Array of configuration parameters:&nbsp;</div></li><li><div> *             'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;&nbsp;</div></li><li><div> *             'ignore_filter_decoding_errors' : if true ignore filter decoding errors;&nbsp;</div></li><li><div> *             'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function setConfig($cfg) {&nbsp;</div></li><li><div>    if (isset($cfg['die_for_errors'])) {&nbsp;</div></li><li><div>        $this-&gt;cfg['die_for_errors'] = !!$cfg['die_for_errors'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (isset($cfg['ignore_filter_decoding_errors'])) {&nbsp;</div></li><li><div>        $this-&gt;cfg['ignore_filter_decoding_errors'] = !!$cfg['ignore_filter_decoding_errors'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (isset($cfg['ignore_missing_filter_decoders'])) {&nbsp;</div></li><li><div>        $this-&gt;cfg['ignore_missing_filter_decoders'] = !!$cfg['ignore_missing_filter_decoders'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Return an array of parsed PDF document objects.&nbsp;</div></li><li><div> * @return (array) Array of parsed PDF document objects.&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> * @since 3.000 (2011-06-26)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>public function getParsedData() {&nbsp;</div></li><li><div>    return array($this-&gt;xref, $this-&gt;objects);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get Cross-Reference (xref) table and trailer data from PDF document data.&nbsp;</div></li><li><div> * @param $offset (int) xref offset (if know).&nbsp;</div></li><li><div> * @param $xref (array) previous xref array (if any).&nbsp;</div></li><li><div> * @return Array containing xref and trailer data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-05-24)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getXrefData($offset=0, $xref=array()) {&nbsp;</div></li><li><div>    if ($offset == 0) {&nbsp;</div></li><li><div>        // find last startxref&nbsp;</div></li><li><div>        if (preg_match_all('/[\r\n]startxref[\s]*[\r\n]+([0-9]+)[\s]*[\r\n]+%%EOF/i', $this-&gt;pdfdata, $matches, PREG_SET_ORDER, $offset) == 0) {&nbsp;</div></li><li><div>            $this-&gt;Error('Unable to find startxref');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $matches = array_pop($matches);&nbsp;</div></li><li><div>        $startxref = $matches[1];&nbsp;</div></li><li><div>    } elseif (strpos($this-&gt;pdfdata, 'xref', $offset) == $offset) {&nbsp;</div></li><li><div>        // Already pointing at the xref table&nbsp;</div></li><li><div>        $startxref = $offset;&nbsp;</div></li><li><div>    } elseif (preg_match('/([0-9]+[\s][0-9]+[\s]obj)/i', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {&nbsp;</div></li><li><div>        // Cross-Reference Stream object&nbsp;</div></li><li><div>        $startxref = $offset;&nbsp;</div></li><li><div>    } elseif (preg_match('/[\r\n]startxref[\s]*[\r\n]+([0-9]+)[\s]*[\r\n]+%%EOF/i', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {&nbsp;</div></li><li><div>        // startxref found&nbsp;</div></li><li><div>        $startxref = $matches[1][0];&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        $this-&gt;Error('Unable to find startxref');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // check xref position&nbsp;</div></li><li><div>    if (strpos($this-&gt;pdfdata, 'xref', $startxref) == $startxref) {&nbsp;</div></li><li><div>        // Cross-Reference&nbsp;</div></li><li><div>        $xref = $this-&gt;decodeXref($startxref, $xref);&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        // Cross-Reference Stream&nbsp;</div></li><li><div>        $xref = $this-&gt;decodeXrefStream($startxref, $xref);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (empty($xref)) {&nbsp;</div></li><li><div>        $this-&gt;Error('Unable to find xref');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $xref;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Decode the Cross-Reference section&nbsp;</div></li><li><div> * @param $startxref (int) Offset at which the xref section starts (position of the 'xref' keyword).&nbsp;</div></li><li><div> * @param $xref (array) Previous xref array (if any).&nbsp;</div></li><li><div> * @return Array containing xref and trailer data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-20)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function decodeXref($startxref, $xref=array()) {&nbsp;</div></li><li><div>    $startxref += 4; // 4 is the lenght of the word 'xref'&nbsp;</div></li><li><div>    // skip initial white space chars: \x00 null (NUL), \x09 horizontal tab (HT), \x0A line feed (LF), \x0C form feed (FF), \x0D carriage return (CR), \x20 space (SP)&nbsp;</div></li><li><div>    $offset = $startxref + strspn($this-&gt;pdfdata, &quot;\x00\x09\x0a\x0c\x0d\x20&quot;, $startxref);&nbsp;</div></li><li><div>    // initialize object number&nbsp;</div></li><li><div>    $obj_num = 0;&nbsp;</div></li><li><div>    // search for cross-reference entries or subsection&nbsp;</div></li><li><div>    while (preg_match('/([0-9]+)[\x20]([0-9]+)[\x20]?([nf]?)(\r\n|[\x20]?[\r\n])/', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) &gt; 0) {&nbsp;</div></li><li><div>        if ($matches[0][1] != $offset) {&nbsp;</div></li><li><div>            // we are on another section&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $offset += strlen($matches[0][0]);&nbsp;</div></li><li><div>        if ($matches[3][0] == 'n') {&nbsp;</div></li><li><div>            // create unique object index: [object number]_[generation number]&nbsp;</div></li><li><div>            $index = $obj_num.'_'.intval($matches[2][0]);&nbsp;</div></li><li><div>            // check if object already exist&nbsp;</div></li><li><div>            if (!isset($xref['xref'][$index])) {&nbsp;</div></li><li><div>                // store object offset position&nbsp;</div></li><li><div>                $xref['xref'][$index] = intval($matches[1][0]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ++$obj_num;&nbsp;</div></li><li><div>        } elseif ($matches[3][0] == 'f') {&nbsp;</div></li><li><div>            ++$obj_num;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            // object number (index)&nbsp;</div></li><li><div>            $obj_num = intval($matches[1][0]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // get trailer data&nbsp;</div></li><li><div>    if (preg_match('/trailer[\s]*&lt;&lt;(.*)&gt;&gt;/isU', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) &gt; 0) {&nbsp;</div></li><li><div>        $trailer_data = $matches[1][0];&nbsp;</div></li><li><div>        if (!isset($xref['trailer']) OR empty($xref['trailer'])) {&nbsp;</div></li><li><div>            // get only the last updated version&nbsp;</div></li><li><div>            $xref['trailer'] = array();&nbsp;</div></li><li><div>            // parse trailer_data&nbsp;</div></li><li><div>            if (preg_match('/Size[\s]+([0-9]+)/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['size'] = intval($matches[1]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/Root[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['root'] = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/Encrypt[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['encrypt'] = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/Info[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['info'] = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/ID[\s]*[\[][\s]*[&lt;]([^&gt;]*)[&gt;][\s]*[&lt;]([^&gt;]*)[&gt;]/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['id'] = array();&nbsp;</div></li><li><div>                $xref['trailer']['id'][0] = $matches[1];&nbsp;</div></li><li><div>                $xref['trailer']['id'][1] = $matches[2];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (preg_match('/Prev[\s]+([0-9]+)/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>            // get previous xref&nbsp;</div></li><li><div>            $xref = $this-&gt;getXrefData(intval($matches[1]), $xref);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        $this-&gt;Error('Unable to find trailer');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $xref;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Decode the Cross-Reference Stream section&nbsp;</div></li><li><div> * @param $startxref (int) Offset at which the xref section starts.&nbsp;</div></li><li><div> * @param $xref (array) Previous xref array (if any).&nbsp;</div></li><li><div> * @return Array containing xref and trailer data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.003 (2013-03-16)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function decodeXrefStream($startxref, $xref=array()) {&nbsp;</div></li><li><div>    // try to read Cross-Reference Stream&nbsp;</div></li><li><div>    $xrefobj = $this-&gt;getRawObject($startxref);&nbsp;</div></li><li><div>    $xrefcrs = $this-&gt;getIndirectObject($xrefobj[1], $startxref, true);&nbsp;</div></li><li><div>    if (!isset($xref['trailer']) OR empty($xref['trailer'])) {&nbsp;</div></li><li><div>        // get only the last updated version&nbsp;</div></li><li><div>        $xref['trailer'] = array();&nbsp;</div></li><li><div>        $filltrailer = true;&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        $filltrailer = false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (!isset($xref['xref'])) {&nbsp;</div></li><li><div>        $xref['xref'] = array();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    $valid_crs = false;&nbsp;</div></li><li><div>    $columns = 0;&nbsp;</div></li><li><div>    $sarr = $xrefcrs[0][1];&nbsp;</div></li><li><div>    foreach ($sarr as $k =&gt; $v) {&nbsp;</div></li><li><div>        if (($v[0] == '/') AND ($v[1] == 'Type') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == '/') AND ($sarr[($k +1)][1] == 'XRef'))) {&nbsp;</div></li><li><div>            $valid_crs = true;&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'Index') AND (isset($sarr[($k +1)]))) {&nbsp;</div></li><li><div>            // first object number in the subsection&nbsp;</div></li><li><div>            $index_first = intval($sarr[($k +1)][1][0][1]);&nbsp;</div></li><li><div>            // number of entries in the subsection&nbsp;</div></li><li><div>            $index_entries = intval($sarr[($k +1)][1][1][1]);&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'Prev') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>            // get previous xref offset&nbsp;</div></li><li><div>            $prevxref = intval($sarr[($k +1)][1]);&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'W') AND (isset($sarr[($k +1)]))) {&nbsp;</div></li><li><div>            // number of bytes (in the decoded stream) of the corresponding field&nbsp;</div></li><li><div>            $wb = array();&nbsp;</div></li><li><div>            $wb[0] = intval($sarr[($k +1)][1][0][1]);&nbsp;</div></li><li><div>            $wb[1] = intval($sarr[($k +1)][1][1][1]);&nbsp;</div></li><li><div>            $wb[2] = intval($sarr[($k +1)][1][2][1]);&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'DecodeParms') AND (isset($sarr[($k +1)][1]))) {&nbsp;</div></li><li><div>            $decpar = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            foreach ($decpar as $kdc =&gt; $vdc) {&nbsp;</div></li><li><div>                if (($vdc[0] == '/') AND ($vdc[1] == 'Columns') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>                    $columns = intval($decpar[($kdc +1)][1]);&nbsp;</div></li><li><div>                } elseif (($vdc[0] == '/') AND ($vdc[1] == 'Predictor') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>                    $predictor = intval($decpar[($kdc +1)][1]);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } elseif ($filltrailer) {&nbsp;</div></li><li><div>            if (($v[0] == '/') AND ($v[1] == 'Size') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>                $xref['trailer']['size'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'Root') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {&nbsp;</div></li><li><div>                $xref['trailer']['root'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'Info') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {&nbsp;</div></li><li><div>                $xref['trailer']['info'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'Encrypt') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {&nbsp;</div></li><li><div>                $xref['trailer']['encrypt'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'ID') AND (isset($sarr[($k +1)]))) {&nbsp;</div></li><li><div>                $xref['trailer']['id'] = array();&nbsp;</div></li><li><div>                $xref['trailer']['id'][0] = $sarr[($k +1)][1][0][1];&nbsp;</div></li><li><div>                $xref['trailer']['id'][1] = $sarr[($k +1)][1][1][1];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // decode data&nbsp;</div></li><li><div>    if ($valid_crs AND isset($xrefcrs[1][3][0])) {&nbsp;</div></li><li><div>        // number of bytes in a row&nbsp;</div></li><li><div>        $rowlen = ($columns + 1);&nbsp;</div></li><li><div>        // convert the stream into an array of integers&nbsp;</div></li><li><div>        $sdata = unpack('C*', $xrefcrs[1][3][0]);&nbsp;</div></li><li><div>        // split the rows&nbsp;</div></li><li><div>        $sdata = array_chunk($sdata, $rowlen);&nbsp;</div></li><li><div>        // initialize decoded array&nbsp;</div></li><li><div>        $ddata = array();&nbsp;</div></li><li><div>        // initialize first row with zeros&nbsp;</div></li><li><div>        $prev_row = array_fill (0, $rowlen, 0);&nbsp;</div></li><li><div>        // for each row apply PNG unpredictor&nbsp;</div></li><li><div>        foreach ($sdata as $k =&gt; $row) {&nbsp;</div></li><li><div>            // initialize new row&nbsp;</div></li><li><div>            $ddata[$k] = array();&nbsp;</div></li><li><div>            // get PNG predictor value&nbsp;</div></li><li><div>            $predictor = (10 + $row[0]);&nbsp;</div></li><li><div>            // for each byte on the row&nbsp;</div></li><li><div>            for ($i=1; $i&lt;=$columns; ++$i) {&nbsp;</div></li><li><div>                // new index&nbsp;</div></li><li><div>                $j = ($i - 1);&nbsp;</div></li><li><div>                $row_up = $prev_row[$j];&nbsp;</div></li><li><div>                if ($i == 1) {&nbsp;</div></li><li><div>                    $row_left = 0;&nbsp;</div></li><li><div>                    $row_upleft = 0;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $row_left = $row[($i - 1)];&nbsp;</div></li><li><div>                    $row_upleft = $prev_row[($j - 1)];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                switch ($predictor) {&nbsp;</div></li><li><div>                    case 10: { // PNG prediction (on encoding, PNG None on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = $row[$i];&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 11: { // PNG prediction (on encoding, PNG Sub on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 12: { // PNG prediction (on encoding, PNG Up on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 13: { // PNG prediction (on encoding, PNG Average on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = (($row[$i] + (($row_left + $row_up) / 2)) & 0xff);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 14: { // PNG prediction (on encoding, PNG Paeth on all rows)&nbsp;</div></li><li><div>                        // initial estimate&nbsp;</div></li><li><div>                        $p = ($row_left + $row_up - $row_upleft);&nbsp;</div></li><li><div>                        // distances&nbsp;</div></li><li><div>                        $pa = abs($p - $row_left);&nbsp;</div></li><li><div>                        $pb = abs($p - $row_up);&nbsp;</div></li><li><div>                        $pc = abs($p - $row_upleft);&nbsp;</div></li><li><div>                        $pmin = min($pa, $pb, $pc);&nbsp;</div></li><li><div>                        // return minumum distance&nbsp;</div></li><li><div>                        switch ($pmin) {&nbsp;</div></li><li><div>                            case $pa: {&nbsp;</div></li><li><div>                                $ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            case $pb: {&nbsp;</div></li><li><div>                                $ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            case $pc: {&nbsp;</div></li><li><div>                                $ddata[$k][$j] = (($row[$i] + $row_upleft) & 0xff);&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    default: { // PNG prediction (on encoding, PNG optimum)&nbsp;</div></li><li><div>                        $this-&gt;Error('Unknown PNG predictor');&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $prev_row = $ddata[$k];&nbsp;</div></li><li><div>        } // end for each row&nbsp;</div></li><li><div>        // complete decoding&nbsp;</div></li><li><div>        $sdata = array();&nbsp;</div></li><li><div>        // for every row&nbsp;</div></li><li><div>        foreach ($ddata as $k =&gt; $row) {&nbsp;</div></li><li><div>            // initialize new row&nbsp;</div></li><li><div>            $sdata[$k] = array(0, 0, 0);&nbsp;</div></li><li><div>            if ($wb[0] == 0) {&nbsp;</div></li><li><div>                // default type field&nbsp;</div></li><li><div>                $sdata[$k][0] = 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $i = 0; // count bytes in the row&nbsp;</div></li><li><div>            // for every column&nbsp;</div></li><li><div>            for ($c = 0; $c &lt; 3; ++$c) {&nbsp;</div></li><li><div>                // for every byte on the column&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $wb[$c]; ++$b) {&nbsp;</div></li><li><div>                    if (isset($row[$i])) {&nbsp;</div></li><li><div>                        $sdata[$k][$c] += ($row[$i] &lt;&lt; (($wb[$c] - 1 - $b) * 8));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    ++$i;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $ddata = array();&nbsp;</div></li><li><div>        // fill xref&nbsp;</div></li><li><div>        if (isset($index_first)) {&nbsp;</div></li><li><div>            $obj_num = $index_first;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $obj_num = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        foreach ($sdata as $k =&gt; $row) {&nbsp;</div></li><li><div>            switch ($row[0]) {&nbsp;</div></li><li><div>                case 0: { // (f) linked list of free objects&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                case 1: { // (n) objects that are in use but are not compressed&nbsp;</div></li><li><div>                    // create unique object index: [object number]_[generation number]&nbsp;</div></li><li><div>                    $index = $obj_num.'_'.$row[2];&nbsp;</div></li><li><div>                    // check if object already exist&nbsp;</div></li><li><div>                    if (!isset($xref['xref'][$index])) {&nbsp;</div></li><li><div>                        // store object offset position&nbsp;</div></li><li><div>                        $xref['xref'][$index] = $row[1];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                case 2: { // compressed objects&nbsp;</div></li><li><div>                    // $row[1] = object number of the object stream in which this object is stored&nbsp;</div></li><li><div>                    // $row[2] = index of this object within the object stream&nbsp;</div></li><li><div>                    $index = $row[1].'_0_'.$row[2];&nbsp;</div></li><li><div>                    $xref['xref'][$index] = -1;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                default: { // null objects&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ++$obj_num;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    } // end decoding data&nbsp;</div></li><li><div>    if (isset($prevxref)) {&nbsp;</div></li><li><div>        // get previous xref&nbsp;</div></li><li><div>        $xref = $this-&gt;getXrefData($prevxref, $xref);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $xref;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get object type, raw value and offset to next object&nbsp;</div></li><li><div> * @param $offset (int) Object offset.&nbsp;</div></li><li><div> * @return array containing object type, raw value and offset to next object&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-20)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getRawObject($offset=0) {&nbsp;</div></li><li><div>    $objtype = ''; // object type to be returned&nbsp;</div></li><li><div>    $objval = ''; // object value to be returned&nbsp;</div></li><li><div>    // skip initial white space chars: \x00 null (NUL), \x09 horizontal tab (HT), \x0A line feed (LF), \x0C form feed (FF), \x0D carriage return (CR), \x20 space (SP)&nbsp;</div></li><li><div>    $offset += strspn($this-&gt;pdfdata, &quot;\x00\x09\x0a\x0c\x0d\x20&quot;, $offset);&nbsp;</div></li><li><div>    // get first char&nbsp;</div></li><li><div>    $char = $this-&gt;pdfdata[$offset];&nbsp;</div></li><li><div>    // get object type&nbsp;</div></li><li><div>    switch ($char) {&nbsp;</div></li><li><div>        case '%': { // \x25 PERCENT SIGN&nbsp;</div></li><li><div>            // skip comment and search for next token&nbsp;</div></li><li><div>            $next = strcspn($this-&gt;pdfdata, &quot;\r\n&quot;, $offset);&nbsp;</div></li><li><div>            if ($next &gt; 0) {&nbsp;</div></li><li><div>                $offset += $next;&nbsp;</div></li><li><div>                return $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '/': { // \x2F SOLIDUS&nbsp;</div></li><li><div>            // name object&nbsp;</div></li><li><div>            $objtype = $char;&nbsp;</div></li><li><div>            ++$offset;&nbsp;</div></li><li><div>            if (preg_match('/^([^\x00\x09\x0a\x0c\x0d\x20\s\x28\x29\x3c\x3e\x5b\x5d\x7b\x7d\x2f\x25]+)/', substr($this-&gt;pdfdata, $offset, 256), $matches) == 1) {&nbsp;</div></li><li><div>                $objval = $matches[1]; // unescaped value&nbsp;</div></li><li><div>                $offset += strlen($objval);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '(':   // \x28 LEFT PARENTHESIS&nbsp;</div></li><li><div>        case ')': { // \x29 RIGHT PARENTHESIS&nbsp;</div></li><li><div>            // literal string object&nbsp;</div></li><li><div>            $objtype = $char;&nbsp;</div></li><li><div>            ++$offset;&nbsp;</div></li><li><div>            $strpos = $offset;&nbsp;</div></li><li><div>            if ($char == '(') {&nbsp;</div></li><li><div>                $open_bracket = 1;&nbsp;</div></li><li><div>                while ($open_bracket &gt; 0) {&nbsp;</div></li><li><div>                    if (!isset($this-&gt;pdfdata{$strpos})) {&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $ch = $this-&gt;pdfdata{$strpos};&nbsp;</div></li><li><div>                    switch ($ch) {&nbsp;</div></li><li><div>                        case '\\': { // REVERSE SOLIDUS (5Ch) (Backslash)&nbsp;</div></li><li><div>                            // skip next character&nbsp;</div></li><li><div>                            ++$strpos;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        case '(': { // LEFT PARENHESIS (28h)&nbsp;</div></li><li><div>                            ++$open_bracket;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        case ')': { // RIGHT PARENTHESIS (29h)&nbsp;</div></li><li><div>                            --$open_bracket;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    ++$strpos;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $objval = substr($this-&gt;pdfdata, $offset, ($strpos - $offset - 1));&nbsp;</div></li><li><div>                $offset = $strpos;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '[':   // \x5B LEFT SQUARE BRACKET&nbsp;</div></li><li><div>        case ']': { // \x5D RIGHT SQUARE BRACKET&nbsp;</div></li><li><div>            // array object&nbsp;</div></li><li><div>            $objtype = $char;&nbsp;</div></li><li><div>            ++$offset;&nbsp;</div></li><li><div>            if ($char == '[') {&nbsp;</div></li><li><div>                // get array content&nbsp;</div></li><li><div>                $objval = array();&nbsp;</div></li><li><div>                do {&nbsp;</div></li><li><div>                    // get element&nbsp;</div></li><li><div>                    $element = $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>                    $offset = $element[2];&nbsp;</div></li><li><div>                    $objval[] = $element;&nbsp;</div></li><li><div>                } while ($element[0] != ']');&nbsp;</div></li><li><div>                // remove closing delimiter&nbsp;</div></li><li><div>                array_pop($objval);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '&lt;':   // \x3C LESS-THAN SIGN&nbsp;</div></li><li><div>        case '&gt;': { // \x3E GREATER-THAN SIGN&nbsp;</div></li><li><div>            if (isset($this-&gt;pdfdata{($offset + 1)}) AND ($this-&gt;pdfdata{($offset + 1)} == $char)) {&nbsp;</div></li><li><div>                // dictionary object&nbsp;</div></li><li><div>                $objtype = $char.$char;&nbsp;</div></li><li><div>                $offset += 2;&nbsp;</div></li><li><div>                if ($char == '&lt;') {&nbsp;</div></li><li><div>                    // get array content&nbsp;</div></li><li><div>                    $objval = array();&nbsp;</div></li><li><div>                    do {&nbsp;</div></li><li><div>                        // get element&nbsp;</div></li><li><div>                        $element = $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>                        $offset = $element[2];&nbsp;</div></li><li><div>                        $objval[] = $element;&nbsp;</div></li><li><div>                    } while ($element[0] != '&gt;&gt;');&nbsp;</div></li><li><div>                    // remove closing delimiter&nbsp;</div></li><li><div>                    array_pop($objval);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                // hexadecimal string object&nbsp;</div></li><li><div>                $objtype = $char;&nbsp;</div></li><li><div>                ++$offset;&nbsp;</div></li><li><div>                if (($char == '&lt;') AND (preg_match('/^([0-9A-Fa-f\x09\x0a\x0c\x0d\x20]+)&gt;/iU', substr($this-&gt;pdfdata, $offset), $matches) == 1)) {&nbsp;</div></li><li><div>                    // remove white space characters&nbsp;</div></li><li><div>                    $objval = strtr($matches[1], &quot;\x09\x0a\x0c\x0d\x20&quot;, '');&nbsp;</div></li><li><div>                    $offset += strlen($matches[0]);&nbsp;</div></li><li><div>                } elseif (($endpos = strpos($this-&gt;pdfdata, '&gt;', $offset)) !== FALSE) {&nbsp;</div></li><li><div>                    $offset = $endpos + 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        default: {&nbsp;</div></li><li><div>            if (substr($this-&gt;pdfdata, $offset, 6) == 'endobj') {&nbsp;</div></li><li><div>                // indirect object&nbsp;</div></li><li><div>                $objtype = 'endobj';&nbsp;</div></li><li><div>                $offset += 6;&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 4) == 'null') {&nbsp;</div></li><li><div>                // null object&nbsp;</div></li><li><div>                $objtype = 'null';&nbsp;</div></li><li><div>                $offset += 4;&nbsp;</div></li><li><div>                $objval = 'null';&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 4) == 'true') {&nbsp;</div></li><li><div>                // boolean true object&nbsp;</div></li><li><div>                $objtype = 'boolean';&nbsp;</div></li><li><div>                $offset += 4;&nbsp;</div></li><li><div>                $objval = 'true';&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 5) == 'false') {&nbsp;</div></li><li><div>                // boolean false object&nbsp;</div></li><li><div>                $objtype = 'boolean';&nbsp;</div></li><li><div>                $offset += 5;&nbsp;</div></li><li><div>                $objval = 'false';&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 6) == 'stream') {&nbsp;</div></li><li><div>                // start stream object&nbsp;</div></li><li><div>                $objtype = 'stream';&nbsp;</div></li><li><div>                $offset += 6;&nbsp;</div></li><li><div>                if (preg_match('/^([\r]?[\n])/isU', substr($this-&gt;pdfdata, $offset), $matches) == 1) {&nbsp;</div></li><li><div>                    $offset += strlen($matches[0]);&nbsp;</div></li><li><div>                    if (preg_match('/(endstream)[\x09\x0a\x0c\x0d\x20]/isU', substr($this-&gt;pdfdata, $offset), $matches, PREG_OFFSET_CAPTURE) == 1) {&nbsp;</div></li><li><div>                        $objval = substr($this-&gt;pdfdata, $offset, $matches[0][1]);&nbsp;</div></li><li><div>                        $offset += $matches[1][1];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 9) == 'endstream') {&nbsp;</div></li><li><div>                // end stream object&nbsp;</div></li><li><div>                $objtype = 'endstream';&nbsp;</div></li><li><div>                $offset += 9;&nbsp;</div></li><li><div>            } elseif (preg_match('/^([0-9]+)[\s]+([0-9]+)[\s]+R/iU', substr($this-&gt;pdfdata, $offset, 33), $matches) == 1) {&nbsp;</div></li><li><div>                // indirect object reference&nbsp;</div></li><li><div>                $objtype = 'objref';&nbsp;</div></li><li><div>                $offset += strlen($matches[0]);&nbsp;</div></li><li><div>                $objval = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            } elseif (preg_match('/^([0-9]+)[\s]+([0-9]+)[\s]+obj/iU', substr($this-&gt;pdfdata, $offset, 33), $matches) == 1) {&nbsp;</div></li><li><div>                // object start&nbsp;</div></li><li><div>                $objtype = 'obj';&nbsp;</div></li><li><div>                $objval = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>                $offset += strlen ($matches[0]);&nbsp;</div></li><li><div>            } elseif (($numlen = strspn($this-&gt;pdfdata, '+-.0123456789', $offset)) &gt; 0) {&nbsp;</div></li><li><div>                // numeric object&nbsp;</div></li><li><div>                $objtype = 'numeric';&nbsp;</div></li><li><div>                $objval = substr($this-&gt;pdfdata, $offset, $numlen);&nbsp;</div></li><li><div>                $offset += $numlen;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return array($objtype, $objval, $offset);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get content of indirect object.&nbsp;</div></li><li><div> * @param $obj_ref (string) Object number and generation number separated by underscore character.&nbsp;</div></li><li><div> * @param $offset (int) Object offset.&nbsp;</div></li><li><div> * @param $decoding (boolean) If true decode streams.&nbsp;</div></li><li><div> * @return array containing object data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-05-24)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getIndirectObject($obj_ref, $offset=0, $decoding=true) {&nbsp;</div></li><li><div>    $obj = explode('_', $obj_ref);&nbsp;</div></li><li><div>    if (($obj === false) OR (count($obj) != 2)) {&nbsp;</div></li><li><div>        $this-&gt;Error('Invalid object reference: '.$obj);&nbsp;</div></li><li><div>        return;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    $objref = $obj[0].' '.$obj[1].' obj';&nbsp;</div></li><li><div>    // ignore leading zeros&nbsp;</div></li><li><div>    $offset += strspn($this-&gt;pdfdata, '0', $offset);&nbsp;</div></li><li><div>    if (strpos($this-&gt;pdfdata, $objref, $offset) != $offset) {&nbsp;</div></li><li><div>        // an indirect reference to an undefined object shall be considered a reference to the null object&nbsp;</div></li><li><div>        return array('null', 'null', $offset);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // starting position of object content&nbsp;</div></li><li><div>    $offset += strlen($objref);&nbsp;</div></li><li><div>    // get array of object content&nbsp;</div></li><li><div>    $objdata = array();&nbsp;</div></li><li><div>    $i = 0; // object main index&nbsp;</div></li><li><div>    do {&nbsp;</div></li><li><div>        // get element&nbsp;</div></li><li><div>        $element = $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>        $offset = $element[2];&nbsp;</div></li><li><div>        // decode stream using stream's dictionary information&nbsp;</div></li><li><div>        if ($decoding AND ($element[0] == 'stream') AND (isset($objdata[($i - 1)][0])) AND ($objdata[($i - 1)][0] == '&lt;&lt;')) {&nbsp;</div></li><li><div>            $element[3] = $this-&gt;decodeStream($objdata[($i - 1)][1], $element[1]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $objdata[$i] = $element;&nbsp;</div></li><li><div>        ++$i;&nbsp;</div></li><li><div>    } while ($element[0] != 'endobj');&nbsp;</div></li><li><div>    // remove closing delimiter&nbsp;</div></li><li><div>    array_pop($objdata);&nbsp;</div></li><li><div>    // return raw object content&nbsp;</div></li><li><div>    return $objdata;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get the content of object, resolving indect object reference if necessary.&nbsp;</div></li><li><div> * @param $obj (string) Object value.&nbsp;</div></li><li><div> * @return array containing object data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-26)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getObjectVal($obj) {&nbsp;</div></li><li><div>    if ($obj[0] == 'objref') {&nbsp;</div></li><li><div>        // reference to indirect object&nbsp;</div></li><li><div>        if (isset($this-&gt;objects[$obj[1]])) {&nbsp;</div></li><li><div>            // this object has been already parsed&nbsp;</div></li><li><div>            return $this-&gt;objects[$obj[1]];&nbsp;</div></li><li><div>        } elseif (isset($this-&gt;xref[$obj[1]])) {&nbsp;</div></li><li><div>            // parse new object&nbsp;</div></li><li><div>            $this-&gt;objects[$obj[1]] = $this-&gt;getIndirectObject($obj[1], $this-&gt;xref[$obj[1]], false);&nbsp;</div></li><li><div>            return $this-&gt;objects[$obj[1]];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $obj;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Decode the specified stream.&nbsp;</div></li><li><div> * @param $sdic (array) Stream's dictionary array.&nbsp;</div></li><li><div> * @param $stream (string) Stream to decode.&nbsp;</div></li><li><div> * @return array containing decoded stream data and remaining filters.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-22)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function decodeStream($sdic, $stream) {&nbsp;</div></li><li><div>    // get stream lenght and filters&nbsp;</div></li><li><div>    $slength = strlen($stream);&nbsp;</div></li><li><div>    if ($slength &lt;= 0) {&nbsp;</div></li><li><div>        return array('', array());&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    $filters = array();&nbsp;</div></li><li><div>    foreach ($sdic as $k =&gt; $v) {&nbsp;</div></li><li><div>        if ($v[0] == '/') {&nbsp;</div></li><li><div>            if (($v[1] == 'Length') AND (isset($sdic[($k + 1)])) AND ($sdic[($k + 1)][0] == 'numeric')) {&nbsp;</div></li><li><div>                // get declared stream lenght&nbsp;</div></li><li><div>                $declength = intval($sdic[($k + 1)][1]);&nbsp;</div></li><li><div>                if ($declength &lt; $slength) {&nbsp;</div></li><li><div>                    $stream = substr($stream, 0, $declength);&nbsp;</div></li><li><div>                    $slength = $declength;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } elseif (($v[1] == 'Filter') AND (isset($sdic[($k + 1)]))) {&nbsp;</div></li><li><div>                // resolve indirect object&nbsp;</div></li><li><div>                $objval = $this-&gt;getObjectVal($sdic[($k + 1)]);&nbsp;</div></li><li><div>                if ($objval[0] == '/') {&nbsp;</div></li><li><div>                    // single filter&nbsp;</div></li><li><div>                    $filters[] = $objval[1];&nbsp;</div></li><li><div>                } elseif ($objval[0] == '[') {&nbsp;</div></li><li><div>                    // array of filters&nbsp;</div></li><li><div>                    foreach ($objval[1] as $flt) {&nbsp;</div></li><li><div>                        if ($flt[0] == '/') {&nbsp;</div></li><li><div>                            $filters[] = $flt[1];&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // decode the stream&nbsp;</div></li><li><div>    $remaining_filters = array();&nbsp;</div></li><li><div>    foreach ($filters as $filter) {&nbsp;</div></li><li><div>        if (in_array($filter, TCPDF_FILTERS::getAvailableFilters())) {&nbsp;</div></li><li><div>            try {&nbsp;</div></li><li><div>                $stream = TCPDF_FILTERS::decodeFilter($filter, $stream);&nbsp;</div></li><li><div>            } catch (Exception $e) {&nbsp;</div></li><li><div>                $emsg = $e-&gt;getMessage();&nbsp;</div></li><li><div>                if ((($emsg[0] == '~') AND !$this-&gt;cfg['ignore_missing_filter_decoders'])&nbsp;</div></li><li><div>                    OR (($emsg[0] != '~') AND !$this-&gt;cfg['ignore_filter_decoding_errors'])) {&nbsp;</div></li><li><div>                    $this-&gt;Error($e-&gt;getMessage());&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            // add missing filter to array&nbsp;</div></li><li><div>            $remaining_filters[] = $filter;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return array($stream, $remaining_filters);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Throw an exception or print an error message and die if the K_TCPDF_PARSER_THROW_EXCEPTION_ERROR constant is set to true.&nbsp;</div></li><li><div> * @param $msg (string) The error message&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> * @since 3.000 (2011-05-23)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>public function Error($msg) {&nbsp;</div></li><li><div>    if ($this-&gt;cfg['die_for_errors']) {&nbsp;</div></li></ol></pre><pre><ol data-line="47" class="block" start="54"><li><div>/* @class TCPDF_PARSER&nbsp;</div></li><li><div> * This is a PHP class for parsing PDF documents.&lt;br&gt;&nbsp;</div></li><li><div> * @package com.tecnick.tcpdf&nbsp;</div></li><li><div> * @brief This is a PHP class for parsing PDF documents..&nbsp;</div></li><li><div> * @version 3.010&nbsp;</div></li><li><div> * @author Nicola Asuni - info@tecnick.com&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>class TCPDF_PARSER {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Raw content of the PDF document.&nbsp;</div></li><li><div> * @private&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>private $pdfdata = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * XREF data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected $xref = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Array of PDF objects.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected $objects = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Class object for decoding filters.&nbsp;</div></li><li><div> * @private&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>private $FilterDecoders;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Array of configuration parameters.&nbsp;</div></li><li><div> * @private&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>private $cfg = array(&nbsp;</div></li><li><div>    'die_for_errors' =&gt; false, &nbsp;</div></li><li><div>    'ignore_filter_decoding_errors' =&gt; true, &nbsp;</div></li><li><div>    'ignore_missing_filter_decoders' =&gt; true, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// -----------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Parse a PDF document an return an array of objects.&nbsp;</div></li><li><div> * @param $data (string) PDF data to parse.&nbsp;</div></li><li><div> * @param $cfg (array) Array of configuration parameters:&nbsp;</div></li><li><div> *             'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;&nbsp;</div></li><li><div> *             'ignore_filter_decoding_errors' : if true ignore filter decoding errors;&nbsp;</div></li><li><div> *             'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> * @since 3.000 (2011-05-24)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>public function __construct($data, $cfg=array()) {&nbsp;</div></li><li><div>    if (empty($data)) {&nbsp;</div></li><li><div>        $this-&gt;Error('Empty PDF data.');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // find the pdf header starting position&nbsp;</div></li><li><div>    if (($trimpos = strpos($data, '%PDF-')) === FALSE) {&nbsp;</div></li><li><div>        $this-&gt;Error('Invalid PDF data: missing %PDF header.');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // get PDF content string&nbsp;</div></li><li><div>    $this-&gt;pdfdata = substr($data, $trimpos);&nbsp;</div></li><li><div>    // get length&nbsp;</div></li><li><div>    $pdflen = strlen($this-&gt;pdfdata);&nbsp;</div></li><li><div>    // set configuration parameters&nbsp;</div></li><li><div>    $this-&gt;setConfig($cfg);&nbsp;</div></li><li><div>    // get xref and trailer data&nbsp;</div></li><li><div>    $this-&gt;xref = $this-&gt;getXrefData();&nbsp;</div></li><li><div>    // parse all document objects&nbsp;</div></li><li><div>    $this-&gt;objects = array();&nbsp;</div></li><li><div>    foreach ($this-&gt;xref['xref'] as $obj =&gt; $offset) {&nbsp;</div></li><li><div>        if (!isset($this-&gt;objects[$obj]) AND ($offset &gt; 0)) {&nbsp;</div></li><li><div>            // decode objects with positive offset&nbsp;</div></li><li><div>            $this-&gt;objects[$obj] = $this-&gt;getIndirectObject($obj, $offset, true);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // release some memory&nbsp;</div></li><li><div>    unset($this-&gt;pdfdata);&nbsp;</div></li><li><div>    $this-&gt;pdfdata = '';&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Set the configuration parameters.&nbsp;</div></li><li><div> * @param $cfg (array) Array of configuration parameters:&nbsp;</div></li><li><div> *             'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;&nbsp;</div></li><li><div> *             'ignore_filter_decoding_errors' : if true ignore filter decoding errors;&nbsp;</div></li><li><div> *             'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function setConfig($cfg) {&nbsp;</div></li><li><div>    if (isset($cfg['die_for_errors'])) {&nbsp;</div></li><li><div>        $this-&gt;cfg['die_for_errors'] = !!$cfg['die_for_errors'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (isset($cfg['ignore_filter_decoding_errors'])) {&nbsp;</div></li><li><div>        $this-&gt;cfg['ignore_filter_decoding_errors'] = !!$cfg['ignore_filter_decoding_errors'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (isset($cfg['ignore_missing_filter_decoders'])) {&nbsp;</div></li><li><div>        $this-&gt;cfg['ignore_missing_filter_decoders'] = !!$cfg['ignore_missing_filter_decoders'];&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Return an array of parsed PDF document objects.&nbsp;</div></li><li><div> * @return (array) Array of parsed PDF document objects.&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> * @since 3.000 (2011-06-26)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>public function getParsedData() {&nbsp;</div></li><li><div>    return array($this-&gt;xref, $this-&gt;objects);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get Cross-Reference (xref) table and trailer data from PDF document data.&nbsp;</div></li><li><div> * @param $offset (int) xref offset (if know).&nbsp;</div></li><li><div> * @param $xref (array) previous xref array (if any).&nbsp;</div></li><li><div> * @return Array containing xref and trailer data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-05-24)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getXrefData($offset=0, $xref=array()) {&nbsp;</div></li><li><div>    if ($offset == 0) {&nbsp;</div></li><li><div>        // find last startxref&nbsp;</div></li><li><div>        if (preg_match_all('/[\r\n]startxref[\s]*[\r\n]+([0-9]+)[\s]*[\r\n]+%%EOF/i', $this-&gt;pdfdata, $matches, PREG_SET_ORDER, $offset) == 0) {&nbsp;</div></li><li><div>            $this-&gt;Error('Unable to find startxref');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $matches = array_pop($matches);&nbsp;</div></li><li><div>        $startxref = $matches[1];&nbsp;</div></li><li><div>    } elseif (strpos($this-&gt;pdfdata, 'xref', $offset) == $offset) {&nbsp;</div></li><li><div>        // Already pointing at the xref table&nbsp;</div></li><li><div>        $startxref = $offset;&nbsp;</div></li><li><div>    } elseif (preg_match('/([0-9]+[\s][0-9]+[\s]obj)/i', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {&nbsp;</div></li><li><div>        // Cross-Reference Stream object&nbsp;</div></li><li><div>        $startxref = $offset;&nbsp;</div></li><li><div>    } elseif (preg_match('/[\r\n]startxref[\s]*[\r\n]+([0-9]+)[\s]*[\r\n]+%%EOF/i', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {&nbsp;</div></li><li><div>        // startxref found&nbsp;</div></li><li><div>        $startxref = $matches[1][0];&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        $this-&gt;Error('Unable to find startxref');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // check xref position&nbsp;</div></li><li><div>    if (strpos($this-&gt;pdfdata, 'xref', $startxref) == $startxref) {&nbsp;</div></li><li><div>        // Cross-Reference&nbsp;</div></li><li><div>        $xref = $this-&gt;decodeXref($startxref, $xref);&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        // Cross-Reference Stream&nbsp;</div></li><li><div>        $xref = $this-&gt;decodeXrefStream($startxref, $xref);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (empty($xref)) {&nbsp;</div></li><li><div>        $this-&gt;Error('Unable to find xref');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $xref;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Decode the Cross-Reference section&nbsp;</div></li><li><div> * @param $startxref (int) Offset at which the xref section starts (position of the 'xref' keyword).&nbsp;</div></li><li><div> * @param $xref (array) Previous xref array (if any).&nbsp;</div></li><li><div> * @return Array containing xref and trailer data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-20)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function decodeXref($startxref, $xref=array()) {&nbsp;</div></li><li><div>    $startxref += 4; // 4 is the lenght of the word 'xref'&nbsp;</div></li><li><div>    // skip initial white space chars: \x00 null (NUL), \x09 horizontal tab (HT), \x0A line feed (LF), \x0C form feed (FF), \x0D carriage return (CR), \x20 space (SP)&nbsp;</div></li><li><div>    $offset = $startxref + strspn($this-&gt;pdfdata, &quot;\x00\x09\x0a\x0c\x0d\x20&quot;, $startxref);&nbsp;</div></li><li><div>    // initialize object number&nbsp;</div></li><li><div>    $obj_num = 0;&nbsp;</div></li><li><div>    // search for cross-reference entries or subsection&nbsp;</div></li><li><div>    while (preg_match('/([0-9]+)[\x20]([0-9]+)[\x20]?([nf]?)(\r\n|[\x20]?[\r\n])/', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) &gt; 0) {&nbsp;</div></li><li><div>        if ($matches[0][1] != $offset) {&nbsp;</div></li><li><div>            // we are on another section&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $offset += strlen($matches[0][0]);&nbsp;</div></li><li><div>        if ($matches[3][0] == 'n') {&nbsp;</div></li><li><div>            // create unique object index: [object number]_[generation number]&nbsp;</div></li><li><div>            $index = $obj_num.'_'.intval($matches[2][0]);&nbsp;</div></li><li><div>            // check if object already exist&nbsp;</div></li><li><div>            if (!isset($xref['xref'][$index])) {&nbsp;</div></li><li><div>                // store object offset position&nbsp;</div></li><li><div>                $xref['xref'][$index] = intval($matches[1][0]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ++$obj_num;&nbsp;</div></li><li><div>        } elseif ($matches[3][0] == 'f') {&nbsp;</div></li><li><div>            ++$obj_num;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            // object number (index)&nbsp;</div></li><li><div>            $obj_num = intval($matches[1][0]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // get trailer data&nbsp;</div></li><li><div>    if (preg_match('/trailer[\s]*&lt;&lt;(.*)&gt;&gt;/isU', $this-&gt;pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) &gt; 0) {&nbsp;</div></li><li><div>        $trailer_data = $matches[1][0];&nbsp;</div></li><li><div>        if (!isset($xref['trailer']) OR empty($xref['trailer'])) {&nbsp;</div></li><li><div>            // get only the last updated version&nbsp;</div></li><li><div>            $xref['trailer'] = array();&nbsp;</div></li><li><div>            // parse trailer_data&nbsp;</div></li><li><div>            if (preg_match('/Size[\s]+([0-9]+)/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['size'] = intval($matches[1]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/Root[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['root'] = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/Encrypt[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['encrypt'] = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/Info[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['info'] = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('/ID[\s]*[\[][\s]*[&lt;]([^&gt;]*)[&gt;][\s]*[&lt;]([^&gt;]*)[&gt;]/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>                $xref['trailer']['id'] = array();&nbsp;</div></li><li><div>                $xref['trailer']['id'][0] = $matches[1];&nbsp;</div></li><li><div>                $xref['trailer']['id'][1] = $matches[2];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (preg_match('/Prev[\s]+([0-9]+)/i', $trailer_data, $matches) &gt; 0) {&nbsp;</div></li><li><div>            // get previous xref&nbsp;</div></li><li><div>            $xref = $this-&gt;getXrefData(intval($matches[1]), $xref);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        $this-&gt;Error('Unable to find trailer');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $xref;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Decode the Cross-Reference Stream section&nbsp;</div></li><li><div> * @param $startxref (int) Offset at which the xref section starts.&nbsp;</div></li><li><div> * @param $xref (array) Previous xref array (if any).&nbsp;</div></li><li><div> * @return Array containing xref and trailer data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.003 (2013-03-16)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function decodeXrefStream($startxref, $xref=array()) {&nbsp;</div></li><li><div>    // try to read Cross-Reference Stream&nbsp;</div></li><li><div>    $xrefobj = $this-&gt;getRawObject($startxref);&nbsp;</div></li><li><div>    $xrefcrs = $this-&gt;getIndirectObject($xrefobj[1], $startxref, true);&nbsp;</div></li><li><div>    if (!isset($xref['trailer']) OR empty($xref['trailer'])) {&nbsp;</div></li><li><div>        // get only the last updated version&nbsp;</div></li><li><div>        $xref['trailer'] = array();&nbsp;</div></li><li><div>        $filltrailer = true;&nbsp;</div></li><li><div>    } else {&nbsp;</div></li><li><div>        $filltrailer = false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    if (!isset($xref['xref'])) {&nbsp;</div></li><li><div>        $xref['xref'] = array();&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    $valid_crs = false;&nbsp;</div></li><li><div>    $columns = 0;&nbsp;</div></li><li><div>    $sarr = $xrefcrs[0][1];&nbsp;</div></li><li><div>    foreach ($sarr as $k =&gt; $v) {&nbsp;</div></li><li><div>        if (($v[0] == '/') AND ($v[1] == 'Type') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == '/') AND ($sarr[($k +1)][1] == 'XRef'))) {&nbsp;</div></li><li><div>            $valid_crs = true;&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'Index') AND (isset($sarr[($k +1)]))) {&nbsp;</div></li><li><div>            // first object number in the subsection&nbsp;</div></li><li><div>            $index_first = intval($sarr[($k +1)][1][0][1]);&nbsp;</div></li><li><div>            // number of entries in the subsection&nbsp;</div></li><li><div>            $index_entries = intval($sarr[($k +1)][1][1][1]);&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'Prev') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>            // get previous xref offset&nbsp;</div></li><li><div>            $prevxref = intval($sarr[($k +1)][1]);&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'W') AND (isset($sarr[($k +1)]))) {&nbsp;</div></li><li><div>            // number of bytes (in the decoded stream) of the corresponding field&nbsp;</div></li><li><div>            $wb = array();&nbsp;</div></li><li><div>            $wb[0] = intval($sarr[($k +1)][1][0][1]);&nbsp;</div></li><li><div>            $wb[1] = intval($sarr[($k +1)][1][1][1]);&nbsp;</div></li><li><div>            $wb[2] = intval($sarr[($k +1)][1][2][1]);&nbsp;</div></li><li><div>        } elseif (($v[0] == '/') AND ($v[1] == 'DecodeParms') AND (isset($sarr[($k +1)][1]))) {&nbsp;</div></li><li><div>            $decpar = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            foreach ($decpar as $kdc =&gt; $vdc) {&nbsp;</div></li><li><div>                if (($vdc[0] == '/') AND ($vdc[1] == 'Columns') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>                    $columns = intval($decpar[($kdc +1)][1]);&nbsp;</div></li><li><div>                } elseif (($vdc[0] == '/') AND ($vdc[1] == 'Predictor') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>                    $predictor = intval($decpar[($kdc +1)][1]);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } elseif ($filltrailer) {&nbsp;</div></li><li><div>            if (($v[0] == '/') AND ($v[1] == 'Size') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {&nbsp;</div></li><li><div>                $xref['trailer']['size'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'Root') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {&nbsp;</div></li><li><div>                $xref['trailer']['root'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'Info') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {&nbsp;</div></li><li><div>                $xref['trailer']['info'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'Encrypt') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {&nbsp;</div></li><li><div>                $xref['trailer']['encrypt'] = $sarr[($k +1)][1];&nbsp;</div></li><li><div>            } elseif (($v[0] == '/') AND ($v[1] == 'ID') AND (isset($sarr[($k +1)]))) {&nbsp;</div></li><li><div>                $xref['trailer']['id'] = array();&nbsp;</div></li><li><div>                $xref['trailer']['id'][0] = $sarr[($k +1)][1][0][1];&nbsp;</div></li><li><div>                $xref['trailer']['id'][1] = $sarr[($k +1)][1][1][1];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // decode data&nbsp;</div></li><li><div>    if ($valid_crs AND isset($xrefcrs[1][3][0])) {&nbsp;</div></li><li><div>        // number of bytes in a row&nbsp;</div></li><li><div>        $rowlen = ($columns + 1);&nbsp;</div></li><li><div>        // convert the stream into an array of integers&nbsp;</div></li><li><div>        $sdata = unpack('C*', $xrefcrs[1][3][0]);&nbsp;</div></li><li><div>        // split the rows&nbsp;</div></li><li><div>        $sdata = array_chunk($sdata, $rowlen);&nbsp;</div></li><li><div>        // initialize decoded array&nbsp;</div></li><li><div>        $ddata = array();&nbsp;</div></li><li><div>        // initialize first row with zeros&nbsp;</div></li><li><div>        $prev_row = array_fill (0, $rowlen, 0);&nbsp;</div></li><li><div>        // for each row apply PNG unpredictor&nbsp;</div></li><li><div>        foreach ($sdata as $k =&gt; $row) {&nbsp;</div></li><li><div>            // initialize new row&nbsp;</div></li><li><div>            $ddata[$k] = array();&nbsp;</div></li><li><div>            // get PNG predictor value&nbsp;</div></li><li><div>            $predictor = (10 + $row[0]);&nbsp;</div></li><li><div>            // for each byte on the row&nbsp;</div></li><li><div>            for ($i=1; $i&lt;=$columns; ++$i) {&nbsp;</div></li><li><div>                // new index&nbsp;</div></li><li><div>                $j = ($i - 1);&nbsp;</div></li><li><div>                $row_up = $prev_row[$j];&nbsp;</div></li><li><div>                if ($i == 1) {&nbsp;</div></li><li><div>                    $row_left = 0;&nbsp;</div></li><li><div>                    $row_upleft = 0;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    $row_left = $row[($i - 1)];&nbsp;</div></li><li><div>                    $row_upleft = $prev_row[($j - 1)];&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                switch ($predictor) {&nbsp;</div></li><li><div>                    case 10: { // PNG prediction (on encoding, PNG None on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = $row[$i];&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 11: { // PNG prediction (on encoding, PNG Sub on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 12: { // PNG prediction (on encoding, PNG Up on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 13: { // PNG prediction (on encoding, PNG Average on all rows)&nbsp;</div></li><li><div>                        $ddata[$k][$j] = (($row[$i] + (($row_left + $row_up) / 2)) & 0xff);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    case 14: { // PNG prediction (on encoding, PNG Paeth on all rows)&nbsp;</div></li><li><div>                        // initial estimate&nbsp;</div></li><li><div>                        $p = ($row_left + $row_up - $row_upleft);&nbsp;</div></li><li><div>                        // distances&nbsp;</div></li><li><div>                        $pa = abs($p - $row_left);&nbsp;</div></li><li><div>                        $pb = abs($p - $row_up);&nbsp;</div></li><li><div>                        $pc = abs($p - $row_upleft);&nbsp;</div></li><li><div>                        $pmin = min($pa, $pb, $pc);&nbsp;</div></li><li><div>                        // return minumum distance&nbsp;</div></li><li><div>                        switch ($pmin) {&nbsp;</div></li><li><div>                            case $pa: {&nbsp;</div></li><li><div>                                $ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            case $pb: {&nbsp;</div></li><li><div>                                $ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            case $pc: {&nbsp;</div></li><li><div>                                $ddata[$k][$j] = (($row[$i] + $row_upleft) & 0xff);&nbsp;</div></li><li><div>                                break;&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    default: { // PNG prediction (on encoding, PNG optimum)&nbsp;</div></li><li><div>                        $this-&gt;Error('Unknown PNG predictor');&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $prev_row = $ddata[$k];&nbsp;</div></li><li><div>        } // end for each row&nbsp;</div></li><li><div>        // complete decoding&nbsp;</div></li><li><div>        $sdata = array();&nbsp;</div></li><li><div>        // for every row&nbsp;</div></li><li><div>        foreach ($ddata as $k =&gt; $row) {&nbsp;</div></li><li><div>            // initialize new row&nbsp;</div></li><li><div>            $sdata[$k] = array(0, 0, 0);&nbsp;</div></li><li><div>            if ($wb[0] == 0) {&nbsp;</div></li><li><div>                // default type field&nbsp;</div></li><li><div>                $sdata[$k][0] = 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $i = 0; // count bytes in the row&nbsp;</div></li><li><div>            // for every column&nbsp;</div></li><li><div>            for ($c = 0; $c &lt; 3; ++$c) {&nbsp;</div></li><li><div>                // for every byte on the column&nbsp;</div></li><li><div>                for ($b = 0; $b &lt; $wb[$c]; ++$b) {&nbsp;</div></li><li><div>                    if (isset($row[$i])) {&nbsp;</div></li><li><div>                        $sdata[$k][$c] += ($row[$i] &lt;&lt; (($wb[$c] - 1 - $b) * 8));&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    ++$i;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $ddata = array();&nbsp;</div></li><li><div>        // fill xref&nbsp;</div></li><li><div>        if (isset($index_first)) {&nbsp;</div></li><li><div>            $obj_num = $index_first;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $obj_num = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        foreach ($sdata as $k =&gt; $row) {&nbsp;</div></li><li><div>            switch ($row[0]) {&nbsp;</div></li><li><div>                case 0: { // (f) linked list of free objects&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                case 1: { // (n) objects that are in use but are not compressed&nbsp;</div></li><li><div>                    // create unique object index: [object number]_[generation number]&nbsp;</div></li><li><div>                    $index = $obj_num.'_'.$row[2];&nbsp;</div></li><li><div>                    // check if object already exist&nbsp;</div></li><li><div>                    if (!isset($xref['xref'][$index])) {&nbsp;</div></li><li><div>                        // store object offset position&nbsp;</div></li><li><div>                        $xref['xref'][$index] = $row[1];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                case 2: { // compressed objects&nbsp;</div></li><li><div>                    // $row[1] = object number of the object stream in which this object is stored&nbsp;</div></li><li><div>                    // $row[2] = index of this object within the object stream&nbsp;</div></li><li><div>                    $index = $row[1].'_0_'.$row[2];&nbsp;</div></li><li><div>                    $xref['xref'][$index] = -1;&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                default: { // null objects&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            ++$obj_num;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    } // end decoding data&nbsp;</div></li><li><div>    if (isset($prevxref)) {&nbsp;</div></li><li><div>        // get previous xref&nbsp;</div></li><li><div>        $xref = $this-&gt;getXrefData($prevxref, $xref);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $xref;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get object type, raw value and offset to next object&nbsp;</div></li><li><div> * @param $offset (int) Object offset.&nbsp;</div></li><li><div> * @return array containing object type, raw value and offset to next object&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-20)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getRawObject($offset=0) {&nbsp;</div></li><li><div>    $objtype = ''; // object type to be returned&nbsp;</div></li><li><div>    $objval = ''; // object value to be returned&nbsp;</div></li><li><div>    // skip initial white space chars: \x00 null (NUL), \x09 horizontal tab (HT), \x0A line feed (LF), \x0C form feed (FF), \x0D carriage return (CR), \x20 space (SP)&nbsp;</div></li><li><div>    $offset += strspn($this-&gt;pdfdata, &quot;\x00\x09\x0a\x0c\x0d\x20&quot;, $offset);&nbsp;</div></li><li><div>    // get first char&nbsp;</div></li><li><div>    $char = $this-&gt;pdfdata[$offset];&nbsp;</div></li><li><div>    // get object type&nbsp;</div></li><li><div>    switch ($char) {&nbsp;</div></li><li><div>        case '%': { // \x25 PERCENT SIGN&nbsp;</div></li><li><div>            // skip comment and search for next token&nbsp;</div></li><li><div>            $next = strcspn($this-&gt;pdfdata, &quot;\r\n&quot;, $offset);&nbsp;</div></li><li><div>            if ($next &gt; 0) {&nbsp;</div></li><li><div>                $offset += $next;&nbsp;</div></li><li><div>                return $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '/': { // \x2F SOLIDUS&nbsp;</div></li><li><div>            // name object&nbsp;</div></li><li><div>            $objtype = $char;&nbsp;</div></li><li><div>            ++$offset;&nbsp;</div></li><li><div>            if (preg_match('/^([^\x00\x09\x0a\x0c\x0d\x20\s\x28\x29\x3c\x3e\x5b\x5d\x7b\x7d\x2f\x25]+)/', substr($this-&gt;pdfdata, $offset, 256), $matches) == 1) {&nbsp;</div></li><li><div>                $objval = $matches[1]; // unescaped value&nbsp;</div></li><li><div>                $offset += strlen($objval);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '(':   // \x28 LEFT PARENTHESIS&nbsp;</div></li><li><div>        case ')': { // \x29 RIGHT PARENTHESIS&nbsp;</div></li><li><div>            // literal string object&nbsp;</div></li><li><div>            $objtype = $char;&nbsp;</div></li><li><div>            ++$offset;&nbsp;</div></li><li><div>            $strpos = $offset;&nbsp;</div></li><li><div>            if ($char == '(') {&nbsp;</div></li><li><div>                $open_bracket = 1;&nbsp;</div></li><li><div>                while ($open_bracket &gt; 0) {&nbsp;</div></li><li><div>                    if (!isset($this-&gt;pdfdata{$strpos})) {&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    $ch = $this-&gt;pdfdata{$strpos};&nbsp;</div></li><li><div>                    switch ($ch) {&nbsp;</div></li><li><div>                        case '\\': { // REVERSE SOLIDUS (5Ch) (Backslash)&nbsp;</div></li><li><div>                            // skip next character&nbsp;</div></li><li><div>                            ++$strpos;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        case '(': { // LEFT PARENHESIS (28h)&nbsp;</div></li><li><div>                            ++$open_bracket;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        case ')': { // RIGHT PARENTHESIS (29h)&nbsp;</div></li><li><div>                            --$open_bracket;&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    ++$strpos;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $objval = substr($this-&gt;pdfdata, $offset, ($strpos - $offset - 1));&nbsp;</div></li><li><div>                $offset = $strpos;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '[':   // \x5B LEFT SQUARE BRACKET&nbsp;</div></li><li><div>        case ']': { // \x5D RIGHT SQUARE BRACKET&nbsp;</div></li><li><div>            // array object&nbsp;</div></li><li><div>            $objtype = $char;&nbsp;</div></li><li><div>            ++$offset;&nbsp;</div></li><li><div>            if ($char == '[') {&nbsp;</div></li><li><div>                // get array content&nbsp;</div></li><li><div>                $objval = array();&nbsp;</div></li><li><div>                do {&nbsp;</div></li><li><div>                    // get element&nbsp;</div></li><li><div>                    $element = $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>                    $offset = $element[2];&nbsp;</div></li><li><div>                    $objval[] = $element;&nbsp;</div></li><li><div>                } while ($element[0] != ']');&nbsp;</div></li><li><div>                // remove closing delimiter&nbsp;</div></li><li><div>                array_pop($objval);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        case '&lt;':   // \x3C LESS-THAN SIGN&nbsp;</div></li><li><div>        case '&gt;': { // \x3E GREATER-THAN SIGN&nbsp;</div></li><li><div>            if (isset($this-&gt;pdfdata{($offset + 1)}) AND ($this-&gt;pdfdata{($offset + 1)} == $char)) {&nbsp;</div></li><li><div>                // dictionary object&nbsp;</div></li><li><div>                $objtype = $char.$char;&nbsp;</div></li><li><div>                $offset += 2;&nbsp;</div></li><li><div>                if ($char == '&lt;') {&nbsp;</div></li><li><div>                    // get array content&nbsp;</div></li><li><div>                    $objval = array();&nbsp;</div></li><li><div>                    do {&nbsp;</div></li><li><div>                        // get element&nbsp;</div></li><li><div>                        $element = $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>                        $offset = $element[2];&nbsp;</div></li><li><div>                        $objval[] = $element;&nbsp;</div></li><li><div>                    } while ($element[0] != '&gt;&gt;');&nbsp;</div></li><li><div>                    // remove closing delimiter&nbsp;</div></li><li><div>                    array_pop($objval);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                // hexadecimal string object&nbsp;</div></li><li><div>                $objtype = $char;&nbsp;</div></li><li><div>                ++$offset;&nbsp;</div></li><li><div>                if (($char == '&lt;') AND (preg_match('/^([0-9A-Fa-f\x09\x0a\x0c\x0d\x20]+)&gt;/iU', substr($this-&gt;pdfdata, $offset), $matches) == 1)) {&nbsp;</div></li><li><div>                    // remove white space characters&nbsp;</div></li><li><div>                    $objval = strtr($matches[1], &quot;\x09\x0a\x0c\x0d\x20&quot;, '');&nbsp;</div></li><li><div>                    $offset += strlen($matches[0]);&nbsp;</div></li><li><div>                } elseif (($endpos = strpos($this-&gt;pdfdata, '&gt;', $offset)) !== FALSE) {&nbsp;</div></li><li><div>                    $offset = $endpos + 1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        default: {&nbsp;</div></li><li><div>            if (substr($this-&gt;pdfdata, $offset, 6) == 'endobj') {&nbsp;</div></li><li><div>                // indirect object&nbsp;</div></li><li><div>                $objtype = 'endobj';&nbsp;</div></li><li><div>                $offset += 6;&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 4) == 'null') {&nbsp;</div></li><li><div>                // null object&nbsp;</div></li><li><div>                $objtype = 'null';&nbsp;</div></li><li><div>                $offset += 4;&nbsp;</div></li><li><div>                $objval = 'null';&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 4) == 'true') {&nbsp;</div></li><li><div>                // boolean true object&nbsp;</div></li><li><div>                $objtype = 'boolean';&nbsp;</div></li><li><div>                $offset += 4;&nbsp;</div></li><li><div>                $objval = 'true';&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 5) == 'false') {&nbsp;</div></li><li><div>                // boolean false object&nbsp;</div></li><li><div>                $objtype = 'boolean';&nbsp;</div></li><li><div>                $offset += 5;&nbsp;</div></li><li><div>                $objval = 'false';&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 6) == 'stream') {&nbsp;</div></li><li><div>                // start stream object&nbsp;</div></li><li><div>                $objtype = 'stream';&nbsp;</div></li><li><div>                $offset += 6;&nbsp;</div></li><li><div>                if (preg_match('/^([\r]?[\n])/isU', substr($this-&gt;pdfdata, $offset), $matches) == 1) {&nbsp;</div></li><li><div>                    $offset += strlen($matches[0]);&nbsp;</div></li><li><div>                    if (preg_match('/(endstream)[\x09\x0a\x0c\x0d\x20]/isU', substr($this-&gt;pdfdata, $offset), $matches, PREG_OFFSET_CAPTURE) == 1) {&nbsp;</div></li><li><div>                        $objval = substr($this-&gt;pdfdata, $offset, $matches[0][1]);&nbsp;</div></li><li><div>                        $offset += $matches[1][1];&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } elseif (substr($this-&gt;pdfdata, $offset, 9) == 'endstream') {&nbsp;</div></li><li><div>                // end stream object&nbsp;</div></li><li><div>                $objtype = 'endstream';&nbsp;</div></li><li><div>                $offset += 9;&nbsp;</div></li><li><div>            } elseif (preg_match('/^([0-9]+)[\s]+([0-9]+)[\s]+R/iU', substr($this-&gt;pdfdata, $offset, 33), $matches) == 1) {&nbsp;</div></li><li><div>                // indirect object reference&nbsp;</div></li><li><div>                $objtype = 'objref';&nbsp;</div></li><li><div>                $offset += strlen($matches[0]);&nbsp;</div></li><li><div>                $objval = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>            } elseif (preg_match('/^([0-9]+)[\s]+([0-9]+)[\s]+obj/iU', substr($this-&gt;pdfdata, $offset, 33), $matches) == 1) {&nbsp;</div></li><li><div>                // object start&nbsp;</div></li><li><div>                $objtype = 'obj';&nbsp;</div></li><li><div>                $objval = intval($matches[1]).'_'.intval($matches[2]);&nbsp;</div></li><li><div>                $offset += strlen ($matches[0]);&nbsp;</div></li><li><div>            } elseif (($numlen = strspn($this-&gt;pdfdata, '+-.0123456789', $offset)) &gt; 0) {&nbsp;</div></li><li><div>                // numeric object&nbsp;</div></li><li><div>                $objtype = 'numeric';&nbsp;</div></li><li><div>                $objval = substr($this-&gt;pdfdata, $offset, $numlen);&nbsp;</div></li><li><div>                $offset += $numlen;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return array($objtype, $objval, $offset);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get content of indirect object.&nbsp;</div></li><li><div> * @param $obj_ref (string) Object number and generation number separated by underscore character.&nbsp;</div></li><li><div> * @param $offset (int) Object offset.&nbsp;</div></li><li><div> * @param $decoding (boolean) If true decode streams.&nbsp;</div></li><li><div> * @return array containing object data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-05-24)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getIndirectObject($obj_ref, $offset=0, $decoding=true) {&nbsp;</div></li><li><div>    $obj = explode('_', $obj_ref);&nbsp;</div></li><li><div>    if (($obj === false) OR (count($obj) != 2)) {&nbsp;</div></li><li><div>        $this-&gt;Error('Invalid object reference: '.$obj);&nbsp;</div></li><li><div>        return;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    $objref = $obj[0].' '.$obj[1].' obj';&nbsp;</div></li><li><div>    // ignore leading zeros&nbsp;</div></li><li><div>    $offset += strspn($this-&gt;pdfdata, '0', $offset);&nbsp;</div></li><li><div>    if (strpos($this-&gt;pdfdata, $objref, $offset) != $offset) {&nbsp;</div></li><li><div>        // an indirect reference to an undefined object shall be considered a reference to the null object&nbsp;</div></li><li><div>        return array('null', 'null', $offset);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // starting position of object content&nbsp;</div></li><li><div>    $offset += strlen($objref);&nbsp;</div></li><li><div>    // get array of object content&nbsp;</div></li><li><div>    $objdata = array();&nbsp;</div></li><li><div>    $i = 0; // object main index&nbsp;</div></li><li><div>    do {&nbsp;</div></li><li><div>        // get element&nbsp;</div></li><li><div>        $element = $this-&gt;getRawObject($offset);&nbsp;</div></li><li><div>        $offset = $element[2];&nbsp;</div></li><li><div>        // decode stream using stream's dictionary information&nbsp;</div></li><li><div>        if ($decoding AND ($element[0] == 'stream') AND (isset($objdata[($i - 1)][0])) AND ($objdata[($i - 1)][0] == '&lt;&lt;')) {&nbsp;</div></li><li><div>            $element[3] = $this-&gt;decodeStream($objdata[($i - 1)][1], $element[1]);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $objdata[$i] = $element;&nbsp;</div></li><li><div>        ++$i;&nbsp;</div></li><li><div>    } while ($element[0] != 'endobj');&nbsp;</div></li><li><div>    // remove closing delimiter&nbsp;</div></li><li><div>    array_pop($objdata);&nbsp;</div></li><li><div>    // return raw object content&nbsp;</div></li><li><div>    return $objdata;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Get the content of object, resolving indect object reference if necessary.&nbsp;</div></li><li><div> * @param $obj (string) Object value.&nbsp;</div></li><li><div> * @return array containing object data.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-26)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function getObjectVal($obj) {&nbsp;</div></li><li><div>    if ($obj[0] == 'objref') {&nbsp;</div></li><li><div>        // reference to indirect object&nbsp;</div></li><li><div>        if (isset($this-&gt;objects[$obj[1]])) {&nbsp;</div></li><li><div>            // this object has been already parsed&nbsp;</div></li><li><div>            return $this-&gt;objects[$obj[1]];&nbsp;</div></li><li><div>        } elseif (isset($this-&gt;xref[$obj[1]])) {&nbsp;</div></li><li><div>            // parse new object&nbsp;</div></li><li><div>            $this-&gt;objects[$obj[1]] = $this-&gt;getIndirectObject($obj[1], $this-&gt;xref[$obj[1]], false);&nbsp;</div></li><li><div>            return $this-&gt;objects[$obj[1]];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return $obj;&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Decode the specified stream.&nbsp;</div></li><li><div> * @param $sdic (array) Stream's dictionary array.&nbsp;</div></li><li><div> * @param $stream (string) Stream to decode.&nbsp;</div></li><li><div> * @return array containing decoded stream data and remaining filters.&nbsp;</div></li><li><div> * @protected&nbsp;</div></li><li><div> * @since 3.000 (2011-06-22)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>protected function decodeStream($sdic, $stream) {&nbsp;</div></li><li><div>    // get stream lenght and filters&nbsp;</div></li><li><div>    $slength = strlen($stream);&nbsp;</div></li><li><div>    if ($slength &lt;= 0) {&nbsp;</div></li><li><div>        return array('', array());&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    $filters = array();&nbsp;</div></li><li><div>    foreach ($sdic as $k =&gt; $v) {&nbsp;</div></li><li><div>        if ($v[0] == '/') {&nbsp;</div></li><li><div>            if (($v[1] == 'Length') AND (isset($sdic[($k + 1)])) AND ($sdic[($k + 1)][0] == 'numeric')) {&nbsp;</div></li><li><div>                // get declared stream lenght&nbsp;</div></li><li><div>                $declength = intval($sdic[($k + 1)][1]);&nbsp;</div></li><li><div>                if ($declength &lt; $slength) {&nbsp;</div></li><li><div>                    $stream = substr($stream, 0, $declength);&nbsp;</div></li><li><div>                    $slength = $declength;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } elseif (($v[1] == 'Filter') AND (isset($sdic[($k + 1)]))) {&nbsp;</div></li><li><div>                // resolve indirect object&nbsp;</div></li><li><div>                $objval = $this-&gt;getObjectVal($sdic[($k + 1)]);&nbsp;</div></li><li><div>                if ($objval[0] == '/') {&nbsp;</div></li><li><div>                    // single filter&nbsp;</div></li><li><div>                    $filters[] = $objval[1];&nbsp;</div></li><li><div>                } elseif ($objval[0] == '[') {&nbsp;</div></li><li><div>                    // array of filters&nbsp;</div></li><li><div>                    foreach ($objval[1] as $flt) {&nbsp;</div></li><li><div>                        if ($flt[0] == '/') {&nbsp;</div></li><li><div>                            $filters[] = $flt[1];&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    // decode the stream&nbsp;</div></li><li><div>    $remaining_filters = array();&nbsp;</div></li><li><div>    foreach ($filters as $filter) {&nbsp;</div></li><li><div>        if (in_array($filter, TCPDF_FILTERS::getAvailableFilters())) {&nbsp;</div></li><li><div>            try {&nbsp;</div></li><li><div>                $stream = TCPDF_FILTERS::decodeFilter($filter, $stream);&nbsp;</div></li><li><div>            } catch (Exception $e) {&nbsp;</div></li><li><div>                $emsg = $e-&gt;getMessage();&nbsp;</div></li><li><div>                if ((($emsg[0] == '~') AND !$this-&gt;cfg['ignore_missing_filter_decoders'])&nbsp;</div></li><li><div>                    OR (($emsg[0] != '~') AND !$this-&gt;cfg['ignore_filter_decoding_errors'])) {&nbsp;</div></li><li><div>                    $this-&gt;Error($e-&gt;getMessage());&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            // add missing filter to array&nbsp;</div></li><li><div>            $remaining_filters[] = $filter;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>    return array($stream, $remaining_filters);&nbsp;</div></li><li><div>}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>/**&nbsp;</div></li><li><div> * Throw an exception or print an error message and die if the K_TCPDF_PARSER_THROW_EXCEPTION_ERROR constant is set to true.&nbsp;</div></li><li><div> * @param $msg (string) The error message&nbsp;</div></li><li><div> * @public&nbsp;</div></li><li><div> * @since 3.000 (2011-05-23)&nbsp;</div></li><li><div> */&nbsp;</div></li><li><div>public function Error($msg) {&nbsp;</div></li><li><div>    if ($this-&gt;cfg['die_for_errors']) {&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 2.0</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/classes/tcpdf_parser/" class="active">2.3</a></li><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.2/classes/tcpdf_parser/" class="">2.2</a></li><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.1/classes/tcpdf_parser/" class="">2.1</a></li><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.0/classes/tcpdf_parser/" class="">2.0</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>TCPDF_PARSER</li><li><span></span>Woocommerce Products Designer</li><li><span></span>2.3</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>