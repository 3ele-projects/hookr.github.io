<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="plugin" data-version="2.3" data-slug="woocommerce-products-designer" data-type="class" data-id="58488"><head xmlns="http://www.w3.org/1999/xhtml"><title> datamatrix | class | Woocommerce Products Designer | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="Datamatrix, class, plugin, woocommerce-products-designer, 2.3" /><meta name="description" content="The Woocommerce Products Designer Datamatrix class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.16"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=386c989fb2262e92cb7888eea9a56551' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.16' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/datamatrix/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fdatamatrix%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fdatamatrix%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"plugin-woocommerce-products-designer-2.3-class-datamatrix","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="datamatrix" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to plugins." href="http://hookr.io/plugins/" class=""><span property="name">plugins</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to woocommerce-products-designer." href="http://hookr.io/plugins/woocommerce-products-designer/" class="plugin"><span property="name">woocommerce-products-designer</span></a><meta property="position" content="3"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 2.3." href="http://hookr.io/plugins/woocommerce-products-designer/2.3/" class="H_VERSION"><span property="name">2.3</span></a><meta property="position" content="4"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/plugins/woocommerce-products-designer/2.3/classes/" class=""><span property="name">classes</span></a><meta property="position" content="5"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">datamatrix</span><meta property="position" content="6"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="208"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/all/" title="All">All <span class="count badge">208</span></a></li><li class="" data-id="new" data-count="0"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/new/" title="New">New <span class="count badge">0</span></a></li><li class="" data-id="hooks" data-count="8"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/hooks/" title="Hooks">Hooks <span class="count badge">8</span></a></li><li class="" data-id="action" data-count="8"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/actions/" title="Actions">Actions <span class="count badge">8</span></a></li><li class="" data-id="filter" data-count="0"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/filters/" title="Filters">Filters <span class="count badge">0</span></a></li><li class="active" data-id="class" data-count="52"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/classes/" title="Classes">Classes <span class="count badge">52</span></a></li><li class="" data-id="constant" data-count="120"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/constants/" title="Constants">Constants <span class="count badge">120</span></a></li><li class="" data-id="function" data-count="22"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/functions/" title="Functions">Functions <span class="count badge">22</span></a></li><li class="" data-id="shortcode" data-count="6"><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">6</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class=""><a href="http://hookr.io/all/" title="Core">Core</a></li><li class="active"><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>Datamatrix</strong></h1><p>The Woocommerce Products Designer <strong>Datamatrix</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(2)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/files/includes-tcpdf-include-barcodes-datamatrix/" class="file">/includes/tcpdf/include/barcodes/datamatrix.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="51" class="block" start="110"><li><div> @class Datamatrix&nbsp;</div></li><li><div>* Class to create DataMatrix ECC 200 barcode arrays for TCPDF class.&nbsp;</div></li><li><div>* DataMatrix (ISO/IEC 16022:2006) is a 2-dimensional bar code.&nbsp;</div></li><li><div>*&nbsp;</div></li><li><div>* @package com.tecnick.tcpdf&nbsp;</div></li><li><div>* @author Nicola Asuni&nbsp;</div></li><li><div>* @version 3.004&nbsp;</div></li><li><div>*/&nbsp;</div></li><li><div>class Datamatrix {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Barcode array to be returned which is readable by TCPDF.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $barcode_array = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Store last used encoding for data codewords.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $last_enc = ENC_ASCII;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Table of Data Matrix ECC 200 Symbol Attributes:&lt;ul&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix rows (including finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix cols (including finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix rows (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix cols (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data rows (with finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data col (with finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data rows (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data col (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;horizontal regions&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;vertical regions&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;regions&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;data codewords&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;error codewords&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;blocks&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;data codewords per block&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;error codewords per block&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;/ul&gt;&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $symbattr = array(&nbsp;</div></li><li><div>      // square form ---------------------------------------------------------------------------------------&nbsp;</div></li><li><div>      array(0x00a, 0x00a, 0x008, 0x008, 0x00a, 0x00a, 0x008, 0x008, 0x001, 0x001, 0x001, 0x003, 0x005, 0x001, 0x003, 0x005), // 10x10&nbsp;</div></li><li><div>      array(0x00c, 0x00c, 0x00a, 0x00a, 0x00c, 0x00c, 0x00a, 0x00a, 0x001, 0x001, 0x001, 0x005, 0x007, 0x001, 0x005, 0x007), // 12x12&nbsp;</div></li><li><div>      array(0x00e, 0x00e, 0x00c, 0x00c, 0x00e, 0x00e, 0x00c, 0x00c, 0x001, 0x001, 0x001, 0x008, 0x00a, 0x001, 0x008, 0x00a), // 14x14&nbsp;</div></li><li><div>      array(0x010, 0x010, 0x00e, 0x00e, 0x010, 0x010, 0x00e, 0x00e, 0x001, 0x001, 0x001, 0x00c, 0x00c, 0x001, 0x00c, 0x00c), // 16x16&nbsp;</div></li><li><div>      array(0x012, 0x012, 0x010, 0x010, 0x012, 0x012, 0x010, 0x010, 0x001, 0x001, 0x001, 0x012, 0x00e, 0x001, 0x012, 0x00e), // 18x18&nbsp;</div></li><li><div>      array(0x014, 0x014, 0x012, 0x012, 0x014, 0x014, 0x012, 0x012, 0x001, 0x001, 0x001, 0x016, 0x012, 0x001, 0x016, 0x012), // 20x20&nbsp;</div></li><li><div>      array(0x016, 0x016, 0x014, 0x014, 0x016, 0x016, 0x014, 0x014, 0x001, 0x001, 0x001, 0x01e, 0x014, 0x001, 0x01e, 0x014), // 22x22&nbsp;</div></li><li><div>      array(0x018, 0x018, 0x016, 0x016, 0x018, 0x018, 0x016, 0x016, 0x001, 0x001, 0x001, 0x024, 0x018, 0x001, 0x024, 0x018), // 24x24&nbsp;</div></li><li><div>      array(0x01a, 0x01a, 0x018, 0x018, 0x01a, 0x01a, 0x018, 0x018, 0x001, 0x001, 0x001, 0x02c, 0x01c, 0x001, 0x02c, 0x01c), // 26x26&nbsp;</div></li><li><div>      array(0x020, 0x020, 0x01c, 0x01c, 0x010, 0x010, 0x00e, 0x00e, 0x002, 0x002, 0x004, 0x03e, 0x024, 0x001, 0x03e, 0x024), // 32x32&nbsp;</div></li><li><div>      array(0x024, 0x024, 0x020, 0x020, 0x012, 0x012, 0x010, 0x010, 0x002, 0x002, 0x004, 0x056, 0x02a, 0x001, 0x056, 0x02a), // 36x36&nbsp;</div></li><li><div>      array(0x028, 0x028, 0x024, 0x024, 0x014, 0x014, 0x012, 0x012, 0x002, 0x002, 0x004, 0x072, 0x030, 0x001, 0x072, 0x030), // 40x40&nbsp;</div></li><li><div>      array(0x02c, 0x02c, 0x028, 0x028, 0x016, 0x016, 0x014, 0x014, 0x002, 0x002, 0x004, 0x090, 0x038, 0x001, 0x090, 0x038), // 44x44&nbsp;</div></li><li><div>      array(0x030, 0x030, 0x02c, 0x02c, 0x018, 0x018, 0x016, 0x016, 0x002, 0x002, 0x004, 0x0ae, 0x044, 0x001, 0x0ae, 0x044), // 48x48&nbsp;</div></li><li><div>      array(0x034, 0x034, 0x030, 0x030, 0x01a, 0x01a, 0x018, 0x018, 0x002, 0x002, 0x004, 0x0cc, 0x054, 0x002, 0x066, 0x02a), // 52x52&nbsp;</div></li><li><div>      array(0x040, 0x040, 0x038, 0x038, 0x010, 0x010, 0x00e, 0x00e, 0x004, 0x004, 0x010, 0x118, 0x070, 0x002, 0x08c, 0x038), // 64x64&nbsp;</div></li><li><div>      array(0x048, 0x048, 0x040, 0x040, 0x012, 0x012, 0x010, 0x010, 0x004, 0x004, 0x010, 0x170, 0x090, 0x004, 0x05c, 0x024), // 72x72&nbsp;</div></li><li><div>      array(0x050, 0x050, 0x048, 0x048, 0x014, 0x014, 0x012, 0x012, 0x004, 0x004, 0x010, 0x1c8, 0x0c0, 0x004, 0x072, 0x030), // 80x80&nbsp;</div></li><li><div>      array(0x058, 0x058, 0x050, 0x050, 0x016, 0x016, 0x014, 0x014, 0x004, 0x004, 0x010, 0x240, 0x0e0, 0x004, 0x090, 0x038), // 88x88&nbsp;</div></li><li><div>      array(0x060, 0x060, 0x058, 0x058, 0x018, 0x018, 0x016, 0x016, 0x004, 0x004, 0x010, 0x2b8, 0x110, 0x004, 0x0ae, 0x044), // 96x96&nbsp;</div></li><li><div>      array(0x068, 0x068, 0x060, 0x060, 0x01a, 0x01a, 0x018, 0x018, 0x004, 0x004, 0x010, 0x330, 0x150, 0x006, 0x088, 0x038), // 104x104&nbsp;</div></li><li><div>      array(0x078, 0x078, 0x06c, 0x06c, 0x014, 0x014, 0x012, 0x012, 0x006, 0x006, 0x024, 0x41a, 0x198, 0x006, 0x0af, 0x044), // 120x120&nbsp;</div></li><li><div>      array(0x084, 0x084, 0x078, 0x078, 0x016, 0x016, 0x014, 0x014, 0x006, 0x006, 0x024, 0x518, 0x1f0, 0x008, 0x0a3, 0x03e), // 132x132&nbsp;</div></li><li><div>      array(0x090, 0x090, 0x084, 0x084, 0x018, 0x018, 0x016, 0x016, 0x006, 0x006, 0x024, 0x616, 0x26c, 0x00a, 0x09c, 0x03e), // 144x144&nbsp;</div></li><li><div>      // rectangular form (currently unused) ---------------------------------------------------------------------------&nbsp;</div></li><li><div>      array(0x008, 0x012, 0x006, 0x010, 0x008, 0x012, 0x006, 0x010, 0x001, 0x001, 0x001, 0x005, 0x007, 0x001, 0x005, 0x007), // 8x18&nbsp;</div></li><li><div>      array(0x008, 0x020, 0x006, 0x01c, 0x008, 0x010, 0x006, 0x00e, 0x001, 0x002, 0x002, 0x00a, 0x00b, 0x001, 0x00a, 0x00b), // 8x32&nbsp;</div></li><li><div>      array(0x00c, 0x01a, 0x00a, 0x018, 0x00c, 0x01a, 0x00a, 0x018, 0x001, 0x001, 0x001, 0x010, 0x00e, 0x001, 0x010, 0x00e), // 12x26&nbsp;</div></li><li><div>      array(0x00c, 0x024, 0x00a, 0x020, 0x00c, 0x012, 0x00a, 0x010, 0x001, 0x002, 0x002, 0x00c, 0x012, 0x001, 0x00c, 0x012), // 12x36&nbsp;</div></li><li><div>      array(0x010, 0x024, 0x00e, 0x020, 0x010, 0x012, 0x00e, 0x010, 0x001, 0x002, 0x002, 0x020, 0x018, 0x001, 0x020, 0x018), // 16x36&nbsp;</div></li><li><div>      array(0x010, 0x030, 0x00e, 0x02c, 0x010, 0x018, 0x00e, 0x016, 0x001, 0x002, 0x002, 0x031, 0x01c, 0x001, 0x031, 0x01c)  // 16x48&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Map encodation modes whit character sets.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $chset_id = array(ENC_C40 =&gt; 'C40', ENC_TXT =&gt; 'TXT', ENC_X12 =&gt;'X12');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Basic set of characters for each encodation mode.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $chset = array(&nbsp;</div></li><li><div>      'C40' =&gt; array( // Basic set for C40 ----------------------------------------------------------------------------&nbsp;</div></li><li><div>          'S1'=&gt;0x00, 'S2'=&gt;0x01, 'S3'=&gt;0x02, 0x20=&gt;0x03, 0x30=&gt;0x04, 0x31=&gt;0x05, 0x32=&gt;0x06, 0x33=&gt;0x07, 0x34=&gt;0x08, 0x35=&gt;0x09, //&nbsp;</div></li><li><div>          0x36=&gt;0x0a, 0x37=&gt;0x0b, 0x38=&gt;0x0c, 0x39=&gt;0x0d, 0x41=&gt;0x0e, 0x42=&gt;0x0f, 0x43=&gt;0x10, 0x44=&gt;0x11, 0x45=&gt;0x12, 0x46=&gt;0x13, //&nbsp;</div></li><li><div>          0x47=&gt;0x14, 0x48=&gt;0x15, 0x49=&gt;0x16, 0x4a=&gt;0x17, 0x4b=&gt;0x18, 0x4c=&gt;0x19, 0x4d=&gt;0x1a, 0x4e=&gt;0x1b, 0x4f=&gt;0x1c, 0x50=&gt;0x1d, //&nbsp;</div></li><li><div>          0x51=&gt;0x1e, 0x52=&gt;0x1f, 0x53=&gt;0x20, 0x54=&gt;0x21, 0x55=&gt;0x22, 0x56=&gt;0x23, 0x57=&gt;0x24, 0x58=&gt;0x25, 0x59=&gt;0x26, 0x5a=&gt;0x27), //&nbsp;</div></li><li><div>      'TXT' =&gt; array( // Basic set for TEXT ---------------------------------------------------------------------------&nbsp;</div></li><li><div>          'S1'=&gt;0x00, 'S2'=&gt;0x01, 'S3'=&gt;0x02, 0x20=&gt;0x03, 0x30=&gt;0x04, 0x31=&gt;0x05, 0x32=&gt;0x06, 0x33=&gt;0x07, 0x34=&gt;0x08, 0x35=&gt;0x09, //&nbsp;</div></li><li><div>          0x36=&gt;0x0a, 0x37=&gt;0x0b, 0x38=&gt;0x0c, 0x39=&gt;0x0d, 0x61=&gt;0x0e, 0x62=&gt;0x0f, 0x63=&gt;0x10, 0x64=&gt;0x11, 0x65=&gt;0x12, 0x66=&gt;0x13, //&nbsp;</div></li><li><div>          0x67=&gt;0x14, 0x68=&gt;0x15, 0x69=&gt;0x16, 0x6a=&gt;0x17, 0x6b=&gt;0x18, 0x6c=&gt;0x19, 0x6d=&gt;0x1a, 0x6e=&gt;0x1b, 0x6f=&gt;0x1c, 0x70=&gt;0x1d, //&nbsp;</div></li><li><div>          0x71=&gt;0x1e, 0x72=&gt;0x1f, 0x73=&gt;0x20, 0x74=&gt;0x21, 0x75=&gt;0x22, 0x76=&gt;0x23, 0x77=&gt;0x24, 0x78=&gt;0x25, 0x79=&gt;0x26, 0x7a=&gt;0x27), //&nbsp;</div></li><li><div>      'SH1' =&gt; array( // Shift 1 set ----------------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x00=&gt;0x00, 0x01=&gt;0x01, 0x02=&gt;0x02, 0x03=&gt;0x03, 0x04=&gt;0x04, 0x05=&gt;0x05, 0x06=&gt;0x06, 0x07=&gt;0x07, 0x08=&gt;0x08, 0x09=&gt;0x09, //&nbsp;</div></li><li><div>          0x0a=&gt;0x0a, 0x0b=&gt;0x0b, 0x0c=&gt;0x0c, 0x0d=&gt;0x0d, 0x0e=&gt;0x0e, 0x0f=&gt;0x0f, 0x10=&gt;0x10, 0x11=&gt;0x11, 0x12=&gt;0x12, 0x13=&gt;0x13, //&nbsp;</div></li><li><div>          0x14=&gt;0x14, 0x15=&gt;0x15, 0x16=&gt;0x16, 0x17=&gt;0x17, 0x18=&gt;0x18, 0x19=&gt;0x19, 0x1a=&gt;0x1a, 0x1b=&gt;0x1b, 0x1c=&gt;0x1c, 0x1d=&gt;0x1d, //&nbsp;</div></li><li><div>          0x1e=&gt;0x1e, 0x1f=&gt;0x1f), //&nbsp;</div></li><li><div>      'SH2' =&gt; array( // Shift 2 set ----------------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x21=&gt;0x00, 0x22=&gt;0x01, 0x23=&gt;0x02, 0x24=&gt;0x03, 0x25=&gt;0x04, 0x26=&gt;0x05, 0x27=&gt;0x06, 0x28=&gt;0x07, 0x29=&gt;0x08, 0x2a=&gt;0x09, //&nbsp;</div></li><li><div>          0x2b=&gt;0x0a, 0x2c=&gt;0x0b, 0x2d=&gt;0x0c, 0x2e=&gt;0x0d, 0x2f=&gt;0x0e, 0x3a=&gt;0x0f, 0x3b=&gt;0x10, 0x3c=&gt;0x11, 0x3d=&gt;0x12, 0x3e=&gt;0x13, //&nbsp;</div></li><li><div>          0x3f=&gt;0x14, 0x40=&gt;0x15, 0x5b=&gt;0x16, 0x5c=&gt;0x17, 0x5d=&gt;0x18, 0x5e=&gt;0x19, 0x5f=&gt;0x1a, 'F1'=&gt;0x1b, 'US'=&gt;0x1e), //&nbsp;</div></li><li><div>      'S3C' =&gt; array( // Shift 3 set for C40 --------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x60=&gt;0x00, 0x61=&gt;0x01, 0x62=&gt;0x02, 0x63=&gt;0x03, 0x64=&gt;0x04, 0x65=&gt;0x05, 0x66=&gt;0x06, 0x67=&gt;0x07, 0x68=&gt;0x08, 0x69=&gt;0x09, //&nbsp;</div></li><li><div>          0x6a=&gt;0x0a, 0x6b=&gt;0x0b, 0x6c=&gt;0x0c, 0x6d=&gt;0x0d, 0x6e=&gt;0x0e, 0x6f=&gt;0x0f, 0x70=&gt;0x10, 0x71=&gt;0x11, 0x72=&gt;0x12, 0x73=&gt;0x13, //&nbsp;</div></li><li><div>          0x74=&gt;0x14, 0x75=&gt;0x15, 0x76=&gt;0x16, 0x77=&gt;0x17, 0x78=&gt;0x18, 0x79=&gt;0x19, 0x7a=&gt;0x1a, 0x7b=&gt;0x1b, 0x7c=&gt;0x1c, 0x7d=&gt;0x1d, //&nbsp;</div></li><li><div>          0x7e=&gt;0x1e, 0x7f=&gt;0x1f), &nbsp;</div></li><li><div>      'S3T' =&gt; array( // Shift 3 set for TEXT -------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x60=&gt;0x00, 0x41=&gt;0x01, 0x42=&gt;0x02, 0x43=&gt;0x03, 0x44=&gt;0x04, 0x45=&gt;0x05, 0x46=&gt;0x06, 0x47=&gt;0x07, 0x48=&gt;0x08, 0x49=&gt;0x09, //&nbsp;</div></li><li><div>          0x4a=&gt;0x0a, 0x4b=&gt;0x0b, 0x4c=&gt;0x0c, 0x4d=&gt;0x0d, 0x4e=&gt;0x0e, 0x4f=&gt;0x0f, 0x50=&gt;0x10, 0x51=&gt;0x11, 0x52=&gt;0x12, 0x53=&gt;0x13, //&nbsp;</div></li><li><div>          0x54=&gt;0x14, 0x55=&gt;0x15, 0x56=&gt;0x16, 0x57=&gt;0x17, 0x58=&gt;0x18, 0x59=&gt;0x19, 0x5a=&gt;0x1a, 0x7b=&gt;0x1b, 0x7c=&gt;0x1c, 0x7d=&gt;0x1d, //&nbsp;</div></li><li><div>          0x7e=&gt;0x1e, 0x7f=&gt;0x1f), //&nbsp;</div></li><li><div>      'X12' =&gt; array( // Set for X12 ----------------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x0d=&gt;0x00, 0x2a=&gt;0x01, 0x3e=&gt;0x02, 0x20=&gt;0x03, 0x30=&gt;0x04, 0x31=&gt;0x05, 0x32=&gt;0x06, 0x33=&gt;0x07, 0x34=&gt;0x08, 0x35=&gt;0x09, //&nbsp;</div></li><li><div>          0x36=&gt;0x0a, 0x37=&gt;0x0b, 0x38=&gt;0x0c, 0x39=&gt;0x0d, 0x41=&gt;0x0e, 0x42=&gt;0x0f, 0x43=&gt;0x10, 0x44=&gt;0x11, 0x45=&gt;0x12, 0x46=&gt;0x13, //&nbsp;</div></li><li><div>          0x47=&gt;0x14, 0x48=&gt;0x15, 0x49=&gt;0x16, 0x4a=&gt;0x17, 0x4b=&gt;0x18, 0x4c=&gt;0x19, 0x4d=&gt;0x1a, 0x4e=&gt;0x1b, 0x4f=&gt;0x1c, 0x50=&gt;0x1d, //&nbsp;</div></li><li><div>          0x51=&gt;0x1e, 0x52=&gt;0x1f, 0x53=&gt;0x20, 0x54=&gt;0x21, 0x55=&gt;0x22, 0x56=&gt;0x23, 0x57=&gt;0x24, 0x58=&gt;0x25, 0x59=&gt;0x26, 0x5a=&gt;0x27) //&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// -----------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * This is the class constructor.&nbsp;</div></li><li><div>   * Creates a datamatrix object&nbsp;</div></li><li><div>   * @param $code (string) Code to represent using Datamatrix.&nbsp;</div></li><li><div>   * @public&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  public function __construct($code) {&nbsp;</div></li><li><div>      $barcode_array = array();&nbsp;</div></li><li><div>      if ((is_null($code)) OR ($code == '\0') OR ($code == '')) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // get data codewords&nbsp;</div></li><li><div>      $cw = $this-&gt;getHighLevelEncoding($code);&nbsp;</div></li><li><div>      // number of data codewords&nbsp;</div></li><li><div>      $nd = count($cw);&nbsp;</div></li><li><div>      // check size&nbsp;</div></li><li><div>      if ($nd &gt; 1558) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // get minimum required matrix size.&nbsp;</div></li><li><div>      foreach ($this-&gt;symbattr as $params) {&nbsp;</div></li><li><div>          if ($params[11] &gt;= $nd) {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ($params[11] &lt; $nd) {&nbsp;</div></li><li><div>          // too much data&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      } elseif ($params[11] &gt; $nd) {&nbsp;</div></li><li><div>          // add padding&nbsp;</div></li><li><div>          if ((($params[11] - $nd) &gt; 1) AND ($cw[($nd - 1)] != 254)) {&nbsp;</div></li><li><div>              if ($this-&gt;last_enc == ENC_EDF) {&nbsp;</div></li><li><div>                  // switch to ASCII encoding&nbsp;</div></li><li><div>                  $cw[] = 124;&nbsp;</div></li><li><div>                  ++$nd;&nbsp;</div></li><li><div>              } elseif (($this-&gt;last_enc != ENC_ASCII) AND ($this-&gt;last_enc != ENC_BASE256)) {&nbsp;</div></li><li><div>                  // switch to ASCII encoding&nbsp;</div></li><li><div>                  $cw[] = 254;&nbsp;</div></li><li><div>                  ++$nd;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ($params[11] &gt; $nd) {&nbsp;</div></li><li><div>              // add first pad&nbsp;</div></li><li><div>              $cw[] = 129;&nbsp;</div></li><li><div>              ++$nd;&nbsp;</div></li><li><div>              // add remaining pads&nbsp;</div></li><li><div>              for ($i = $nd; $i &lt; $params[11]; ++$i) {&nbsp;</div></li><li><div>                  $cw[] = $this-&gt;get253StateCodeword(129, $i);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // add error correction codewords&nbsp;</div></li><li><div>      $cw = $this-&gt;getErrorCorrection($cw, $params[13], $params[14], $params[15]);&nbsp;</div></li><li><div>      // initialize empty arrays&nbsp;</div></li><li><div>      $grid = array_fill(0, ($params[2] * $params[3]), 0);&nbsp;</div></li><li><div>      // get placement map&nbsp;</div></li><li><div>      $places = $this-&gt;getPlacementMap($params[2], $params[3]);&nbsp;</div></li><li><div>      // fill the grid with data&nbsp;</div></li><li><div>      $grid = array();&nbsp;</div></li><li><div>      $i = 0;&nbsp;</div></li><li><div>      // region data row max index&nbsp;</div></li><li><div>      $rdri = ($params[4] - 1);&nbsp;</div></li><li><div>      // region data column max index&nbsp;</div></li><li><div>      $rdci = ($params[5] - 1);&nbsp;</div></li><li><div>      // for each vertical region&nbsp;</div></li><li><div>      for ($vr = 0; $vr &lt; $params[9]; ++$vr) {&nbsp;</div></li><li><div>          // for each row on region&nbsp;</div></li><li><div>          for ($r = 0; $r &lt; $params[4]; ++$r) {&nbsp;</div></li><li><div>              // get row&nbsp;</div></li><li><div>              $row = (($vr * $params[4]) + $r);&nbsp;</div></li><li><div>              // for each horizontal region&nbsp;</div></li><li><div>              for ($hr = 0; $hr &lt; $params[8]; ++$hr) {&nbsp;</div></li><li><div>                  // for each column on region&nbsp;</div></li><li><div>                  for ($c = 0; $c &lt; $params[5]; ++$c) {&nbsp;</div></li><li><div>                      // get column&nbsp;</div></li><li><div>                      $col = (($hr * $params[5]) + $c);&nbsp;</div></li><li><div>                      // braw bits by case&nbsp;</div></li><li><div>                      if ($r == 0) {&nbsp;</div></li><li><div>                          // top finder pattern&nbsp;</div></li><li><div>                          if ($c % 2) {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 0;&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      } elseif ($r == $rdri) {&nbsp;</div></li><li><div>                          // bottom finder pattern&nbsp;</div></li><li><div>                          $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                      } elseif ($c == 0) {&nbsp;</div></li><li><div>                          // left finder pattern&nbsp;</div></li><li><div>                          $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                      } elseif ($c == $rdci) {&nbsp;</div></li><li><div>                          // right finder pattern&nbsp;</div></li><li><div>                          if ($r % 2) {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 0;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      } else { // data bit&nbsp;</div></li><li><div>                          if ($places[$i] &lt; 2) {&nbsp;</div></li><li><div>                              $grid[$row][$col] = $places[$i];&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              // codeword ID&nbsp;</div></li><li><div>                              $cw_id = (floor($places[$i] / 10) - 1);&nbsp;</div></li><li><div>                              // codeword BIT mask&nbsp;</div></li><li><div>                              $cw_bit = pow(2, (8 - ($places[$i] % 10)));&nbsp;</div></li><li><div>                              $grid[$row][$col] = (($cw[$cw_id] & $cw_bit) == 0) ? 0 : 1;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          ++$i;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $this-&gt;barcode_array['num_rows'] = $params[0];&nbsp;</div></li><li><div>      $this-&gt;barcode_array['num_cols'] = $params[1];&nbsp;</div></li><li><div>      $this-&gt;barcode_array['bcode'] = $grid;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Returns a barcode array which is readable by TCPDF&nbsp;</div></li><li><div>   * @return array barcode array readable by TCPDF;&nbsp;</div></li><li><div>   * @public&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  public function getBarcodeArray() {&nbsp;</div></li><li><div>      return $this-&gt;barcode_array;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Product of two numbers in a Power-of-Two Galois Field&nbsp;</div></li><li><div>   * @param $a (int) first number to multiply.&nbsp;</div></li><li><div>   * @param $b (int) second number to multiply.&nbsp;</div></li><li><div>   * @param $log (array) Log table.&nbsp;</div></li><li><div>   * @param $alog (array) Anti-Log table.&nbsp;</div></li><li><div>   * @param $gf (array) Number of Factors of the Reed-Solomon polynomial.&nbsp;</div></li><li><div>   * @return int product&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getGFProduct($a, $b, $log, $alog, $gf) {&nbsp;</div></li><li><div>      if (($a == 0) OR ($b == 0)) {&nbsp;</div></li><li><div>          return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return ($alog[($log[$a] + $log[$b]) % ($gf - 1)]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Add error correction codewords to data codewords array (ANNEX E).&nbsp;</div></li><li><div>   * @param $wd (array) Array of datacodewords.&nbsp;</div></li><li><div>   * @param $nb (int) Number of blocks.&nbsp;</div></li><li><div>   * @param $nd (int) Number of data codewords per block.&nbsp;</div></li><li><div>   * @param $nc (int) Number of correction codewords per block.&nbsp;</div></li><li><div>   * @param $gf (int) numner of fields on log/antilog table (power of 2).&nbsp;</div></li><li><div>   * @param $pp (int) The value of its prime modulus polynomial (301 for ECC200).&nbsp;</div></li><li><div>   * @return array data codewords + error codewords&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getErrorCorrection($wd, $nb, $nd, $nc, $gf=256, $pp=301) {&nbsp;</div></li><li><div>      // generate the log ($log) and antilog ($alog) tables&nbsp;</div></li><li><div>      $log[0] = 0;&nbsp;</div></li><li><div>      $alog[0] = 1;&nbsp;</div></li><li><div>      for ($i = 1; $i &lt; $gf; ++$i) {&nbsp;</div></li><li><div>          $alog[$i] = ($alog[($i - 1)] * 2);&nbsp;</div></li><li><div>          if ($alog[$i] &gt;= $gf) {&nbsp;</div></li><li><div>              $alog[$i] ^= $pp;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $log[$alog[$i]] = $i;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      ksort($log);&nbsp;</div></li><li><div>      // generate the polynomial coefficients (c)&nbsp;</div></li><li><div>      $c = array_fill(0, ($nc + 1), 0);&nbsp;</div></li><li><div>      $c[0] = 1;&nbsp;</div></li><li><div>      for ($i = 1; $i &lt;= $nc; ++$i) {&nbsp;</div></li><li><div>          $c[$i] = $c[($i-1)];&nbsp;</div></li><li><div>          for ($j = ($i - 1); $j &gt;= 1; --$j) {&nbsp;</div></li><li><div>              $c[$j] = $c[($j - 1)] ^ $this-&gt;getGFProduct($c[$j], $alog[$i], $log, $alog, $gf);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $c[0] = $this-&gt;getGFProduct($c[0], $alog[$i], $log, $alog, $gf);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      ksort($c);&nbsp;</div></li><li><div>      // total number of data codewords&nbsp;</div></li><li><div>      $num_wd = ($nb * $nd);&nbsp;</div></li><li><div>      // total number of error codewords&nbsp;</div></li><li><div>      $num_we = ($nb * $nc);&nbsp;</div></li><li><div>      // for each block&nbsp;</div></li><li><div>      for ($b = 0; $b &lt; $nb; ++$b) {&nbsp;</div></li><li><div>          // create interleaved data block&nbsp;</div></li><li><div>          $block = array();&nbsp;</div></li><li><div>          for ($n = $b; $n &lt; $num_wd; $n += $nb) {&nbsp;</div></li><li><div>              $block[] = $wd[$n];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // initialize error codewords&nbsp;</div></li><li><div>          $we = array_fill(0, ($nc + 1), 0);&nbsp;</div></li><li><div>          // calculate error correction codewords for this block&nbsp;</div></li><li><div>          for ($i = 0; $i &lt; $nd; ++$i) {&nbsp;</div></li><li><div>              $k = ($we[0] ^ $block[$i]);&nbsp;</div></li><li><div>              for ($j = 0; $j &lt; $nc; ++$j) {&nbsp;</div></li><li><div>                  $we[$j] = ($we[($j + 1)] ^ $this-&gt;getGFProduct($k, $c[($nc - $j - 1)], $log, $alog, $gf));&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // add error codewords at the end of data codewords&nbsp;</div></li><li><div>          $j = 0;&nbsp;</div></li><li><div>          for ($i = $b; $i &lt; $num_we; $i += $nb) {&nbsp;</div></li><li><div>              $wd[($num_wd + $i)] = $we[$j];&nbsp;</div></li><li><div>              ++$j;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // reorder codewords&nbsp;</div></li><li><div>      ksort($wd);&nbsp;</div></li><li><div>      return $wd;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Return the 253-state codeword&nbsp;</div></li><li><div>   * @param $cwpad (int) Pad codeword.&nbsp;</div></li><li><div>   * @param $cwpos (int) Number of data codewords from the beginning of encoded data.&nbsp;</div></li><li><div>   * @return pad codeword&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function get253StateCodeword($cwpad, $cwpos) {&nbsp;</div></li><li><div>      $pad = ($cwpad + (((149 * $cwpos) % 253) + 1));&nbsp;</div></li><li><div>      if ($pad &gt; 254) {&nbsp;</div></li><li><div>          $pad -= 254;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $pad;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Return the 255-state codeword&nbsp;</div></li><li><div>   * @param $cwpad (int) Pad codeword.&nbsp;</div></li><li><div>   * @param $cwpos (int) Number of data codewords from the beginning of encoded data.&nbsp;</div></li><li><div>   * @return pad codeword&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function get255StateCodeword($cwpad, $cwpos) {&nbsp;</div></li><li><div>      $pad = ($cwpad + (((149 * $cwpos) % 255) + 1));&nbsp;</div></li><li><div>      if ($pad &gt; 255) {&nbsp;</div></li><li><div>          $pad -= 256;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $pad;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Returns true if the char belongs to the selected mode&nbsp;</div></li><li><div>   * @param $chr (int) Character (byte) to check.&nbsp;</div></li><li><div>   * @param $mode (int) Current encoding mode.&nbsp;</div></li><li><div>   * @return boolean true if the char is of the selected mode.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function isCharMode($chr, $mode) {&nbsp;</div></li><li><div>      $status = false;&nbsp;</div></li><li><div>      switch ($mode) {&nbsp;</div></li><li><div>          case ENC_ASCII: { // ASCII character 0 to 127&nbsp;</div></li><li><div>              $status = (($chr &gt;= 0) AND ($chr &lt;= 127));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_C40: { // Upper-case alphanumeric&nbsp;</div></li><li><div>              $status = (($chr == 32) OR (($chr &gt;= 48) AND ($chr &lt;= 57)) OR (($chr &gt;= 65) AND ($chr &lt;= 90)));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_TXT: { // Lower-case alphanumeric&nbsp;</div></li><li><div>              $status = (($chr == 32) OR (($chr &gt;= 48) AND ($chr &lt;= 57)) OR (($chr &gt;= 97) AND ($chr &lt;= 122)));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_X12: { // ANSI X12&nbsp;</div></li><li><div>              $status = (($chr == 13) OR ($chr == 42) OR ($chr == 62));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_EDF: { // ASCII character 32 to 94&nbsp;</div></li><li><div>              $status = (($chr &gt;= 32) AND ($chr &lt;= 94));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_BASE256: { // Function character (FNC1, Structured Append, Reader Program, or Code Page)&nbsp;</div></li><li><div>              $status = (($chr == 232) OR ($chr == 233) OR ($chr == 234) OR ($chr == 241));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_ASCII_EXT: { // ASCII character 128 to 255&nbsp;</div></li><li><div>              $status = (($chr &gt;= 128) AND ($chr &lt;= 255));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_ASCII_NUM: { // ASCII digits&nbsp;</div></li><li><div>              $status = (($chr &gt;= 48) AND ($chr &lt;= 57));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $status;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * The look-ahead test scans the data to be encoded to find the best mode (Annex P - steps from J to S).&nbsp;</div></li><li><div>   * @param $data (string) data to encode&nbsp;</div></li><li><div>   * @param $pos (int) current position&nbsp;</div></li><li><div>   * @param $mode (int) current encoding mode&nbsp;</div></li><li><div>   * @return int encoding mode&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function lookAheadTest($data, $pos, $mode) {&nbsp;</div></li><li><div>      $data_length = strlen($data);&nbsp;</div></li><li><div>      if ($pos &gt;= $data_length) {&nbsp;</div></li><li><div>          return $mode;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $charscount = 0; // count processed chars&nbsp;</div></li><li><div>      // STEP J&nbsp;</div></li><li><div>      if ($mode == ENC_ASCII) {&nbsp;</div></li><li><div>          $numch = array(0, 1, 1, 1, 1, 1.25);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $numch = array(1, 2, 2, 2, 2, 2.25);&nbsp;</div></li><li><div>          $numch[$mode] = 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      while (true) {&nbsp;</div></li><li><div>          // STEP K&nbsp;</div></li><li><div>          if (($pos + $charscount) == $data_length) {&nbsp;</div></li><li><div>              if ($numch[ENC_ASCII] &lt;= ceil(min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_ASCII;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_BASE256] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF]))) {&nbsp;</div></li><li><div>                  return ENC_BASE256;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_EDF] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_EDF;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_TXT] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_TXT;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_X12] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_X12;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              return ENC_C40;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // get char&nbsp;</div></li><li><div>          $chr = ord($data[$pos + $charscount]);&nbsp;</div></li><li><div>          $charscount++;&nbsp;</div></li><li><div>          // STEP L&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_ASCII_NUM)) {&nbsp;</div></li><li><div>              $numch[ENC_ASCII] += (1 / 2);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_ASCII] = ceil($numch[ENC_ASCII]);&nbsp;</div></li><li><div>              $numch[ENC_ASCII] += 2;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_ASCII] = ceil($numch[ENC_ASCII]);&nbsp;</div></li><li><div>              $numch[ENC_ASCII] += 1;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP M&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_C40)) {&nbsp;</div></li><li><div>              $numch[ENC_C40] += (2 / 3);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_C40] += (8 / 3);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_C40] += (4 / 3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP N&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_TXT)) {&nbsp;</div></li><li><div>              $numch[ENC_TXT] += (2 / 3);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_TXT] += (8 / 3);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_TXT] += (4 / 3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP O&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_X12) OR $this-&gt;isCharMode($chr, ENC_C40)) {&nbsp;</div></li><li><div>              $numch[ENC_X12] += (2 / 3);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_X12] += (13 / 3);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_X12] += (10 / 3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP P&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_EDF)) {&nbsp;</div></li><li><div>              $numch[ENC_EDF] += (3 / 4);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_EDF] += (17 / 4);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_EDF] += (13 / 4);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP Q&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_BASE256)) {&nbsp;</div></li><li><div>              $numch[ENC_BASE256] += 4;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_BASE256] += 1;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP R&nbsp;</div></li><li><div>          if ($charscount &gt;= 4) {&nbsp;</div></li><li><div>              if (($numch[ENC_ASCII] + 1) &lt;= min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_ASCII;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ((($numch[ENC_BASE256] + 1) &lt;= $numch[ENC_ASCII])&nbsp;</div></li><li><div>                  OR (($numch[ENC_BASE256] + 1) &lt; min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF]))) {&nbsp;</div></li><li><div>                  return ENC_BASE256;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_EDF] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_EDF;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_TXT] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_TXT;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_X12] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_X12;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_C40] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  if ($numch[ENC_C40] &lt; $numch[ENC_X12]) {&nbsp;</div></li><li><div>                      return ENC_C40;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  if ($numch[ENC_C40] == $numch[ENC_X12]) {&nbsp;</div></li><li><div>                      $k = ($pos + $charscount + 1);&nbsp;</div></li><li><div>                      while ($k &lt; $data_length) {&nbsp;</div></li><li><div>                          $tmpchr = ord($data{$k});&nbsp;</div></li><li><div>                          if ($this-&gt;isCharMode($tmpchr, ENC_X12)) {&nbsp;</div></li><li><div>                              return ENC_X12;&nbsp;</div></li><li><div>                          } elseif (!($this-&gt;isCharMode($tmpchr, ENC_X12) OR $this-&gt;isCharMode($tmpchr, ENC_C40))) {&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          ++$k;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      return ENC_C40;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } // end of while&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Get the switching codeword to a new encoding mode (latch codeword)&nbsp;</div></li><li><div>   * @param $mode (int) New encoding mode.&nbsp;</div></li><li><div>   * @return (int) Switch codeword.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getSwitchEncodingCodeword($mode) {&nbsp;</div></li><li><div>      switch ($mode) {&nbsp;</div></li><li><div>          case ENC_ASCII: { // ASCII character 0 to 127&nbsp;</div></li><li><div>              $cw = 254;&nbsp;</div></li><li><div>              if ($this-&gt;last_enc == ENC_EDF) {&nbsp;</div></li><li><div>                  $cw = 124;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_C40: { // Upper-case alphanumeric&nbsp;</div></li><li><div>              $cw = 230;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_TXT: { // Lower-case alphanumeric&nbsp;</div></li><li><div>              $cw = 239;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_X12: { // ANSI X12&nbsp;</div></li><li><div>              $cw = 238;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_EDF: { // ASCII character 32 to 94&nbsp;</div></li><li><div>              $cw = 240;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_BASE256: { // Function character (FNC1, Structured Append, Reader Program, or Code Page)&nbsp;</div></li><li><div>              $cw = 231;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $cw;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Choose the minimum matrix size and return the max number of data codewords.&nbsp;</div></li><li><div>   * @param $numcw (int) Number of current codewords.&nbsp;</div></li><li><div>   * @return number of data codewords in matrix&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getMaxDataCodewords($numcw) {&nbsp;</div></li><li><div>      foreach ($this-&gt;symbattr as $key =&gt; $matrix) {&nbsp;</div></li><li><div>          if ($matrix[11] &gt;= $numcw) {&nbsp;</div></li><li><div>              return $matrix[11];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Get high level encoding using the minimum symbol data characters for ECC 200&nbsp;</div></li><li><div>   * @param $data (string) data to encode&nbsp;</div></li><li><div>   * @return array of codewords&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getHighLevelEncoding($data) {&nbsp;</div></li><li><div>      // STEP A. Start in ASCII encodation.&nbsp;</div></li><li><div>      $enc = ENC_ASCII; // current encoding mode&nbsp;</div></li><li><div>      $pos = 0; // current position&nbsp;</div></li><li><div>      $cw = array(); // array of codewords to be returned&nbsp;</div></li><li><div>      $cw_num = 0; // number of data codewords&nbsp;</div></li><li><div>      $data_lenght = strlen($data); // number of chars&nbsp;</div></li><li><div>      while ($pos &lt; $data_lenght) {&nbsp;</div></li><li><div>          // set last used encoding&nbsp;</div></li><li><div>          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>          switch ($enc) {&nbsp;</div></li><li><div>              case ENC_ASCII: { // STEP B. While in ASCII encodation&nbsp;</div></li><li><div>                  if (($data_lenght &gt; 1) AND ($pos &lt; ($data_lenght - 1)) AND ($this-&gt;isCharMode(ord($data[$pos]), ENC_ASCII_NUM) AND $this-&gt;isCharMode(ord($data[$pos + 1]), ENC_ASCII_NUM))) {&nbsp;</div></li><li><div>                      // 1. If the next data sequence is at least 2 consecutive digits, encode the next two digits as a double digit in ASCII mode.&nbsp;</div></li><li><div>                      $cw[] = (intval(substr($data, $pos, 2)) + 130);&nbsp;</div></li><li><div>                      ++$cw_num;&nbsp;</div></li><li><div>                      $pos += 2;&nbsp;</div></li><li><div>                  } else {&nbsp;</div></li><li><div>                      // 2. If the look-ahead test (starting at step J) indicates another mode, switch to that mode.&nbsp;</div></li><li><div>                      $newenc = $this-&gt;lookAheadTest($data, $pos, $enc);&nbsp;</div></li><li><div>                      if ($newenc != $enc) {&nbsp;</div></li><li><div>                          // switch to new encoding&nbsp;</div></li><li><div>                          $enc = $newenc;&nbsp;</div></li><li><div>                          $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                          ++$cw_num;&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          // get new byte&nbsp;</div></li><li><div>                          $chr = ord($data[$pos]);&nbsp;</div></li><li><div>                          ++$pos;&nbsp;</div></li><li><div>                          if ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>                              // 3. If the next data character is extended ASCII (greater than 127) encode it in ASCII mode first using the Upper Shift (value 235) character.&nbsp;</div></li><li><div>                              $cw[] = 235;&nbsp;</div></li><li><div>                              $cw[] = ($chr - 127);&nbsp;</div></li><li><div>                              $cw_num += 2;&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              // 4. Otherwise process the next data character in ASCII encodation.&nbsp;</div></li><li><div>                              $cw[] = ($chr + 1);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              case ENC_C40 :   // Upper-case alphanumeric&nbsp;</div></li><li><div>              case ENC_TXT :   // Lower-case alphanumeric&nbsp;</div></li><li><div>              case ENC_X12 : { // ANSI X12&nbsp;</div></li><li><div>                  $temp_cw = array();&nbsp;</div></li><li><div>                  $p = 0;&nbsp;</div></li><li><div>                  $epos = $pos;&nbsp;</div></li><li><div>                  // get charset ID&nbsp;</div></li><li><div>                  $set_id = $this-&gt;chset_id[$enc];&nbsp;</div></li><li><div>                  // get basic charset for current encoding&nbsp;</div></li><li><div>                  $charset = $this-&gt;chset[$set_id];&nbsp;</div></li><li><div>                  do {&nbsp;</div></li><li><div>                      // 2. process the next character in C40 encodation.&nbsp;</div></li><li><div>                      $chr = ord($data[$epos]);&nbsp;</div></li><li><div>                      ++$epos;&nbsp;</div></li><li><div>                      // check for extended character&nbsp;</div></li><li><div>                      if ($chr & 0x80) {&nbsp;</div></li><li><div>                          if ($enc == ENC_X12) {&nbsp;</div></li><li><div>                              return false;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $chr = ($chr & 0x7f);&nbsp;</div></li><li><div>                          $temp_cw[] = 1; // shift 2&nbsp;</div></li><li><div>                          $temp_cw[] = 30; // upper shift&nbsp;</div></li><li><div>                          $p += 2;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      if (isset($charset[$chr])) {&nbsp;</div></li><li><div>                          $temp_cw[] = $charset[$chr];&nbsp;</div></li><li><div>                          ++$p;&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          if (isset($this-&gt;chset['SH1'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 0; // shift 1&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['SH1'];&nbsp;</div></li><li><div>                          } elseif (isset($chr, $this-&gt;chset['SH2'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 1; // shift 2&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['SH2'];&nbsp;</div></li><li><div>                          } elseif (($enc == ENC_C40) AND isset($this-&gt;chset['S3C'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 2; // shift 3&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['S3C'];&nbsp;</div></li><li><div>                          } elseif (($enc == ENC_TXT) AND isset($this-&gt;chset['S3T'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 2; // shift 3&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['S3T'];&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              return false;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $temp_cw[] = $shiftset[$chr];&nbsp;</div></li><li><div>                          $p += 2;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      if ($p &gt;= 3) {&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $c2 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $c3 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $p -= 3;&nbsp;</div></li><li><div>                          $tmp = ((1600 * $c1) + (40 * $c2) + $c3 + 1);&nbsp;</div></li><li><div>                          $cw[] = ($tmp &gt;&gt; 8);&nbsp;</div></li><li><div>                          $cw[] = ($tmp % 256);&nbsp;</div></li><li><div>                          $cw_num += 2;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          // 1. If the C40 encoding is at the point of starting a new double symbol character and if the look-ahead test (starting at step J) indicates another mode, switch to that mode.&nbsp;</div></li><li><div>                          $newenc = $this-&gt;lookAheadTest($data, $pos, $enc);&nbsp;</div></li><li><div>                          if ($newenc != $enc) {&nbsp;</div></li><li><div>                              // switch to new encoding&nbsp;</div></li><li><div>                              $enc = $newenc;&nbsp;</div></li><li><div>                              if ($enc != ENC_ASCII) {&nbsp;</div></li><li><div>                                  // set unlatch character&nbsp;</div></li><li><div>                                  $cw[] = $this-&gt;getSwitchEncodingCodeword(ENC_ASCII);&nbsp;</div></li><li><div>                                  ++$cw_num;&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>                              $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                              $pos -= $p;&nbsp;</div></li><li><div>                              $p = 0;&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  } while (($p &gt; 0) AND ($epos &lt; $data_lenght));&nbsp;</div></li><li><div>                  // process last data (if any)&nbsp;</div></li><li><div>                  if ($p &gt; 0) {&nbsp;</div></li><li><div>                      // get remaining number of data symbols&nbsp;</div></li><li><div>                      $cwr = ($this-&gt;getMaxDataCodewords($cw_num) - $cw_num);&nbsp;</div></li><li><div>                      if (($cwr == 1) AND ($p == 1)) {&nbsp;</div></li><li><div>                          // d. If one symbol character remains and one C40 value (data character) remains to be encoded&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          --$p;&nbsp;</div></li><li><div>                          $cw[] = ($chr + 1);&nbsp;</div></li><li><div>                          ++$cw_num;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $enc = ENC_ASCII;&nbsp;</div></li><li><div>                          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                      } elseif (($cwr == 2) AND ($p == 1)) {&nbsp;</div></li><li><div>                          // c. If two symbol characters remain and only one C40 value (data character) remains to be encoded&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          --$p;&nbsp;</div></li><li><div>                          $cw[] = 254;&nbsp;</div></li><li><div>                          $cw[] = ($chr + 1);&nbsp;</div></li><li><div>                          $cw_num += 2;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $enc = ENC_ASCII;&nbsp;</div></li><li><div>                          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                      } elseif (($cwr == 2) AND ($p == 2)) {&nbsp;</div></li><li><div>                          // b. If two symbol characters remain and two C40 values remain to be encoded&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $c2 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $p -= 2;&nbsp;</div></li><li><div>                          $tmp = ((1600 * $c1) + (40 * $c2) + 1);&nbsp;</div></li><li><div>                          $cw[] = ($tmp &gt;&gt; 8);&nbsp;</div></li><li><div>                          $cw[] = ($tmp % 256);&nbsp;</div></li><li><div>                          $cw_num += 2;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $enc = ENC_ASCII;&nbsp;</div></li><li><div>                          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          // switch to ASCII encoding&nbsp;</div></li><li><div>                          if ($enc != ENC_ASCII) {&nbsp;</div></li><li><div>                              $enc = ENC_ASCII;&nbsp;</div></li><li><div>                              $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                              $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                              $pos = ($epos - $p);&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              case ENC_EDF: { // F. While in EDIFACT (EDF) encodation&nbsp;</div></li><li><div>                  // initialize temporary array with 0 lenght&nbsp;</div></li><li><div>                  $temp_cw = array();&nbsp;</div></li><li><div>                  $epos = $pos;&nbsp;</div></li><li><div>                  $field_lenght = 0;&nbsp;</div></li><li><div>                  $newenc = $enc;&nbsp;</div></li><li><div>                  do {&nbsp;</div></li><li><div>                      // 2. process the next character in EDIFACT encodation.&nbsp;</div></li><li><div>                      $chr = ord($data[$epos]);&nbsp;</div></li><li><div>                      if ($this-&gt;isCharMode($chr, ENC_EDF)) {&nbsp;</div></li><li><div>                          ++$epos;&nbsp;</div></li><li><div>                          $temp_cw[] = $chr;&nbsp;</div></li><li><div>                          ++$field_lenght;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      if (($field_lenght == 4) OR ($epos == $data_lenght) OR !$this-&gt;isCharMode($chr, ENC_EDF)) {&nbsp;</div></li><li><div>                          if (($epos == $data_lenght) AND ($field_lenght &lt; 3)) {&nbsp;</div></li><li><div>                              $enc = ENC_ASCII;&nbsp;</div></li><li><div>                              $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          if ($field_lenght &lt; 4) {&nbsp;</div></li><li><div>                              // set unlatch character&nbsp;</div></li><li><div>                              $temp_cw[] = 0x1f;&nbsp;</div></li><li><div>                              ++$field_lenght;&nbsp;</div></li><li><div>                              // fill empty characters&nbsp;</div></li><li><div>                              for ($i = $field_lenght; $i &lt; 4; ++$i) {&nbsp;</div></li><li><div>                                  $temp_cw[] = 0;&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>                              $enc = ENC_ASCII;&nbsp;</div></li><li><div>                              $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          // encodes four data characters in three codewords&nbsp;</div></li><li><div>                          $tcw = (($temp_cw[0] & 0x3F) &lt;&lt; 2) + (($temp_cw[1] & 0x30) &gt;&gt; 4);&nbsp;</div></li><li><div>                          if ($tcw &gt; 0) {&nbsp;</div></li><li><div>                              $cw[] = $tcw;&nbsp;</div></li><li><div>                              $cw_num++;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $tcw= (($temp_cw[1] & 0x0F) &lt;&lt; 4) + (($temp_cw[2] & 0x3C) &gt;&gt; 2);&nbsp;</div></li><li><div>                          if ($tcw &gt; 0) {&nbsp;</div></li><li><div>                              $cw[] = $tcw;&nbsp;</div></li><li><div>                              $cw_num++;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $tcw = (($temp_cw[2] & 0x03) &lt;&lt; 6) + ($temp_cw[3] & 0x3F);&nbsp;</div></li><li><div>                          if ($tcw &gt; 0) {&nbsp;</div></li><li><div>                              $cw[] = $tcw;&nbsp;</div></li><li><div>                              $cw_num++;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $temp_cw = array();&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $field_lenght = 0;&nbsp;</div></li><li><div>                          if ($enc == ENC_ASCII) {&nbsp;</div></li><li><div>                              break; // exit from EDIFACT mode&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  } while ($epos &lt; $data_lenght);&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              case ENC_BASE256: { // G. While in Base 256 (B256) encodation&nbsp;</div></li><li><div>                  // initialize temporary array with 0 lenght&nbsp;</div></li><li><div>                  $temp_cw = array();&nbsp;</div></li><li><div>                  $field_lenght = 0;&nbsp;</div></li><li><div>                  while (($pos &lt; $data_lenght) AND ($field_lenght &lt;= 1555)) {&nbsp;</div></li><li><div>                      $newenc = $this-&gt;lookAheadTest($data, $pos, $enc);&nbsp;</div></li><li><div>                      if ($newenc != $enc) {&nbsp;</div></li><li><div>                          // 1. If the look-ahead test (starting at step J) indicates another mode, switch to that mode.&nbsp;</div></li><li><div>                          $enc = $newenc;&nbsp;</div></li><li><div>                          break; // exit from B256 mode&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          // 2. Otherwise, process the next character in Base 256 encodation.&nbsp;</div></li><li><div>                          $chr = ord($data[$pos]);&nbsp;</div></li><li><div>                          ++$pos;&nbsp;</div></li><li><div>                          $temp_cw[] = $chr;&nbsp;</div></li><li><div>                          ++$field_lenght;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  // set field lenght&nbsp;</div></li><li><div>                  if ($field_lenght &lt;= 249) {&nbsp;</div></li><li><div>                      $cw[] = $this-&gt;get255StateCodeword($field_lenght, ($cw_num + 1));&nbsp;</div></li><li><div>                      ++$cw_num;&nbsp;</div></li><li><div>                  } else {&nbsp;</div></li><li><div>                      $cw[] = $this-&gt;get255StateCodeword((floor($field_lenght / 250) + 249), ($cw_num + 1));&nbsp;</div></li><li><div>                      $cw[] = $this-&gt;get255StateCodeword(($field_lenght % 250), ($cw_num + 2));&nbsp;</div></li><li><div>                      $cw_num += 2;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  if (!empty($temp_cw)) {&nbsp;</div></li><li><div>                      // add B256 field&nbsp;</div></li><li><div>                      foreach ($temp_cw as $p =&gt; $cht) {&nbsp;</div></li><li><div>                          $cw[] = $this-&gt;get255StateCodeword($cht, ($cw_num + $p + 1));&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          } // end of switch enc&nbsp;</div></li><li><div>      } // end of while&nbsp;</div></li><li><div>      return $cw;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places &quot;chr+bit&quot; with appropriate wrapping within array[].&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $row (int) Row number.&nbsp;</div></li><li><div>   * @param $col (int) Column number.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @param $bit (int) Bit.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeModule($marr, $nrow, $ncol, $row, $col, $chr, $bit) {&nbsp;</div></li><li><div>      if ($row &lt; 0) {&nbsp;</div></li><li><div>          $row += $nrow;&nbsp;</div></li><li><div>          $col += (4 - (($nrow + 4) % 8));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ($col &lt; 0) {&nbsp;</div></li><li><div>          $col += $ncol;&nbsp;</div></li><li><div>          $row += (4 - (($ncol + 4) % 8));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $marr[(($row * $ncol) + $col)] = ((10 * $chr) + $bit);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of a utah-shaped symbol character.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $row (int) Row number.&nbsp;</div></li><li><div>   * @param $col (int) Column number.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeUtah($marr, $nrow, $ncol, $row, $col, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-2, $col-2, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-2, $col-1, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-1, $col-2, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-1, $col-1, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-1, $col, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row, $col-2, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row, $col-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row, $col, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the first special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerA($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 1, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 2, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 2, $ncol-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 3, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the second special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerB($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-3, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-2, 0, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-4, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-3, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the third special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerC($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-3, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-2, 0, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 2, $ncol-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 3, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the fourth special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerD($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, $ncol-1, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-3, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-3, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-2, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Build a placement map.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getPlacementMap($nrow, $ncol) {&nbsp;</div></li><li><div>      // initialize array with zeros&nbsp;</div></li><li><div>      $marr = array_fill(0, ($nrow * $ncol), 0);&nbsp;</div></li><li><div>      // set starting values&nbsp;</div></li><li><div>      $chr = 1;&nbsp;</div></li><li><div>      $row = 4;&nbsp;</div></li><li><div>      $col = 0;&nbsp;</div></li><li><div>      do {&nbsp;</div></li><li><div>          // repeatedly first check for one of the special corner cases, then&nbsp;</div></li><li><div>          if (($row == $nrow) AND ($col == 0)) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerA($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (($row == ($nrow - 2)) AND ($col == 0) AND ($ncol % 4)) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerB($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (($row == ($nrow - 2)) AND ($col == 0) AND (($ncol % 8) == 4)) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerC($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (($row == ($nrow + 4)) AND ($col == 2) AND (!($ncol % 8))) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerD($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // sweep upward diagonally, inserting successive characters, &nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              if (($row &lt; $nrow) AND ($col &gt;= 0) AND (!$marr[(($row * $ncol) + $col)])) {&nbsp;</div></li><li><div>                  $marr = $this-&gt;placeUtah($marr, $nrow, $ncol, $row, $col, $chr);&nbsp;</div></li><li><div>                  ++$chr;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $row -= 2;&nbsp;</div></li><li><div>              $col += 2;&nbsp;</div></li><li><div>          } while (($row &gt;= 0) AND ($col &lt; $ncol));&nbsp;</div></li><li><div>          ++$row;&nbsp;</div></li><li><div>          $col += 3;&nbsp;</div></li><li><div>          // & then sweep downward diagonally, inserting successive characters, ...&nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              if (($row &gt;= 0) AND ($col &lt; $ncol) AND (!$marr[(($row * $ncol) + $col)])) {&nbsp;</div></li><li><div>                  $marr = $this-&gt;placeUtah($marr, $nrow, $ncol, $row, $col, $chr);&nbsp;</div></li><li><div>                  ++$chr;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $row += 2;&nbsp;</div></li><li><div>              $col -= 2;&nbsp;</div></li><li><div>          } while (($row &lt; $nrow) AND ($col &gt;= 0));&nbsp;</div></li><li><div>          $row += 3;&nbsp;</div></li><li><div>          ++$col;&nbsp;</div></li><li><div>          // ... until the entire array is scanned&nbsp;</div></li><li><div>      } while (($row &lt; $nrow) OR ($col &lt; $ncol));&nbsp;</div></li><li><div>      // lastly, if the lower righthand corner is untouched, fill in fixed pattern&nbsp;</div></li></ol></pre><pre><ol data-line="51" class="block" start="110"><li><div> @class Datamatrix&nbsp;</div></li><li><div>* Class to create DataMatrix ECC 200 barcode arrays for TCPDF class.&nbsp;</div></li><li><div>* DataMatrix (ISO/IEC 16022:2006) is a 2-dimensional bar code.&nbsp;</div></li><li><div>*&nbsp;</div></li><li><div>* @package com.tecnick.tcpdf&nbsp;</div></li><li><div>* @author Nicola Asuni&nbsp;</div></li><li><div>* @version 3.004&nbsp;</div></li><li><div>*/&nbsp;</div></li><li><div>class Datamatrix {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Barcode array to be returned which is readable by TCPDF.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $barcode_array = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Store last used encoding for data codewords.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $last_enc = ENC_ASCII;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Table of Data Matrix ECC 200 Symbol Attributes:&lt;ul&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix rows (including finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix cols (including finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix rows (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;total matrix cols (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data rows (with finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data col (with finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data rows (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;region data col (without finder pattern)&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;horizontal regions&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;vertical regions&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;regions&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;data codewords&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;error codewords&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;blocks&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;data codewords per block&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;li&gt;error codewords per block&lt;/li&gt;&nbsp;</div></li><li><div>   * &lt;/ul&gt;&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $symbattr = array(&nbsp;</div></li><li><div>      // square form ---------------------------------------------------------------------------------------&nbsp;</div></li><li><div>      array(0x00a, 0x00a, 0x008, 0x008, 0x00a, 0x00a, 0x008, 0x008, 0x001, 0x001, 0x001, 0x003, 0x005, 0x001, 0x003, 0x005), // 10x10&nbsp;</div></li><li><div>      array(0x00c, 0x00c, 0x00a, 0x00a, 0x00c, 0x00c, 0x00a, 0x00a, 0x001, 0x001, 0x001, 0x005, 0x007, 0x001, 0x005, 0x007), // 12x12&nbsp;</div></li><li><div>      array(0x00e, 0x00e, 0x00c, 0x00c, 0x00e, 0x00e, 0x00c, 0x00c, 0x001, 0x001, 0x001, 0x008, 0x00a, 0x001, 0x008, 0x00a), // 14x14&nbsp;</div></li><li><div>      array(0x010, 0x010, 0x00e, 0x00e, 0x010, 0x010, 0x00e, 0x00e, 0x001, 0x001, 0x001, 0x00c, 0x00c, 0x001, 0x00c, 0x00c), // 16x16&nbsp;</div></li><li><div>      array(0x012, 0x012, 0x010, 0x010, 0x012, 0x012, 0x010, 0x010, 0x001, 0x001, 0x001, 0x012, 0x00e, 0x001, 0x012, 0x00e), // 18x18&nbsp;</div></li><li><div>      array(0x014, 0x014, 0x012, 0x012, 0x014, 0x014, 0x012, 0x012, 0x001, 0x001, 0x001, 0x016, 0x012, 0x001, 0x016, 0x012), // 20x20&nbsp;</div></li><li><div>      array(0x016, 0x016, 0x014, 0x014, 0x016, 0x016, 0x014, 0x014, 0x001, 0x001, 0x001, 0x01e, 0x014, 0x001, 0x01e, 0x014), // 22x22&nbsp;</div></li><li><div>      array(0x018, 0x018, 0x016, 0x016, 0x018, 0x018, 0x016, 0x016, 0x001, 0x001, 0x001, 0x024, 0x018, 0x001, 0x024, 0x018), // 24x24&nbsp;</div></li><li><div>      array(0x01a, 0x01a, 0x018, 0x018, 0x01a, 0x01a, 0x018, 0x018, 0x001, 0x001, 0x001, 0x02c, 0x01c, 0x001, 0x02c, 0x01c), // 26x26&nbsp;</div></li><li><div>      array(0x020, 0x020, 0x01c, 0x01c, 0x010, 0x010, 0x00e, 0x00e, 0x002, 0x002, 0x004, 0x03e, 0x024, 0x001, 0x03e, 0x024), // 32x32&nbsp;</div></li><li><div>      array(0x024, 0x024, 0x020, 0x020, 0x012, 0x012, 0x010, 0x010, 0x002, 0x002, 0x004, 0x056, 0x02a, 0x001, 0x056, 0x02a), // 36x36&nbsp;</div></li><li><div>      array(0x028, 0x028, 0x024, 0x024, 0x014, 0x014, 0x012, 0x012, 0x002, 0x002, 0x004, 0x072, 0x030, 0x001, 0x072, 0x030), // 40x40&nbsp;</div></li><li><div>      array(0x02c, 0x02c, 0x028, 0x028, 0x016, 0x016, 0x014, 0x014, 0x002, 0x002, 0x004, 0x090, 0x038, 0x001, 0x090, 0x038), // 44x44&nbsp;</div></li><li><div>      array(0x030, 0x030, 0x02c, 0x02c, 0x018, 0x018, 0x016, 0x016, 0x002, 0x002, 0x004, 0x0ae, 0x044, 0x001, 0x0ae, 0x044), // 48x48&nbsp;</div></li><li><div>      array(0x034, 0x034, 0x030, 0x030, 0x01a, 0x01a, 0x018, 0x018, 0x002, 0x002, 0x004, 0x0cc, 0x054, 0x002, 0x066, 0x02a), // 52x52&nbsp;</div></li><li><div>      array(0x040, 0x040, 0x038, 0x038, 0x010, 0x010, 0x00e, 0x00e, 0x004, 0x004, 0x010, 0x118, 0x070, 0x002, 0x08c, 0x038), // 64x64&nbsp;</div></li><li><div>      array(0x048, 0x048, 0x040, 0x040, 0x012, 0x012, 0x010, 0x010, 0x004, 0x004, 0x010, 0x170, 0x090, 0x004, 0x05c, 0x024), // 72x72&nbsp;</div></li><li><div>      array(0x050, 0x050, 0x048, 0x048, 0x014, 0x014, 0x012, 0x012, 0x004, 0x004, 0x010, 0x1c8, 0x0c0, 0x004, 0x072, 0x030), // 80x80&nbsp;</div></li><li><div>      array(0x058, 0x058, 0x050, 0x050, 0x016, 0x016, 0x014, 0x014, 0x004, 0x004, 0x010, 0x240, 0x0e0, 0x004, 0x090, 0x038), // 88x88&nbsp;</div></li><li><div>      array(0x060, 0x060, 0x058, 0x058, 0x018, 0x018, 0x016, 0x016, 0x004, 0x004, 0x010, 0x2b8, 0x110, 0x004, 0x0ae, 0x044), // 96x96&nbsp;</div></li><li><div>      array(0x068, 0x068, 0x060, 0x060, 0x01a, 0x01a, 0x018, 0x018, 0x004, 0x004, 0x010, 0x330, 0x150, 0x006, 0x088, 0x038), // 104x104&nbsp;</div></li><li><div>      array(0x078, 0x078, 0x06c, 0x06c, 0x014, 0x014, 0x012, 0x012, 0x006, 0x006, 0x024, 0x41a, 0x198, 0x006, 0x0af, 0x044), // 120x120&nbsp;</div></li><li><div>      array(0x084, 0x084, 0x078, 0x078, 0x016, 0x016, 0x014, 0x014, 0x006, 0x006, 0x024, 0x518, 0x1f0, 0x008, 0x0a3, 0x03e), // 132x132&nbsp;</div></li><li><div>      array(0x090, 0x090, 0x084, 0x084, 0x018, 0x018, 0x016, 0x016, 0x006, 0x006, 0x024, 0x616, 0x26c, 0x00a, 0x09c, 0x03e), // 144x144&nbsp;</div></li><li><div>      // rectangular form (currently unused) ---------------------------------------------------------------------------&nbsp;</div></li><li><div>      array(0x008, 0x012, 0x006, 0x010, 0x008, 0x012, 0x006, 0x010, 0x001, 0x001, 0x001, 0x005, 0x007, 0x001, 0x005, 0x007), // 8x18&nbsp;</div></li><li><div>      array(0x008, 0x020, 0x006, 0x01c, 0x008, 0x010, 0x006, 0x00e, 0x001, 0x002, 0x002, 0x00a, 0x00b, 0x001, 0x00a, 0x00b), // 8x32&nbsp;</div></li><li><div>      array(0x00c, 0x01a, 0x00a, 0x018, 0x00c, 0x01a, 0x00a, 0x018, 0x001, 0x001, 0x001, 0x010, 0x00e, 0x001, 0x010, 0x00e), // 12x26&nbsp;</div></li><li><div>      array(0x00c, 0x024, 0x00a, 0x020, 0x00c, 0x012, 0x00a, 0x010, 0x001, 0x002, 0x002, 0x00c, 0x012, 0x001, 0x00c, 0x012), // 12x36&nbsp;</div></li><li><div>      array(0x010, 0x024, 0x00e, 0x020, 0x010, 0x012, 0x00e, 0x010, 0x001, 0x002, 0x002, 0x020, 0x018, 0x001, 0x020, 0x018), // 16x36&nbsp;</div></li><li><div>      array(0x010, 0x030, 0x00e, 0x02c, 0x010, 0x018, 0x00e, 0x016, 0x001, 0x002, 0x002, 0x031, 0x01c, 0x001, 0x031, 0x01c)  // 16x48&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Map encodation modes whit character sets.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $chset_id = array(ENC_C40 =&gt; 'C40', ENC_TXT =&gt; 'TXT', ENC_X12 =&gt;'X12');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Basic set of characters for each encodation mode.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected $chset = array(&nbsp;</div></li><li><div>      'C40' =&gt; array( // Basic set for C40 ----------------------------------------------------------------------------&nbsp;</div></li><li><div>          'S1'=&gt;0x00, 'S2'=&gt;0x01, 'S3'=&gt;0x02, 0x20=&gt;0x03, 0x30=&gt;0x04, 0x31=&gt;0x05, 0x32=&gt;0x06, 0x33=&gt;0x07, 0x34=&gt;0x08, 0x35=&gt;0x09, //&nbsp;</div></li><li><div>          0x36=&gt;0x0a, 0x37=&gt;0x0b, 0x38=&gt;0x0c, 0x39=&gt;0x0d, 0x41=&gt;0x0e, 0x42=&gt;0x0f, 0x43=&gt;0x10, 0x44=&gt;0x11, 0x45=&gt;0x12, 0x46=&gt;0x13, //&nbsp;</div></li><li><div>          0x47=&gt;0x14, 0x48=&gt;0x15, 0x49=&gt;0x16, 0x4a=&gt;0x17, 0x4b=&gt;0x18, 0x4c=&gt;0x19, 0x4d=&gt;0x1a, 0x4e=&gt;0x1b, 0x4f=&gt;0x1c, 0x50=&gt;0x1d, //&nbsp;</div></li><li><div>          0x51=&gt;0x1e, 0x52=&gt;0x1f, 0x53=&gt;0x20, 0x54=&gt;0x21, 0x55=&gt;0x22, 0x56=&gt;0x23, 0x57=&gt;0x24, 0x58=&gt;0x25, 0x59=&gt;0x26, 0x5a=&gt;0x27), //&nbsp;</div></li><li><div>      'TXT' =&gt; array( // Basic set for TEXT ---------------------------------------------------------------------------&nbsp;</div></li><li><div>          'S1'=&gt;0x00, 'S2'=&gt;0x01, 'S3'=&gt;0x02, 0x20=&gt;0x03, 0x30=&gt;0x04, 0x31=&gt;0x05, 0x32=&gt;0x06, 0x33=&gt;0x07, 0x34=&gt;0x08, 0x35=&gt;0x09, //&nbsp;</div></li><li><div>          0x36=&gt;0x0a, 0x37=&gt;0x0b, 0x38=&gt;0x0c, 0x39=&gt;0x0d, 0x61=&gt;0x0e, 0x62=&gt;0x0f, 0x63=&gt;0x10, 0x64=&gt;0x11, 0x65=&gt;0x12, 0x66=&gt;0x13, //&nbsp;</div></li><li><div>          0x67=&gt;0x14, 0x68=&gt;0x15, 0x69=&gt;0x16, 0x6a=&gt;0x17, 0x6b=&gt;0x18, 0x6c=&gt;0x19, 0x6d=&gt;0x1a, 0x6e=&gt;0x1b, 0x6f=&gt;0x1c, 0x70=&gt;0x1d, //&nbsp;</div></li><li><div>          0x71=&gt;0x1e, 0x72=&gt;0x1f, 0x73=&gt;0x20, 0x74=&gt;0x21, 0x75=&gt;0x22, 0x76=&gt;0x23, 0x77=&gt;0x24, 0x78=&gt;0x25, 0x79=&gt;0x26, 0x7a=&gt;0x27), //&nbsp;</div></li><li><div>      'SH1' =&gt; array( // Shift 1 set ----------------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x00=&gt;0x00, 0x01=&gt;0x01, 0x02=&gt;0x02, 0x03=&gt;0x03, 0x04=&gt;0x04, 0x05=&gt;0x05, 0x06=&gt;0x06, 0x07=&gt;0x07, 0x08=&gt;0x08, 0x09=&gt;0x09, //&nbsp;</div></li><li><div>          0x0a=&gt;0x0a, 0x0b=&gt;0x0b, 0x0c=&gt;0x0c, 0x0d=&gt;0x0d, 0x0e=&gt;0x0e, 0x0f=&gt;0x0f, 0x10=&gt;0x10, 0x11=&gt;0x11, 0x12=&gt;0x12, 0x13=&gt;0x13, //&nbsp;</div></li><li><div>          0x14=&gt;0x14, 0x15=&gt;0x15, 0x16=&gt;0x16, 0x17=&gt;0x17, 0x18=&gt;0x18, 0x19=&gt;0x19, 0x1a=&gt;0x1a, 0x1b=&gt;0x1b, 0x1c=&gt;0x1c, 0x1d=&gt;0x1d, //&nbsp;</div></li><li><div>          0x1e=&gt;0x1e, 0x1f=&gt;0x1f), //&nbsp;</div></li><li><div>      'SH2' =&gt; array( // Shift 2 set ----------------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x21=&gt;0x00, 0x22=&gt;0x01, 0x23=&gt;0x02, 0x24=&gt;0x03, 0x25=&gt;0x04, 0x26=&gt;0x05, 0x27=&gt;0x06, 0x28=&gt;0x07, 0x29=&gt;0x08, 0x2a=&gt;0x09, //&nbsp;</div></li><li><div>          0x2b=&gt;0x0a, 0x2c=&gt;0x0b, 0x2d=&gt;0x0c, 0x2e=&gt;0x0d, 0x2f=&gt;0x0e, 0x3a=&gt;0x0f, 0x3b=&gt;0x10, 0x3c=&gt;0x11, 0x3d=&gt;0x12, 0x3e=&gt;0x13, //&nbsp;</div></li><li><div>          0x3f=&gt;0x14, 0x40=&gt;0x15, 0x5b=&gt;0x16, 0x5c=&gt;0x17, 0x5d=&gt;0x18, 0x5e=&gt;0x19, 0x5f=&gt;0x1a, 'F1'=&gt;0x1b, 'US'=&gt;0x1e), //&nbsp;</div></li><li><div>      'S3C' =&gt; array( // Shift 3 set for C40 --------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x60=&gt;0x00, 0x61=&gt;0x01, 0x62=&gt;0x02, 0x63=&gt;0x03, 0x64=&gt;0x04, 0x65=&gt;0x05, 0x66=&gt;0x06, 0x67=&gt;0x07, 0x68=&gt;0x08, 0x69=&gt;0x09, //&nbsp;</div></li><li><div>          0x6a=&gt;0x0a, 0x6b=&gt;0x0b, 0x6c=&gt;0x0c, 0x6d=&gt;0x0d, 0x6e=&gt;0x0e, 0x6f=&gt;0x0f, 0x70=&gt;0x10, 0x71=&gt;0x11, 0x72=&gt;0x12, 0x73=&gt;0x13, //&nbsp;</div></li><li><div>          0x74=&gt;0x14, 0x75=&gt;0x15, 0x76=&gt;0x16, 0x77=&gt;0x17, 0x78=&gt;0x18, 0x79=&gt;0x19, 0x7a=&gt;0x1a, 0x7b=&gt;0x1b, 0x7c=&gt;0x1c, 0x7d=&gt;0x1d, //&nbsp;</div></li><li><div>          0x7e=&gt;0x1e, 0x7f=&gt;0x1f), &nbsp;</div></li><li><div>      'S3T' =&gt; array( // Shift 3 set for TEXT -------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x60=&gt;0x00, 0x41=&gt;0x01, 0x42=&gt;0x02, 0x43=&gt;0x03, 0x44=&gt;0x04, 0x45=&gt;0x05, 0x46=&gt;0x06, 0x47=&gt;0x07, 0x48=&gt;0x08, 0x49=&gt;0x09, //&nbsp;</div></li><li><div>          0x4a=&gt;0x0a, 0x4b=&gt;0x0b, 0x4c=&gt;0x0c, 0x4d=&gt;0x0d, 0x4e=&gt;0x0e, 0x4f=&gt;0x0f, 0x50=&gt;0x10, 0x51=&gt;0x11, 0x52=&gt;0x12, 0x53=&gt;0x13, //&nbsp;</div></li><li><div>          0x54=&gt;0x14, 0x55=&gt;0x15, 0x56=&gt;0x16, 0x57=&gt;0x17, 0x58=&gt;0x18, 0x59=&gt;0x19, 0x5a=&gt;0x1a, 0x7b=&gt;0x1b, 0x7c=&gt;0x1c, 0x7d=&gt;0x1d, //&nbsp;</div></li><li><div>          0x7e=&gt;0x1e, 0x7f=&gt;0x1f), //&nbsp;</div></li><li><div>      'X12' =&gt; array( // Set for X12 ----------------------------------------------------------------------------------&nbsp;</div></li><li><div>          0x0d=&gt;0x00, 0x2a=&gt;0x01, 0x3e=&gt;0x02, 0x20=&gt;0x03, 0x30=&gt;0x04, 0x31=&gt;0x05, 0x32=&gt;0x06, 0x33=&gt;0x07, 0x34=&gt;0x08, 0x35=&gt;0x09, //&nbsp;</div></li><li><div>          0x36=&gt;0x0a, 0x37=&gt;0x0b, 0x38=&gt;0x0c, 0x39=&gt;0x0d, 0x41=&gt;0x0e, 0x42=&gt;0x0f, 0x43=&gt;0x10, 0x44=&gt;0x11, 0x45=&gt;0x12, 0x46=&gt;0x13, //&nbsp;</div></li><li><div>          0x47=&gt;0x14, 0x48=&gt;0x15, 0x49=&gt;0x16, 0x4a=&gt;0x17, 0x4b=&gt;0x18, 0x4c=&gt;0x19, 0x4d=&gt;0x1a, 0x4e=&gt;0x1b, 0x4f=&gt;0x1c, 0x50=&gt;0x1d, //&nbsp;</div></li><li><div>          0x51=&gt;0x1e, 0x52=&gt;0x1f, 0x53=&gt;0x20, 0x54=&gt;0x21, 0x55=&gt;0x22, 0x56=&gt;0x23, 0x57=&gt;0x24, 0x58=&gt;0x25, 0x59=&gt;0x26, 0x5a=&gt;0x27) //&nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>// -----------------------------------------------------------------------------&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * This is the class constructor.&nbsp;</div></li><li><div>   * Creates a datamatrix object&nbsp;</div></li><li><div>   * @param $code (string) Code to represent using Datamatrix.&nbsp;</div></li><li><div>   * @public&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  public function __construct($code) {&nbsp;</div></li><li><div>      $barcode_array = array();&nbsp;</div></li><li><div>      if ((is_null($code)) OR ($code == '\0') OR ($code == '')) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // get data codewords&nbsp;</div></li><li><div>      $cw = $this-&gt;getHighLevelEncoding($code);&nbsp;</div></li><li><div>      // number of data codewords&nbsp;</div></li><li><div>      $nd = count($cw);&nbsp;</div></li><li><div>      // check size&nbsp;</div></li><li><div>      if ($nd &gt; 1558) {&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // get minimum required matrix size.&nbsp;</div></li><li><div>      foreach ($this-&gt;symbattr as $params) {&nbsp;</div></li><li><div>          if ($params[11] &gt;= $nd) {&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ($params[11] &lt; $nd) {&nbsp;</div></li><li><div>          // too much data&nbsp;</div></li><li><div>          return false;&nbsp;</div></li><li><div>      } elseif ($params[11] &gt; $nd) {&nbsp;</div></li><li><div>          // add padding&nbsp;</div></li><li><div>          if ((($params[11] - $nd) &gt; 1) AND ($cw[($nd - 1)] != 254)) {&nbsp;</div></li><li><div>              if ($this-&gt;last_enc == ENC_EDF) {&nbsp;</div></li><li><div>                  // switch to ASCII encoding&nbsp;</div></li><li><div>                  $cw[] = 124;&nbsp;</div></li><li><div>                  ++$nd;&nbsp;</div></li><li><div>              } elseif (($this-&gt;last_enc != ENC_ASCII) AND ($this-&gt;last_enc != ENC_BASE256)) {&nbsp;</div></li><li><div>                  // switch to ASCII encoding&nbsp;</div></li><li><div>                  $cw[] = 254;&nbsp;</div></li><li><div>                  ++$nd;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if ($params[11] &gt; $nd) {&nbsp;</div></li><li><div>              // add first pad&nbsp;</div></li><li><div>              $cw[] = 129;&nbsp;</div></li><li><div>              ++$nd;&nbsp;</div></li><li><div>              // add remaining pads&nbsp;</div></li><li><div>              for ($i = $nd; $i &lt; $params[11]; ++$i) {&nbsp;</div></li><li><div>                  $cw[] = $this-&gt;get253StateCodeword(129, $i);&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // add error correction codewords&nbsp;</div></li><li><div>      $cw = $this-&gt;getErrorCorrection($cw, $params[13], $params[14], $params[15]);&nbsp;</div></li><li><div>      // initialize empty arrays&nbsp;</div></li><li><div>      $grid = array_fill(0, ($params[2] * $params[3]), 0);&nbsp;</div></li><li><div>      // get placement map&nbsp;</div></li><li><div>      $places = $this-&gt;getPlacementMap($params[2], $params[3]);&nbsp;</div></li><li><div>      // fill the grid with data&nbsp;</div></li><li><div>      $grid = array();&nbsp;</div></li><li><div>      $i = 0;&nbsp;</div></li><li><div>      // region data row max index&nbsp;</div></li><li><div>      $rdri = ($params[4] - 1);&nbsp;</div></li><li><div>      // region data column max index&nbsp;</div></li><li><div>      $rdci = ($params[5] - 1);&nbsp;</div></li><li><div>      // for each vertical region&nbsp;</div></li><li><div>      for ($vr = 0; $vr &lt; $params[9]; ++$vr) {&nbsp;</div></li><li><div>          // for each row on region&nbsp;</div></li><li><div>          for ($r = 0; $r &lt; $params[4]; ++$r) {&nbsp;</div></li><li><div>              // get row&nbsp;</div></li><li><div>              $row = (($vr * $params[4]) + $r);&nbsp;</div></li><li><div>              // for each horizontal region&nbsp;</div></li><li><div>              for ($hr = 0; $hr &lt; $params[8]; ++$hr) {&nbsp;</div></li><li><div>                  // for each column on region&nbsp;</div></li><li><div>                  for ($c = 0; $c &lt; $params[5]; ++$c) {&nbsp;</div></li><li><div>                      // get column&nbsp;</div></li><li><div>                      $col = (($hr * $params[5]) + $c);&nbsp;</div></li><li><div>                      // braw bits by case&nbsp;</div></li><li><div>                      if ($r == 0) {&nbsp;</div></li><li><div>                          // top finder pattern&nbsp;</div></li><li><div>                          if ($c % 2) {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 0;&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      } elseif ($r == $rdri) {&nbsp;</div></li><li><div>                          // bottom finder pattern&nbsp;</div></li><li><div>                          $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                      } elseif ($c == 0) {&nbsp;</div></li><li><div>                          // left finder pattern&nbsp;</div></li><li><div>                          $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                      } elseif ($c == $rdci) {&nbsp;</div></li><li><div>                          // right finder pattern&nbsp;</div></li><li><div>                          if ($r % 2) {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 1;&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              $grid[$row][$col] = 0;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      } else { // data bit&nbsp;</div></li><li><div>                          if ($places[$i] &lt; 2) {&nbsp;</div></li><li><div>                              $grid[$row][$col] = $places[$i];&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              // codeword ID&nbsp;</div></li><li><div>                              $cw_id = (floor($places[$i] / 10) - 1);&nbsp;</div></li><li><div>                              // codeword BIT mask&nbsp;</div></li><li><div>                              $cw_bit = pow(2, (8 - ($places[$i] % 10)));&nbsp;</div></li><li><div>                              $grid[$row][$col] = (($cw[$cw_id] & $cw_bit) == 0) ? 0 : 1;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          ++$i;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $this-&gt;barcode_array['num_rows'] = $params[0];&nbsp;</div></li><li><div>      $this-&gt;barcode_array['num_cols'] = $params[1];&nbsp;</div></li><li><div>      $this-&gt;barcode_array['bcode'] = $grid;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Returns a barcode array which is readable by TCPDF&nbsp;</div></li><li><div>   * @return array barcode array readable by TCPDF;&nbsp;</div></li><li><div>   * @public&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  public function getBarcodeArray() {&nbsp;</div></li><li><div>      return $this-&gt;barcode_array;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Product of two numbers in a Power-of-Two Galois Field&nbsp;</div></li><li><div>   * @param $a (int) first number to multiply.&nbsp;</div></li><li><div>   * @param $b (int) second number to multiply.&nbsp;</div></li><li><div>   * @param $log (array) Log table.&nbsp;</div></li><li><div>   * @param $alog (array) Anti-Log table.&nbsp;</div></li><li><div>   * @param $gf (array) Number of Factors of the Reed-Solomon polynomial.&nbsp;</div></li><li><div>   * @return int product&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getGFProduct($a, $b, $log, $alog, $gf) {&nbsp;</div></li><li><div>      if (($a == 0) OR ($b == 0)) {&nbsp;</div></li><li><div>          return 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return ($alog[($log[$a] + $log[$b]) % ($gf - 1)]);&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Add error correction codewords to data codewords array (ANNEX E).&nbsp;</div></li><li><div>   * @param $wd (array) Array of datacodewords.&nbsp;</div></li><li><div>   * @param $nb (int) Number of blocks.&nbsp;</div></li><li><div>   * @param $nd (int) Number of data codewords per block.&nbsp;</div></li><li><div>   * @param $nc (int) Number of correction codewords per block.&nbsp;</div></li><li><div>   * @param $gf (int) numner of fields on log/antilog table (power of 2).&nbsp;</div></li><li><div>   * @param $pp (int) The value of its prime modulus polynomial (301 for ECC200).&nbsp;</div></li><li><div>   * @return array data codewords + error codewords&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getErrorCorrection($wd, $nb, $nd, $nc, $gf=256, $pp=301) {&nbsp;</div></li><li><div>      // generate the log ($log) and antilog ($alog) tables&nbsp;</div></li><li><div>      $log[0] = 0;&nbsp;</div></li><li><div>      $alog[0] = 1;&nbsp;</div></li><li><div>      for ($i = 1; $i &lt; $gf; ++$i) {&nbsp;</div></li><li><div>          $alog[$i] = ($alog[($i - 1)] * 2);&nbsp;</div></li><li><div>          if ($alog[$i] &gt;= $gf) {&nbsp;</div></li><li><div>              $alog[$i] ^= $pp;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $log[$alog[$i]] = $i;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      ksort($log);&nbsp;</div></li><li><div>      // generate the polynomial coefficients (c)&nbsp;</div></li><li><div>      $c = array_fill(0, ($nc + 1), 0);&nbsp;</div></li><li><div>      $c[0] = 1;&nbsp;</div></li><li><div>      for ($i = 1; $i &lt;= $nc; ++$i) {&nbsp;</div></li><li><div>          $c[$i] = $c[($i-1)];&nbsp;</div></li><li><div>          for ($j = ($i - 1); $j &gt;= 1; --$j) {&nbsp;</div></li><li><div>              $c[$j] = $c[($j - 1)] ^ $this-&gt;getGFProduct($c[$j], $alog[$i], $log, $alog, $gf);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          $c[0] = $this-&gt;getGFProduct($c[0], $alog[$i], $log, $alog, $gf);&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      ksort($c);&nbsp;</div></li><li><div>      // total number of data codewords&nbsp;</div></li><li><div>      $num_wd = ($nb * $nd);&nbsp;</div></li><li><div>      // total number of error codewords&nbsp;</div></li><li><div>      $num_we = ($nb * $nc);&nbsp;</div></li><li><div>      // for each block&nbsp;</div></li><li><div>      for ($b = 0; $b &lt; $nb; ++$b) {&nbsp;</div></li><li><div>          // create interleaved data block&nbsp;</div></li><li><div>          $block = array();&nbsp;</div></li><li><div>          for ($n = $b; $n &lt; $num_wd; $n += $nb) {&nbsp;</div></li><li><div>              $block[] = $wd[$n];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // initialize error codewords&nbsp;</div></li><li><div>          $we = array_fill(0, ($nc + 1), 0);&nbsp;</div></li><li><div>          // calculate error correction codewords for this block&nbsp;</div></li><li><div>          for ($i = 0; $i &lt; $nd; ++$i) {&nbsp;</div></li><li><div>              $k = ($we[0] ^ $block[$i]);&nbsp;</div></li><li><div>              for ($j = 0; $j &lt; $nc; ++$j) {&nbsp;</div></li><li><div>                  $we[$j] = ($we[($j + 1)] ^ $this-&gt;getGFProduct($k, $c[($nc - $j - 1)], $log, $alog, $gf));&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // add error codewords at the end of data codewords&nbsp;</div></li><li><div>          $j = 0;&nbsp;</div></li><li><div>          for ($i = $b; $i &lt; $num_we; $i += $nb) {&nbsp;</div></li><li><div>              $wd[($num_wd + $i)] = $we[$j];&nbsp;</div></li><li><div>              ++$j;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      // reorder codewords&nbsp;</div></li><li><div>      ksort($wd);&nbsp;</div></li><li><div>      return $wd;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Return the 253-state codeword&nbsp;</div></li><li><div>   * @param $cwpad (int) Pad codeword.&nbsp;</div></li><li><div>   * @param $cwpos (int) Number of data codewords from the beginning of encoded data.&nbsp;</div></li><li><div>   * @return pad codeword&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function get253StateCodeword($cwpad, $cwpos) {&nbsp;</div></li><li><div>      $pad = ($cwpad + (((149 * $cwpos) % 253) + 1));&nbsp;</div></li><li><div>      if ($pad &gt; 254) {&nbsp;</div></li><li><div>          $pad -= 254;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $pad;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Return the 255-state codeword&nbsp;</div></li><li><div>   * @param $cwpad (int) Pad codeword.&nbsp;</div></li><li><div>   * @param $cwpos (int) Number of data codewords from the beginning of encoded data.&nbsp;</div></li><li><div>   * @return pad codeword&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function get255StateCodeword($cwpad, $cwpos) {&nbsp;</div></li><li><div>      $pad = ($cwpad + (((149 * $cwpos) % 255) + 1));&nbsp;</div></li><li><div>      if ($pad &gt; 255) {&nbsp;</div></li><li><div>          $pad -= 256;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $pad;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Returns true if the char belongs to the selected mode&nbsp;</div></li><li><div>   * @param $chr (int) Character (byte) to check.&nbsp;</div></li><li><div>   * @param $mode (int) Current encoding mode.&nbsp;</div></li><li><div>   * @return boolean true if the char is of the selected mode.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function isCharMode($chr, $mode) {&nbsp;</div></li><li><div>      $status = false;&nbsp;</div></li><li><div>      switch ($mode) {&nbsp;</div></li><li><div>          case ENC_ASCII: { // ASCII character 0 to 127&nbsp;</div></li><li><div>              $status = (($chr &gt;= 0) AND ($chr &lt;= 127));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_C40: { // Upper-case alphanumeric&nbsp;</div></li><li><div>              $status = (($chr == 32) OR (($chr &gt;= 48) AND ($chr &lt;= 57)) OR (($chr &gt;= 65) AND ($chr &lt;= 90)));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_TXT: { // Lower-case alphanumeric&nbsp;</div></li><li><div>              $status = (($chr == 32) OR (($chr &gt;= 48) AND ($chr &lt;= 57)) OR (($chr &gt;= 97) AND ($chr &lt;= 122)));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_X12: { // ANSI X12&nbsp;</div></li><li><div>              $status = (($chr == 13) OR ($chr == 42) OR ($chr == 62));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_EDF: { // ASCII character 32 to 94&nbsp;</div></li><li><div>              $status = (($chr &gt;= 32) AND ($chr &lt;= 94));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_BASE256: { // Function character (FNC1, Structured Append, Reader Program, or Code Page)&nbsp;</div></li><li><div>              $status = (($chr == 232) OR ($chr == 233) OR ($chr == 234) OR ($chr == 241));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_ASCII_EXT: { // ASCII character 128 to 255&nbsp;</div></li><li><div>              $status = (($chr &gt;= 128) AND ($chr &lt;= 255));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_ASCII_NUM: { // ASCII digits&nbsp;</div></li><li><div>              $status = (($chr &gt;= 48) AND ($chr &lt;= 57));&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $status;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * The look-ahead test scans the data to be encoded to find the best mode (Annex P - steps from J to S).&nbsp;</div></li><li><div>   * @param $data (string) data to encode&nbsp;</div></li><li><div>   * @param $pos (int) current position&nbsp;</div></li><li><div>   * @param $mode (int) current encoding mode&nbsp;</div></li><li><div>   * @return int encoding mode&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function lookAheadTest($data, $pos, $mode) {&nbsp;</div></li><li><div>      $data_length = strlen($data);&nbsp;</div></li><li><div>      if ($pos &gt;= $data_length) {&nbsp;</div></li><li><div>          return $mode;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $charscount = 0; // count processed chars&nbsp;</div></li><li><div>      // STEP J&nbsp;</div></li><li><div>      if ($mode == ENC_ASCII) {&nbsp;</div></li><li><div>          $numch = array(0, 1, 1, 1, 1, 1.25);&nbsp;</div></li><li><div>      } else {&nbsp;</div></li><li><div>          $numch = array(1, 2, 2, 2, 2, 2.25);&nbsp;</div></li><li><div>          $numch[$mode] = 0;&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      while (true) {&nbsp;</div></li><li><div>          // STEP K&nbsp;</div></li><li><div>          if (($pos + $charscount) == $data_length) {&nbsp;</div></li><li><div>              if ($numch[ENC_ASCII] &lt;= ceil(min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_ASCII;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_BASE256] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF]))) {&nbsp;</div></li><li><div>                  return ENC_BASE256;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_EDF] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_EDF;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_TXT] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_TXT;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ($numch[ENC_X12] &lt; ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256]))) {&nbsp;</div></li><li><div>                  return ENC_X12;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              return ENC_C40;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // get char&nbsp;</div></li><li><div>          $chr = ord($data[$pos + $charscount]);&nbsp;</div></li><li><div>          $charscount++;&nbsp;</div></li><li><div>          // STEP L&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_ASCII_NUM)) {&nbsp;</div></li><li><div>              $numch[ENC_ASCII] += (1 / 2);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_ASCII] = ceil($numch[ENC_ASCII]);&nbsp;</div></li><li><div>              $numch[ENC_ASCII] += 2;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_ASCII] = ceil($numch[ENC_ASCII]);&nbsp;</div></li><li><div>              $numch[ENC_ASCII] += 1;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP M&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_C40)) {&nbsp;</div></li><li><div>              $numch[ENC_C40] += (2 / 3);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_C40] += (8 / 3);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_C40] += (4 / 3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP N&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_TXT)) {&nbsp;</div></li><li><div>              $numch[ENC_TXT] += (2 / 3);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_TXT] += (8 / 3);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_TXT] += (4 / 3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP O&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_X12) OR $this-&gt;isCharMode($chr, ENC_C40)) {&nbsp;</div></li><li><div>              $numch[ENC_X12] += (2 / 3);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_X12] += (13 / 3);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_X12] += (10 / 3);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP P&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_EDF)) {&nbsp;</div></li><li><div>              $numch[ENC_EDF] += (3 / 4);&nbsp;</div></li><li><div>          } elseif ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>              $numch[ENC_EDF] += (17 / 4);&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_EDF] += (13 / 4);&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP Q&nbsp;</div></li><li><div>          if ($this-&gt;isCharMode($chr, ENC_BASE256)) {&nbsp;</div></li><li><div>              $numch[ENC_BASE256] += 4;&nbsp;</div></li><li><div>          } else {&nbsp;</div></li><li><div>              $numch[ENC_BASE256] += 1;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // STEP R&nbsp;</div></li><li><div>          if ($charscount &gt;= 4) {&nbsp;</div></li><li><div>              if (($numch[ENC_ASCII] + 1) &lt;= min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_ASCII;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if ((($numch[ENC_BASE256] + 1) &lt;= $numch[ENC_ASCII])&nbsp;</div></li><li><div>                  OR (($numch[ENC_BASE256] + 1) &lt; min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF]))) {&nbsp;</div></li><li><div>                  return ENC_BASE256;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_EDF] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_EDF;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_TXT] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_TXT;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_X12] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  return ENC_X12;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              if (($numch[ENC_C40] + 1) &lt; min($numch[ENC_ASCII], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256])) {&nbsp;</div></li><li><div>                  if ($numch[ENC_C40] &lt; $numch[ENC_X12]) {&nbsp;</div></li><li><div>                      return ENC_C40;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  if ($numch[ENC_C40] == $numch[ENC_X12]) {&nbsp;</div></li><li><div>                      $k = ($pos + $charscount + 1);&nbsp;</div></li><li><div>                      while ($k &lt; $data_length) {&nbsp;</div></li><li><div>                          $tmpchr = ord($data{$k});&nbsp;</div></li><li><div>                          if ($this-&gt;isCharMode($tmpchr, ENC_X12)) {&nbsp;</div></li><li><div>                              return ENC_X12;&nbsp;</div></li><li><div>                          } elseif (!($this-&gt;isCharMode($tmpchr, ENC_X12) OR $this-&gt;isCharMode($tmpchr, ENC_C40))) {&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          ++$k;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      return ENC_C40;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      } // end of while&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Get the switching codeword to a new encoding mode (latch codeword)&nbsp;</div></li><li><div>   * @param $mode (int) New encoding mode.&nbsp;</div></li><li><div>   * @return (int) Switch codeword.&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getSwitchEncodingCodeword($mode) {&nbsp;</div></li><li><div>      switch ($mode) {&nbsp;</div></li><li><div>          case ENC_ASCII: { // ASCII character 0 to 127&nbsp;</div></li><li><div>              $cw = 254;&nbsp;</div></li><li><div>              if ($this-&gt;last_enc == ENC_EDF) {&nbsp;</div></li><li><div>                  $cw = 124;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_C40: { // Upper-case alphanumeric&nbsp;</div></li><li><div>              $cw = 230;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_TXT: { // Lower-case alphanumeric&nbsp;</div></li><li><div>              $cw = 239;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_X12: { // ANSI X12&nbsp;</div></li><li><div>              $cw = 238;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_EDF: { // ASCII character 32 to 94&nbsp;</div></li><li><div>              $cw = 240;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          case ENC_BASE256: { // Function character (FNC1, Structured Append, Reader Program, or Code Page)&nbsp;</div></li><li><div>              $cw = 231;&nbsp;</div></li><li><div>              break;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return $cw;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Choose the minimum matrix size and return the max number of data codewords.&nbsp;</div></li><li><div>   * @param $numcw (int) Number of current codewords.&nbsp;</div></li><li><div>   * @return number of data codewords in matrix&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getMaxDataCodewords($numcw) {&nbsp;</div></li><li><div>      foreach ($this-&gt;symbattr as $key =&gt; $matrix) {&nbsp;</div></li><li><div>          if ($matrix[11] &gt;= $numcw) {&nbsp;</div></li><li><div>              return $matrix[11];&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      return 0;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Get high level encoding using the minimum symbol data characters for ECC 200&nbsp;</div></li><li><div>   * @param $data (string) data to encode&nbsp;</div></li><li><div>   * @return array of codewords&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getHighLevelEncoding($data) {&nbsp;</div></li><li><div>      // STEP A. Start in ASCII encodation.&nbsp;</div></li><li><div>      $enc = ENC_ASCII; // current encoding mode&nbsp;</div></li><li><div>      $pos = 0; // current position&nbsp;</div></li><li><div>      $cw = array(); // array of codewords to be returned&nbsp;</div></li><li><div>      $cw_num = 0; // number of data codewords&nbsp;</div></li><li><div>      $data_lenght = strlen($data); // number of chars&nbsp;</div></li><li><div>      while ($pos &lt; $data_lenght) {&nbsp;</div></li><li><div>          // set last used encoding&nbsp;</div></li><li><div>          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>          switch ($enc) {&nbsp;</div></li><li><div>              case ENC_ASCII: { // STEP B. While in ASCII encodation&nbsp;</div></li><li><div>                  if (($data_lenght &gt; 1) AND ($pos &lt; ($data_lenght - 1)) AND ($this-&gt;isCharMode(ord($data[$pos]), ENC_ASCII_NUM) AND $this-&gt;isCharMode(ord($data[$pos + 1]), ENC_ASCII_NUM))) {&nbsp;</div></li><li><div>                      // 1. If the next data sequence is at least 2 consecutive digits, encode the next two digits as a double digit in ASCII mode.&nbsp;</div></li><li><div>                      $cw[] = (intval(substr($data, $pos, 2)) + 130);&nbsp;</div></li><li><div>                      ++$cw_num;&nbsp;</div></li><li><div>                      $pos += 2;&nbsp;</div></li><li><div>                  } else {&nbsp;</div></li><li><div>                      // 2. If the look-ahead test (starting at step J) indicates another mode, switch to that mode.&nbsp;</div></li><li><div>                      $newenc = $this-&gt;lookAheadTest($data, $pos, $enc);&nbsp;</div></li><li><div>                      if ($newenc != $enc) {&nbsp;</div></li><li><div>                          // switch to new encoding&nbsp;</div></li><li><div>                          $enc = $newenc;&nbsp;</div></li><li><div>                          $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                          ++$cw_num;&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          // get new byte&nbsp;</div></li><li><div>                          $chr = ord($data[$pos]);&nbsp;</div></li><li><div>                          ++$pos;&nbsp;</div></li><li><div>                          if ($this-&gt;isCharMode($chr, ENC_ASCII_EXT)) {&nbsp;</div></li><li><div>                              // 3. If the next data character is extended ASCII (greater than 127) encode it in ASCII mode first using the Upper Shift (value 235) character.&nbsp;</div></li><li><div>                              $cw[] = 235;&nbsp;</div></li><li><div>                              $cw[] = ($chr - 127);&nbsp;</div></li><li><div>                              $cw_num += 2;&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              // 4. Otherwise process the next data character in ASCII encodation.&nbsp;</div></li><li><div>                              $cw[] = ($chr + 1);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              case ENC_C40 :   // Upper-case alphanumeric&nbsp;</div></li><li><div>              case ENC_TXT :   // Lower-case alphanumeric&nbsp;</div></li><li><div>              case ENC_X12 : { // ANSI X12&nbsp;</div></li><li><div>                  $temp_cw = array();&nbsp;</div></li><li><div>                  $p = 0;&nbsp;</div></li><li><div>                  $epos = $pos;&nbsp;</div></li><li><div>                  // get charset ID&nbsp;</div></li><li><div>                  $set_id = $this-&gt;chset_id[$enc];&nbsp;</div></li><li><div>                  // get basic charset for current encoding&nbsp;</div></li><li><div>                  $charset = $this-&gt;chset[$set_id];&nbsp;</div></li><li><div>                  do {&nbsp;</div></li><li><div>                      // 2. process the next character in C40 encodation.&nbsp;</div></li><li><div>                      $chr = ord($data[$epos]);&nbsp;</div></li><li><div>                      ++$epos;&nbsp;</div></li><li><div>                      // check for extended character&nbsp;</div></li><li><div>                      if ($chr & 0x80) {&nbsp;</div></li><li><div>                          if ($enc == ENC_X12) {&nbsp;</div></li><li><div>                              return false;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $chr = ($chr & 0x7f);&nbsp;</div></li><li><div>                          $temp_cw[] = 1; // shift 2&nbsp;</div></li><li><div>                          $temp_cw[] = 30; // upper shift&nbsp;</div></li><li><div>                          $p += 2;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      if (isset($charset[$chr])) {&nbsp;</div></li><li><div>                          $temp_cw[] = $charset[$chr];&nbsp;</div></li><li><div>                          ++$p;&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          if (isset($this-&gt;chset['SH1'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 0; // shift 1&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['SH1'];&nbsp;</div></li><li><div>                          } elseif (isset($chr, $this-&gt;chset['SH2'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 1; // shift 2&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['SH2'];&nbsp;</div></li><li><div>                          } elseif (($enc == ENC_C40) AND isset($this-&gt;chset['S3C'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 2; // shift 3&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['S3C'];&nbsp;</div></li><li><div>                          } elseif (($enc == ENC_TXT) AND isset($this-&gt;chset['S3T'][$chr])) {&nbsp;</div></li><li><div>                              $temp_cw[] = 2; // shift 3&nbsp;</div></li><li><div>                              $shiftset = $this-&gt;chset['S3T'];&nbsp;</div></li><li><div>                          } else {&nbsp;</div></li><li><div>                              return false;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $temp_cw[] = $shiftset[$chr];&nbsp;</div></li><li><div>                          $p += 2;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      if ($p &gt;= 3) {&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $c2 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $c3 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $p -= 3;&nbsp;</div></li><li><div>                          $tmp = ((1600 * $c1) + (40 * $c2) + $c3 + 1);&nbsp;</div></li><li><div>                          $cw[] = ($tmp &gt;&gt; 8);&nbsp;</div></li><li><div>                          $cw[] = ($tmp % 256);&nbsp;</div></li><li><div>                          $cw_num += 2;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          // 1. If the C40 encoding is at the point of starting a new double symbol character and if the look-ahead test (starting at step J) indicates another mode, switch to that mode.&nbsp;</div></li><li><div>                          $newenc = $this-&gt;lookAheadTest($data, $pos, $enc);&nbsp;</div></li><li><div>                          if ($newenc != $enc) {&nbsp;</div></li><li><div>                              // switch to new encoding&nbsp;</div></li><li><div>                              $enc = $newenc;&nbsp;</div></li><li><div>                              if ($enc != ENC_ASCII) {&nbsp;</div></li><li><div>                                  // set unlatch character&nbsp;</div></li><li><div>                                  $cw[] = $this-&gt;getSwitchEncodingCodeword(ENC_ASCII);&nbsp;</div></li><li><div>                                  ++$cw_num;&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>                              $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                              $pos -= $p;&nbsp;</div></li><li><div>                              $p = 0;&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  } while (($p &gt; 0) AND ($epos &lt; $data_lenght));&nbsp;</div></li><li><div>                  // process last data (if any)&nbsp;</div></li><li><div>                  if ($p &gt; 0) {&nbsp;</div></li><li><div>                      // get remaining number of data symbols&nbsp;</div></li><li><div>                      $cwr = ($this-&gt;getMaxDataCodewords($cw_num) - $cw_num);&nbsp;</div></li><li><div>                      if (($cwr == 1) AND ($p == 1)) {&nbsp;</div></li><li><div>                          // d. If one symbol character remains and one C40 value (data character) remains to be encoded&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          --$p;&nbsp;</div></li><li><div>                          $cw[] = ($chr + 1);&nbsp;</div></li><li><div>                          ++$cw_num;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $enc = ENC_ASCII;&nbsp;</div></li><li><div>                          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                      } elseif (($cwr == 2) AND ($p == 1)) {&nbsp;</div></li><li><div>                          // c. If two symbol characters remain and only one C40 value (data character) remains to be encoded&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          --$p;&nbsp;</div></li><li><div>                          $cw[] = 254;&nbsp;</div></li><li><div>                          $cw[] = ($chr + 1);&nbsp;</div></li><li><div>                          $cw_num += 2;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $enc = ENC_ASCII;&nbsp;</div></li><li><div>                          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                      } elseif (($cwr == 2) AND ($p == 2)) {&nbsp;</div></li><li><div>                          // b. If two symbol characters remain and two C40 values remain to be encoded&nbsp;</div></li><li><div>                          $c1 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $c2 = array_shift($temp_cw);&nbsp;</div></li><li><div>                          $p -= 2;&nbsp;</div></li><li><div>                          $tmp = ((1600 * $c1) + (40 * $c2) + 1);&nbsp;</div></li><li><div>                          $cw[] = ($tmp &gt;&gt; 8);&nbsp;</div></li><li><div>                          $cw[] = ($tmp % 256);&nbsp;</div></li><li><div>                          $cw_num += 2;&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $enc = ENC_ASCII;&nbsp;</div></li><li><div>                          $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          // switch to ASCII encoding&nbsp;</div></li><li><div>                          if ($enc != ENC_ASCII) {&nbsp;</div></li><li><div>                              $enc = ENC_ASCII;&nbsp;</div></li><li><div>                              $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                              $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                              $pos = ($epos - $p);&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              case ENC_EDF: { // F. While in EDIFACT (EDF) encodation&nbsp;</div></li><li><div>                  // initialize temporary array with 0 lenght&nbsp;</div></li><li><div>                  $temp_cw = array();&nbsp;</div></li><li><div>                  $epos = $pos;&nbsp;</div></li><li><div>                  $field_lenght = 0;&nbsp;</div></li><li><div>                  $newenc = $enc;&nbsp;</div></li><li><div>                  do {&nbsp;</div></li><li><div>                      // 2. process the next character in EDIFACT encodation.&nbsp;</div></li><li><div>                      $chr = ord($data[$epos]);&nbsp;</div></li><li><div>                      if ($this-&gt;isCharMode($chr, ENC_EDF)) {&nbsp;</div></li><li><div>                          ++$epos;&nbsp;</div></li><li><div>                          $temp_cw[] = $chr;&nbsp;</div></li><li><div>                          ++$field_lenght;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                      if (($field_lenght == 4) OR ($epos == $data_lenght) OR !$this-&gt;isCharMode($chr, ENC_EDF)) {&nbsp;</div></li><li><div>                          if (($epos == $data_lenght) AND ($field_lenght &lt; 3)) {&nbsp;</div></li><li><div>                              $enc = ENC_ASCII;&nbsp;</div></li><li><div>                              $cw[] = $this-&gt;getSwitchEncodingCodeword($enc);&nbsp;</div></li><li><div>                              ++$cw_num;&nbsp;</div></li><li><div>                              break;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          if ($field_lenght &lt; 4) {&nbsp;</div></li><li><div>                              // set unlatch character&nbsp;</div></li><li><div>                              $temp_cw[] = 0x1f;&nbsp;</div></li><li><div>                              ++$field_lenght;&nbsp;</div></li><li><div>                              // fill empty characters&nbsp;</div></li><li><div>                              for ($i = $field_lenght; $i &lt; 4; ++$i) {&nbsp;</div></li><li><div>                                  $temp_cw[] = 0;&nbsp;</div></li><li><div>                              }&nbsp;</div></li><li><div>                              $enc = ENC_ASCII;&nbsp;</div></li><li><div>                              $this-&gt;last_enc = $enc;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          // encodes four data characters in three codewords&nbsp;</div></li><li><div>                          $tcw = (($temp_cw[0] & 0x3F) &lt;&lt; 2) + (($temp_cw[1] & 0x30) &gt;&gt; 4);&nbsp;</div></li><li><div>                          if ($tcw &gt; 0) {&nbsp;</div></li><li><div>                              $cw[] = $tcw;&nbsp;</div></li><li><div>                              $cw_num++;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $tcw= (($temp_cw[1] & 0x0F) &lt;&lt; 4) + (($temp_cw[2] & 0x3C) &gt;&gt; 2);&nbsp;</div></li><li><div>                          if ($tcw &gt; 0) {&nbsp;</div></li><li><div>                              $cw[] = $tcw;&nbsp;</div></li><li><div>                              $cw_num++;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $tcw = (($temp_cw[2] & 0x03) &lt;&lt; 6) + ($temp_cw[3] & 0x3F);&nbsp;</div></li><li><div>                          if ($tcw &gt; 0) {&nbsp;</div></li><li><div>                              $cw[] = $tcw;&nbsp;</div></li><li><div>                              $cw_num++;&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                          $temp_cw = array();&nbsp;</div></li><li><div>                          $pos = $epos;&nbsp;</div></li><li><div>                          $field_lenght = 0;&nbsp;</div></li><li><div>                          if ($enc == ENC_ASCII) {&nbsp;</div></li><li><div>                              break; // exit from EDIFACT mode&nbsp;</div></li><li><div>                          }&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  } while ($epos &lt; $data_lenght);&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              case ENC_BASE256: { // G. While in Base 256 (B256) encodation&nbsp;</div></li><li><div>                  // initialize temporary array with 0 lenght&nbsp;</div></li><li><div>                  $temp_cw = array();&nbsp;</div></li><li><div>                  $field_lenght = 0;&nbsp;</div></li><li><div>                  while (($pos &lt; $data_lenght) AND ($field_lenght &lt;= 1555)) {&nbsp;</div></li><li><div>                      $newenc = $this-&gt;lookAheadTest($data, $pos, $enc);&nbsp;</div></li><li><div>                      if ($newenc != $enc) {&nbsp;</div></li><li><div>                          // 1. If the look-ahead test (starting at step J) indicates another mode, switch to that mode.&nbsp;</div></li><li><div>                          $enc = $newenc;&nbsp;</div></li><li><div>                          break; // exit from B256 mode&nbsp;</div></li><li><div>                      } else {&nbsp;</div></li><li><div>                          // 2. Otherwise, process the next character in Base 256 encodation.&nbsp;</div></li><li><div>                          $chr = ord($data[$pos]);&nbsp;</div></li><li><div>                          ++$pos;&nbsp;</div></li><li><div>                          $temp_cw[] = $chr;&nbsp;</div></li><li><div>                          ++$field_lenght;&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  // set field lenght&nbsp;</div></li><li><div>                  if ($field_lenght &lt;= 249) {&nbsp;</div></li><li><div>                      $cw[] = $this-&gt;get255StateCodeword($field_lenght, ($cw_num + 1));&nbsp;</div></li><li><div>                      ++$cw_num;&nbsp;</div></li><li><div>                  } else {&nbsp;</div></li><li><div>                      $cw[] = $this-&gt;get255StateCodeword((floor($field_lenght / 250) + 249), ($cw_num + 1));&nbsp;</div></li><li><div>                      $cw[] = $this-&gt;get255StateCodeword(($field_lenght % 250), ($cw_num + 2));&nbsp;</div></li><li><div>                      $cw_num += 2;&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  if (!empty($temp_cw)) {&nbsp;</div></li><li><div>                      // add B256 field&nbsp;</div></li><li><div>                      foreach ($temp_cw as $p =&gt; $cht) {&nbsp;</div></li><li><div>                          $cw[] = $this-&gt;get255StateCodeword($cht, ($cw_num + $p + 1));&nbsp;</div></li><li><div>                      }&nbsp;</div></li><li><div>                  }&nbsp;</div></li><li><div>                  break;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>          } // end of switch enc&nbsp;</div></li><li><div>      } // end of while&nbsp;</div></li><li><div>      return $cw;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places &quot;chr+bit&quot; with appropriate wrapping within array[].&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $row (int) Row number.&nbsp;</div></li><li><div>   * @param $col (int) Column number.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @param $bit (int) Bit.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeModule($marr, $nrow, $ncol, $row, $col, $chr, $bit) {&nbsp;</div></li><li><div>      if ($row &lt; 0) {&nbsp;</div></li><li><div>          $row += $nrow;&nbsp;</div></li><li><div>          $col += (4 - (($nrow + 4) % 8));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      if ($col &lt; 0) {&nbsp;</div></li><li><div>          $col += $ncol;&nbsp;</div></li><li><div>          $row += (4 - (($ncol + 4) % 8));&nbsp;</div></li><li><div>      }&nbsp;</div></li><li><div>      $marr[(($row * $ncol) + $col)] = ((10 * $chr) + $bit);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of a utah-shaped symbol character.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $row (int) Row number.&nbsp;</div></li><li><div>   * @param $col (int) Column number.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeUtah($marr, $nrow, $ncol, $row, $col, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-2, $col-2, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-2, $col-1, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-1, $col-2, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-1, $col-1, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row-1, $col, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row, $col-2, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row, $col-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $row, $col, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the first special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerA($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 1, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 2, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 2, $ncol-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 3, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the second special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerB($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-3, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-2, 0, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-4, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-3, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the third special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerC($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-3, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-2, 0, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 2, $ncol-1, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 3, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Places the 8 bits of the fourth special corner case.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $marr (array) Array of symbols.&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @param $chr (int) Char byte.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function placeCornerD($marr, $nrow, $ncol, $chr) {&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, 0, $chr, 1);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, $nrow-1, $ncol-1, $chr, 2);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-3, $chr, 3);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-2, $chr, 4);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 0, $ncol-1, $chr, 5);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-3, $chr, 6);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-2, $chr, 7);&nbsp;</div></li><li><div>      $marr = $this-&gt;placeModule($marr, $nrow, $ncol, 1, $ncol-1, $chr, 8);&nbsp;</div></li><li><div>      return $marr;&nbsp;</div></li><li><div>  }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>  /**&nbsp;</div></li><li><div>   * Build a placement map.&nbsp;</div></li><li><div>   * (Annex F - ECC 200 symbol character placement)&nbsp;</div></li><li><div>   * @param $nrow (int) Number of rows.&nbsp;</div></li><li><div>   * @param $ncol (int) Number of columns.&nbsp;</div></li><li><div>   * @return array&nbsp;</div></li><li><div>   * @protected&nbsp;</div></li><li><div>   */&nbsp;</div></li><li><div>  protected function getPlacementMap($nrow, $ncol) {&nbsp;</div></li><li><div>      // initialize array with zeros&nbsp;</div></li><li><div>      $marr = array_fill(0, ($nrow * $ncol), 0);&nbsp;</div></li><li><div>      // set starting values&nbsp;</div></li><li><div>      $chr = 1;&nbsp;</div></li><li><div>      $row = 4;&nbsp;</div></li><li><div>      $col = 0;&nbsp;</div></li><li><div>      do {&nbsp;</div></li><li><div>          // repeatedly first check for one of the special corner cases, then&nbsp;</div></li><li><div>          if (($row == $nrow) AND ($col == 0)) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerA($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (($row == ($nrow - 2)) AND ($col == 0) AND ($ncol % 4)) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerB($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (($row == ($nrow - 2)) AND ($col == 0) AND (($ncol % 8) == 4)) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerC($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          if (($row == ($nrow + 4)) AND ($col == 2) AND (!($ncol % 8))) {&nbsp;</div></li><li><div>              $marr = $this-&gt;placeCornerD($marr, $nrow, $ncol, $chr);&nbsp;</div></li><li><div>              ++$chr;&nbsp;</div></li><li><div>          }&nbsp;</div></li><li><div>          // sweep upward diagonally, inserting successive characters, &nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              if (($row &lt; $nrow) AND ($col &gt;= 0) AND (!$marr[(($row * $ncol) + $col)])) {&nbsp;</div></li><li><div>                  $marr = $this-&gt;placeUtah($marr, $nrow, $ncol, $row, $col, $chr);&nbsp;</div></li><li><div>                  ++$chr;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $row -= 2;&nbsp;</div></li><li><div>              $col += 2;&nbsp;</div></li><li><div>          } while (($row &gt;= 0) AND ($col &lt; $ncol));&nbsp;</div></li><li><div>          ++$row;&nbsp;</div></li><li><div>          $col += 3;&nbsp;</div></li><li><div>          // & then sweep downward diagonally, inserting successive characters, ...&nbsp;</div></li><li><div>          do {&nbsp;</div></li><li><div>              if (($row &gt;= 0) AND ($col &lt; $ncol) AND (!$marr[(($row * $ncol) + $col)])) {&nbsp;</div></li><li><div>                  $marr = $this-&gt;placeUtah($marr, $nrow, $ncol, $row, $col, $chr);&nbsp;</div></li><li><div>                  ++$chr;&nbsp;</div></li><li><div>              }&nbsp;</div></li><li><div>              $row += 2;&nbsp;</div></li><li><div>              $col -= 2;&nbsp;</div></li><li><div>          } while (($row &lt; $nrow) AND ($col &gt;= 0));&nbsp;</div></li><li><div>          $row += 3;&nbsp;</div></li><li><div>          ++$col;&nbsp;</div></li><li><div>          // ... until the entire array is scanned&nbsp;</div></li><li><div>      } while (($row &lt; $nrow) OR ($col &lt; $ncol));&nbsp;</div></li><li><div>      // lastly, if the lower righthand corner is untouched, fill in fixed pattern&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 2.0</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.3/classes/datamatrix/" class="active">2.3</a></li><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.2/classes/datamatrix/" class="">2.2</a></li><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.1/classes/datamatrix/" class="">2.1</a></li><li><a href="http://hookr.io/plugins/woocommerce-products-designer/2.0/classes/datamatrix/" class="">2.0</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>plugin</li><li><span></span>class</li><li><span></span>Datamatrix</li><li><span></span>Woocommerce Products Designer</li><li><span></span>2.3</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2018 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>