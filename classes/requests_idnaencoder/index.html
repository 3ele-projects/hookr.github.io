<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="wordpress" data-type="class" data-id="3313"><head xmlns="http://www.w3.org/1999/xhtml"><title> requests_idnaencoder | class | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="Requests_IDNAEncoder, class, wordpress, 4.7.4" /><meta name="description" content="IDNA URL encoder" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.25"}};!function(e,n,t){var a;function i(e){var t=n.createElement("canvas"),a=t.getContext&&t.getContext("2d"),i=String.fromCharCode;return!(!a||!a.fillText)&&(a.textBaseline="top",a.font="600 32px Arial","flag"===e?(a.fillText(i(55356,56806,55356,56826),0,0),3e3<t.toDataURL().length):"diversity"===e?(a.fillText(i(55356,57221),0,0),t=a.getImageData(16,16,1,1).data,a.fillText(i(55356,57221,55356,57343),0,0),(t=a.getImageData(16,16,1,1).data)[0],t[1],t[2],t[3],!0):("simple"===e?a.fillText(i(55357,56835),0,0):a.fillText(i(55356,57135),0,0),0!==a.getImageData(16,16,1,1).data[0]))}function o(e){var t=n.createElement("script");t.src=e,t.type="text/javascript",n.getElementsByTagName("head")[0].appendChild(t)}t.supports={simple:i("simple"),flag:i("flag"),unicode8:i("unicode8"),diversity:i("diversity")},t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.simple&&t.supports.flag&&t.supports.unicode8&&t.supports.diversity||(a=function(){t.readyCallback()},n.addEventListener?(n.addEventListener("DOMContentLoaded",a,!1),e.addEventListener("load",a,!1)):(e.attachEvent("onload",a),n.attachEvent("onreadystatechange",function(){"complete"===n.readyState&&t.readyCallback()})),(a=t.source||{}).concatemoji?o(a.concatemoji):a.wpemoji&&a.twemoji&&(o(a.twemoji),o(a.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=a02094eb77e1225bbfe8e06afc5fbeed' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.25' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/requests_idnaencoder/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Frequests_idnaencoder%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Frequests_idnaencoder%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-class-requests_idnaencoder","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="requests_idnaencoder" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="http://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/4.7.4/classes/" class=""><span property="name">classes</span></a><meta property="position" content="3"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">requests_idnaencoder</span><meta property="position" content="4"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="http://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="http://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="http://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="http://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="active" data-id="class" data-count="351"><a href="http://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="http://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>Requests_IDNAEncoder</strong></h1><p>IDNA URL encoder.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/4.7.4/files/wp-includes-requests-idnaencoder/" class="file">/wp-includes/Requests/IDNAEncoder.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="13" class="block" start="13"><li><div>class Requests_IDNAEncoder {&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * ACE prefix used for IDNA&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see https://tools.ietf.org/html/rfc3490#section-5&nbsp;</div></li><li><div>     * @var string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const ACE_PREFIX = 'xn--';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**#@+&nbsp;</div></li><li><div>     * Bootstrap constant for Punycode&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see https://tools.ietf.org/html/rfc3492#section-5&nbsp;</div></li><li><div>     * @var int&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    const BOOTSTRAP_BASE = 36;&nbsp;</div></li><li><div>    const BOOTSTRAP_TMIN = 1;&nbsp;</div></li><li><div>    const BOOTSTRAP_TMAX = 26;&nbsp;</div></li><li><div>    const BOOTSTRAP_SKEW = 38;&nbsp;</div></li><li><div>    const BOOTSTRAP_DAMP = 700;&nbsp;</div></li><li><div>    const BOOTSTRAP_INITIAL_BIAS = 72;&nbsp;</div></li><li><div>    const BOOTSTRAP_INITIAL_N = 128;&nbsp;</div></li><li><div>    /**#@-*/&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Encode a hostname using Punycode&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $string Hostname&nbsp;</div></li><li><div>     * @return string Punycode-encoded hostname&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function encode($string) {&nbsp;</div></li><li><div>        $parts = explode('.', $string);&nbsp;</div></li><li><div>        foreach ($parts as &$part) {&nbsp;</div></li><li><div>            $part = self::to_ascii($part);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return implode('.', $parts);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Convert a UTF-8 string to an ASCII string using Punycode&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @throws Requests_Exception Provided string longer than 64 ASCII characters (`idna.provided_too_long`)&nbsp;</div></li><li><div>     * @throws Requests_Exception Prepared string longer than 64 ASCII characters (`idna.prepared_too_long`)&nbsp;</div></li><li><div>     * @throws Requests_Exception Provided string already begins with xn-- (`idna.provided_is_prefixed`)&nbsp;</div></li><li><div>     * @throws Requests_Exception Encoded string longer than 64 ASCII characters (`idna.encoded_too_long`)&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $string ASCII or UTF-8 string (max length 64 characters)&nbsp;</div></li><li><div>     * @return string ASCII string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function to_ascii($string) {&nbsp;</div></li><li><div>        // Step 1: Check if the string is already ASCII&nbsp;</div></li><li><div>        if (self::is_ascii($string)) {&nbsp;</div></li><li><div>            // Skip to step 7&nbsp;</div></li><li><div>            if (strlen($string) &lt; 64) {&nbsp;</div></li><li><div>                return $string;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            throw new Requests_Exception('Provided string is too long', 'idna.provided_too_long', $string);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Step 2: nameprep&nbsp;</div></li><li><div>        $string = self::nameprep($string);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Step 3: UseSTD3ASCIIRules is false, continue&nbsp;</div></li><li><div>        // Step 4: Check if it's ASCII now&nbsp;</div></li><li><div>        if (self::is_ascii($string)) {&nbsp;</div></li><li><div>            // Skip to step 7&nbsp;</div></li><li><div>            if (strlen($string) &lt; 64) {&nbsp;</div></li><li><div>                return $string;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            throw new Requests_Exception('Prepared string is too long', 'idna.prepared_too_long', $string);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Step 5: Check ACE prefix&nbsp;</div></li><li><div>        if (strpos($string, self::ACE_PREFIX) === 0) {&nbsp;</div></li><li><div>            throw new Requests_Exception('Provided string begins with ACE prefix', 'idna.provided_is_prefixed', $string);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Step 6: Encode with Punycode&nbsp;</div></li><li><div>        $string = self::punycode_encode($string);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Step 7: Prepend ACE prefix&nbsp;</div></li><li><div>        $string = self::ACE_PREFIX . $string;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Step 8: Check size&nbsp;</div></li><li><div>        if (strlen($string) &lt; 64) {&nbsp;</div></li><li><div>            return $string;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        throw new Requests_Exception('Encoded string is too long', 'idna.encoded_too_long', $string);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Check whether a given string contains only ASCII characters&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @internal (Testing found regex was the fastest implementation)&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $string&nbsp;</div></li><li><div>     * @return bool Is the string ASCII-only?&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected static function is_ascii($string) {&nbsp;</div></li><li><div>        return (preg_match('/(?:[^\x00-\x7F])/', $string) !== 1);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Prepare a string for use as an IDNA name&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @todo Implement this based on RFC 3491 and the newer 5891&nbsp;</div></li><li><div>     * @param string $string&nbsp;</div></li><li><div>     * @return string Prepared string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected static function nameprep($string) {&nbsp;</div></li><li><div>        return $string;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Convert a UTF-8 string to a UCS-4 codepoint array&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Based on Requests_IRI::replace_invalid_with_pct_encoding()&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @throws Requests_Exception Invalid UTF-8 codepoint (`idna.invalidcodepoint`)&nbsp;</div></li><li><div>     * @param string $input&nbsp;</div></li><li><div>     * @return array Unicode code points&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected static function utf8_to_codepoints($input) {&nbsp;</div></li><li><div>        $codepoints = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Get number of bytes&nbsp;</div></li><li><div>        $strlen = strlen($input);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        for ($position = 0; $position &lt; $strlen; $position++) {&nbsp;</div></li><li><div>            $value = ord($input[$position]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // One byte sequence:&nbsp;</div></li><li><div>            if ((~$value & 0x80) === 0x80) {&nbsp;</div></li><li><div>                $character = $value;&nbsp;</div></li><li><div>                $length = 1;&nbsp;</div></li><li><div>                $remaining = 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Two byte sequence:&nbsp;</div></li><li><div>            elseif (($value & 0xE0) === 0xC0) {&nbsp;</div></li><li><div>                $character = ($value & 0x1F) &lt;&lt; 6;&nbsp;</div></li><li><div>                $length = 2;&nbsp;</div></li><li><div>                $remaining = 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Three byte sequence:&nbsp;</div></li><li><div>            elseif (($value & 0xF0) === 0xE0) {&nbsp;</div></li><li><div>                $character = ($value & 0x0F) &lt;&lt; 12;&nbsp;</div></li><li><div>                $length = 3;&nbsp;</div></li><li><div>                $remaining = 2;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Four byte sequence:&nbsp;</div></li><li><div>            elseif (($value & 0xF8) === 0xF0) {&nbsp;</div></li><li><div>                $character = ($value & 0x07) &lt;&lt; 18;&nbsp;</div></li><li><div>                $length = 4;&nbsp;</div></li><li><div>                $remaining = 3;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Invalid byte:&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $value);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ($remaining &gt; 0) {&nbsp;</div></li><li><div>                if ($position + $length &gt; $strlen) {&nbsp;</div></li><li><div>                    throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $character);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                for ($position++; $remaining &gt; 0; $position++) {&nbsp;</div></li><li><div>                    $value = ord($input[$position]);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    // If it is invalid, count the sequence as invalid and reprocess the current byte:&nbsp;</div></li><li><div>                    if (($value & 0xC0) !== 0x80) {&nbsp;</div></li><li><div>                        throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $character);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                    $character |= ($value & 0x3F) &lt;&lt; (--$remaining * 6);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $position--;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if (&nbsp;</div></li><li><div>                // Non-shortest form sequences are invalid&nbsp;</div></li><li><div>                   $length &gt; 1 && $character &lt;= 0x7F&nbsp;</div></li><li><div>                || $length &gt; 2 && $character &lt;= 0x7FF&nbsp;</div></li><li><div>                || $length &gt; 3 && $character &lt;= 0xFFFF&nbsp;</div></li><li><div>                // Outside of range of ucschar codepoints&nbsp;</div></li><li><div>                // Noncharacters&nbsp;</div></li><li><div>                || ($character & 0xFFFE) === 0xFFFE&nbsp;</div></li><li><div>                || $character &gt;= 0xFDD0 && $character &lt;= 0xFDEF&nbsp;</div></li><li><div>                || (&nbsp;</div></li><li><div>                    // Everything else not in ucschar&nbsp;</div></li><li><div>                       $character &gt; 0xD7FF && $character &lt; 0xF900&nbsp;</div></li><li><div>                    || $character &lt; 0x20&nbsp;</div></li><li><div>                    || $character &gt; 0x7E && $character &lt; 0xA0&nbsp;</div></li><li><div>                    || $character &gt; 0xEFFFD&nbsp;</div></li><li><div> )&nbsp;</div></li><li><div> ) {&nbsp;</div></li><li><div>                throw new Requests_Exception('Invalid Unicode codepoint', 'idna.invalidcodepoint', $character);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $codepoints[] = $character;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $codepoints;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * RFC3492-compliant encoder&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @internal Pseudo-code from Section 6.3 is commented with &quot;#&quot; next to relevant code&nbsp;</div></li><li><div>     * @throws Requests_Exception On character outside of the domain (never happens with Punycode) (`idna.character_outside_domain`)&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $input UTF-8 encoded string to encode&nbsp;</div></li><li><div>     * @return string Punycode-encoded string&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function punycode_encode($input) {&nbsp;</div></li><li><div>        $output = '';&nbsp;</div></li><li><div>#        let n = initial_n&nbsp;</div></li><li><div>        $n = self::BOOTSTRAP_INITIAL_N;&nbsp;</div></li><li><div>#        let delta = 0&nbsp;</div></li><li><div>        $delta = 0;&nbsp;</div></li><li><div>#        let bias = initial_bias&nbsp;</div></li><li><div>        $bias = self::BOOTSTRAP_INITIAL_BIAS;&nbsp;</div></li><li><div>#        let h = b = the number of basic code points in the input&nbsp;</div></li><li><div>        $h = $b = 0; // see loop&nbsp;</div></li><li><div>#        copy them to the output in order&nbsp;</div></li><li><div>        $codepoints = self::utf8_to_codepoints($input);&nbsp;</div></li><li><div>        $extended = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ($codepoints as $char) {&nbsp;</div></li><li><div>            if ($char &lt; 128) {&nbsp;</div></li><li><div>                // Character is valid ASCII&nbsp;</div></li><li><div>                // TODO: this should also check if it's valid for a URL&nbsp;</div></li><li><div>                $output .= chr($char);&nbsp;</div></li><li><div>                $h++;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // Check if the character is non-ASCII, but below initial n&nbsp;</div></li><li><div>            // This never occurs for Punycode, so ignore in coverage&nbsp;</div></li><li><div>            // @codeCoverageIgnoreStart&nbsp;</div></li><li><div>            elseif ($char &lt; $n) {&nbsp;</div></li><li><div>                throw new Requests_Exception('Invalid character', 'idna.character_outside_domain', $char);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            // @codeCoverageIgnoreEnd&nbsp;</div></li><li><div>            else {&nbsp;</div></li><li><div>                $extended[$char] = true;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $extended = array_keys($extended);&nbsp;</div></li><li><div>        sort($extended);&nbsp;</div></li><li><div>        $b = $h;&nbsp;</div></li><li><div>#        [copy them] followed by a delimiter if b &gt; 0&nbsp;</div></li><li><div>        if (strlen($output) &gt; 0) {&nbsp;</div></li><li><div>            $output .= '-';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>#        {if the input contains a non-basic code point &lt; n then fail}&nbsp;</div></li><li><div>#        while h &lt; length(input) do begin&nbsp;</div></li><li><div>        while ($h &lt; count($codepoints)) {&nbsp;</div></li><li><div>#            let m = the minimum code point &gt;= n in the input&nbsp;</div></li><li><div>            $m = array_shift($extended);&nbsp;</div></li><li><div>            //printf('next code point to insert is %s' . PHP_EOL, dechex($m));&nbsp;</div></li><li><div>#            let delta = delta + (m - n) * (h + 1), fail on overflow&nbsp;</div></li><li><div>            $delta += ($m - $n) * ($h + 1);&nbsp;</div></li><li><div>#            let n = m&nbsp;</div></li><li><div>            $n = $m;&nbsp;</div></li><li><div>#            for each code point c in the input (in order) do begin&nbsp;</div></li><li><div>            for ($num = 0; $num &lt; count($codepoints); $num++) {&nbsp;</div></li><li><div>                $c = $codepoints[$num];&nbsp;</div></li><li><div>#                if c &lt; n then increment delta, fail on overflow&nbsp;</div></li><li><div>                if ($c &lt; $n) {&nbsp;</div></li><li><div>                    $delta++;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>#                if c == n then begin&nbsp;</div></li><li><div>                elseif ($c === $n) {&nbsp;</div></li><li><div>#                    let q = delta&nbsp;</div></li><li><div>                    $q = $delta;&nbsp;</div></li><li><div>#                    for k = base to infinity in steps of base do begin&nbsp;</div></li><li><div>                    for ($k = self::BOOTSTRAP_BASE; ; $k += self::BOOTSTRAP_BASE) {&nbsp;</div></li><li><div>#                        let t = tmin if k &lt;= bias {+ tmin}, or&nbsp;</div></li><li><div>#                                tmax if k &gt;= bias + tmax, or k - bias otherwise&nbsp;</div></li><li><div>                        if ($k &lt;= ($bias + self::BOOTSTRAP_TMIN)) {&nbsp;</div></li><li><div>                            $t = self::BOOTSTRAP_TMIN;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        elseif ($k &gt;= ($bias + self::BOOTSTRAP_TMAX)) {&nbsp;</div></li><li><div>                            $t = self::BOOTSTRAP_TMAX;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                        else {&nbsp;</div></li><li><div>                            $t = $k - $bias;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>#                        if q &lt; t then break&nbsp;</div></li><li><div>                        if ($q &lt; $t) {&nbsp;</div></li><li><div>                            break;&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>#                        output the code point for digit t + ((q - t) mod (base - t))&nbsp;</div></li><li><div>                        $digit = $t + (($q - $t) % (self::BOOTSTRAP_BASE - $t));&nbsp;</div></li><li><div>                        $output .= self::digit_to_char($digit);&nbsp;</div></li><li><div>#                        let q = (q - t) div (base - t)&nbsp;</div></li><li><div>                        $q = floor(($q - $t) / (self::BOOTSTRAP_BASE - $t));&nbsp;</div></li><li><div>#                    end&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>#                    output the code point for digit q&nbsp;</div></li><li><div>                    $output .= self::digit_to_char($q);&nbsp;</div></li><li><div>#                    let bias = adapt(delta, h + 1, test h equals b?)&nbsp;</div></li><li><div>                    $bias = self::adapt($delta, $h + 1, $h === $b);&nbsp;</div></li><li><div>#                    let delta = 0&nbsp;</div></li><li><div>                    $delta = 0;&nbsp;</div></li><li><div>#                    increment h&nbsp;</div></li><li><div>                    $h++;&nbsp;</div></li><li><div>#                end&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>#            end&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>#            increment delta and n&nbsp;</div></li><li><div>            $delta++;&nbsp;</div></li><li><div>            $n++;&nbsp;</div></li><li><div>#        end&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $output;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Convert a digit to its respective character&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see https://tools.ietf.org/html/rfc3492#section-5&nbsp;</div></li><li><div>     * @throws Requests_Exception On invalid digit (`idna.invalid_digit`)&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param int $digit Digit in the range 0-35&nbsp;</div></li><li><div>     * @return string Single character corresponding to digit&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected static function digit_to_char($digit) {&nbsp;</div></li><li><div>        // @codeCoverageIgnoreStart&nbsp;</div></li><li><div>        // As far as I know, this never happens, but still good to be sure.&nbsp;</div></li><li><div>        if ($digit &lt; 0 || $digit &gt; 35) {&nbsp;</div></li><li><div>            throw new Requests_Exception(sprintf('Invalid digit %d', $digit), 'idna.invalid_digit', $digit);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // @codeCoverageIgnoreEnd&nbsp;</div></li><li><div>        $digits = 'abcdefghijklmnopqrstuvwxyz0123456789';&nbsp;</div></li><li><div>        return substr($digits, $digit, 1);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Adapt the bias&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @see https://tools.ietf.org/html/rfc3492#section-6.1&nbsp;</div></li><li><div>     * @param int $delta&nbsp;</div></li><li><div>     * @param int $numpoints&nbsp;</div></li><li><div>     * @param bool $firsttime&nbsp;</div></li><li><div>     * @return int New bias&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected static function adapt($delta, $numpoints, $firsttime) {&nbsp;</div></li><li><div>#    function adapt(delta, numpoints, firsttime):&nbsp;</div></li><li><div>#        if firsttime then let delta = delta div damp&nbsp;</div></li><li><div>        if ($firsttime) {&nbsp;</div></li><li><div>            $delta = floor($delta / self::BOOTSTRAP_DAMP);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>#        else let delta = delta div 2&nbsp;</div></li><li><div>        else {&nbsp;</div></li><li><div>            $delta = floor($delta / 2);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>#        let delta = delta + (delta div numpoints)&nbsp;</div></li><li><div>        $delta += floor($delta / $numpoints);&nbsp;</div></li><li><div>#        let k = 0&nbsp;</div></li><li><div>        $k = 0;&nbsp;</div></li><li><div>#        while delta &gt; ((base - tmin) * tmax) div 2 do begin&nbsp;</div></li><li><div>        $max = floor(((self::BOOTSTRAP_BASE - self::BOOTSTRAP_TMIN) * self::BOOTSTRAP_TMAX) / 2);&nbsp;</div></li><li><div>        while ($delta &gt; $max) {&nbsp;</div></li><li><div>#            let delta = delta div (base - tmin)&nbsp;</div></li><li><div>            $delta = floor($delta / (self::BOOTSTRAP_BASE - self::BOOTSTRAP_TMIN));&nbsp;</div></li><li><div>#            let k = k + base&nbsp;</div></li><li><div>            $k += self::BOOTSTRAP_BASE;&nbsp;</div></li><li><div>#        end&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>#        return k + (((base - tmin + 1) * delta) div (delta + skew))&nbsp;</div></li><li><div>        return $k + floor(((self::BOOTSTRAP_BASE - self::BOOTSTRAP_TMIN + 1) * $delta) / ($delta + self::BOOTSTRAP_SKEW));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 4.7</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/4.7.4/classes/requests_idnaencoder/" class="active">4.7.4</a></li><li><a href="http://hookr.io/4.7.3/classes/requests_idnaencoder/" class="">4.7.3</a></li><li><a href="http://hookr.io/4.7.2/classes/requests_idnaencoder/" class="">4.7.2</a></li><li><a href="http://hookr.io/4.7.1/classes/requests_idnaencoder/" class="">4.7.1</a></li><li><a href="http://hookr.io/4.7/classes/requests_idnaencoder/" class="">4.7</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>class</li><li><span></span>Requests_IDNAEncoder</li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2021 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>