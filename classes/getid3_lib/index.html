<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="wordpress" data-type="class" data-id="1318"><head xmlns="http://www.w3.org/1999/xhtml"><title> getid3_lib | class | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="getid3_lib, class, wordpress, 4.7.4" /><meta name="description" content="The WordPress Core getid3 lib class." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="https://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="https://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="https://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="https://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"https:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.24"}};!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;return g&&g.fillText?(g.textBaseline="top",g.font="600 32px Arial","flag"===a?(g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3):"diversity"===a?(g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e):("simple"===a?g.fillText(h(55357,56835),0,0):g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag"),unicode8:d("unicode8"),diversity:d("diversity")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag&&c.supports.unicode8&&c.supports.diversity||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='https://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=7f730069669715b03a97132ef139b1d0' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='https://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.24' type='text/css' media='screen' /><script type="text/javascript" src="https://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="https://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="https://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="https://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="https://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='https://hookr.io/wp-json/' /><link rel="canonical" href="https://hookr.io/classes/getid3_lib/" /><link rel="alternate" type="application/json+oembed" href="https://hookr.io/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fhookr.io%2Fclasses%2Fgetid3_lib%2F" /><link rel="alternate" type="text/xml+oembed" href="https://hookr.io/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fhookr.io%2Fclasses%2Fgetid3_lib%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"https:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"https:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-class-getid3_lib","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="https://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="https://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="getid3_lib" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="https://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="https://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="https://hookr.io/4.7.4/classes/" class=""><span property="name">classes</span></a><meta property="position" content="3"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">getid3_lib</span><meta property="position" content="4"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="https://hookr.io" title="hookr.io"><img src="https://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="https://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="https://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="https://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="https://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="https://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="active" data-id="class" data-count="351"><a href="https://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="https://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="https://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="https://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="https://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="https://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="https://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="https://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="https://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="https://hookr.io/about/" title="About">About</a></li><li class=""><a href="https://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>getid3_lib</strong></h1><p>The WordPress Core <strong>getid3 lib</strong> class.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="https://hookr.io/4.7.4/files/wp-includes-id3-getid3-lib/" class="file">/wp-includes/ID3/getid3.lib.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="15" class="block" start="15"><li><div>class getid3_lib&nbsp;</div></li><li><div>{&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function PrintHexBytes($string, $hex=true, $spaces=true, $htmlencoding='UTF-8') {&nbsp;</div></li><li><div>        $returnstring = '';&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i++) {&nbsp;</div></li><li><div>            if ($hex) {&nbsp;</div></li><li><div>                $returnstring .= str_pad(dechex(ord($string{$i})), 2, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $returnstring .= ' '.(preg_match(&quot;#[\x20-\x7E]#&quot;, $string{$i}) ? $string{$i} : '');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($spaces) {&nbsp;</div></li><li><div>                $returnstring .= ' ';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (!empty($htmlencoding)) {&nbsp;</div></li><li><div>            if ($htmlencoding === true) {&nbsp;</div></li><li><div>                $htmlencoding = 'UTF-8'; // prior to getID3 v1.9.0 the function's 4th parameter was boolean&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $returnstring = htmlentities($returnstring, ENT_QUOTES, $htmlencoding);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $returnstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function trunc($floatnumber) {&nbsp;</div></li><li><div>        // truncates a floating-point number at the decimal point&nbsp;</div></li><li><div>        // returns int (if possible, otherwise float)&nbsp;</div></li><li><div>        if ($floatnumber &gt;= 1) {&nbsp;</div></li><li><div>            $truncatednumber = floor($floatnumber);&nbsp;</div></li><li><div>        } elseif ($floatnumber &lt;= -1) {&nbsp;</div></li><li><div>            $truncatednumber = ceil($floatnumber);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $truncatednumber = 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (self::intValueSupported($truncatednumber)) {&nbsp;</div></li><li><div>            $truncatednumber = (int) $truncatednumber;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $truncatednumber;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function safe_inc(&$variable, $increment=1) {&nbsp;</div></li><li><div>        if (isset($variable)) {&nbsp;</div></li><li><div>            $variable += $increment;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $variable = $increment;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function CastAsInt($floatnum) {&nbsp;</div></li><li><div>        // convert to float if not already&nbsp;</div></li><li><div>        $floatnum = (float) $floatnum;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // convert a float to type int, only if possible&nbsp;</div></li><li><div>        if (self::trunc($floatnum) == $floatnum) {&nbsp;</div></li><li><div>            // it's not floating point&nbsp;</div></li><li><div>            if (self::intValueSupported($floatnum)) {&nbsp;</div></li><li><div>                // it's within int range&nbsp;</div></li><li><div>                $floatnum = (int) $floatnum;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $floatnum;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function intValueSupported($num) {&nbsp;</div></li><li><div>        // check if integers are 64-bit&nbsp;</div></li><li><div>        static $hasINT64 = null;&nbsp;</div></li><li><div>        if ($hasINT64 === null) { // 10x faster than is_null()&nbsp;</div></li><li><div>            $hasINT64 = is_int(pow(2, 31)); // 32-bit int are limited to (2^31)-1&nbsp;</div></li><li><div>            if (!$hasINT64 && !defined('PHP_INT_MIN')) {&nbsp;</div></li><li><div>                define('PHP_INT_MIN', ~PHP_INT_MAX);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // if integers are 64-bit - no other check required&nbsp;</div></li><li><div>        if ($hasINT64 || (($num &lt;= PHP_INT_MAX) && ($num &gt;= PHP_INT_MIN))) {&nbsp;</div></li><li><div>            return true;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function DecimalizeFraction($fraction) {&nbsp;</div></li><li><div>        list($numerator, $denominator) = explode('/', $fraction);&nbsp;</div></li><li><div>        return $numerator / ($denominator ? $denominator : 1);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function DecimalBinary2Float($binarynumerator) {&nbsp;</div></li><li><div>        $numerator = self::Bin2Dec($binarynumerator);&nbsp;</div></li><li><div>        $denominator = self::Bin2Dec('1'.str_repeat('0', strlen($binarynumerator)));&nbsp;</div></li><li><div>        return ($numerator / $denominator);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function NormalizeBinaryPoint($binarypointnumber, $maxbits=52) {&nbsp;</div></li><li><div>        // http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html&nbsp;</div></li><li><div>        if (strpos($binarypointnumber, '.') === false) {&nbsp;</div></li><li><div>            $binarypointnumber = '0.'.$binarypointnumber;&nbsp;</div></li><li><div>        } elseif ($binarypointnumber{0} == '.') {&nbsp;</div></li><li><div>            $binarypointnumber = '0'.$binarypointnumber;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $exponent = 0;&nbsp;</div></li><li><div>        while (($binarypointnumber{0} != '1') || (substr($binarypointnumber, 1, 1) != '.')) {&nbsp;</div></li><li><div>            if (substr($binarypointnumber, 1, 1) == '.') {&nbsp;</div></li><li><div>                $exponent--;&nbsp;</div></li><li><div>                $binarypointnumber = substr($binarypointnumber, 2, 1).'.'.substr($binarypointnumber, 3);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $pointpos = strpos($binarypointnumber, '.');&nbsp;</div></li><li><div>                $exponent += ($pointpos - 1);&nbsp;</div></li><li><div>                $binarypointnumber = str_replace('.', '', $binarypointnumber);&nbsp;</div></li><li><div>                $binarypointnumber = $binarypointnumber{0}.'.'.substr($binarypointnumber, 1);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $binarypointnumber = str_pad(substr($binarypointnumber, 0, $maxbits + 2), $maxbits + 2, '0', STR_PAD_RIGHT);&nbsp;</div></li><li><div>        return array('normalized'=&gt;$binarypointnumber, 'exponent'=&gt;(int) $exponent);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function Float2BinaryDecimal($floatvalue) {&nbsp;</div></li><li><div>        // http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html&nbsp;</div></li><li><div>        $maxbits = 128; // to how many bits of precision should the calculations be taken?&nbsp;</div></li><li><div>        $intpart = self::trunc($floatvalue);&nbsp;</div></li><li><div>        $floatpart = abs($floatvalue - $intpart);&nbsp;</div></li><li><div>        $pointbitstring = '';&nbsp;</div></li><li><div>        while (($floatpart != 0) && (strlen($pointbitstring) &lt; $maxbits)) {&nbsp;</div></li><li><div>            $floatpart *= 2;&nbsp;</div></li><li><div>            $pointbitstring .= (string) self::trunc($floatpart);&nbsp;</div></li><li><div>            $floatpart -= self::trunc($floatpart);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $binarypointnumber = decbin($intpart).'.'.$pointbitstring;&nbsp;</div></li><li><div>        return $binarypointnumber;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function Float2String($floatvalue, $bits) {&nbsp;</div></li><li><div>        // http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee-expl.html&nbsp;</div></li><li><div>        switch ($bits) {&nbsp;</div></li><li><div>            case 32:&nbsp;</div></li><li><div>                $exponentbits = 8;&nbsp;</div></li><li><div>                $fractionbits = 23;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 64:&nbsp;</div></li><li><div>                $exponentbits = 11;&nbsp;</div></li><li><div>                $fractionbits = 52;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($floatvalue &gt;= 0) {&nbsp;</div></li><li><div>            $signbit = '0';&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $signbit = '1';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $normalizedbinary = self::NormalizeBinaryPoint(self::Float2BinaryDecimal($floatvalue), $fractionbits);&nbsp;</div></li><li><div>        $biasedexponent = pow(2, $exponentbits - 1) - 1 + $normalizedbinary['exponent']; // (127 or 1023) +/- exponent&nbsp;</div></li><li><div>        $exponentbitstring = str_pad(decbin($biasedexponent), $exponentbits, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>        $fractionbitstring = str_pad(substr($normalizedbinary['normalized'], 2), $fractionbits, '0', STR_PAD_RIGHT);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return self::BigEndian2String(self::Bin2Dec($signbit.$exponentbitstring.$fractionbitstring), $bits % 8, false);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function LittleEndian2Float($byteword) {&nbsp;</div></li><li><div>        return self::BigEndian2Float(strrev($byteword));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function BigEndian2Float($byteword) {&nbsp;</div></li><li><div>        // ANSI/IEEE Standard 754-1985, Standard for Binary Floating Point Arithmetic&nbsp;</div></li><li><div>        // http://www.psc.edu/general/software/packages/ieee/ieee.html&nbsp;</div></li><li><div>        // http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee.html&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $bitword = self::BigEndian2Bin($byteword);&nbsp;</div></li><li><div>        if (!$bitword) {&nbsp;</div></li><li><div>            return 0;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $signbit = $bitword{0};&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        switch (strlen($byteword) * 8) {&nbsp;</div></li><li><div>            case 32:&nbsp;</div></li><li><div>                $exponentbits = 8;&nbsp;</div></li><li><div>                $fractionbits = 23;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 64:&nbsp;</div></li><li><div>                $exponentbits = 11;&nbsp;</div></li><li><div>                $fractionbits = 52;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 80:&nbsp;</div></li><li><div>                // 80-bit Apple SANE format&nbsp;</div></li><li><div>                // http://www.mactech.com/articles/mactech/Vol.06/06.01/SANENormalized/&nbsp;</div></li><li><div>                $exponentstring = substr($bitword, 1, 15);&nbsp;</div></li><li><div>                $isnormalized = intval($bitword{16});&nbsp;</div></li><li><div>                $fractionstring = substr($bitword, 17, 63);&nbsp;</div></li><li><div>                $exponent = pow(2, self::Bin2Dec($exponentstring) - 16383);&nbsp;</div></li><li><div>                $fraction = $isnormalized + self::DecimalBinary2Float($fractionstring);&nbsp;</div></li><li><div>                $floatvalue = $exponent * $fraction;&nbsp;</div></li><li><div>                if ($signbit == '1') {&nbsp;</div></li><li><div>                    $floatvalue *= -1;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return $floatvalue;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                return false;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $exponentstring = substr($bitword, 1, $exponentbits);&nbsp;</div></li><li><div>        $fractionstring = substr($bitword, $exponentbits + 1, $fractionbits);&nbsp;</div></li><li><div>        $exponent = self::Bin2Dec($exponentstring);&nbsp;</div></li><li><div>        $fraction = self::Bin2Dec($fractionstring);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (($exponent == (pow(2, $exponentbits) - 1)) && ($fraction != 0)) {&nbsp;</div></li><li><div>            // Not a Number&nbsp;</div></li><li><div>            $floatvalue = false;&nbsp;</div></li><li><div>        } elseif (($exponent == (pow(2, $exponentbits) - 1)) && ($fraction == 0)) {&nbsp;</div></li><li><div>            if ($signbit == '1') {&nbsp;</div></li><li><div>                $floatvalue = '-infinity';&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $floatvalue = '+infinity';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } elseif (($exponent == 0) && ($fraction == 0)) {&nbsp;</div></li><li><div>            if ($signbit == '1') {&nbsp;</div></li><li><div>                $floatvalue = -0;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $floatvalue = 0;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $floatvalue = ($signbit ? 0 : -0);&nbsp;</div></li><li><div>        } elseif (($exponent == 0) && ($fraction != 0)) {&nbsp;</div></li><li><div>            // These are 'unnormalized' values&nbsp;</div></li><li><div>            $floatvalue = pow(2, (-1 * (pow(2, $exponentbits - 1) - 2))) * self::DecimalBinary2Float($fractionstring);&nbsp;</div></li><li><div>            if ($signbit == '1') {&nbsp;</div></li><li><div>                $floatvalue *= -1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } elseif ($exponent != 0) {&nbsp;</div></li><li><div>            $floatvalue = pow(2, ($exponent - (pow(2, $exponentbits - 1) - 1))) * (1 + self::DecimalBinary2Float($fractionstring));&nbsp;</div></li><li><div>            if ($signbit == '1') {&nbsp;</div></li><li><div>                $floatvalue *= -1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return (float) $floatvalue;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function BigEndian2Int($byteword, $synchsafe=false, $signed=false) {&nbsp;</div></li><li><div>        $intvalue = 0;&nbsp;</div></li><li><div>        $bytewordlen = strlen($byteword);&nbsp;</div></li><li><div>        if ($bytewordlen == 0) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $bytewordlen; $i++) {&nbsp;</div></li><li><div>            if ($synchsafe) { // disregard MSB, effectively 7-bit bytes&nbsp;</div></li><li><div>                //$intvalue = $intvalue | (ord($byteword{$i}) & 0x7F) &lt;&lt; (($bytewordlen - 1 - $i) * 7); // faster, but runs into problems past 2^31 on 32-bit systems&nbsp;</div></li><li><div>                $intvalue += (ord($byteword{$i}) & 0x7F) * pow(2, ($bytewordlen - 1 - $i) * 7);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $intvalue += ord($byteword{$i}) * pow(256, ($bytewordlen - 1 - $i));&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($signed && !$synchsafe) {&nbsp;</div></li><li><div>            // synchsafe ints are not allowed to be signed&nbsp;</div></li><li><div>            if ($bytewordlen &lt;= PHP_INT_SIZE) {&nbsp;</div></li><li><div>                $signMaskBit = 0x80 &lt;&lt; (8 * ($bytewordlen - 1));&nbsp;</div></li><li><div>                if ($intvalue & $signMaskBit) {&nbsp;</div></li><li><div>                    $intvalue = 0 - ($intvalue & ($signMaskBit - 1));&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                throw new Exception('ERROR: Cannot have signed integers larger than '.(8 * PHP_INT_SIZE).'-bits ('.strlen($byteword).') in self::BigEndian2Int()');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return self::CastAsInt($intvalue);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function LittleEndian2Int($byteword, $signed=false) {&nbsp;</div></li><li><div>        return self::BigEndian2Int(strrev($byteword), false, $signed);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function BigEndian2Bin($byteword) {&nbsp;</div></li><li><div>        $binvalue = '';&nbsp;</div></li><li><div>        $bytewordlen = strlen($byteword);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; $bytewordlen; $i++) {&nbsp;</div></li><li><div>            $binvalue .= str_pad(decbin(ord($byteword{$i})), 8, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $binvalue;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function BigEndian2String($number, $minbytes=1, $synchsafe=false, $signed=false) {&nbsp;</div></li><li><div>        if ($number &lt; 0) {&nbsp;</div></li><li><div>            throw new Exception('ERROR: self::BigEndian2String() does not support negative numbers');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $maskbyte = (($synchsafe || $signed) ? 0x7F : 0xFF);&nbsp;</div></li><li><div>        $intstring = '';&nbsp;</div></li><li><div>        if ($signed) {&nbsp;</div></li><li><div>            if ($minbytes &gt; PHP_INT_SIZE) {&nbsp;</div></li><li><div>                throw new Exception('ERROR: Cannot have signed integers larger than '.(8 * PHP_INT_SIZE).'-bits in self::BigEndian2String()');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $number = $number & (0x80 &lt;&lt; (8 * ($minbytes - 1)));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        while ($number != 0) {&nbsp;</div></li><li><div>            $quotient = ($number / ($maskbyte + 1));&nbsp;</div></li><li><div>            $intstring = chr(ceil(($quotient - floor($quotient)) * $maskbyte)).$intstring;&nbsp;</div></li><li><div>            $number = floor($quotient);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return str_pad($intstring, $minbytes, &quot;\x00&quot;, STR_PAD_LEFT);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function Dec2Bin($number) {&nbsp;</div></li><li><div>        while ($number &gt;= 256) {&nbsp;</div></li><li><div>            $bytes[] = (($number / 256) - (floor($number / 256))) * 256;&nbsp;</div></li><li><div>            $number = floor($number / 256);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $bytes[] = $number;&nbsp;</div></li><li><div>        $binstring = '';&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; count($bytes); $i++) {&nbsp;</div></li><li><div>            $binstring = (($i == count($bytes) - 1) ? decbin($bytes[$i]) : str_pad(decbin($bytes[$i]), 8, '0', STR_PAD_LEFT)).$binstring;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $binstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function Bin2Dec($binstring, $signed=false) {&nbsp;</div></li><li><div>        $signmult = 1;&nbsp;</div></li><li><div>        if ($signed) {&nbsp;</div></li><li><div>            if ($binstring{0} == '1') {&nbsp;</div></li><li><div>                $signmult = -1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $binstring = substr($binstring, 1);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $decvalue = 0;&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($binstring); $i++) {&nbsp;</div></li><li><div>            $decvalue += ((int) substr($binstring, strlen($binstring) - $i - 1, 1)) * pow(2, $i);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return self::CastAsInt($decvalue * $signmult);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function Bin2String($binstring) {&nbsp;</div></li><li><div>        // return 'hi' for input of '0110100001101001'&nbsp;</div></li><li><div>        $string = '';&nbsp;</div></li><li><div>        $binstringreversed = strrev($binstring);&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($binstringreversed); $i += 8) {&nbsp;</div></li><li><div>            $string = chr(self::Bin2Dec(strrev(substr($binstringreversed, $i, 8)))).$string;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $string;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function LittleEndian2String($number, $minbytes=1, $synchsafe=false) {&nbsp;</div></li><li><div>        $intstring = '';&nbsp;</div></li><li><div>        while ($number &gt; 0) {&nbsp;</div></li><li><div>            if ($synchsafe) {&nbsp;</div></li><li><div>                $intstring = $intstring.chr($number & 127);&nbsp;</div></li><li><div>                $number &gt;&gt;= 7;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $intstring = $intstring.chr($number & 255);&nbsp;</div></li><li><div>                $number &gt;&gt;= 8;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return str_pad($intstring, $minbytes, &quot;\x00&quot;, STR_PAD_RIGHT);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function array_merge_clobber($array1, $array2) {&nbsp;</div></li><li><div>        // written by kchireability*com&nbsp;</div></li><li><div>        // taken from http://www.php.net/manual/en/function.array-merge-recursive.php&nbsp;</div></li><li><div>        if (!is_array($array1) || !is_array($array2)) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $newarray = $array1;&nbsp;</div></li><li><div>        foreach ($array2 as $key =&gt; $val) {&nbsp;</div></li><li><div>            if (is_array($val) && isset($newarray[$key]) && is_array($newarray[$key])) {&nbsp;</div></li><li><div>                $newarray[$key] = self::array_merge_clobber($newarray[$key], $val);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $newarray[$key] = $val;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newarray;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function array_merge_noclobber($array1, $array2) {&nbsp;</div></li><li><div>        if (!is_array($array1) || !is_array($array2)) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $newarray = $array1;&nbsp;</div></li><li><div>        foreach ($array2 as $key =&gt; $val) {&nbsp;</div></li><li><div>            if (is_array($val) && isset($newarray[$key]) && is_array($newarray[$key])) {&nbsp;</div></li><li><div>                $newarray[$key] = self::array_merge_noclobber($newarray[$key], $val);&nbsp;</div></li><li><div>            } elseif (!isset($newarray[$key])) {&nbsp;</div></li><li><div>                $newarray[$key] = $val;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newarray;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function ksort_recursive(&$theArray) {&nbsp;</div></li><li><div>        ksort($theArray);&nbsp;</div></li><li><div>        foreach ($theArray as $key =&gt; $value) {&nbsp;</div></li><li><div>            if (is_array($value)) {&nbsp;</div></li><li><div>                self::ksort_recursive($theArray[$key]);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function fileextension($filename, $numextensions=1) {&nbsp;</div></li><li><div>        if (strstr($filename, '.')) {&nbsp;</div></li><li><div>            $reversedfilename = strrev($filename);&nbsp;</div></li><li><div>            $offset = 0;&nbsp;</div></li><li><div>            for ($i = 0; $i &lt; $numextensions; $i++) {&nbsp;</div></li><li><div>                $offset = strpos($reversedfilename, '.', $offset + 1);&nbsp;</div></li><li><div>                if ($offset === false) {&nbsp;</div></li><li><div>                    return '';&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return strrev(substr($reversedfilename, 0, $offset));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return '';&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function PlaytimeString($seconds) {&nbsp;</div></li><li><div>        $sign = (($seconds &lt; 0) ? '-' : '');&nbsp;</div></li><li><div>        $seconds = round(abs($seconds));&nbsp;</div></li><li><div>        $H = (int) floor( $seconds                            / 3600);&nbsp;</div></li><li><div>        $M = (int) floor(($seconds - (3600 * $H) ) /   60);&nbsp;</div></li><li><div>        $S = (int) round( $seconds - (3600 * $H) - (60 * $M) );&nbsp;</div></li><li><div>        return $sign.($H ? $H.':' : '').($H ? str_pad($M, 2, '0', STR_PAD_LEFT) : intval($M)).':'.str_pad($S, 2, 0, STR_PAD_LEFT);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function DateMac2Unix($macdate) {&nbsp;</div></li><li><div>        // Macintosh timestamp: seconds since 00:00h January 1, 1904&nbsp;</div></li><li><div>        // UNIX timestamp:      seconds since 00:00h January 1, 1970&nbsp;</div></li><li><div>        return self::CastAsInt($macdate - 2082844800);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function FixedPoint8_8($rawdata) {&nbsp;</div></li><li><div>        return self::BigEndian2Int(substr($rawdata, 0, 1)) + (float) (self::BigEndian2Int(substr($rawdata, 1, 1)) / pow(2, 8));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function FixedPoint16_16($rawdata) {&nbsp;</div></li><li><div>        return self::BigEndian2Int(substr($rawdata, 0, 2)) + (float) (self::BigEndian2Int(substr($rawdata, 2, 2)) / pow(2, 16));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function FixedPoint2_30($rawdata) {&nbsp;</div></li><li><div>        $binarystring = self::BigEndian2Bin($rawdata);&nbsp;</div></li><li><div>        return self::Bin2Dec(substr($binarystring, 0, 2)) + (float) (self::Bin2Dec(substr($binarystring, 2, 30)) / pow(2, 30));&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function CreateDeepArray($ArrayPath, $Separator, $Value) {&nbsp;</div></li><li><div>        // assigns $Value to a nested array path:&nbsp;</div></li><li><div>        //   $foo = self::CreateDeepArray('/path/to/my', '/', 'file.txt')&nbsp;</div></li><li><div>        // is the same as:&nbsp;</div></li><li><div>        //   $foo = array('path'=&gt;array('to'=&gt;'array('my'=&gt;array('file.txt'))));&nbsp;</div></li><li><div>        // or&nbsp;</div></li><li><div>        //   $foo['path']['to']['my'] = 'file.txt';&nbsp;</div></li><li><div>        $ArrayPath = ltrim($ArrayPath, $Separator);&nbsp;</div></li><li><div>        if (($pos = strpos($ArrayPath, $Separator)) !== false) {&nbsp;</div></li><li><div>            $ReturnedArray[substr($ArrayPath, 0, $pos)] = self::CreateDeepArray(substr($ArrayPath, $pos + 1), $Separator, $Value);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $ReturnedArray[$ArrayPath] = $Value;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $ReturnedArray;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function array_max($arraydata, $returnkey=false) {&nbsp;</div></li><li><div>        $maxvalue = false;&nbsp;</div></li><li><div>        $maxkey = false;&nbsp;</div></li><li><div>        foreach ($arraydata as $key =&gt; $value) {&nbsp;</div></li><li><div>            if (!is_array($value)) {&nbsp;</div></li><li><div>                if ($value &gt; $maxvalue) {&nbsp;</div></li><li><div>                    $maxvalue = $value;&nbsp;</div></li><li><div>                    $maxkey = $key;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return ($returnkey ? $maxkey : $maxvalue);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function array_min($arraydata, $returnkey=false) {&nbsp;</div></li><li><div>        $minvalue = false;&nbsp;</div></li><li><div>        $minkey = false;&nbsp;</div></li><li><div>        foreach ($arraydata as $key =&gt; $value) {&nbsp;</div></li><li><div>            if (!is_array($value)) {&nbsp;</div></li><li><div>                if ($value &gt; $minvalue) {&nbsp;</div></li><li><div>                    $minvalue = $value;&nbsp;</div></li><li><div>                    $minkey = $key;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return ($returnkey ? $minkey : $minvalue);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function XML2array($XMLstring) {&nbsp;</div></li><li><div>        if (function_exists('simplexml_load_string') && function_exists('libxml_disable_entity_loader')) {&nbsp;</div></li><li><div>            // http://websec.io/2012/08/27/Preventing-XEE-in-PHP.html&nbsp;</div></li><li><div>            // https://core.trac.wordpress.org/changeset/29378&nbsp;</div></li><li><div>            $loader = libxml_disable_entity_loader(true);&nbsp;</div></li><li><div>            $XMLobject = simplexml_load_string($XMLstring, 'SimpleXMLElement', LIBXML_NOENT);&nbsp;</div></li><li><div>            $return = self::SimpleXMLelement2array($XMLobject);&nbsp;</div></li><li><div>            libxml_disable_entity_loader($loader);&nbsp;</div></li><li><div>            return $return;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function SimpleXMLelement2array($XMLobject) {&nbsp;</div></li><li><div>        if (!is_object($XMLobject) && !is_array($XMLobject)) {&nbsp;</div></li><li><div>            return $XMLobject;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $XMLarray = (is_object($XMLobject) ? get_object_vars($XMLobject) : $XMLobject);&nbsp;</div></li><li><div>        foreach ($XMLarray as $key =&gt; $value) {&nbsp;</div></li><li><div>            $XMLarray[$key] = self::SimpleXMLelement2array($value);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $XMLarray;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // Allan Hansen &lt;ahartemis*dk&gt;&nbsp;</div></li><li><div>    // self::md5_data() - returns md5sum for a file from startuing position to absolute end position&nbsp;</div></li><li><div>    public static function hash_data($file, $offset, $end, $algorithm) {&nbsp;</div></li><li><div>        static $tempdir = '';&nbsp;</div></li><li><div>        if (!self::intValueSupported($end)) {&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        switch ($algorithm) {&nbsp;</div></li><li><div>            case 'md5':&nbsp;</div></li><li><div>                $hash_function = 'md5_file';&nbsp;</div></li><li><div>                $unix_call = 'md5sum';&nbsp;</div></li><li><div>                $windows_call = 'md5sum.exe';&nbsp;</div></li><li><div>                $hash_length = 32;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'sha1':&nbsp;</div></li><li><div>                $hash_function = 'sha1_file';&nbsp;</div></li><li><div>                $unix_call = 'sha1sum';&nbsp;</div></li><li><div>                $windows_call = 'sha1sum.exe';&nbsp;</div></li><li><div>                $hash_length = 40;&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                throw new Exception('Invalid algorithm ('.$algorithm.') in self::hash_data()');&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $size = $end - $offset;&nbsp;</div></li><li><div>        while (true) {&nbsp;</div></li><li><div>            if (GETID3_OS_ISWINDOWS) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                // It seems that sha1sum.exe for Windows only works on physical files, does not accept piped data&nbsp;</div></li><li><div>                // Fall back to create-temp-file method:&nbsp;</div></li><li><div>                if ($algorithm == 'sha1') {&nbsp;</div></li><li><div>                    break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $RequiredFiles = array('cygwin1.dll', 'head.exe', 'tail.exe', $windows_call);&nbsp;</div></li><li><div>                foreach ($RequiredFiles as $required_file) {&nbsp;</div></li><li><div>                    if (!is_readable(GETID3_HELPERAPPSDIR.$required_file)) {&nbsp;</div></li><li><div>                        // helper apps not available - fall back to old method&nbsp;</div></li><li><div>                        break 2;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                $commandline = GETID3_HELPERAPPSDIR.'head.exe -c '.$end.' '.escapeshellarg(str_replace('/', DIRECTORY_SEPARATOR, $file)).' | ';&nbsp;</div></li><li><div>                $commandline .= GETID3_HELPERAPPSDIR.'tail.exe -c '.$size.' | ';&nbsp;</div></li><li><div>                $commandline .= GETID3_HELPERAPPSDIR.$windows_call;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                $commandline = 'head -c'.$end.' '.escapeshellarg($file).' | ';&nbsp;</div></li><li><div>                $commandline .= 'tail -c'.$size.' | ';&nbsp;</div></li><li><div>                $commandline .= $unix_call;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if (preg_match('#(1|ON)#i', ini_get('safe_mode'))) {&nbsp;</div></li><li><div>                //throw new Exception('PHP running in Safe Mode - backtick operator not available, using slower non-system-call '.$algorithm.' algorithm');&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return substr(`$commandline`, 0, $hash_length);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (empty($tempdir)) {&nbsp;</div></li><li><div>            // yes this is ugly, feel free to suggest a better way&nbsp;</div></li><li><div>            require_once(dirname(__FILE__).'/getid3.php');&nbsp;</div></li><li><div>            $getid3_temp = new getID3();&nbsp;</div></li><li><div>            $tempdir = $getid3_temp-&gt;tempdir;&nbsp;</div></li><li><div>            unset($getid3_temp);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // try to create a temporary file in the system temp directory - invalid dirname should force to system temp dir&nbsp;</div></li><li><div>        if (($data_filename = tempnam($tempdir, 'gI3')) === false) {&nbsp;</div></li><li><div>            // can't find anywhere to create a temp file, just fail&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Init&nbsp;</div></li><li><div>        $result = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // copy parts of file&nbsp;</div></li><li><div>        try {&nbsp;</div></li><li><div>            self::CopyFileParts($file, $data_filename, $offset, $end - $offset);&nbsp;</div></li><li><div>            $result = $hash_function($data_filename);&nbsp;</div></li><li><div>        } catch (Exception $e) {&nbsp;</div></li><li><div>            throw new Exception('self::CopyFileParts() failed in getid_lib::hash_data(): '.$e-&gt;getMessage());&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        unlink($data_filename);&nbsp;</div></li><li><div>        return $result;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function CopyFileParts($filename_source, $filename_dest, $offset, $length) {&nbsp;</div></li><li><div>        if (!self::intValueSupported($offset + $length)) {&nbsp;</div></li><li><div>            throw new Exception('cannot copy file portion, it extends beyond the '.round(PHP_INT_MAX / 1073741824).'GB limit');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (is_readable($filename_source) && is_file($filename_source) && ($fp_src = fopen($filename_source, 'rb'))) {&nbsp;</div></li><li><div>            if (($fp_dest = fopen($filename_dest, 'wb'))) {&nbsp;</div></li><li><div>                if (fseek($fp_src, $offset) == 0) {&nbsp;</div></li><li><div>                    $byteslefttowrite = $length;&nbsp;</div></li><li><div>                    while (($byteslefttowrite &gt; 0) && ($buffer = fread($fp_src, min($byteslefttowrite, getID3::FREAD_BUFFER_SIZE)))) {&nbsp;</div></li><li><div>                        $byteswritten = fwrite($fp_dest, $buffer, $byteslefttowrite);&nbsp;</div></li><li><div>                        $byteslefttowrite -= $byteswritten;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    return true;&nbsp;</div></li><li><div>                } else {&nbsp;</div></li><li><div>                    throw new Exception('failed to seek to offset '.$offset.' in '.$filename_source);&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                fclose($fp_dest);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                throw new Exception('failed to create file for writing '.$filename_dest);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            fclose($fp_src);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            throw new Exception('failed to open file for reading '.$filename_source);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function iconv_fallback_int_utf8($charval) {&nbsp;</div></li><li><div>        if ($charval &lt; 128) {&nbsp;</div></li><li><div>            // 0bbbbbbb&nbsp;</div></li><li><div>            $newcharstring = chr($charval);&nbsp;</div></li><li><div>        } elseif ($charval &lt; 2048) {&nbsp;</div></li><li><div>            // 110bbbbb 10bbbbbb&nbsp;</div></li><li><div>            $newcharstring = chr(($charval &gt;&gt;   6) | 0xC0);&nbsp;</div></li><li><div>            $newcharstring .= chr(($charval & 0x3F) | 0x80);&nbsp;</div></li><li><div>        } elseif ($charval &lt; 65536) {&nbsp;</div></li><li><div>            // 1110bbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>            $newcharstring = chr(($charval &gt;&gt;  12) | 0xE0);&nbsp;</div></li><li><div>            $newcharstring .= chr(($charval &gt;&gt;   6) | 0xC0);&nbsp;</div></li><li><div>            $newcharstring .= chr(($charval & 0x3F) | 0x80);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>            $newcharstring = chr(($charval &gt;&gt;  18) | 0xF0);&nbsp;</div></li><li><div>            $newcharstring .= chr(($charval &gt;&gt;  12) | 0xC0);&nbsp;</div></li><li><div>            $newcharstring .= chr(($charval &gt;&gt;   6) | 0xC0);&nbsp;</div></li><li><div>            $newcharstring .= chr(($charval & 0x3F) | 0x80);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ISO-8859-1 =&gt; UTF-8&nbsp;</div></li><li><div>    public static function iconv_fallback_iso88591_utf8($string, $bom=false) {&nbsp;</div></li><li><div>        if (function_exists('utf8_encode')) {&nbsp;</div></li><li><div>            return utf8_encode($string);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // utf8_encode() unavailable, use getID3()'s iconv_fallback() conversions (possibly PHP is compiled without XML support)&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        if ($bom) {&nbsp;</div></li><li><div>            $newcharstring .= &quot;\xEF\xBB\xBF&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i++) {&nbsp;</div></li><li><div>            $charval = ord($string{$i});&nbsp;</div></li><li><div>            $newcharstring .= self::iconv_fallback_int_utf8($charval);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ISO-8859-1 =&gt; UTF-16BE&nbsp;</div></li><li><div>    public static function iconv_fallback_iso88591_utf16be($string, $bom=false) {&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        if ($bom) {&nbsp;</div></li><li><div>            $newcharstring .= &quot;\xFE\xFF&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i++) {&nbsp;</div></li><li><div>            $newcharstring .= &quot;\x00&quot;.$string{$i};&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ISO-8859-1 =&gt; UTF-16LE&nbsp;</div></li><li><div>    public static function iconv_fallback_iso88591_utf16le($string, $bom=false) {&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        if ($bom) {&nbsp;</div></li><li><div>            $newcharstring .= &quot;\xFF\xFE&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i++) {&nbsp;</div></li><li><div>            $newcharstring .= $string{$i}.&quot;\x00&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // ISO-8859-1 =&gt; UTF-16LE (BOM)&nbsp;</div></li><li><div>    public static function iconv_fallback_iso88591_utf16($string) {&nbsp;</div></li><li><div>        return self::iconv_fallback_iso88591_utf16le($string, true);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-8 =&gt; ISO-8859-1&nbsp;</div></li><li><div>    public static function iconv_fallback_utf8_iso88591($string) {&nbsp;</div></li><li><div>        if (function_exists('utf8_decode')) {&nbsp;</div></li><li><div>            return utf8_decode($string);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // utf8_decode() unavailable, use getID3()'s iconv_fallback() conversions (possibly PHP is compiled without XML support)&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        $offset = 0;&nbsp;</div></li><li><div>        $stringlength = strlen($string);&nbsp;</div></li><li><div>        while ($offset &lt; $stringlength) {&nbsp;</div></li><li><div>            if ((ord($string{$offset}) | 0x07) == 0xF7) {&nbsp;</div></li><li><div>                // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x07) &lt;&lt; 18) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 1)}) & 0x3F) &lt;&lt; 12) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 2)}) & 0x3F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 3)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 4;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x0F) == 0xEF) {&nbsp;</div></li><li><div>                // 1110bbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x0F) &lt;&lt; 12) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 1)}) & 0x3F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 2)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 3;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x1F) == 0xDF) {&nbsp;</div></li><li><div>                // 110bbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x1F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 1)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 2;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x7F) == 0x7F) {&nbsp;</div></li><li><div>                // 0bbbbbbb&nbsp;</div></li><li><div>                $charval = ord($string{$offset});&nbsp;</div></li><li><div>                $offset += 1;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                // error? throw some kind of warning here?&nbsp;</div></li><li><div>                $charval = false;&nbsp;</div></li><li><div>                $offset += 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($charval !== false) {&nbsp;</div></li><li><div>                $newcharstring .= (($charval &lt; 256) ? chr($charval) : '?');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-8 =&gt; UTF-16BE&nbsp;</div></li><li><div>    public static function iconv_fallback_utf8_utf16be($string, $bom=false) {&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        if ($bom) {&nbsp;</div></li><li><div>            $newcharstring .= &quot;\xFE\xFF&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $offset = 0;&nbsp;</div></li><li><div>        $stringlength = strlen($string);&nbsp;</div></li><li><div>        while ($offset &lt; $stringlength) {&nbsp;</div></li><li><div>            if ((ord($string{$offset}) | 0x07) == 0xF7) {&nbsp;</div></li><li><div>                // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x07) &lt;&lt; 18) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 1)}) & 0x3F) &lt;&lt; 12) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 2)}) & 0x3F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 3)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 4;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x0F) == 0xEF) {&nbsp;</div></li><li><div>                // 1110bbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x0F) &lt;&lt; 12) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 1)}) & 0x3F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 2)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 3;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x1F) == 0xDF) {&nbsp;</div></li><li><div>                // 110bbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x1F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 1)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 2;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x7F) == 0x7F) {&nbsp;</div></li><li><div>                // 0bbbbbbb&nbsp;</div></li><li><div>                $charval = ord($string{$offset});&nbsp;</div></li><li><div>                $offset += 1;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                // error? throw some kind of warning here?&nbsp;</div></li><li><div>                $charval = false;&nbsp;</div></li><li><div>                $offset += 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($charval !== false) {&nbsp;</div></li><li><div>                $newcharstring .= (($charval &lt; 65536) ? self::BigEndian2String($charval, 2) : &quot;\x00&quot;.'?');&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-8 =&gt; UTF-16LE&nbsp;</div></li><li><div>    public static function iconv_fallback_utf8_utf16le($string, $bom=false) {&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        if ($bom) {&nbsp;</div></li><li><div>            $newcharstring .= &quot;\xFF\xFE&quot;;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $offset = 0;&nbsp;</div></li><li><div>        $stringlength = strlen($string);&nbsp;</div></li><li><div>        while ($offset &lt; $stringlength) {&nbsp;</div></li><li><div>            if ((ord($string{$offset}) | 0x07) == 0xF7) {&nbsp;</div></li><li><div>                // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x07) &lt;&lt; 18) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 1)}) & 0x3F) &lt;&lt; 12) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 2)}) & 0x3F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 3)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 4;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x0F) == 0xEF) {&nbsp;</div></li><li><div>                // 1110bbbb 10bbbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x0F) &lt;&lt; 12) &&nbsp;</div></li><li><div>                           ((ord($string{($offset + 1)}) & 0x3F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 2)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 3;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x1F) == 0xDF) {&nbsp;</div></li><li><div>                // 110bbbbb 10bbbbbb&nbsp;</div></li><li><div>                $charval = ((ord($string{($offset + 0)}) & 0x1F) &lt;&lt;  6) &&nbsp;</div></li><li><div>                            (ord($string{($offset + 1)}) & 0x3F);&nbsp;</div></li><li><div>                $offset += 2;&nbsp;</div></li><li><div>            } elseif ((ord($string{$offset}) | 0x7F) == 0x7F) {&nbsp;</div></li><li><div>                // 0bbbbbbb&nbsp;</div></li><li><div>                $charval = ord($string{$offset});&nbsp;</div></li><li><div>                $offset += 1;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                // error? maybe throw some warning here?&nbsp;</div></li><li><div>                $charval = false;&nbsp;</div></li><li><div>                $offset += 1;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ($charval !== false) {&nbsp;</div></li><li><div>                $newcharstring .= (($charval &lt; 65536) ? self::LittleEndian2String($charval, 2) : '?'.&quot;\x00&quot;);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-8 =&gt; UTF-16LE (BOM)&nbsp;</div></li><li><div>    public static function iconv_fallback_utf8_utf16($string) {&nbsp;</div></li><li><div>        return self::iconv_fallback_utf8_utf16le($string, true);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-16BE =&gt; UTF-8&nbsp;</div></li><li><div>    public static function iconv_fallback_utf16be_utf8($string) {&nbsp;</div></li><li><div>        if (substr($string, 0, 2) == &quot;\xFE\xFF&quot;) {&nbsp;</div></li><li><div>            // strip BOM&nbsp;</div></li><li><div>            $string = substr($string, 2);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i += 2) {&nbsp;</div></li><li><div>            $charval = self::BigEndian2Int(substr($string, $i, 2));&nbsp;</div></li><li><div>            $newcharstring .= self::iconv_fallback_int_utf8($charval);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-16LE =&gt; UTF-8&nbsp;</div></li><li><div>    public static function iconv_fallback_utf16le_utf8($string) {&nbsp;</div></li><li><div>        if (substr($string, 0, 2) == &quot;\xFF\xFE&quot;) {&nbsp;</div></li><li><div>            // strip BOM&nbsp;</div></li><li><div>            $string = substr($string, 2);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i += 2) {&nbsp;</div></li><li><div>            $charval = self::LittleEndian2Int(substr($string, $i, 2));&nbsp;</div></li><li><div>            $newcharstring .= self::iconv_fallback_int_utf8($charval);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-16BE =&gt; ISO-8859-1&nbsp;</div></li><li><div>    public static function iconv_fallback_utf16be_iso88591($string) {&nbsp;</div></li><li><div>        if (substr($string, 0, 2) == &quot;\xFE\xFF&quot;) {&nbsp;</div></li><li><div>            // strip BOM&nbsp;</div></li><li><div>            $string = substr($string, 2);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i += 2) {&nbsp;</div></li><li><div>            $charval = self::BigEndian2Int(substr($string, $i, 2));&nbsp;</div></li><li><div>            $newcharstring .= (($charval &lt; 256) ? chr($charval) : '?');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-16LE =&gt; ISO-8859-1&nbsp;</div></li><li><div>    public static function iconv_fallback_utf16le_iso88591($string) {&nbsp;</div></li><li><div>        if (substr($string, 0, 2) == &quot;\xFF\xFE&quot;) {&nbsp;</div></li><li><div>            // strip BOM&nbsp;</div></li><li><div>            $string = substr($string, 2);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $newcharstring = '';&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; strlen($string); $i += 2) {&nbsp;</div></li><li><div>            $charval = self::LittleEndian2Int(substr($string, $i, 2));&nbsp;</div></li><li><div>            $newcharstring .= (($charval &lt; 256) ? chr($charval) : '?');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $newcharstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-16 (BOM) =&gt; ISO-8859-1&nbsp;</div></li><li><div>    public static function iconv_fallback_utf16_iso88591($string) {&nbsp;</div></li><li><div>        $bom = substr($string, 0, 2);&nbsp;</div></li><li><div>        if ($bom == &quot;\xFE\xFF&quot;) {&nbsp;</div></li><li><div>            return self::iconv_fallback_utf16be_iso88591(substr($string, 2));&nbsp;</div></li><li><div>        } elseif ($bom == &quot;\xFF\xFE&quot;) {&nbsp;</div></li><li><div>            return self::iconv_fallback_utf16le_iso88591(substr($string, 2));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $string;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // UTF-16 (BOM) =&gt; UTF-8&nbsp;</div></li><li><div>    public static function iconv_fallback_utf16_utf8($string) {&nbsp;</div></li><li><div>        $bom = substr($string, 0, 2);&nbsp;</div></li><li><div>        if ($bom == &quot;\xFE\xFF&quot;) {&nbsp;</div></li><li><div>            return self::iconv_fallback_utf16be_utf8(substr($string, 2));&nbsp;</div></li><li><div>        } elseif ($bom == &quot;\xFF\xFE&quot;) {&nbsp;</div></li><li><div>            return self::iconv_fallback_utf16le_utf8(substr($string, 2));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $string;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function iconv_fallback($in_charset, $out_charset, $string) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ($in_charset == $out_charset) {&nbsp;</div></li><li><div>            return $string;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // iconv() availble&nbsp;</div></li><li><div>        if (function_exists('iconv')) {&nbsp;</div></li><li><div>            if ($converted_string = @iconv($in_charset, $out_charset.'//TRANSLIT', $string)) {&nbsp;</div></li><li><div>                switch ($out_charset) {&nbsp;</div></li><li><div>                    case 'ISO-8859-1':&nbsp;</div></li><li><div>                        $converted_string = rtrim($converted_string, &quot;\x00&quot;);&nbsp;</div></li><li><div>                        break;&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                return $converted_string;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // iconv() may sometimes fail with &quot;illegal character in input string&quot; error message&nbsp;</div></li><li><div>            // and return an empty string, but returning the unconverted string is more useful&nbsp;</div></li><li><div>            return $string;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // iconv() not available&nbsp;</div></li><li><div>        static $ConversionFunctionList = array();&nbsp;</div></li><li><div>        if (empty($ConversionFunctionList)) {&nbsp;</div></li><li><div>            $ConversionFunctionList['ISO-8859-1']['UTF-8'] = 'iconv_fallback_iso88591_utf8';&nbsp;</div></li><li><div>            $ConversionFunctionList['ISO-8859-1']['UTF-16'] = 'iconv_fallback_iso88591_utf16';&nbsp;</div></li><li><div>            $ConversionFunctionList['ISO-8859-1']['UTF-16BE'] = 'iconv_fallback_iso88591_utf16be';&nbsp;</div></li><li><div>            $ConversionFunctionList['ISO-8859-1']['UTF-16LE'] = 'iconv_fallback_iso88591_utf16le';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-8']['ISO-8859-1'] = 'iconv_fallback_utf8_iso88591';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-8']['UTF-16'] = 'iconv_fallback_utf8_utf16';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-8']['UTF-16BE'] = 'iconv_fallback_utf8_utf16be';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-8']['UTF-16LE'] = 'iconv_fallback_utf8_utf16le';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-16']['ISO-8859-1'] = 'iconv_fallback_utf16_iso88591';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-16']['UTF-8'] = 'iconv_fallback_utf16_utf8';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-16LE']['ISO-8859-1'] = 'iconv_fallback_utf16le_iso88591';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-16LE']['UTF-8'] = 'iconv_fallback_utf16le_utf8';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-16BE']['ISO-8859-1'] = 'iconv_fallback_utf16be_iso88591';&nbsp;</div></li><li><div>            $ConversionFunctionList['UTF-16BE']['UTF-8'] = 'iconv_fallback_utf16be_utf8';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (isset($ConversionFunctionList[strtoupper($in_charset)][strtoupper($out_charset)])) {&nbsp;</div></li><li><div>            $ConversionFunction = $ConversionFunctionList[strtoupper($in_charset)][strtoupper($out_charset)];&nbsp;</div></li><li><div>            return self::$ConversionFunction($string);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        throw new Exception('PHP does not have iconv() support - cannot convert from '.$in_charset.' to '.$out_charset);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function recursiveMultiByteCharString2HTML($data, $charset='ISO-8859-1') {&nbsp;</div></li><li><div>        if (is_string($data)) {&nbsp;</div></li><li><div>            return self::MultiByteCharString2HTML($data, $charset);&nbsp;</div></li><li><div>        } elseif (is_array($data)) {&nbsp;</div></li><li><div>            $return_data = array();&nbsp;</div></li><li><div>            foreach ($data as $key =&gt; $value) {&nbsp;</div></li><li><div>                $return_data[$key] = self::recursiveMultiByteCharString2HTML($value, $charset);&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            return $return_data;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        // integer, float, objects, resources, etc&nbsp;</div></li><li><div>        return $data;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function MultiByteCharString2HTML($string, $charset='ISO-8859-1') {&nbsp;</div></li><li><div>        $string = (string) $string; // in case trying to pass a numeric (float, int) string, would otherwise return an empty string&nbsp;</div></li><li><div>        $HTMLstring = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        switch ($charset) {&nbsp;</div></li><li><div>            case '1251':&nbsp;</div></li><li><div>            case '1252':&nbsp;</div></li><li><div>            case '866':&nbsp;</div></li><li><div>            case '932':&nbsp;</div></li><li><div>            case '936':&nbsp;</div></li><li><div>            case '950':&nbsp;</div></li><li><div>            case 'BIG5':&nbsp;</div></li><li><div>            case 'BIG5-HKSCS':&nbsp;</div></li><li><div>            case 'cp1251':&nbsp;</div></li><li><div>            case 'cp1252':&nbsp;</div></li><li><div>            case 'cp866':&nbsp;</div></li><li><div>            case 'EUC-JP':&nbsp;</div></li><li><div>            case 'EUCJP':&nbsp;</div></li><li><div>            case 'GB2312':&nbsp;</div></li><li><div>            case 'ibm866':&nbsp;</div></li><li><div>            case 'ISO-8859-1':&nbsp;</div></li><li><div>            case 'ISO-8859-15':&nbsp;</div></li><li><div>            case 'ISO8859-1':&nbsp;</div></li><li><div>            case 'ISO8859-15':&nbsp;</div></li><li><div>            case 'KOI8-R':&nbsp;</div></li><li><div>            case 'koi8-ru':&nbsp;</div></li><li><div>            case 'koi8r':&nbsp;</div></li><li><div>            case 'Shift_JIS':&nbsp;</div></li><li><div>            case 'SJIS':&nbsp;</div></li><li><div>            case 'win-1251':&nbsp;</div></li><li><div>            case 'Windows-1251':&nbsp;</div></li><li><div>            case 'Windows-1252':&nbsp;</div></li><li><div>                $HTMLstring = htmlentities($string, ENT_COMPAT, $charset);&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'UTF-8':&nbsp;</div></li><li><div>                $strlen = strlen($string);&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; $strlen; $i++) {&nbsp;</div></li><li><div>                    $char_ord_val = ord($string{$i});&nbsp;</div></li><li><div>                    $charval = 0;&nbsp;</div></li><li><div>                    if ($char_ord_val &lt; 0x80) {&nbsp;</div></li><li><div>                        $charval = $char_ord_val;&nbsp;</div></li><li><div>                    } elseif ((($char_ord_val & 0xF0) &gt;&gt; 4) == 0x0F  &&  $i+3 &lt; $strlen) {&nbsp;</div></li><li><div>                        $charval = (($char_ord_val & 0x07) &lt;&lt; 18);&nbsp;</div></li><li><div>                        $charval += ((ord($string{++$i}) & 0x3F) &lt;&lt; 12);&nbsp;</div></li><li><div>                        $charval += ((ord($string{++$i}) & 0x3F) &lt;&lt; 6);&nbsp;</div></li><li><div>                        $charval +=  (ord($string{++$i}) & 0x3F);&nbsp;</div></li><li><div>                    } elseif ((($char_ord_val & 0xE0) &gt;&gt; 5) == 0x07  &&  $i+2 &lt; $strlen) {&nbsp;</div></li><li><div>                        $charval = (($char_ord_val & 0x0F) &lt;&lt; 12);&nbsp;</div></li><li><div>                        $charval += ((ord($string{++$i}) & 0x3F) &lt;&lt; 6);&nbsp;</div></li><li><div>                        $charval +=  (ord($string{++$i}) & 0x3F);&nbsp;</div></li><li><div>                    } elseif ((($char_ord_val & 0xC0) &gt;&gt; 6) == 0x03  &&  $i+1 &lt; $strlen) {&nbsp;</div></li><li><div>                        $charval = (($char_ord_val & 0x1F) &lt;&lt; 6);&nbsp;</div></li><li><div>                        $charval += (ord($string{++$i}) & 0x3F);&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    if (($charval &gt;= 32) && ($charval &lt;= 127)) {&nbsp;</div></li><li><div>                        $HTMLstring .= htmlentities(chr($charval));&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $HTMLstring .= '&#'.$charval.';';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'UTF-16LE':&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; strlen($string); $i += 2) {&nbsp;</div></li><li><div>                    $charval = self::LittleEndian2Int(substr($string, $i, 2));&nbsp;</div></li><li><div>                    if (($charval &gt;= 32) && ($charval &lt;= 127)) {&nbsp;</div></li><li><div>                        $HTMLstring .= chr($charval);&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $HTMLstring .= '&#'.$charval.';';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            case 'UTF-16BE':&nbsp;</div></li><li><div>                for ($i = 0; $i &lt; strlen($string); $i += 2) {&nbsp;</div></li><li><div>                    $charval = self::BigEndian2Int(substr($string, $i, 2));&nbsp;</div></li><li><div>                    if (($charval &gt;= 32) && ($charval &lt;= 127)) {&nbsp;</div></li><li><div>                        $HTMLstring .= chr($charval);&nbsp;</div></li><li><div>                    } else {&nbsp;</div></li><li><div>                        $HTMLstring .= '&#'.$charval.';';&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            default:&nbsp;</div></li><li><div>                $HTMLstring = 'ERROR: Character set &quot;'.$charset.'&quot; not supported in MultiByteCharString2HTML()';&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $HTMLstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function RGADnameLookup($namecode) {&nbsp;</div></li><li><div>        static $RGADname = array();&nbsp;</div></li><li><div>        if (empty($RGADname)) {&nbsp;</div></li><li><div>            $RGADname[0] = 'not set';&nbsp;</div></li><li><div>            $RGADname[1] = 'Track Gain Adjustment';&nbsp;</div></li><li><div>            $RGADname[2] = 'Album Gain Adjustment';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return (isset($RGADname[$namecode]) ? $RGADname[$namecode] : '');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function RGADoriginatorLookup($originatorcode) {&nbsp;</div></li><li><div>        static $RGADoriginator = array();&nbsp;</div></li><li><div>        if (empty($RGADoriginator)) {&nbsp;</div></li><li><div>            $RGADoriginator[0] = 'unspecified';&nbsp;</div></li><li><div>            $RGADoriginator[1] = 'pre-set by artist/producer/mastering engineer';&nbsp;</div></li><li><div>            $RGADoriginator[2] = 'set by user';&nbsp;</div></li><li><div>            $RGADoriginator[3] = 'determined automatically';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return (isset($RGADoriginator[$originatorcode]) ? $RGADoriginator[$originatorcode] : '');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function RGADadjustmentLookup($rawadjustment, $signbit) {&nbsp;</div></li><li><div>        $adjustment = $rawadjustment / 10;&nbsp;</div></li><li><div>        if ($signbit == 1) {&nbsp;</div></li><li><div>            $adjustment *= -1;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return (float) $adjustment;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function RGADgainString($namecode, $originatorcode, $replaygain) {&nbsp;</div></li><li><div>        if ($replaygain &lt; 0) {&nbsp;</div></li><li><div>            $signbit = '1';&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $signbit = '0';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $storedreplaygain = intval(round($replaygain * 10));&nbsp;</div></li><li><div>        $gainstring = str_pad(decbin($namecode), 3, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>        $gainstring .= str_pad(decbin($originatorcode), 3, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>        $gainstring .= $signbit;&nbsp;</div></li><li><div>        $gainstring .= str_pad(decbin($storedreplaygain), 9, '0', STR_PAD_LEFT);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $gainstring;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function RGADamplitude2dB($amplitude) {&nbsp;</div></li><li><div>        return 20 * log10($amplitude);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function GetDataImageSize($imgData, &$imageinfo=array()) {&nbsp;</div></li><li><div>        static $tempdir = '';&nbsp;</div></li><li><div>        if (empty($tempdir)) {&nbsp;</div></li><li><div>            // yes this is ugly, feel free to suggest a better way&nbsp;</div></li><li><div>            require_once(dirname(__FILE__).'/getid3.php');&nbsp;</div></li><li><div>            $getid3_temp = new getID3();&nbsp;</div></li><li><div>            $tempdir = $getid3_temp-&gt;tempdir;&nbsp;</div></li><li><div>            unset($getid3_temp);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        $GetDataImageSize = false;&nbsp;</div></li><li><div>        if ($tempfilename = tempnam($tempdir, 'gI3')) {&nbsp;</div></li><li><div>            if (is_writable($tempfilename) && is_file($tempfilename) && ($tmp = fopen($tempfilename, 'wb'))) {&nbsp;</div></li><li><div>                fwrite($tmp, $imgData);&nbsp;</div></li><li><div>                fclose($tmp);&nbsp;</div></li><li><div>                $GetDataImageSize = @getimagesize($tempfilename, $imageinfo);&nbsp;</div></li><li><div>                $GetDataImageSize['height'] = $GetDataImageSize[0];&nbsp;</div></li><li><div>                $GetDataImageSize['width'] = $GetDataImageSize[1];&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            unlink($tempfilename);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $GetDataImageSize;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function ImageExtFromMime($mime_type) {&nbsp;</div></li><li><div>        // temporary way, works OK for now, but should be reworked in the future&nbsp;</div></li><li><div>        return str_replace(array('image/', 'x-', 'jpeg'), array('', '', 'jpg'), $mime_type);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function ImageTypesLookup($imagetypeid) {&nbsp;</div></li><li><div>        static $ImageTypesLookup = array();&nbsp;</div></li><li><div>        if (empty($ImageTypesLookup)) {&nbsp;</div></li><li><div>            $ImageTypesLookup[1] = 'gif';&nbsp;</div></li><li><div>            $ImageTypesLookup[2] = 'jpeg';&nbsp;</div></li><li><div>            $ImageTypesLookup[3] = 'png';&nbsp;</div></li><li><div>            $ImageTypesLookup[4] = 'swf';&nbsp;</div></li><li><div>            $ImageTypesLookup[5] = 'psd';&nbsp;</div></li><li><div>            $ImageTypesLookup[6] = 'bmp';&nbsp;</div></li><li><div>            $ImageTypesLookup[7] = 'tiff (little-endian)';&nbsp;</div></li><li><div>            $ImageTypesLookup[8] = 'tiff (big-endian)';&nbsp;</div></li><li><div>            $ImageTypesLookup[9] = 'jpc';&nbsp;</div></li><li><div>            $ImageTypesLookup[10] = 'jp2';&nbsp;</div></li><li><div>            $ImageTypesLookup[11] = 'jpx';&nbsp;</div></li><li><div>            $ImageTypesLookup[12] = 'jb2';&nbsp;</div></li><li><div>            $ImageTypesLookup[13] = 'swc';&nbsp;</div></li><li><div>            $ImageTypesLookup[14] = 'iff';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return (isset($ImageTypesLookup[$imagetypeid]) ? $ImageTypesLookup[$imagetypeid] : '');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function CopyTagsToComments(&$ThisFileInfo) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Copy all entries from ['tags'] into common ['comments']&nbsp;</div></li><li><div>        if (!empty($ThisFileInfo['tags'])) {&nbsp;</div></li><li><div>            foreach ($ThisFileInfo['tags'] as $tagtype =&gt; $tagarray) {&nbsp;</div></li><li><div>                foreach ($tagarray as $tagname =&gt; $tagdata) {&nbsp;</div></li><li><div>                    foreach ($tagdata as $key =&gt; $value) {&nbsp;</div></li><li><div>                        if (!empty($value)) {&nbsp;</div></li><li><div>                            if (empty($ThisFileInfo['comments'][$tagname])) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                // fall through and append value&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } elseif ($tagtype == 'id3v1') {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $newvaluelength = strlen(trim($value));&nbsp;</div></li><li><div>                                foreach ($ThisFileInfo['comments'][$tagname] as $existingkey =&gt; $existingvalue) {&nbsp;</div></li><li><div>                                    $oldvaluelength = strlen(trim($existingvalue));&nbsp;</div></li><li><div>                                    if (($newvaluelength &lt;= $oldvaluelength) && (substr($existingvalue, 0, $newvaluelength) == trim($value))) {&nbsp;</div></li><li><div>                                        // new value is identical but shorter-than (or equal-length to) one already in comments - skip&nbsp;</div></li><li><div>                                        break 2;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            } elseif (!is_array($value)) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                                $newvaluelength = strlen(trim($value));&nbsp;</div></li><li><div>                                foreach ($ThisFileInfo['comments'][$tagname] as $existingkey =&gt; $existingvalue) {&nbsp;</div></li><li><div>                                    $oldvaluelength = strlen(trim($existingvalue));&nbsp;</div></li><li><div>                                    if ((strlen($existingvalue) &gt; 10) && ($newvaluelength &gt; $oldvaluelength) && (substr(trim($value), 0, strlen($existingvalue)) == $existingvalue)) {&nbsp;</div></li><li><div>                                        $ThisFileInfo['comments'][$tagname][$existingkey] = trim($value);&nbsp;</div></li><li><div>                                        //break 2;&nbsp;</div></li><li><div>                                        break;&nbsp;</div></li><li><div>                                    }&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                            if (is_array($value) || empty($ThisFileInfo['comments'][$tagname]) || !in_array(trim($value), $ThisFileInfo['comments'][$tagname])) {&nbsp;</div></li><li><div>                                $value = (is_string($value) ? trim($value) : $value);&nbsp;</div></li><li><div>                                if (!is_numeric($key)) {&nbsp;</div></li><li><div>                                    $ThisFileInfo['comments'][$tagname][$key] = $value;&nbsp;</div></li><li><div>                                } else {&nbsp;</div></li><li><div>                                    $ThisFileInfo['comments'][$tagname][] = $value;&nbsp;</div></li><li><div>                                }&nbsp;</div></li><li><div>                            }&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Copy to ['comments_html']&nbsp;</div></li><li><div>            if (!empty($ThisFileInfo['comments'])) {&nbsp;</div></li><li><div>                foreach ($ThisFileInfo['comments'] as $field =&gt; $values) {&nbsp;</div></li><li><div>                    if ($field == 'picture') {&nbsp;</div></li><li><div>                        // pictures can take up a lot of space, and we don't need multiple copies of them&nbsp;</div></li><li><div>                        // let there be a single copy in [comments][picture], and not elsewhere&nbsp;</div></li><li><div>                        continue;&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                    foreach ($values as $index =&gt; $value) {&nbsp;</div></li><li><div>                        if (is_array($value)) {&nbsp;</div></li><li><div>                            $ThisFileInfo['comments_html'][$field][$index] = $value;&nbsp;</div></li><li><div>                        } else {&nbsp;</div></li><li><div>                            $ThisFileInfo['comments_html'][$field][$index] = str_replace('&#0;', '', self::MultiByteCharString2HTML($value, $ThisFileInfo['encoding']));&nbsp;</div></li><li><div>                        }&nbsp;</div></li><li><div>                    }&nbsp;</div></li><li><div>                }&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return true;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function EmbeddedLookup($key, $begin, $end, $file, $name) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Cached&nbsp;</div></li><li><div>        static $cache;&nbsp;</div></li><li><div>        if (isset($cache[$file][$name])) {&nbsp;</div></li><li><div>            return (isset($cache[$file][$name][$key]) ? $cache[$file][$name][$key] : '');&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Init&nbsp;</div></li><li><div>        $keylength = strlen($key);&nbsp;</div></li><li><div>        $line_count = $end - $begin - 7;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Open php file&nbsp;</div></li><li><div>        $fp = fopen($file, 'r');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Discard $begin lines&nbsp;</div></li><li><div>        for ($i = 0; $i &lt; ($begin + 3); $i++) {&nbsp;</div></li><li><div>            fgets($fp, 1024);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Loop thru line&nbsp;</div></li><li><div>        while (0 &lt; $line_count--) {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Read line&nbsp;</div></li><li><div>            $line = ltrim(fgets($fp, 1024), &quot;\t &quot;);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // METHOD A: only cache the matching key - less memory but slower on next lookup of not-previously-looked-up key&nbsp;</div></li><li><div>            //$keycheck = substr($line, 0, $keylength);&nbsp;</div></li><li><div>            //if ($key == $keycheck)  {&nbsp;</div></li><li><div>            //    $cache[$file][$name][$keycheck] = substr($line, $keylength + 1);&nbsp;</div></li><li><div>            //    break;&nbsp;</div></li><li><div>            //}&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // METHOD B: cache all keys in this lookup - more memory but faster on next lookup of not-previously-looked-up key&nbsp;</div></li><li><div>            //$cache[$file][$name][substr($line, 0, $keylength)] = trim(substr($line, $keylength + 1));&nbsp;</div></li><li><div>            $explodedLine = explode(&quot;\t&quot;, $line, 2);&nbsp;</div></li><li><div>            $ThisKey = (isset($explodedLine[0]) ? $explodedLine[0] : '');&nbsp;</div></li><li><div>            $ThisValue = (isset($explodedLine[1]) ? $explodedLine[1] : '');&nbsp;</div></li><li><div>            $cache[$file][$name][$ThisKey] = trim($ThisValue);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Close and return&nbsp;</div></li><li><div>        fclose($fp);&nbsp;</div></li><li><div>        return (isset($cache[$file][$name][$key]) ? $cache[$file][$name][$key] : '');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function IncludeDependency($filename, $sourcefile, $DieOnFailure=false) {&nbsp;</div></li><li><div>        global $GETID3_ERRORARRAY;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (file_exists($filename)) {&nbsp;</div></li><li><div>            if (include_once($filename)) {&nbsp;</div></li><li><div>                return true;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $diemessage = basename($sourcefile).' depends on '.$filename.', which has errors';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $diemessage = basename($sourcefile).' depends on '.$filename.', which is missing';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ($DieOnFailure) {&nbsp;</div></li><li><div>            throw new Exception($diemessage);&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $GETID3_ERRORARRAY[] = $diemessage;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function trimNullByte($string) {&nbsp;</div></li><li><div>        return trim($string, &quot;\x00&quot;);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    public static function getFileSizeSyscall($path) {&nbsp;</div></li><li><div>        $filesize = false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if (GETID3_OS_ISWINDOWS) {&nbsp;</div></li><li><div>            if (class_exists('COM')) { // From PHP 5.3.15 and 5.4.5, COM and DOTNET is no longer built into the php core.you have to add COM support in php.ini:&nbsp;</div></li><li><div>                $filesystem = new COM('Scripting.FileSystemObject');&nbsp;</div></li><li><div>                $file = $filesystem-&gt;GetFile($path);&nbsp;</div></li><li><div>                $filesize = $file-&gt;Size();&nbsp;</div></li><li><div>                unset($filesystem, $file);&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $commandline = 'for %I in ('.escapeshellarg($path).') do @echo %~zI';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $commandline = 'ls -l '.escapeshellarg($path).' | awk \'{print $5}\'';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if (isset($commandline)) {&nbsp;</div></li><li><div>            $output = trim(`$commandline`);&nbsp;</div></li><li><div>            if (ctype_digit($output)) {&nbsp;</div></li><li><div>                $filesize = (float) $output;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        return $filesize;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>    * Workaround for Bug #37268 (https://bugs.php.net/bug.php?id=37268)&nbsp;</div></li><li><div>    * @param string $path A path.&nbsp;</div></li><li><div>    * @param string $suffix If the name component ends in suffix this will also be cut off.&nbsp;</div></li><li><div>    * @return string&nbsp;</div></li><li><div>    */&nbsp;</div></li><li><div>    public static function mb_basename($path, $suffix = null) {&nbsp;</div></li><li><div>        $splited = preg_split('#/#', rtrim($path, '/ '));&nbsp;</div></li><li><div>        return substr(basename('X'.$splited[count($splited) - 1], $suffix), 1);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="https://hookr.io/plugin/"><img src="https://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 4.7</dd><dt>Others</dt><dd><ul><li><a href="https://hookr.io/4.7.4/classes/getid3_lib/" class="active">4.7.4</a></li><li><a href="https://hookr.io/4.7.3/classes/getid3_lib/" class="">4.7.3</a></li><li><a href="https://hookr.io/4.7.2/classes/getid3_lib/" class="">4.7.2</a></li><li><a href="https://hookr.io/4.7.1/classes/getid3_lib/" class="">4.7.1</a></li><li><a href="https://hookr.io/4.7/classes/getid3_lib/" class="">4.7</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>class</li><li><span></span>getid3_lib</li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2021 hookr.io <strong>(beta)</strong> | <a href="https://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="https://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>