<!DOCTYPE html> <!--[if lt IE 7]><html class="hookr class lt-ie9 lt-ie8 lt-ie7 ie"><![endif]--> <!--[if IE 7]><html class="hookr class lt-ie9 lt-ie8 ie7 ie"><![endif]--> <!--[if IE 8]><html class="hookr class lt-ie9 ie8 ie"><![endif]--> <!--[if IE 9]><html class="hookr class ie9 ie"><![endif]--> <!--[if gt IE 9]><html class="hookr class gt-ie9 ie"><![endif]--><html lang="en-US" id="single" class="hookr class" data-site="wordpress" data-type="class" data-id="5687"><head xmlns="http://www.w3.org/1999/xhtml"><title> wp_http | class | WordPress | hookr.io</title><meta charset="UTF-8"><meta name="author" content="thepassionofthechris \m/," /><meta name="keywords" content="WP_Http, class, wordpress, 4.7.4" /><meta name="description" content="Core class used for managing HTTP transports and making HTTP requests." /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel="shortcut icon" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.ico" /><link rel="icon" type="image/png" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.png"><link rel="icon" type="image/gif" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.gif"><link rel="icon" type="image/jpeg" href="http://hookr.io/wp-content/themes/hookr/assets/images/favicon.jpg"><meta name="google-site-verification" content="Q5dnl0YziNqRLCBxFtc2Rd8vUuueYAt6VIUYZItvEL4" /><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/hookr.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.4.25"}};!function(e,n,t){var a;function i(e){var t=n.createElement("canvas"),a=t.getContext&&t.getContext("2d"),i=String.fromCharCode;return!(!a||!a.fillText)&&(a.textBaseline="top",a.font="600 32px Arial","flag"===e?(a.fillText(i(55356,56806,55356,56826),0,0),3e3<t.toDataURL().length):"diversity"===e?(a.fillText(i(55356,57221),0,0),t=a.getImageData(16,16,1,1).data,a.fillText(i(55356,57221,55356,57343),0,0),(t=a.getImageData(16,16,1,1).data)[0],t[1],t[2],t[3],!0):("simple"===e?a.fillText(i(55357,56835),0,0):a.fillText(i(55356,57135),0,0),0!==a.getImageData(16,16,1,1).data[0]))}function o(e){var t=n.createElement("script");t.src=e,t.type="text/javascript",n.getElementsByTagName("head")[0].appendChild(t)}t.supports={simple:i("simple"),flag:i("flag"),unicode8:i("unicode8"),diversity:i("diversity")},t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.simple&&t.supports.flag&&t.supports.unicode8&&t.supports.diversity||(a=function(){t.readyCallback()},n.addEventListener?(n.addEventListener("DOMContentLoaded",a,!1),e.addEventListener("load",a,!1)):(e.attachEvent("onload",a),n.attachEvent("onreadystatechange",function(){"complete"===n.readyState&&t.readyCallback()})),(a=t.source||{}).concatemoji?o(a.concatemoji):a.wpemoji&&a.twemoji&&(o(a.twemoji),o(a.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0
.07em !important;vertical-align:-0.1em !important;background:none !important;padding:0
!important}</style><link rel='stylesheet' id='screen-css'  href='http://hookr.io/wp-content/themes/hookr/assets/css/hookr.css?ver=5101c1c3a26da2aaea1302a2ab06130b' type='text/css' media='screen' /><link rel='stylesheet' id='qtip-css'  href='http://hookr.io/wp-content/themes/hookr/assets/vendor/jquery.qtip.custom/jquery.qtip.min.css?ver=4.4.25' type='text/css' media='screen' /><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fU9dGoIwDLsQW_XbHbyAXmCMAsNBsS2otxcYvqFP_UmaJg66x4T8LtzemD427BVtH4fiBC3RncGLoAp0AqWYRDS2lA4ZMw4VMZREKsp-NM46e14PlShpHJc_UwSsawz6R6CbURX38oNzDUwp3egSX1iZ3osif0PIhinVK3YQI9NsWNYRs6dAnCNt0zNWDW4OPw.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdTPzS8tTtXLzcwDAA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/fZBBDsIwDAQ_RG1Kn8AvuKWJUQ1JHBIXVF5PKOoFKZV8Gc_KK3nAmVHNWCBwPAxfKp4d5ZWPOIncM5pSSAve6jxmygskbyxN4mvwP_Sk6KRSSJ6vS9dDD6eNGkdXbu3hV9nUs7JvSpNqrzXK0uwFKyFJpKg7V3jPwZPp1XjDm7JYz2kUk10XTFHK6LgoXqo5b-YD.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9DPyM_PLtJPLC5OLSnWL0vNS8kv0s8qLE0tqtQrLMks0EsuLS7Jz0URys3MAwA.js"></script><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9YvzdRPTUtLTS7RzchMz8gB4hK93Mw8HQP9jPz87CL9xOLi1JJi_axiCF8vsSBTrzgzLz0nFQA.js"></script><link rel='https://api.w.org/' href='http://hookr.io/wp-json/' /><link rel="canonical" href="http://hookr.io/classes/wp_http/" /><link rel="alternate" type="application/json+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fwp_http%2F" /><link rel="alternate" type="text/xml+oembed" href="http://hookr.io/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhookr.io%2Fclasses%2Fwp_http%2F&#038;format=xml" /><script>/*<![CDATA[*/if('undefined'===typeof Hookr)
var Hookr={};if('undefined'===typeof Hookr.Util)
Hookr.Util={};Hookr.Util=jQuery&&jQuery.extend(Hookr.Util,{"adminAjax":"http:\/\/hookr.io\/wp-admin\/admin-ajax.php","themeUrl":"http:\/\/hookr.io\/wp-content\/themes\/hookr\/","apiKey":"wordpress-4.7.4-class-wp_http","actions":{"popover":0,"range":1,"search":2,"stat":3}});/*]]>*/</script><!--[if lt IE 9]><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv.js"></script><script src="http://hookr.io/wp-content/themes/hookr/assets/js/html5shiv-printshiv.js"></script><![endif]--></head><body id="wp_http" class="single single-class single-format-standard"><div id="gutter"><div><ul id="nav-breadcrumb" role="navigation" class="pivot clear fix"><li class="home"><a title="Go to hookr.io." href="http://hookr.io" class="home">hookr.io</a></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to 4.7.4." href="http://hookr.io/4.7.4/" class="H_VERSION"><span property="name">4.7.4</span></a><meta property="position" content="2"></span></li><li>/</li><li><span property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" title="Go to classes." href="http://hookr.io/4.7.4/classes/" class=""><span property="name">classes</span></a><meta property="position" content="3"></span></li><li>/</li><li class="current_item"><span property="itemListElement" typeof="ListItem"><span property="name">wp_http</span><meta property="position" content="4"></span></li></ul></div></div><header class="jv-fixed"><div> <button class="btn" data-jv-trigger="left"><span></span></button><h1 title="hookr.io"><a href="http://hookr.io" title="hookr.io"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/hookr.svg" title="The WordPress Hook/API Index" alt="The WordPress Hook/API Index"/></a></h1> <nav id="nav-api-types" class="pivot clearfix" data-jv-order="0" data-jv-content="left" data-active="class"><ul role="navigation"><li class="" data-id="all" data-count="6316"><a href="http://hookr.io/4.7.4/all/" title="All">All <span class="count badge">6316</span></a></li><li class="" data-id="new" data-count="6"><a href="http://hookr.io/4.7.4/new/" title="New">New <span class="count badge">6</span></a></li><li class="" data-id="hooks" data-count="2538"><a href="http://hookr.io/4.7.4/hooks/" title="Hooks">Hooks <span class="count badge">2538</span></a></li><li class="" data-id="action" data-count="864"><a href="http://hookr.io/4.7.4/actions/" title="Actions">Actions <span class="count badge">864</span></a></li><li class="" data-id="filter" data-count="1674"><a href="http://hookr.io/4.7.4/filters/" title="Filters">Filters <span class="count badge">1674</span></a></li><li class="active" data-id="class" data-count="351"><a href="http://hookr.io/4.7.4/classes/" title="Classes">Classes <span class="count badge">351</span></a></li><li class="" data-id="constant" data-count="566"><a href="http://hookr.io/4.7.4/constants/" title="Constants">Constants <span class="count badge">566</span></a></li><li class="" data-id="function" data-count="2853"><a href="http://hookr.io/4.7.4/functions/" title="Functions">Functions <span class="count badge">2853</span></a></li><li class="" data-id="shortcode" data-count="8"><a href="http://hookr.io/4.7.4/shortcodes/" title="Shortcodes">Shortcodes <span class="count badge">8</span></a></li></ul> </nav> <nav id="nav-main" class="pivot" data-jv-order="1" data-jv-content="left"><ul role="navigation"><li class="active"><a href="http://hookr.io/all/" title="Core">Core</a></li><li class=""><a href="http://hookr.io/plugins/" title="Plugins">Plugins</a></li><li class=""><a href="http://hookr.io/themes/" title="Themes">Themes</a></li><li class=""><a href="http://hookr.io/features/" title="Features">Features</a></li><li class=""><a href="http://hookr.io/plugin/" title="Plugin">Plugin</a></li><li class=""><a href="http://hookr.io/about/" title="About">About</a></li><li class=""><a href="http://hookr.io/contact/" title="Contact">Contact</a></li></ul> </nav></div> </header><div role="main" id="middle"><div><div id="mainbar"> <article><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=hookrio" id="_carbonads_js"></script><noscript>derpy.</noscript> <section><h1><strong>WP_Http</strong></h1><p>Core class used for managing HTTP transports and making HTTP requests.</p> </section> <section id="defined" class="source"><h2>Defined <span class="count">(1)</span></h2><p>The class is defined in the following location(s).</p><dl><dt><strong><a href="http://hookr.io/4.7.4/files/wp-includes-class-http/" class="file">/wp-includes/class-http.php <span>&nbsp;</span></a></strong></dt><dd><pre><ol data-line="28" class="block" start="28"><li><div>class WP_Http {&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    // Aliases for HTTP response codes.&nbsp;</div></li><li><div>    const HTTP_CONTINUE = 100;&nbsp;</div></li><li><div>    const SWITCHING_PROTOCOLS = 101;&nbsp;</div></li><li><div>    const PROCESSING = 102;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const OK = 200;&nbsp;</div></li><li><div>    const CREATED = 201;&nbsp;</div></li><li><div>    const ACCEPTED = 202;&nbsp;</div></li><li><div>    const NON_AUTHORITATIVE_INFORMATION = 203;&nbsp;</div></li><li><div>    const NO_CONTENT = 204;&nbsp;</div></li><li><div>    const RESET_CONTENT = 205;&nbsp;</div></li><li><div>    const PARTIAL_CONTENT = 206;&nbsp;</div></li><li><div>    const MULTI_STATUS = 207;&nbsp;</div></li><li><div>    const IM_USED = 226;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const MULTIPLE_CHOICES = 300;&nbsp;</div></li><li><div>    const MOVED_PERMANENTLY = 301;&nbsp;</div></li><li><div>    const FOUND = 302;&nbsp;</div></li><li><div>    const SEE_OTHER = 303;&nbsp;</div></li><li><div>    const NOT_MODIFIED = 304;&nbsp;</div></li><li><div>    const USE_PROXY = 305;&nbsp;</div></li><li><div>    const RESERVED = 306;&nbsp;</div></li><li><div>    const TEMPORARY_REDIRECT = 307;&nbsp;</div></li><li><div>    const PERMANENT_REDIRECT = 308;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const BAD_REQUEST = 400;&nbsp;</div></li><li><div>    const UNAUTHORIZED = 401;&nbsp;</div></li><li><div>    const PAYMENT_REQUIRED = 402;&nbsp;</div></li><li><div>    const FORBIDDEN = 403;&nbsp;</div></li><li><div>    const NOT_FOUND = 404;&nbsp;</div></li><li><div>    const METHOD_NOT_ALLOWED = 405;&nbsp;</div></li><li><div>    const NOT_ACCEPTABLE = 406;&nbsp;</div></li><li><div>    const PROXY_AUTHENTICATION_REQUIRED = 407;&nbsp;</div></li><li><div>    const REQUEST_TIMEOUT = 408;&nbsp;</div></li><li><div>    const CONFLICT = 409;&nbsp;</div></li><li><div>    const GONE = 410;&nbsp;</div></li><li><div>    const LENGTH_REQUIRED = 411;&nbsp;</div></li><li><div>    const PRECONDITION_FAILED = 412;&nbsp;</div></li><li><div>    const REQUEST_ENTITY_TOO_LARGE = 413;&nbsp;</div></li><li><div>    const REQUEST_URI_TOO_LONG = 414;&nbsp;</div></li><li><div>    const UNSUPPORTED_MEDIA_TYPE = 415;&nbsp;</div></li><li><div>    const REQUESTED_RANGE_NOT_SATISFIABLE = 416;&nbsp;</div></li><li><div>    const EXPECTATION_FAILED = 417;&nbsp;</div></li><li><div>    const IM_A_TEAPOT = 418;&nbsp;</div></li><li><div>    const MISDIRECTED_REQUEST = 421;&nbsp;</div></li><li><div>    const UNPROCESSABLE_ENTITY = 422;&nbsp;</div></li><li><div>    const LOCKED = 423;&nbsp;</div></li><li><div>    const FAILED_DEPENDENCY = 424;&nbsp;</div></li><li><div>    const UPGRADE_REQUIRED = 426;&nbsp;</div></li><li><div>    const PRECONDITION_REQUIRED = 428;&nbsp;</div></li><li><div>    const TOO_MANY_REQUESTS = 429;&nbsp;</div></li><li><div>    const REQUEST_HEADER_FIELDS_TOO_LARGE = 431;&nbsp;</div></li><li><div>    const UNAVAILABLE_FOR_LEGAL_REASONS = 451;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    const INTERNAL_SERVER_ERROR = 500;&nbsp;</div></li><li><div>    const NOT_IMPLEMENTED = 501;&nbsp;</div></li><li><div>    const BAD_GATEWAY = 502;&nbsp;</div></li><li><div>    const SERVICE_UNAVAILABLE = 503;&nbsp;</div></li><li><div>    const GATEWAY_TIMEOUT = 504;&nbsp;</div></li><li><div>    const HTTP_VERSION_NOT_SUPPORTED = 505;&nbsp;</div></li><li><div>    const VARIANT_ALSO_NEGOTIATES = 506;&nbsp;</div></li><li><div>    const INSUFFICIENT_STORAGE = 507;&nbsp;</div></li><li><div>    const NOT_EXTENDED = 510;&nbsp;</div></li><li><div>    const NETWORK_AUTHENTICATION_REQUIRED = 511;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Send an HTTP request to a URI.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Please note: The only URI that are supported in the HTTP Transport implementation&nbsp;</div></li><li><div>     * are the HTTP and HTTPS protocols.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @since 2.7.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string       $url  The request URL.&nbsp;</div></li><li><div>     * @param string|array $args {&nbsp;</div></li><li><div>     *     Optional. Array or string of HTTP request arguments.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     *     @type string       $method              Request method. Accepts 'GET', 'POST', 'HEAD', or 'PUT'.&nbsp;</div></li><li><div>     *                                             Some transports technically allow others, but should not be&nbsp;</div></li><li><div>     *                                             assumed. Default 'GET'.&nbsp;</div></li><li><div>     *     @type int          $timeout             How long the connection should stay open in seconds. Default 5.&nbsp;</div></li><li><div>     *     @type int          $redirection         Number of allowed redirects. Not supported by all transports&nbsp;</div></li><li><div>     *                                             Default 5.&nbsp;</div></li><li><div>     *     @type string       $httpversion         Version of the HTTP protocol to use. Accepts '1.0' and '1.1'.&nbsp;</div></li><li><div>     *                                             Default '1.0'.&nbsp;</div></li><li><div>     *     @type string       $user-agent          User-agent value sent.&nbsp;</div></li><li><div>     *                                             Default WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ).&nbsp;</div></li><li><div>     *     @type bool         $reject_unsafe_urls  Whether to pass URLs through wp_http_validate_url().&nbsp;</div></li><li><div>     *                                             Default false.&nbsp;</div></li><li><div>     *     @type bool         $blocking            Whether the calling code requires the result of the request.&nbsp;</div></li><li><div>     *                                             If set to false, the request will be sent to the remote server, &nbsp;</div></li><li><div>     *                                             and processing returned to the calling code immediately, the caller&nbsp;</div></li><li><div>     *                                             will know if the request succeeded or failed, but will not receive&nbsp;</div></li><li><div>     *                                             any response from the remote server. Default true.&nbsp;</div></li><li><div>     *     @type string|array $headers             Array or string of headers to send with the request.&nbsp;</div></li><li><div>     *                                             Default empty array.&nbsp;</div></li><li><div>     *     @type array        $cookies             List of cookies to send with the request. Default empty array.&nbsp;</div></li><li><div>     *     @type string|array $body                Body to send with the request. Default null.&nbsp;</div></li><li><div>     *     @type bool         $compress            Whether to compress the $body when sending the request.&nbsp;</div></li><li><div>     *                                             Default false.&nbsp;</div></li><li><div>     *     @type bool         $decompress          Whether to decompress a compressed response. If set to false and&nbsp;</div></li><li><div>     *                                             compressed content is returned in the response anyway, it will&nbsp;</div></li><li><div>     *                                             need to be separately decompressed. Default true.&nbsp;</div></li><li><div>     *     @type bool         $sslverify           Whether to verify SSL for the request. Default true.&nbsp;</div></li><li><div>     *     @type string       sslcertificates      Absolute path to an SSL certificate .crt file.&nbsp;</div></li><li><div>     *                                             Default ABSPATH . WPINC . '/certificates/ca-bundle.crt'.&nbsp;</div></li><li><div>     *     @type bool         $stream              Whether to stream to a file. If set to true and no filename was&nbsp;</div></li><li><div>     *                                             given, it will be droped it in the WP temp dir and its name will&nbsp;</div></li><li><div>     *                                             be set using the basename of the URL. Default false.&nbsp;</div></li><li><div>     *     @type string       $filename            Filename of the file to write to when streaming. $stream must be&nbsp;</div></li><li><div>     *                                             set to true. Default null.&nbsp;</div></li><li><div>     *     @type int          $limit_response_size Size in bytes to limit the response to. Default null.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * }&nbsp;</div></li><li><div>     * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'.&nbsp;</div></li><li><div>     *                        A WP_Error instance upon error.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function request( $url, $args = array() ) {&nbsp;</div></li><li><div>        $defaults = array(&nbsp;</div></li><li><div>            'method' =&gt; 'GET', &nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Filters the timeout value for an HTTP request.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 2.7.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param int $timeout_value Time in seconds until a request times out.&nbsp;</div></li><li><div>             *                           Default 5.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            'timeout' =&gt; apply_filters( 'http_request_timeout', 5 ), &nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Filters the number of redirects allowed during an HTTP request.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 2.7.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param int $redirect_count Number of redirects allowed. Default 5.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            'redirection' =&gt; apply_filters( 'http_request_redirection_count', 5 ), &nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Filters the version of the HTTP protocol used in a request.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 2.7.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param string $version Version of HTTP used. Accepts '1.0' and '1.1'.&nbsp;</div></li><li><div>             *                        Default '1.0'.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            'httpversion' =&gt; apply_filters( 'http_request_version', '1.0' ), &nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Filters the user agent value sent with an HTTP request.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 2.7.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param string $user_agent WordPress user agent string.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            'user-agent' =&gt; apply_filters( 'http_headers_useragent', 'WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ) ), &nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Filters whether to pass URLs through wp_http_validate_url() in an HTTP request.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 3.6.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param bool $pass_url Whether to pass URLs through wp_http_validate_url().&nbsp;</div></li><li><div>             *                       Default false.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            'reject_unsafe_urls' =&gt; apply_filters( 'http_request_reject_unsafe_urls', false ), &nbsp;</div></li><li><div>            'blocking' =&gt; true, &nbsp;</div></li><li><div>            'headers' =&gt; array(), &nbsp;</div></li><li><div>            'cookies' =&gt; array(), &nbsp;</div></li><li><div>            'body' =&gt; null, &nbsp;</div></li><li><div>            'compress' =&gt; false, &nbsp;</div></li><li><div>            'decompress' =&gt; true, &nbsp;</div></li><li><div>            'sslverify' =&gt; true, &nbsp;</div></li><li><div>            'sslcertificates' =&gt; ABSPATH . WPINC . '/certificates/ca-bundle.crt', &nbsp;</div></li><li><div>            'stream' =&gt; false, &nbsp;</div></li><li><div>            'filename' =&gt; null, &nbsp;</div></li><li><div>            'limit_response_size' =&gt; null, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Pre-parse for the HEAD checks.&nbsp;</div></li><li><div>        $args = wp_parse_args( $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // By default, Head requests do not cause redirections.&nbsp;</div></li><li><div>        if ( isset($args['method']) && 'HEAD' == $args['method'] )&nbsp;</div></li><li><div>            $defaults['redirection'] = 0;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters the arguments used in an HTTP request.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 2.7.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array  $r   An array of HTTP request arguments.&nbsp;</div></li><li><div>         * @param string $url The request URL.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $r = apply_filters( 'http_request_args', $r, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // The transports decrement this, store a copy of the original value for loop purposes.&nbsp;</div></li><li><div>        if ( ! isset( $r['_redirection'] ) )&nbsp;</div></li><li><div>            $r['_redirection'] = $r['redirection'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters whether to preempt an HTTP request's return value.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Returning a non-false value from the filter will short-circuit the HTTP request and return&nbsp;</div></li><li><div>         * early with that value. A filter should return either:&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         *  - An array containing 'headers', 'body', 'response', 'cookies', and 'filename' elements&nbsp;</div></li><li><div>         *  - A WP_Error instance&nbsp;</div></li><li><div>         *  - boolean false (to avoid short-circuiting the response)&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * Returning any other value may result in unexpected behaviour.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 2.9.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param false|array|WP_Error $preempt Whether to preempt an HTTP request's return value. Default false.&nbsp;</div></li><li><div>         * @param array               $r        HTTP request arguments.&nbsp;</div></li><li><div>         * @param string              $url      The request URL.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $pre = apply_filters( 'pre_http_request', false, $r, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( false !== $pre )&nbsp;</div></li><li><div>            return $pre;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( function_exists( 'wp_kses_bad_protocol' ) ) {&nbsp;</div></li><li><div>            if ( $r['reject_unsafe_urls'] ) {&nbsp;</div></li><li><div>                $url = wp_http_validate_url( $url );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ( $url ) {&nbsp;</div></li><li><div>                $url = wp_kses_bad_protocol( $url, array( 'http', 'https', 'ssl' ) );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $arrURL = @parse_url( $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( empty( $url ) || empty( $arrURL['scheme'] ) ) {&nbsp;</div></li><li><div>            return new WP_Error('http_request_failed', __('A valid URL was not provided.'));&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( $this-&gt;block_request( $url ) ) {&nbsp;</div></li><li><div>            return new WP_Error( 'http_request_failed', __( 'User has blocked requests through HTTP.' ) );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If we are streaming to a file but no filename was given drop it in the WP temp dir&nbsp;</div></li><li><div>        // and pick its name using the basename of the $url&nbsp;</div></li><li><div>        if ( $r['stream'] ) {&nbsp;</div></li><li><div>            if ( empty( $r['filename'] ) ) {&nbsp;</div></li><li><div>                $r['filename'] = get_temp_dir() . basename( $url );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Force some settings if we are streaming to a file and check for existence and perms of destination directory&nbsp;</div></li><li><div>            $r['blocking'] = true;&nbsp;</div></li><li><div>            if ( ! wp_is_writable( dirname( $r['filename'] ) ) ) {&nbsp;</div></li><li><div>                return new WP_Error( 'http_request_failed', __( 'Destination directory for file streaming does not exist or is not writable.' ) );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( is_null( $r['headers'] ) ) {&nbsp;</div></li><li><div>            $r['headers'] = array();&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // WP allows passing in headers as a string, weirdly.&nbsp;</div></li><li><div>        if ( ! is_array( $r['headers'] ) ) {&nbsp;</div></li><li><div>            $processedHeaders = WP_Http::processHeaders( $r['headers'] );&nbsp;</div></li><li><div>            $r['headers'] = $processedHeaders['headers'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Setup arguments&nbsp;</div></li><li><div>        $headers = $r['headers'];&nbsp;</div></li><li><div>        $data = $r['body'];&nbsp;</div></li><li><div>        $type = $r['method'];&nbsp;</div></li><li><div>        $options = array(&nbsp;</div></li><li><div>            'timeout' =&gt; $r['timeout'], &nbsp;</div></li><li><div>            'useragent' =&gt; $r['user-agent'], &nbsp;</div></li><li><div>            'blocking' =&gt; $r['blocking'], &nbsp;</div></li><li><div>            'hooks' =&gt; new WP_HTTP_Requests_Hooks( $url, $r ), &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Ensure redirects follow browser behaviour.&nbsp;</div></li><li><div>        $options['hooks']-&gt;register( 'requests.before_redirect', array( get_class(), 'browser_redirect_compatibility' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( $r['stream'] ) {&nbsp;</div></li><li><div>            $options['filename'] = $r['filename'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        if ( empty( $r['redirection'] ) ) {&nbsp;</div></li><li><div>            $options['follow_redirects'] = false;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $options['redirects'] = $r['redirection'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Use byte limit, if we can&nbsp;</div></li><li><div>        if ( isset( $r['limit_response_size'] ) ) {&nbsp;</div></li><li><div>            $options['max_bytes'] = $r['limit_response_size'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If we've got cookies, use and convert them to Requests_Cookie.&nbsp;</div></li><li><div>        if ( ! empty( $r['cookies'] ) ) {&nbsp;</div></li><li><div>            $options['cookies'] = WP_Http::normalize_cookies( $r['cookies'] );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // SSL certificate handling&nbsp;</div></li><li><div>        if ( ! $r['sslverify'] ) {&nbsp;</div></li><li><div>            $options['verify'] = false;&nbsp;</div></li><li><div>            $options['verifyname'] = false;&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $options['verify'] = $r['sslcertificates'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // All non-GET/HEAD requests should put the arguments in the form body.&nbsp;</div></li><li><div>        if ( 'HEAD' !== $type && 'GET' !== $type ) {&nbsp;</div></li><li><div>            $options['data_format'] = 'body';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters whether SSL should be verified for non-local requests.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 2.8.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param bool $ssl_verify Whether to verify the SSL connection. Default true.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $options['verify'] = apply_filters( 'https_ssl_verify', $options['verify'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Check for proxies.&nbsp;</div></li><li><div>        $proxy = new WP_HTTP_Proxy();&nbsp;</div></li><li><div>        if ( $proxy-&gt;is_enabled() && $proxy-&gt;send_through_proxy( $url ) ) {&nbsp;</div></li><li><div>            $options['proxy'] = new Requests_Proxy_HTTP( $proxy-&gt;host() . ':' . $proxy-&gt;port() );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( $proxy-&gt;use_authentication() ) {&nbsp;</div></li><li><div>                $options['proxy']-&gt;use_authentication = true;&nbsp;</div></li><li><div>                $options['proxy']-&gt;user = $proxy-&gt;username();&nbsp;</div></li><li><div>                $options['proxy']-&gt;pass = $proxy-&gt;password();&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Avoid issues where mbstring.func_overload is enabled&nbsp;</div></li><li><div>        mbstring_binary_safe_encoding();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        try {&nbsp;</div></li><li><div>            $requests_response = Requests::request( $url, $headers, $data, $type, $options );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Convert the response into an array&nbsp;</div></li><li><div>            $http_response = new WP_HTTP_Requests_Response( $requests_response, $r['filename'] );&nbsp;</div></li><li><div>            $response = $http_response-&gt;to_array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Add the original object to the array.&nbsp;</div></li><li><div>            $response['http_response'] = $http_response;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>        catch ( Requests_Exception $e ) {&nbsp;</div></li><li><div>            $response = new WP_Error( 'http_request_failed', $e-&gt;getMessage() );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        reset_mbstring_encoding();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Fires after an HTTP API response is received and before the response is returned.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 2.8.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array|WP_Error $response HTTP response or WP_Error object.&nbsp;</div></li><li><div>         * @param string         $context  Context under which the hook is fired.&nbsp;</div></li><li><div>         * @param string         $class    HTTP transport used.&nbsp;</div></li><li><div>         * @param array          $args     HTTP request arguments.&nbsp;</div></li><li><div>         * @param string         $url      The request URL.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        do_action( 'http_api_debug', $response, 'response', 'Requests', $r, $url );&nbsp;</div></li><li><div>        if ( is_wp_error( $response ) ) {&nbsp;</div></li><li><div>            return $response;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( ! $r['blocking'] ) {&nbsp;</div></li><li><div>            return array(&nbsp;</div></li><li><div>                'headers' =&gt; array(), &nbsp;</div></li><li><div>                'body' =&gt; '', &nbsp;</div></li><li><div>                'response' =&gt; array(&nbsp;</div></li><li><div>                    'code' =&gt; false, &nbsp;</div></li><li><div>                    'message' =&gt; false, &nbsp;</div></li><li><div> ), &nbsp;</div></li><li><div>                'cookies' =&gt; array(), &nbsp;</div></li><li><div>                'http_response' =&gt; null, &nbsp;</div></li><li><div> );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters the HTTP API response immediately before the response is returned.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 2.9.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array  $response HTTP response.&nbsp;</div></li><li><div>         * @param array  $r        HTTP request arguments.&nbsp;</div></li><li><div>         * @param string $url      The request URL.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        return apply_filters( 'http_response', $response, $r, $url );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Normalizes cookies for using in Requests.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 4.6.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param array $cookies List of cookies to send with the request.&nbsp;</div></li><li><div>     * @return Requests_Cookie_Jar Cookie holder object.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function normalize_cookies( $cookies ) {&nbsp;</div></li><li><div>        $cookie_jar = new Requests_Cookie_Jar();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        foreach ( $cookies as $name =&gt; $value ) {&nbsp;</div></li><li><div>            if ( $value instanceof WP_Http_Cookie ) {&nbsp;</div></li><li><div>                $cookie_jar[ $value-&gt;name ] = new Requests_Cookie( $value-&gt;name, $value-&gt;value, $value-&gt;get_attributes() );&nbsp;</div></li><li><div>            } elseif ( is_scalar( $value ) ) {&nbsp;</div></li><li><div>                $cookie_jar[ $name ] = new Requests_Cookie( $name, $value );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $cookie_jar;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Match redirect behaviour to browser handling.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Changes 302 redirects from POST to GET to match browser handling. Per&nbsp;</div></li><li><div>     * RFC 7231, user agents can deviate from the strict reading of the&nbsp;</div></li><li><div>     * specification for compatibility purposes.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 4.6.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string            $location URL to redirect to.&nbsp;</div></li><li><div>     * @param array             $headers  Headers for the redirect.&nbsp;</div></li><li><div>     * @param array             $options  Redirect request options.&nbsp;</div></li><li><div>     * @param Requests_Response $original Response object.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function browser_redirect_compatibility( $location, $headers, $data, &$options, $original ) {&nbsp;</div></li><li><div>        // Browser compat&nbsp;</div></li><li><div>        if ( $original-&gt;status_code === 302 ) {&nbsp;</div></li><li><div>            $options['type'] = Requests::GET;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Tests which transports are capable of supporting the request.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 3.2.0&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param array $args Request arguments&nbsp;</div></li><li><div>     * @param string $url URL to Request&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @return string|false Class name for the first transport that claims to support the request. False if no transport claims to support the request.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function _get_first_available_transport( $args, $url = null ) {&nbsp;</div></li><li><div>        $transports = array( 'curl', 'streams' );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters which HTTP transports are available and in what order.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 3.7.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array  $transports Array of HTTP transports to check. Default array contains&nbsp;</div></li><li><div>         *                           'curl', and 'streams', in that order.&nbsp;</div></li><li><div>         * @param array  $args       HTTP request arguments.&nbsp;</div></li><li><div>         * @param string $url        The URL to request.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        $request_order = apply_filters( 'http_api_transports', $transports, $args, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Loop over each transport on each HTTP request looking for one which will serve this request's needs.&nbsp;</div></li><li><div>        foreach ( $request_order as $transport ) {&nbsp;</div></li><li><div>            if ( in_array( $transport, $transports ) ) {&nbsp;</div></li><li><div>                $transport = ucfirst( $transport );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            $class = 'WP_Http_' . $transport;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Check to see if this transport is a possibility, calls the transport statically.&nbsp;</div></li><li><div>            if ( !call_user_func( array( $class, 'test' ), $args, $url ) )&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            return $class;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Dispatches a HTTP request to a supporting transport.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Tests each transport in order to find a transport which matches the request arguments.&nbsp;</div></li><li><div>     * Also caches the transport instance to be used later.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * The order for requests is cURL, and then PHP Streams.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 3.2.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     * @access private&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $url URL to Request&nbsp;</div></li><li><div>     * @param array $args Request arguments&nbsp;</div></li><li><div>     * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    private function _dispatch_request( $url, $args ) {&nbsp;</div></li><li><div>        static $transports = array();&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $class = $this-&gt;_get_first_available_transport( $args, $url );&nbsp;</div></li><li><div>        if ( !$class )&nbsp;</div></li><li><div>            return new WP_Error( 'http_failure', __( 'There are no HTTP transports available which can complete the requested request.' ) );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Transport claims to support request, instantiate it and give it a whirl.&nbsp;</div></li><li><div>        if ( empty( $transports[$class] ) )&nbsp;</div></li><li><div>            $transports[$class] = new $class;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $response = $transports[$class]-&gt;request( $url, $args );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /** This action is documented in wp-includes/class-http.php */&nbsp;</div></li><li><div>        do_action( 'http_api_debug', $response, 'response', $class, $args, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( is_wp_error( $response ) )&nbsp;</div></li><li><div>            return $response;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * Filters the HTTP API response immediately before the response is returned.&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @since 2.9.0&nbsp;</div></li><li><div>         *&nbsp;</div></li><li><div>         * @param array  $response HTTP response.&nbsp;</div></li><li><div>         * @param array  $args     HTTP request arguments.&nbsp;</div></li><li><div>         * @param string $url      The request URL.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        return apply_filters( 'http_response', $response, $args, $url );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Uses the POST HTTP method.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Used for sending data that is expected to be in the body.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @since 2.7.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string       $url  The request URL.&nbsp;</div></li><li><div>     * @param string|array $args Optional. Override the defaults.&nbsp;</div></li><li><div>     * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function post($url, $args = array()) {&nbsp;</div></li><li><div>        $defaults = array('method' =&gt; 'POST');&nbsp;</div></li><li><div>        $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>        return $this-&gt;request($url, $r);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Uses the GET HTTP method.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Used for sending data that is expected to be in the body.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @since 2.7.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $url The request URL.&nbsp;</div></li><li><div>     * @param string|array $args Optional. Override the defaults.&nbsp;</div></li><li><div>     * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function get($url, $args = array()) {&nbsp;</div></li><li><div>        $defaults = array('method' =&gt; 'GET');&nbsp;</div></li><li><div>        $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>        return $this-&gt;request($url, $r);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Uses the HEAD HTTP method.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Used for sending data that is expected to be in the body.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @since 2.7.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $url The request URL.&nbsp;</div></li><li><div>     * @param string|array $args Optional. Override the defaults.&nbsp;</div></li><li><div>     * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function head($url, $args = array()) {&nbsp;</div></li><li><div>        $defaults = array('method' =&gt; 'HEAD');&nbsp;</div></li><li><div>        $r = wp_parse_args( $args, $defaults );&nbsp;</div></li><li><div>        return $this-&gt;request($url, $r);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Parses the responses and splits the parts into headers and body.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     * @since 2.7.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $strResponse The full response string&nbsp;</div></li><li><div>     * @return array Array with 'headers' and 'body' keys.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function processResponse($strResponse) {&nbsp;</div></li><li><div>        $res = explode(&quot;\r\n\r\n&quot;, $strResponse, 2);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return array('headers' =&gt; $res[0], 'body' =&gt; isset($res[1]) ? $res[1] : '');&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Transform header string into an array.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If an array is given then it is assumed to be raw header data with numeric keys with the&nbsp;</div></li><li><div>     * headers as the values. No headers must be passed that were already processed.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     * @since 2.7.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string|array $headers&nbsp;</div></li><li><div>     * @param string $url The URL that was requested&nbsp;</div></li><li><div>     * @return array Processed string headers. If duplicate headers are encountered, &nbsp;</div></li><li><div>     *                     Then a numbered array is returned as the value of that header-key.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function processHeaders( $headers, $url = '' ) {&nbsp;</div></li><li><div>        // Split headers, one per array element.&nbsp;</div></li><li><div>        if ( is_string($headers) ) {&nbsp;</div></li><li><div>            // Tolerate line terminator: CRLF = LF (RFC 2616 19.3).&nbsp;</div></li><li><div>            $headers = str_replace(&quot;\r\n&quot;, &quot;\n&quot;, $headers);&nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Unfold folded header fields. LWS = [CRLF] 1*( SP | HT ) &lt;US-ASCII SP, space (32)&gt;, &nbsp;</div></li><li><div>             * &lt;US-ASCII HT, horizontal-tab (9)&gt; (RFC 2616 2.2).&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            $headers = preg_replace('/\n[ \t]/', ' ', $headers);&nbsp;</div></li><li><div>            // Create the headers array.&nbsp;</div></li><li><div>            $headers = explode(&quot;\n&quot;, $headers);&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $response = array('code' =&gt; 0, 'message' =&gt; '');&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        /**&nbsp;</div></li><li><div>         * If a redirection has taken place, The headers for each page request may have been passed.&nbsp;</div></li><li><div>         * In this case, determine the final HTTP header and parse from there.&nbsp;</div></li><li><div>         */&nbsp;</div></li><li><div>        for ( $i = count($headers)-1; $i &gt;= 0; $i-- ) {&nbsp;</div></li><li><div>            if ( !empty($headers[$i]) && false === strpos($headers[$i], ':') ) {&nbsp;</div></li><li><div>                $headers = array_splice($headers, $i);&nbsp;</div></li><li><div>                break;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $cookies = array();&nbsp;</div></li><li><div>        $newheaders = array();&nbsp;</div></li><li><div>        foreach ( (array) $headers as $tempheader ) {&nbsp;</div></li><li><div>            if ( empty($tempheader) )&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( false === strpos($tempheader, ':') ) {&nbsp;</div></li><li><div>                $stack = explode(' ', $tempheader, 3);&nbsp;</div></li><li><div>                $stack[] = '';&nbsp;</div></li><li><div>                list( , $response['code'], $response['message']) = $stack;&nbsp;</div></li><li><div>                continue;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            list($key, $value) = explode(':', $tempheader, 2);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $key = strtolower( $key );&nbsp;</div></li><li><div>            $value = trim( $value );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( isset( $newheaders[ $key ] ) ) {&nbsp;</div></li><li><div>                if ( ! is_array( $newheaders[ $key ] ) )&nbsp;</div></li><li><div>                    $newheaders[$key] = array( $newheaders[ $key ] );&nbsp;</div></li><li><div>                $newheaders[ $key ][] = $value;&nbsp;</div></li><li><div>            } else {&nbsp;</div></li><li><div>                $newheaders[ $key ] = $value;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>            if ( 'set-cookie' == $key )&nbsp;</div></li><li><div>                $cookies[] = new WP_Http_Cookie( $value, $url );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Cast the Response Code to an int&nbsp;</div></li><li><div>        $response['code'] = intval( $response['code'] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return array('response' =&gt; $response, 'headers' =&gt; $newheaders, 'cookies' =&gt; $cookies);&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Takes the arguments for a ::request() and checks for the cookie array.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If it's found, then it upgrades any basic name =&gt; value pairs to WP_Http_Cookie instances, &nbsp;</div></li><li><div>     * which are each parsed into strings and added to the Cookie: header (within the arguments array).&nbsp;</div></li><li><div>     * Edits the array by reference.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @version 2.8.0&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param array $r Full array of args passed into ::request()&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function buildCookieHeader( &$r ) {&nbsp;</div></li><li><div>        if ( ! empty($r['cookies']) ) {&nbsp;</div></li><li><div>            // Upgrade any name =&gt; value cookie pairs to WP_HTTP_Cookie instances.&nbsp;</div></li><li><div>            foreach ( $r['cookies'] as $name =&gt; $value ) {&nbsp;</div></li><li><div>                if ( ! is_object( $value ) )&nbsp;</div></li><li><div>                    $r['cookies'][ $name ] = new WP_Http_Cookie( array( 'name' =&gt; $name, 'value' =&gt; $value ) );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $cookies_header = '';&nbsp;</div></li><li><div>            foreach ( (array) $r['cookies'] as $cookie ) {&nbsp;</div></li><li><div>                $cookies_header .= $cookie-&gt;getHeaderValue() . '; ';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $cookies_header = substr( $cookies_header, 0, -2 );&nbsp;</div></li><li><div>            $r['headers']['cookie'] = $cookies_header;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Decodes chunk transfer-encoding, based off the HTTP 1.1 specification.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Based off the HTTP http_encoding_dechunk function.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @link https://tools.ietf.org/html/rfc2616#section-19.4.6 Process for chunked decoding.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     * @since 2.7.0&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $body Body content&nbsp;</div></li><li><div>     * @return string Chunked decoded body on success or raw body on failure.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function chunkTransferDecode( $body ) {&nbsp;</div></li><li><div>        // The body is not chunked encoded or is malformed.&nbsp;</div></li><li><div>        if ( ! preg_match( '/^([0-9a-f]+)[^\r\n]*\r\n/i', trim( $body ) ) )&nbsp;</div></li><li><div>            return $body;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $parsed_body = '';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // We'll be altering $body, so need a backup in case of error.&nbsp;</div></li><li><div>        $body_original = $body;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        while ( true ) {&nbsp;</div></li><li><div>            $has_chunk = (bool) preg_match( '/^([0-9a-f]+)[^\r\n]*\r\n/i', $body, $match );&nbsp;</div></li><li><div>            if ( ! $has_chunk || empty( $match[1] ) )&nbsp;</div></li><li><div>                return $body_original;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            $length = hexdec( $match[1] );&nbsp;</div></li><li><div>            $chunk_length = strlen( $match[0] );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Parse out the chunk of data.&nbsp;</div></li><li><div>            $parsed_body .= substr( $body, $chunk_length, $length );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Remove the chunk from the raw data.&nbsp;</div></li><li><div>            $body = substr( $body, $length + $chunk_length );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // End of the document.&nbsp;</div></li><li><div>            if ( '0' === trim( $body ) )&nbsp;</div></li><li><div>                return $parsed_body;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Block requests through the proxy.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * Those who are behind a proxy and want to prevent access to certain hosts may do so. This will&nbsp;</div></li><li><div>     * prevent plugins from working and core functionality, if you don't include api.wordpress.org.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * You block external URL requests by defining WP_HTTP_BLOCK_EXTERNAL as true in your wp-config.php&nbsp;</div></li><li><div>     * file and this will only allow localhost and your site to make requests. The constant&nbsp;</div></li><li><div>     * WP_ACCESSIBLE_HOSTS will allow additional hosts to go through for requests. The format of the&nbsp;</div></li><li><div>     * WP_ACCESSIBLE_HOSTS constant is a comma separated list of hostnames to allow, wildcard domains&nbsp;</div></li><li><div>     * are supported, eg *.wordpress.org will allow for all subdomains of wordpress.org to be contacted.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 2.8.0&nbsp;</div></li><li><div>     * @link https://core.trac.wordpress.org/ticket/8927 Allow preventing external requests.&nbsp;</div></li><li><div>     * @link https://core.trac.wordpress.org/ticket/14636 Allow wildcard domains in WP_ACCESSIBLE_HOSTS&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @staticvar array|null $accessible_hosts&nbsp;</div></li><li><div>     * @staticvar array      $wildcard_regex&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $uri URI of url.&nbsp;</div></li><li><div>     * @return bool True to block, false to allow.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public function block_request($uri) {&nbsp;</div></li><li><div>        // We don't need to block requests, because nothing is blocked.&nbsp;</div></li><li><div>        if ( ! defined( 'WP_HTTP_BLOCK_EXTERNAL' ) || ! WP_HTTP_BLOCK_EXTERNAL )&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $check = parse_url($uri);&nbsp;</div></li><li><div>        if ( ! $check )&nbsp;</div></li><li><div>            return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $home = parse_url( get_option('siteurl') );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Don't block requests back to ourselves by default.&nbsp;</div></li><li><div>        if ( 'localhost' == $check['host'] || ( isset( $home['host'] ) && $home['host'] == $check['host'] ) ) {&nbsp;</div></li><li><div>            /**&nbsp;</div></li><li><div>             * Filters whether to block local requests through the proxy.&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @since 2.8.0&nbsp;</div></li><li><div>             *&nbsp;</div></li><li><div>             * @param bool $block Whether to block local requests through proxy.&nbsp;</div></li><li><div>             *                    Default false.&nbsp;</div></li><li><div>             */&nbsp;</div></li><li><div>            return apply_filters( 'block_local_requests', false );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( !defined('WP_ACCESSIBLE_HOSTS') )&nbsp;</div></li><li><div>            return true;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        static $accessible_hosts = null;&nbsp;</div></li><li><div>        static $wildcard_regex = array();&nbsp;</div></li><li><div>        if ( null === $accessible_hosts ) {&nbsp;</div></li><li><div>            $accessible_hosts = preg_split('|, \s*|', WP_ACCESSIBLE_HOSTS);&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            if ( false !== strpos(WP_ACCESSIBLE_HOSTS, '*') ) {&nbsp;</div></li><li><div>                $wildcard_regex = array();&nbsp;</div></li><li><div>                foreach ( $accessible_hosts as $host )&nbsp;</div></li><li><div>                    $wildcard_regex[] = str_replace( '\*', '.+', preg_quote( $host, '/' ) );&nbsp;</div></li><li><div>                $wildcard_regex = '/^(' . implode('|', $wildcard_regex) . ')$/i';&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( !empty($wildcard_regex) )&nbsp;</div></li><li><div>            return !preg_match($wildcard_regex, $check['host']);&nbsp;</div></li><li><div>        else&nbsp;</div></li><li><div>            return !in_array( $check['host'], $accessible_hosts ); //Inverse logic, If it's in the array, then we can't access it.&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Used as a wrapper for PHP's parse_url() function that handles edgecases in &lt; PHP 5.4.7.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @access protected&nbsp;</div></li><li><div>     * @deprecated 4.4.0 Use wp_parse_url()&nbsp;</div></li><li><div>     * @see wp_parse_url()&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $url The URL to parse.&nbsp;</div></li><li><div>     * @return bool|array False on failure; Array of URL components on success;&nbsp;</div></li><li><div>     *                    See parse_url()'s return values.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    protected static function parse_url( $url ) {&nbsp;</div></li><li><div>        _deprecated_function( __METHOD__, '4.4.0', 'wp_parse_url()' );&nbsp;</div></li><li><div>        return wp_parse_url( $url );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Converts a relative URL to an absolute URL relative to a given URL.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * If an Absolute URL is provided, no processing of that URL is done.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 3.4.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     * @access public&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $maybe_relative_path The URL which might be relative&nbsp;</div></li><li><div>     * @param string $url                 The URL which $maybe_relative_path is relative to&nbsp;</div></li><li><div>     * @return string An Absolute URL, in a failure condition where the URL cannot be parsed, the relative URL will be returned.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function make_absolute_url( $maybe_relative_path, $url ) {&nbsp;</div></li><li><div>        if ( empty( $url ) )&nbsp;</div></li><li><div>            return $maybe_relative_path;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( ! $url_parts = wp_parse_url( $url ) ) {&nbsp;</div></li><li><div>            return $maybe_relative_path;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( ! $relative_url_parts = wp_parse_url( $maybe_relative_path ) ) {&nbsp;</div></li><li><div>            return $maybe_relative_path;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Check for a scheme on the 'relative' url&nbsp;</div></li><li><div>        if ( ! empty( $relative_url_parts['scheme'] ) ) {&nbsp;</div></li><li><div>            return $maybe_relative_path;&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $absolute_path = $url_parts['scheme'] . '://';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Schemeless URL's will make it this far, so we check for a host in the relative url and convert it to a protocol-url&nbsp;</div></li><li><div>        if ( isset( $relative_url_parts['host'] ) ) {&nbsp;</div></li><li><div>            $absolute_path .= $relative_url_parts['host'];&nbsp;</div></li><li><div>            if ( isset( $relative_url_parts['port'] ) )&nbsp;</div></li><li><div>                $absolute_path .= ':' . $relative_url_parts['port'];&nbsp;</div></li><li><div>        } else {&nbsp;</div></li><li><div>            $absolute_path .= $url_parts['host'];&nbsp;</div></li><li><div>            if ( isset( $url_parts['port'] ) )&nbsp;</div></li><li><div>                $absolute_path .= ':' . $url_parts['port'];&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Start off with the Absolute URL path.&nbsp;</div></li><li><div>        $path = ! empty( $url_parts['path'] ) ? $url_parts['path'] : '/';&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If it's a root-relative path, then great.&nbsp;</div></li><li><div>        if ( ! empty( $relative_url_parts['path'] ) && '/' == $relative_url_parts['path'][0] ) {&nbsp;</div></li><li><div>            $path = $relative_url_parts['path'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Else it's a relative path.&nbsp;</div></li><li><div>        } elseif ( ! empty( $relative_url_parts['path'] ) ) {&nbsp;</div></li><li><div>            // Strip off any file components from the absolute path.&nbsp;</div></li><li><div>            $path = substr( $path, 0, strrpos( $path, '/' ) + 1 );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Build the new path.&nbsp;</div></li><li><div>            $path .= $relative_url_parts['path'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Strip all /path/../ out of the path.&nbsp;</div></li><li><div>            while ( strpos( $path, '../' ) &gt; 1 ) {&nbsp;</div></li><li><div>                $path = preg_replace( '![^/]+/\.\./!', '', $path );&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>            // Strip any final leading ../ from the path.&nbsp;</div></li><li><div>            $path = preg_replace( '!^/(\.\./)+!', '', $path );&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Add the Query string.&nbsp;</div></li><li><div>        if ( ! empty( $relative_url_parts['query'] ) )&nbsp;</div></li><li><div>            $path .= '?' . $relative_url_parts['query'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return $absolute_path . '/' . ltrim( $path, '/' );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Handles HTTP Redirects and follows them if appropriate.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 3.7.0&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $url The URL which was requested.&nbsp;</div></li><li><div>     * @param array $args The Arguments which were used to make the request.&nbsp;</div></li><li><div>     * @param array $response The Response of the HTTP request.&nbsp;</div></li><li><div>     * @return false|object False if no redirect is present, a WP_HTTP or WP_Error result otherwise.&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function handle_redirects( $url, $args, $response ) {&nbsp;</div></li><li><div>        // If no redirects are present, or, redirects were not requested, perform no action.&nbsp;</div></li><li><div>        if ( ! isset( $response['headers']['location'] ) || 0 === $args['_redirection'] )&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Only perform redirections on redirection http codes.&nbsp;</div></li><li><div>        if ( $response['response']['code'] &gt; 399 || $response['response']['code'] &lt; 300 )&nbsp;</div></li><li><div>            return false;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Don't redirect if we've run out of redirects.&nbsp;</div></li><li><div>        if ( $args['redirection']-- &lt;= 0 )&nbsp;</div></li><li><div>            return new WP_Error( 'http_request_failed', __('Too many redirects.') );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $redirect_location = $response['headers']['location'];&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // If there were multiple Location headers, use the last header specified.&nbsp;</div></li><li><div>        if ( is_array( $redirect_location ) )&nbsp;</div></li><li><div>            $redirect_location = array_pop( $redirect_location );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        $redirect_location = WP_Http::make_absolute_url( $redirect_location, $url );&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // POST requests should not POST to a redirected location.&nbsp;</div></li><li><div>        if ( 'POST' == $args['method'] ) {&nbsp;</div></li><li><div>            if ( in_array( $response['response']['code'], array( 302, 303 ) ) )&nbsp;</div></li><li><div>                $args['method'] = 'GET';&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        // Include valid cookies in the redirect process.&nbsp;</div></li><li><div>        if ( ! empty( $response['cookies'] ) ) {&nbsp;</div></li><li><div>            foreach ( $response['cookies'] as $cookie ) {&nbsp;</div></li><li><div>                if ( $cookie-&gt;test( $redirect_location ) )&nbsp;</div></li><li><div>                    $args['cookies'][] = $cookie;&nbsp;</div></li><li><div>            }&nbsp;</div></li><li><div>        }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return wp_remote_request( $redirect_location, $args );&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>    /**&nbsp;</div></li><li><div>     * Determines if a specified string represents an IP address or not.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * This function also detects the type of the IP address, returning either&nbsp;</div></li><li><div>     * '4' or '6' to represent a IPv4 and IPv6 address respectively.&nbsp;</div></li><li><div>     * This does not verify if the IP is a valid IP, only that it appears to be&nbsp;</div></li><li><div>     * an IP address.&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @link http://home.deds.nl/~aeron/regex/ for IPv6 regex&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @since 3.7.0&nbsp;</div></li><li><div>     * @static&nbsp;</div></li><li><div>     *&nbsp;</div></li><li><div>     * @param string $maybe_ip A suspected IP address&nbsp;</div></li><li><div>     * @return integer|bool Upon success, '4' or '6' to represent a IPv4 or IPv6 address, false upon failure&nbsp;</div></li><li><div>     */&nbsp;</div></li><li><div>    public static function is_ip_address( $maybe_ip ) {&nbsp;</div></li><li><div>        if ( preg_match( '/^\d{1, 3}\.\d{1, 3}\.\d{1, 3}\.\d{1, 3}$/', $maybe_ip ) )&nbsp;</div></li><li><div>            return 4;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        if ( false !== strpos( $maybe_ip, ':' ) && preg_match( '/^(((?=.*(::))(?!.*\3.+\3))\3?|([\dA-F]{1, 4}(\3|:\b|$)|\2))(?4) {5}((?4) {2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b) {4})$/i', trim( $maybe_ip, ' []' ) ) )&nbsp;</div></li><li><div>            return 6;&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>        return false;&nbsp;</div></li><li><div>    }&nbsp;</div></li><li><div>&nbsp;</div></li><li><div>}&nbsp;</div></li></ol></pre></dd></dl> </section> </article></div><div id="sidebar"><ul class="widgets"><li> <a href="http://hookr.io/plugin/"><img src="http://hookr.io/wp-content/themes/hookr/assets/images/plugin-download.jpg" /></a></li><li id="versions"><dl><dt>Version(s)</dt><dd><dl><dt>Since</dt><dd> 2.7.0</dd><dt>Others</dt><dd><ul><li><a href="http://hookr.io/4.7.4/classes/wp_http/" class="active">4.7.4</a></li><li><a href="http://hookr.io/4.7.3/classes/wp_http/" class="">4.7.3</a></li><li><a href="http://hookr.io/4.7.2/classes/wp_http/" class="">4.7.2</a></li><li><a href="http://hookr.io/4.7.1/classes/wp_http/" class="">4.7.1</a></li><li><a href="http://hookr.io/4.7/classes/wp_http/" class="">4.7</a></li></ul></dd></dl></dd></dl></li><li id="tags"><dl><dt>Tags</dt><dd><ul><li><span></span>wordpress</li><li><span></span>class</li><li><span></span>WP_Http</li><li><span></span>wp-include</li></ul></dd></dl></li></ul></div></div></div><script>Hookr.View.init();Hookr.Single.init();</script><footer><div><ul id="nav-social" class="pivot" role="navigation"><li id="twitter"><a href="http://twitter.com/hookr_io" title="Follow me!"></a></li></ul><div> &copy; 2021 hookr.io <strong>(beta)</strong> | <a href="http://hookr.io/privacy/" title="Privacy">Privacy</a> | Proudly Powered by WordPress</div></div> </footer><script type="text/javascript" src="http://hookr.io/wp-content/cache/minify/000000/M9EvL9BNzU1KTdHLzcwDAA.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-49583310-1','hookr.io');ga('send','pageview');</script></body></html>